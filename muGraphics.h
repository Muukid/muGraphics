/*
muGraphics.h - Muukid
Public domain* single-file C library for high-level cross-graphics-API rendering.
No warranty implied; use at your own risk.

Licensed under MIT License or public domain, whichever you prefer.
More explicit license information at the end of file.

@TODO Add Vulkan validation layer usage with custom user callback.
@TODO Add automatic sub-allocation for buffer data that is too large to process.
@TODO Make a system for optimal Vulkan memory allocation.
@TODO Find a way for X11 to be fine with Vulkan existing while the window is being resized... may
have to block for the entire duration of it being resized.
@TODO mu_X_buffer_render_count(..., size_m X_count)
@TODO Desired FPS.
@TODO Abstract Vulkan uniform buffer handlers, too messy right now.

@MENTION MUG_VK_LOOK_AHEAD_FRAMES
@MENTION MUG_GL_PRIMITIVE_RESTART_INDEX_32 and MUG_GL_PRIMITIVE_RESTART_INDEX_16
@MENTION Buffer locking.
*/

#ifndef MUG_H
	#define MUG_H
	
	/* muCOSA commit beab34d header */
		
		#define MUCOSA_OPENGL
		#define MUCOSA_VULKAN
		#define MUCOSA_NO_INCLUDE_VULKAN
	
		#if !defined(MU_CHECK_VERSION_MISMATCHING) && defined(MUCOSA_H) && \
			(MUCOSA_VERSION_MAJOR != 1 || MUCOSA_VERSION_MINOR != 0 || MUCOSA_VERSION_PATCH != 0)

			#pragma message("[MUG] muCOSA's header has already been defined, but version doesn't match the version that this library is built for. This may lead to errors, warnings, or unexpected behavior. Define MU_CHECK_VERSION_MISMATCHING before this to turn off this message.")

		#endif

		#ifndef MUCOSA_H
			#define MUCOSA_H
			
			/* muString commit 6678f59 header */
			
				#if !defined(MU_CHECK_VERSION_MISMATCHING) && defined(MUS_H) && \
					(MUS_VERSION_MAJOR != 1 || MUS_VERSION_MINOR != 0 || MUS_VERSION_PATCH != 0)

					#pragma message("[MUCOSA] muString's header has already been defined, but version doesn't match the version that this library is built for. This may lead to errors, warnings, or unexpected behavior. Define MU_CHECK_VERSION_MISMATCHING before this to turn off this message.")

				#endif

				#ifndef MUS_H
					#define MUS_H
					
					/* muMemoryAllocator version 1.0.0 header */
					
						#if !defined(MU_CHECK_VERSION_MISMATCHING) && defined(MUMA_H) && \
							(MUMA_VERSION_MAJOR != 1 || MUMA_VERSION_MINOR != 0 || MUMA_VERSION_PATCH != 0)

							#pragma message("[MUS] muMemoryAllocator's header has already been defined, but version doesn't match the version that this library is built for. This may lead to errors, warnings, or unexpected behavior. Define MU_CHECK_VERSION_MISMATCHING before this to turn off this message.")

						#endif

						#ifndef MUMA_H
							#define MUMA_H
							
							/* muUtility version 1.0.0 header */
							
								#if !defined(MU_CHECK_VERSION_MISMATCHING) && defined(MUU_H) && \
									(MUU_VERSION_MAJOR != 1 || MUU_VERSION_MINOR != 0 || MUU_VERSION_PATCH != 0)

									#pragma message("[MUMA] muUtility's header has already been defined, but version doesn't match the version that this library is built for. This may lead to errors, warnings, or unexpected behavior. Define MU_CHECK_VERSION_MISMATCHING before this to turn off this message.")

								#endif

								#ifndef MUU_H
									#define MUU_H
									
									#if !defined(MU_SECURE_WARNINGS) && !defined(_CRT_SECURE_NO_WARNINGS)
										#define _CRT_SECURE_NO_WARNINGS
									#endif

									#ifdef __cplusplus
									extern "C" { // }
									#endif

									#define MUU_VERSION_MAJOR 1
									#define MUU_VERSION_MINOR 0
									#define MUU_VERSION_PATCH 0

									/* C standard library dependencies */

										#if !defined(int8_m)      || \
											!defined(uint8_m)     || \
											!defined(int16_m)     || \
											!defined(uint16_m)    || \
											!defined(int32_m)     || \
											!defined(uint32_m)    || \
											!defined(int64_m)     || \
											!defined(uint64_m)    || \
											!defined(MU_SIZE_MAX)

											#define __STDC_LIMIT_MACROS
											#define __STDC_CONSTANT_MACROS
											#include <stdint.h>

											#ifndef int8_m
												#ifdef INT8_MAX
													#define int8_m int8_t
												#else
													#define int8_m char
												#endif
											#endif

											#ifndef uint8_m
												#ifdef UINT8_MAX
													#define uint8_m uint8_t
												#else
													#define uint8_m unsigned char
												#endif
											#endif

											#ifndef int16_m
												#ifdef INT16_MAX
													#define int16_m int16_t
												#else
													#define int16_m short
												#endif
											#endif

											#ifndef uint16_m
												#ifdef UINT16_MAX
													#define uint16_m uint16_t
												#else
													#define uint16_m unsigned short
												#endif
											#endif

											#ifndef int32_m
												#ifdef INT32_MAX
													#define int32_m int32_t
												#else
													#define int32_m long
												#endif
											#endif

											#ifndef uint32_m
												#ifdef UINT32_MAX
													#define uint32_m uint32_t
												#else
													#define uint32_m unsigned long
												#endif
											#endif

											#ifndef int64_m
												#ifdef INT64_MAX
													#define int64_m int64_t
												#else
													#define int64_m long long
												#endif
											#endif

											#ifndef uint64_m
												#ifdef UINT64_MAX
													#define uint64_m uint64_t
												#else
													#define uint64_m unsigned long long
												#endif
											#endif

											#ifndef MU_SIZE_MAX
												#define MU_SIZE_MAX SIZE_MAX
											#endif

										#endif

										#if !defined(size_m)

											#include <stddef.h>

											#ifndef size_m
												#define size_m size_t
											#endif

										#endif

										#if !defined(muBool)   || \
											!defined(MU_TRUE)  || \
											!defined(MU_FALSE)

											#include <stdbool.h>

											#ifndef muBool
												#define muBool bool
											#endif

											#ifndef MU_TRUE
												#define MU_TRUE true
											#endif

											#ifndef MU_FALSE
												#define MU_FALSE false
											#endif

										#endif

									/* Useful macros */

										#ifndef MUDEF
											#ifdef MU_STATIC
												#define MUDEF static
											#else
												#define MUDEF extern
											#endif
										#endif

										#ifndef MU_ZERO_STRUCT
											#ifdef __cplusplus
												#define MU_ZERO_STRUCT(s) {}
											#else
												#define MU_ZERO_STRUCT(s) (s){0}
											#endif
										#endif

										#ifndef MU_ZERO_STRUCT_CONST
											#ifdef __cplusplus
												#define MU_ZERO_STRUCT_CONST(s) {}
											#else
												#define MU_ZERO_STRUCT_CONST(s) {0}
											#endif
										#endif

										#ifndef muByte
											#define muByte uint8_m
										#endif

										#ifndef mu_rle_uint8
											#define mu_rle_uint8(b) ((uint8_m)b[0] << 0)
										#endif
										#ifndef mu_rbe_uint8
											#define mu_rbe_uint8(b) ((uint8_m)b[0] << 0)
										#endif

										#ifndef mu_rle_uint16
											#define mu_rle_uint16(b) ((uint16_m)b[0] << 0 | (uint16_m)b[1] << 8)
										#endif
										#ifndef mu_rbe_uint16
											#define mu_rbe_uint16(b) ((uint16_m)b[1] << 0 | (uint16_m)b[0] << 8)
										#endif

										#ifndef mu_rle_uint32
											#define mu_rle_uint32(b) ((uint32_m)b[0] << 0 | (uint32_m)b[1] << 8 | (uint32_m)b[2] << 16 | (uint32_m)b[3] << 24)
										#endif
										#ifndef mu_rbe_uint32
											#define mu_rbe_uint32(b) ((uint32_m)b[3] << 0 | (uint32_m)b[2] << 8 | (uint32_m)b[1] << 16 | (uint32_m)b[0] << 24)
										#endif

										#ifndef mu_rle_uint64
											#define mu_rle_uint64(b) ((uint64_m)b[0] << 0 | (uint64_m)b[1] << 8 | (uint64_m)b[2] << 16 | (uint64_m)b[3] << 24 | (uint64_m)b[4] << 32 | (uint64_m)b[5] << 40 | (uint64_m)b[6] << 48 | (uint64_m)b[7] << 56)
										#endif
										#ifndef mu_rbe_uint64
											#define mu_rbe_uint64(b) ((uint64_m)b[7] << 0 | (uint64_m)b[6] << 8 | (uint64_m)b[5] << 16 | (uint64_m)b[4] << 24 | (uint64_m)b[3] << 32 | (uint64_m)b[2] << 40 | (uint64_m)b[1] << 48 | (uint64_m)b[0] << 56)
										#endif

										#ifndef mu_wle_uint8
											#define mu_wle_uint8(b, i) b[0] = (uint8_m)(i >> 0);
										#endif
										#ifndef mu_wbe_uint8
											#define mu_wbe_uint8(b, i) b[0] = (uint8_m)(i >> 0);
										#endif

										#ifndef mu_wle_uint16
											#define mu_wle_uint16(b, i) b[0] = (uint8_m)(i >> 0); b[1] = (uint8_m)(i >> 8);
										#endif
										#ifndef mu_wbe_uint16
											#define mu_wbe_uint16(b, i) b[1] = (uint8_m)(i >> 0); b[0] = (uint8_m)(i >> 8);
										#endif

										#ifndef mu_wle_uint32
											#define mu_wle_uint32(b, i) b[0] = (uint8_m)(i >> 0); b[1] = (uint8_m)(i >> 8); b[2] = (uint8_m)(i >> 16); b[3] = (uint8_m)(i >> 24);
										#endif
										#ifndef mu_wbe_uint32
											#define mu_wbe_uint32(b, i) b[3] = (uint8_m)(i >> 0); b[2] = (uint8_m)(i >> 8); b[1] = (uint8_m)(i >> 16); b[0] = (uint8_m)(i >> 24);
										#endif

										#ifndef mu_wle_uint64
											#define mu_wle_uint64(b, i) b[0] = (uint8_m)(i >> 0); b[1] = (uint8_m)(i >> 8); b[2] = (uint8_m)(i >> 16); b[3] = (uint8_m)(i >> 24); b[4] = (uint8_m)(i >> 32); b[5] = (uint8_m)(i >> 40); b[6] = (uint8_m)(i >> 48); b[7] = (uint8_m)(i >> 56);
										#endif
										#ifndef mu_wbe_uint64
											#define mu_wbe_uint64(b, i) b[7] = (uint8_m)(i >> 0); b[6] = (uint8_m)(i >> 8); b[5] = (uint8_m)(i >> 16); b[4] = (uint8_m)(i >> 24); b[3] = (uint8_m)(i >> 32); b[2] = (uint8_m)(i >> 40); b[1] = (uint8_m)(i >> 48); b[0] = (uint8_m)(i >> 56);
										#endif

										#ifndef MU_NULL_PTR
											#define MU_NULL_PTR 0
										#endif

										#ifndef MU_NULL
											#define MU_NULL 0
										#endif

										#ifndef MU_NONE
											#define MU_NONE MU_SIZE_MAX
										#endif

										#ifndef MU_SET_RESULT
											#define MU_SET_RESULT(res, val) if(res!=MU_NULL_PTR){*res=val;}
										#endif

										#ifndef MU_ASSERT
											#define MU_ASSERT(cond, res, val, after) if(!(cond)){MU_SET_RESULT(res, val) after}
										#endif

										#define MU_ENUM(name, ...) enum _##name{__VA_ARGS__};typedef enum _##name _##name; typedef size_m name;

										#if !defined(MU_WIN32) && !defined(MU_UNIX)
											#if defined(WIN32) || defined(_WIN32)
												#define MU_WIN32
											#elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
												#define MU_UNIX
											#endif
										#endif

										#define MU_HRARRAY_DEFAULT_FUNC(name) \
											muBool name##_comp(name t0, name t1) { \
												return t0.active == t1.active; \
											} \
											\
											void name##_on_creation(name* p) { \
												if (p != MU_NULL_PTR) { \
													MU_LOCK_CREATE(p->lock, p->lock_active) \
												} \
											} \
											void name##_on_destruction(name* p) { \
												if (p != MU_NULL_PTR) { \
													MU_LOCK_DESTROY(p->lock, p->lock_active) \
												} \
											} \
											void name##_on_hold(name* p) { \
												if (p != MU_NULL_PTR) { \
													MU_LOCK_LOCK(p->lock, p->lock_active) \
												} \
											} \
											void name##_on_release(name* p) { \
												if (p != MU_NULL_PTR) { \
													MU_LOCK_UNLOCK(p->lock, p->lock_active) \
												} \
											} \
											\
											mu_dynamic_hrarray_declaration( \
												name##_array, name, name##_, name##_comp, \
												name##_on_creation, name##_on_destruction, name##_on_hold, name##_on_release \
											)

										#define MU_SAFEFUNC(result, lib_prefix, context, fail_return) \
											MU_SET_RESULT(result, lib_prefix##SUCCESS) \
											MU_ASSERT(context != MU_NULL_PTR, result, lib_prefix##NOT_YET_INITIALIZED, fail_return) \

										#define MU_HOLD(result, item, da, context, lib_prefix, fail_return, da_prefix) \
											MU_ASSERT(item < da.length, result, lib_prefix##INVALID_ID, fail_return) \
											da_prefix##hold_element(0, &da, item); \
											MU_ASSERT(da.data[item].active, result, lib_prefix##INVALID_ID, da_prefix##release_element(0, &da, item); fail_return)

										#define MU_RELEASE(da, item, da_prefix) \
											da_prefix##release_element(0, &da, item);

									#ifdef __cplusplus
									}
									#endif

								#endif /* MUU_H */
							
							#ifdef __cplusplus
								extern "C" {
							#endif

							#define MUMA_VERSION_MAJOR 1
							#define MUMA_VERSION_MINOR 0
							#define MUMA_VERSION_PATCH 0

							/* C standard library dependencies */

								#if !defined(mu_malloc)  || \
									!defined(mu_free)    || \
									!defined(mu_realloc)

									#include <stdlib.h>

									#ifndef mu_malloc
										#define mu_malloc malloc
									#endif

									#ifndef mu_free
										#define mu_free free
									#endif

									#ifndef mu_realloc
										#define mu_realloc realloc
									#endif

								#endif

								#if !defined(mu_memset)  || \
									!defined(mu_memcpy)  || \
									!defined(mu_memmove)

									#include <string.h>

									#ifndef mu_memset
										#define mu_memset memset
									#endif

									#ifndef mu_memcpy
										#define mu_memcpy memcpy
									#endif

									#ifndef mu_memmove
										#define mu_memmove memmove
									#endif

								#endif

							/* Enums */

								MU_ENUM(mumaResult, 
									MUMA_SUCCESS,

									MUMA_FAILED_TO_ALLOCATE,
									MUMA_INVALID_INDEX,
									MUMA_INVALID_SHIFT_AMOUNT,
									MUMA_NOT_FOUND
								)

							/* Functions */

								#ifdef MUMA_NAMES
									MUDEF const char* muma_result_get_name(mumaResult result);
								#endif

							/* API macro functionality */

								#define mu_dynamic_array_declaration(struct_name, type, function_name_prefix, type_comparison_func) \
									\
									struct struct_name { \
										type* data; \
										size_m allocated_length; \
										size_m length; \
									}; typedef struct struct_name struct_name; \
									\
									struct_name function_name_prefix##create(mumaResult* result, size_m length) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										struct_name s = MU_ZERO_STRUCT(struct_name); \
										s.data = MU_NULL_PTR; \
										s.allocated_length = length; \
										s.length = length; \
										\
										if (s.length == 0) { \
											return s; \
										} \
										\
										s.data = (type*)mu_malloc(sizeof(type)*s.allocated_length); \
										if (s.data == 0) { \
											MU_SET_RESULT(result, MUMA_FAILED_TO_ALLOCATE) \
											s.allocated_length = 0; \
											s.length = 0; \
											return s; \
										} \
										\
										mu_memset(s.data, 0, sizeof(type)*s.allocated_length);\
										return s;\
									} \
									\
									struct_name function_name_prefix##destroy(mumaResult* result, struct_name s) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (s.data != MU_NULL_PTR) { \
											mu_free(s.data); \
											s.data = MU_NULL_PTR; \
										} \
										\
										s.allocated_length = 0; \
										s.length = 0; \
										return s; \
									} \
									\
									struct_name function_name_prefix##resize(mumaResult* result, struct_name s, size_m length) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (s.length == length) { \
											return s; \
										} \
										\
										if (s.data == MU_NULL_PTR) { \
											if (length == 0) { \
												return s; \
											} \
											\
											mumaResult res = MUMA_SUCCESS; \
											s = function_name_prefix##create(&res, length); \
											if (res != MUMA_SUCCESS) { \
												MU_SET_RESULT(result, res) \
												return s; \
											} \
										} \
										\
										if (length == 0) { \
											s.length = 0; \
											mu_memset(s.data, 0, sizeof(type)*s.allocated_length); \
											return s; \
										} \
										\
										size_m old_length = s.length; \
										size_m old_allocated_length = s.allocated_length; \
										s.length = length; \
										\
										if ((s.length > s.allocated_length) || (s.length < s.allocated_length/2)) { \
											while (s.length > s.allocated_length) { \
												s.allocated_length *= 2; \
											} \
											while (s.length < s.allocated_length/2) { \
												s.allocated_length /= 2; \
											} \
											\
											type* new_data = (type*)mu_realloc(s.data, sizeof(type) * s.allocated_length); \
											if (new_data == 0) { \
												s.length = old_length; \
												s.allocated_length = old_allocated_length; \
												MU_SET_RESULT(result, MUMA_FAILED_TO_ALLOCATE) \
												return s; \
											} \
											\
											s.data = new_data; \
										} \
										\
										if (old_length < s.length) { \
											mu_memset(&s.data[old_length], 0, sizeof(type)*(s.allocated_length-old_length)); \
										} \
										\
										return s; \
									} \
									\
									struct_name function_name_prefix##lshift(mumaResult* result, struct_name s, size_m index, size_m amount) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (index >= s.length) { \
											MU_SET_RESULT(result, MUMA_INVALID_INDEX) \
											return s; \
										} \
										\
										if (amount == 0) { \
											return s; \
										} \
										\
										if (amount > index) { \
											MU_SET_RESULT(result, MUMA_INVALID_SHIFT_AMOUNT) \
											return s; \
										} \
										\
										mu_memmove(&s.data[index-amount], &s.data[index], sizeof(type)*(s.length-index)); \
										\
										mumaResult res = MUMA_SUCCESS; \
										s = function_name_prefix##resize(&res, s, s.length-amount); \
										if (res != MUMA_SUCCESS) { \
											MU_SET_RESULT(result, res) \
											return s; \
										} \
										\
										return s; \
									} \
									\
									struct_name function_name_prefix##rshift(mumaResult* result, struct_name s, size_m index, size_m amount) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (index >= s.length) { \
											MU_SET_RESULT(result, MUMA_INVALID_INDEX) \
											return s; \
										} \
										\
										if (amount == 0) { \
											return s; \
										} \
										\
										mumaResult res = MUMA_SUCCESS; \
										s = function_name_prefix##resize(&res, s, s.length+amount); \
										if (res != MUMA_SUCCESS) { \
											MU_SET_RESULT(result, res) \
											return s; \
										} \
										\
										/* I have genuinely no idea why it needs to have a -1. It crashes if you don't. */\
										/* And lshift doesn't need one. Why?? */ \
										mu_memmove(&s.data[index+amount], &s.data[index], sizeof(type)*((s.length-index)-1)); \
										mu_memset(&s.data[index], 0, sizeof(type)*(amount)); \
										\
										return s; \
									} \
									\
									struct_name function_name_prefix##multiinsert(mumaResult* result, struct_name s, size_m index, type* insert, size_m count) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										mumaResult res = MUMA_SUCCESS; \
										s = function_name_prefix##rshift(&res, s, index, count); \
										if (res != MUMA_SUCCESS) { \
											MU_SET_RESULT(result, res) \
											return s; \
										} \
										\
										mu_memcpy(&s.data[index], insert, sizeof(type)*count); \
										return s; \
									} \
									\
									struct_name function_name_prefix##insert(mumaResult* result, struct_name s, size_m index, type insert) { \
										return function_name_prefix##multiinsert(result, s, index, &insert, 1); \
									} \
									\
									struct_name function_name_prefix##multierase(mumaResult* result, struct_name s, size_m index, size_m count) { \
										return function_name_prefix##lshift(result, s, index+count, count); \
									} \
									\
									struct_name function_name_prefix##erase(mumaResult* result, struct_name s, size_m index) { \
										return function_name_prefix##multierase(result, s, index, 1); \
									} \
									struct_name function_name_prefix##clear(mumaResult* result, struct_name s) { \
										return function_name_prefix##destroy(result, s); \
									} \
									\
									struct_name function_name_prefix##multipush(mumaResult* result, struct_name s, type* push, size_m count) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										mumaResult res = MUMA_SUCCESS; \
										s = function_name_prefix##resize(&res, s, s.length+count); \
										if (res != MUMA_SUCCESS) { \
											MU_SET_RESULT(result, res) \
											return s; \
										} \
										\
										mu_memcpy(&s.data[s.length-count], push, sizeof(type)*count); \
										return s; \
									} \
									\
									struct_name function_name_prefix##push(mumaResult* result, struct_name s, type push) { \
										return function_name_prefix##multipush(result, s, &push, 1); \
									} \
									\
									struct_name function_name_prefix##multipop(mumaResult* result, struct_name s, size_m count) { \
										return function_name_prefix##resize(result, s, s.length-count); \
									} \
									\
									struct_name function_name_prefix##pop(mumaResult* result, struct_name s) { \
										return function_name_prefix##multipop(result, s, 1); \
									} \
									\
									size_m function_name_prefix##find(mumaResult* result, struct_name s, type find) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										for (size_m i = 0; i < s.length; i++) { \
											if (type_comparison_func(find, s.data[i])) { \
												return i; \
											} \
										} \
										\
										MU_SET_RESULT(result, MUMA_NOT_FOUND) \
										return MU_NONE; \
									} \
									\
									struct_name function_name_prefix##find_push(mumaResult* result, struct_name s, type find, size_m* p_index) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										mumaResult res = MUMA_SUCCESS; \
										size_m index = function_name_prefix##find(&res, s, find); \
										if (index != MU_NONE) { \
											if (p_index != MU_NULL_PTR) { \
												*p_index = index; \
											} \
											return s; \
										} \
										if (res != MUMA_SUCCESS && res != MUMA_NOT_FOUND) { \
											if (p_index != MU_NULL_PTR) { \
												*p_index = MU_NONE; \
											} \
											MU_SET_RESULT(result, res) \
											return s; \
										} \
										\
										s = function_name_prefix##push(&res, s, find); \
										if (res != MUMA_SUCCESS) { \
											if (p_index != MU_NULL_PTR) { \
												*p_index = MU_NONE; \
											} \
											MU_SET_RESULT(result, res) \
											return s; \
										} \
										\
										if (p_index != MU_NULL_PTR) { \
											*p_index = s.length-1; \
										} \
										return s; \
									}

								#define mu_dynamic_hrarray_declaration( \
									struct_name, type, function_name_prefix, type_comparison_func, \
									on_creation, on_destruction, on_hold, on_release \
								) \
									\
									struct struct_name { \
										type* data; \
										size_m allocated_length; \
										size_m length; \
									}; typedef struct struct_name struct_name; \
									\
									struct_name function_name_prefix##create(mumaResult* result, size_m length) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										struct_name s = MU_ZERO_STRUCT(struct_name); \
										s.data = MU_NULL_PTR; \
										s.allocated_length = length; \
										s.length = length; \
										\
										if (s.length == 0) { \
											return s; \
										} \
										\
										s.data = (type*)mu_malloc(sizeof(type)*s.allocated_length); \
										if (s.data == 0) { \
											MU_SET_RESULT(result, MUMA_FAILED_TO_ALLOCATE) \
											s.allocated_length = 0; \
											s.length = 0; \
											return s; \
										} \
										\
										mu_memset(s.data, 0, sizeof(type)*s.allocated_length); \
										\
										for (size_m i = 0; i < s.length; i++) { \
											on_creation(&s.data[i]); \
										} \
										return s;\
									} \
									\
									void function_name_prefix##hold_element(mumaResult* result, struct_name* s, size_m index) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (index >= s->length) { \
											MU_SET_RESULT(result, MUMA_INVALID_INDEX) \
											return; \
										} \
										\
										on_hold(&s->data[index]); \
									} \
									\
									void function_name_prefix##release_element(mumaResult* result, struct_name* s, size_m index) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (index >= s->length) { \
											MU_SET_RESULT(result, MUMA_INVALID_INDEX) \
											return; \
										} \
										\
										on_release(&s->data[index]); \
									} \
									\
									void function_name_prefix##destroy(mumaResult* result, struct_name* s) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										for (size_m i = 0; i < s->length; i++) { \
											function_name_prefix##hold_element(0, s, i); \
										} \
										\
										for (size_m i = 0; i < s->length; i++) { \
											on_destruction(&s->data[i]); \
										} \
										\
										if (s->data != MU_NULL_PTR) { \
											mu_free(s->data); \
											s->data = MU_NULL_PTR; \
										} \
										\
										s->allocated_length = 0; \
										s->length = 0; \
									} \
									\
									void function_name_prefix##inner_resize(mumaResult* result, struct_name* s, size_m length, muBool cd) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (s->length == length) { \
											return; \
										} \
										\
										if (s->data == MU_NULL_PTR) { \
											if (length == 0) { \
												return; \
											} \
											\
											mumaResult res = MUMA_SUCCESS; \
											*s = function_name_prefix##create(&res, length); \
											if (res != MUMA_SUCCESS) { \
												MU_SET_RESULT(result, res) \
												return; \
											} \
										} \
										\
										if (length == 0) { \
											for (size_m i = 0; i < s->length; i++) { \
												on_destruction(&s->data[i]); \
											} \
											s->length = 0; \
											mu_memset(s->data, 0, sizeof(type)*s->allocated_length); \
											return; \
										} \
										\
										if (cd) { \
											for (size_m i = 0; i < s->length; i++) { \
												function_name_prefix##hold_element(0, s, i); \
											} \
										} \
										\
										size_m old_length = s->length; \
										size_m old_allocated_length = s->allocated_length; \
										s->length = length; \
										\
										/* Note: this is really dangerous, because it's not guaranteed that the  */ \
										/* reallocation will follow through. If it doesn't, we've now called the */ \
										/* destroy function on a bunch of elements that still exist. I can't     */ \
										/* really think of a better way of doing it than this right now, though. */ \
										if (cd && old_length > s->length) { \
											for (size_m i = s->length; i < old_length; i++) { \
												on_destruction(&s->data[i]); \
											} \
										} \
										\
										if ((s->length > s->allocated_length) || (s->length < s->allocated_length/2)) { \
											while (s->length > s->allocated_length) { \
												s->allocated_length *= 2; \
											} \
											while (s->length < s->allocated_length/2) { \
												s->allocated_length /= 2; \
											} \
											\
											type* new_data = (type*)mu_realloc(s->data, sizeof(type) * s->allocated_length); \
											if (new_data == 0) { \
												s->length = old_length; \
												s->allocated_length = old_allocated_length; \
												if (cd) { \
													for (size_m i = 0; i < s->length; i++) { \
														function_name_prefix##release_element(0, s, i); \
													} \
												} \
												MU_SET_RESULT(result, MUMA_FAILED_TO_ALLOCATE) \
												return; \
											} \
											\
											s->data = new_data; \
										} \
										\
										if (old_length < s->length) { \
											mu_memset(&s->data[old_length], 0, sizeof(type)*(s->allocated_length-old_length)); \
											\
											if (cd) { \
												for (size_m i = old_length; i < s->length; i++) { \
													on_creation(&s->data[i]); \
												} \
											} \
										} \
										\
										if (cd) { \
											for (size_m i = 0; i < s->length && i < old_length; i++) { \
												function_name_prefix##release_element(0, s, i); \
											} \
										} \
									} \
									\
									void function_name_prefix##resize(mumaResult* result, struct_name* s, size_m length) { \
										function_name_prefix##inner_resize(result, s, length, MU_TRUE); \
									} \
									\
									void function_name_prefix##inner_lshift(mumaResult* result, struct_name* s, size_m index, size_m amount, muBool cd) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (index >= s->length) { \
											MU_SET_RESULT(result, MUMA_INVALID_INDEX) \
											return; \
										} \
										\
										if (amount == 0) { \
											return; \
										} \
										\
										if (amount > index) { \
											MU_SET_RESULT(result, MUMA_INVALID_SHIFT_AMOUNT) \
											return; \
										} \
										\
										if (cd) { \
											for (size_m i = 0; i < s->length; i++) { \
												function_name_prefix##hold_element(0, s, i); \
											} \
										} \
										\
										/* Dangerous; resize may fail after this */ \
										if (cd) { \
											for (size_m i = index-amount; i < index; i++) { \
												on_destruction(&s->data[i]); \
											} \
										} \
										\
										mu_memmove(&s->data[index-amount], &s->data[index], sizeof(type)*(s->length-index)); \
										\
										mumaResult res = MUMA_SUCCESS; \
										function_name_prefix##inner_resize(&res, s, s->length-amount, MU_FALSE); \
										\
										if (cd) { \
											for (size_m i = 0; i < s->length; i++) { \
												function_name_prefix##release_element(0, s, i); \
											} \
										} \
										\
										if (res != MUMA_SUCCESS) { \
											MU_SET_RESULT(result, res) \
											return; \
										} \
									} \
									\
									void function_name_prefix##lshift(mumaResult* result, struct_name* s, size_m index, size_m amount) { \
										function_name_prefix##inner_lshift(result, s, index, amount, MU_TRUE); \
									} \
									\
									void function_name_prefix##inner_rshift(mumaResult* result, struct_name* s, size_m index, size_m amount, muBool cd) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										if (index >= s->length) { \
											MU_SET_RESULT(result, MUMA_INVALID_INDEX) \
											return; \
										} \
										\
										if (amount == 0) { \
											return; \
										} \
										\
										if (cd) { \
											for (size_m i = 0; i < s->length; i++) { \
												function_name_prefix##hold_element(0, s, i); \
											} \
										} \
										\
										mumaResult res = MUMA_SUCCESS; \
										function_name_prefix##inner_resize(&res, s, s->length+amount, MU_FALSE); \
										if (res != MUMA_SUCCESS) { \
											if (cd) { \
												for (size_m i = 0; i < s->length; i++) { \
													function_name_prefix##release_element(0, s, i); \
												} \
											} \
											MU_SET_RESULT(result, res) \
											return; \
										} \
										\
										mu_memmove(&s->data[index+amount], &s->data[index], sizeof(type)*((s->length-index)-1)); \
										\
										if (cd) { \
											for (size_m i = 0; i < index; i++) { \
												function_name_prefix##release_element(0, s, i); \
											} \
											for (size_m i = index+amount; i < s->length; i++) { \
												function_name_prefix##release_element(0, s, i); \
											} \
										} \
										\
										mu_memset(&s->data[index], 0, sizeof(type)*(amount)); \
										\
										if (cd) { \
											for (size_m i = index; i < index+amount; i++) { \
												on_creation(&s->data[i]); \
											} \
										} \
									} \
									\
									void function_name_prefix##rshift(mumaResult* result, struct_name* s, size_m index, size_m amount) { \
										function_name_prefix##inner_rshift(result, s, index, amount, MU_TRUE); \
									} \
									\
									void function_name_prefix##multiinsert(mumaResult* result, struct_name* s, size_m index, type* insert, size_m count) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										for (size_m i = 0; i < s->length; i++) { \
											function_name_prefix##hold_element(0, s, i); \
										} \
										\
										mumaResult res = MUMA_SUCCESS; \
										function_name_prefix##inner_rshift(&res, s, index, count, MU_FALSE); \
										if (res != MUMA_SUCCESS) { \
											for (size_m i = 0; i < s->length; i++) { \
												function_name_prefix##release_element(0, s, i); \
											} \
											MU_SET_RESULT(result, res) \
											return; \
										} \
										\
										mu_memcpy(&s->data[index], insert, sizeof(type)*count); \
										\
										for (size_m i = 0; i < index; i++) { \
											function_name_prefix##release_element(0, s, i); \
										} \
										for (size_m i = index+count; i < s->length; i++) { \
											function_name_prefix##release_element(0, s, i); \
										} \
										\
										for (size_m i = index; i < index+count; i++) { \
											on_creation(&s->data[i]); \
										} \
									} \
									\
									void function_name_prefix##insert(mumaResult* result, struct_name* s, size_m index, type insert) { \
										function_name_prefix##multiinsert(result, s, index, &insert, 1); \
									} \
									\
									void function_name_prefix##multierase(mumaResult* result, struct_name* s, size_m index, size_m count) { \
										function_name_prefix##lshift(result, s, index+count, count); \
									} \
									\
									void function_name_prefix##erase(mumaResult* result, struct_name* s, size_m index) { \
										function_name_prefix##multierase(result, s, index, 1); \
									} \
									void function_name_prefix##clear(mumaResult* result, struct_name* s) { \
										function_name_prefix##destroy(result, s); \
									} \
									\
									void function_name_prefix##multipush(mumaResult* result, struct_name* s, type* push, size_m count) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										size_m old_length = s->length; \
										for (size_m i = 0; i < s->length; i++) { \
											function_name_prefix##hold_element(0, s, i); \
										} \
										\
										mumaResult res = MUMA_SUCCESS; \
										function_name_prefix##inner_resize(&res, s, s->length+count, MU_FALSE); \
										if (res != MUMA_SUCCESS) { \
											for (size_m i = 0; i < s->length; i++) { \
												function_name_prefix##release_element(0, s, i); \
											} \
											MU_SET_RESULT(result, res) \
											return; \
										} \
										\
										mu_memcpy(&s->data[s->length-count], push, sizeof(type)*count); \
										\
										for (size_m i = 0; i < old_length; i++) { \
											function_name_prefix##release_element(0, s, i); \
										} \
										\
										for (size_m i = s->length-count; i < s->length; i++) { \
											on_creation(&s->data[i]); \
										} \
									} \
									\
									void function_name_prefix##push(mumaResult* result, struct_name* s, type push) { \
										function_name_prefix##multipush(result, s, &push, 1); \
									} \
									\
									void function_name_prefix##multipop(mumaResult* result, struct_name* s, size_m count) { \
										function_name_prefix##resize(result, s, s->length-count); \
									} \
									\
									void function_name_prefix##pop(mumaResult* result, struct_name* s) { \
										function_name_prefix##multipop(result, s, 1); \
									} \
									\
									size_m function_name_prefix##find(mumaResult* result, struct_name* s, type find) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										for (size_m i = 0; i < s->length; i++) { \
											function_name_prefix##hold_element(0, s, i); \
											if (type_comparison_func(find, s->data[i])) { \
												function_name_prefix##release_element(0, s, i); \
												return i; \
											} \
											function_name_prefix##release_element(0, s, i); \
										} \
										\
										MU_SET_RESULT(result, MUMA_NOT_FOUND) \
										return MU_NONE; \
									} \
									\
									void function_name_prefix##find_push(mumaResult* result, struct_name* s, type find, size_m* p_index) { \
										MU_SET_RESULT(result, MUMA_SUCCESS) \
										\
										mumaResult res = MUMA_SUCCESS; \
										size_m index = function_name_prefix##find(&res, s, find); \
										if (index != MU_NONE) { \
											if (p_index != MU_NULL_PTR) { \
												*p_index = index; \
											} \
											return; \
										} \
										if (res != MUMA_SUCCESS && res != MUMA_NOT_FOUND) { \
											if (p_index != MU_NULL_PTR) { \
												*p_index = MU_NONE; \
											} \
											MU_SET_RESULT(result, res) \
											return; \
										} \
										\
										function_name_prefix##push(&res, s, find); \
										if (res != MUMA_SUCCESS) { \
											if (p_index != MU_NULL_PTR) { \
												*p_index = MU_NONE; \
											} \
											MU_SET_RESULT(result, res) \
											return; \
										} \
										\
										if (p_index != MU_NULL_PTR) { \
											*p_index = s->length-1; \
										} \
									}

							#ifdef __cplusplus
								}
							#endif

						#endif /* MUMA_H */

					/* muMultithreading version 1.0.0 header (only if thread safe) */
					// CHANGES:
					// * Removed muma header inclusion because this library already has it.
					#ifdef MU_THREADSAFE
						#if !defined(MU_CHECK_VERSION_MISMATCHING) && defined(MUM_H) && \
							(MUM_VERSION_MAJOR != 1 || MUM_VERSION_MINOR != 0 || MUM_VERSION_PATCH != 0)

							#pragma message("[MUS] muMultithreading's header has already been defined, but version doesn't match the version that this library is built for. This may lead to errors, warnings, or unexpected behavior. Define MU_CHECK_VERSION_MISMATCHING before this to turn off this message.")

						#endif

						#ifndef MUM_H
							#define MUM_H

							#ifdef __cplusplus
							extern "C" { // }
							#endif

							#define MUM_VERSION_MAJOR 1
							#define MUM_VERSION_MINOR 0
							#define MUM_VERSION_PATCH 0

							/* Enums */

								MU_ENUM(mumResult,
									MUM_SUCCESS,

									MUM_MUMA_SUCCESS,
									MUM_MUMA_FAILED_TO_ALLOCATE,
									MUM_MUMA_INVALID_INDEX,
									MUM_MUMA_INVALID_SHIFT_AMOUNT,
									MUM_MUMA_NOT_FOUND,

									MUM_ALLOCATION_FAILED,

									MUM_ALREADY_INITIALIZED,
									MUM_ALREADY_TERMINATED,
									MUM_NOT_YET_INITIALIZED,

									MUM_CREATE_CALL_FAILED,
									MUM_DESTROY_CALL_FAILED,
									MUM_WAIT_CALL_FAILED,
									MUM_LOCK_CALL_FAILED,
									MUM_UNLOCK_CALL_FAILED,
									MUM_GET_RETURN_VALUE_CALL_FAILED,

									MUM_INVALID_ID,

									MUM_THREAD_TIMED_OUT,
									MUM_PREVIOUS_THREAD_CLOSED_BEFORE_LOCK
								)

							/* Macros */

								#define muThread size_m
								#define muMutex size_m
								#define muSpinlock size_m

								#ifdef MU_SPINLOCK
									#define muLock muSpinlock
									#define mu_lock_create mu_spinlock_create
									#define mu_lock_destroy mu_spinlock_destroy
									#define mu_lock_lock mu_spinlock_lock
									#define mu_lock_unlock mu_spinlock_unlock
								#else
									#define muLock muMutex
									#define mu_lock_create mu_mutex_create
									#define mu_lock_destroy mu_mutex_destroy
									#define mu_lock_lock mu_mutex_lock
									#define mu_lock_unlock mu_mutex_unlock
								#endif

							/* Incomplete types */

								typedef struct mumContext mumContext;

							/* Global variables */

								MUDEF mumContext* mum_global_context;

							/* Functions */

								/* Names */

									#ifdef MUM_NAMES
										MUDEF const char* mum_result_get_name(mumResult result);
									#endif

								/* Initiation/Termination */

									MUDEF void mum_init(mumResult* result);
									MUDEF void mum_term(mumResult* result);

								/* Thread */

									MUDEF muThread mu_thread_create(mumResult* result, void (*start)(void* args), void* args);
									MUDEF muThread mu_thread_destroy(mumResult* result, muThread thread);

									MUDEF void mu_thread_exit(void* ret);
									MUDEF void mu_thread_wait(mumResult* result, muThread thread);
									MUDEF void* mu_thread_get_return_value(mumResult* result, muThread thread);

								/* Mutex */

									MUDEF muMutex mu_mutex_create(mumResult* result);
									MUDEF muMutex mu_mutex_destroy(mumResult* result, muMutex mutex);

									MUDEF void mu_mutex_lock(mumResult* result, muMutex mutex);
									MUDEF void mu_mutex_unlock(mumResult* result, muMutex mutex);

								/* Spinlock */

									MUDEF muSpinlock mu_spinlock_create(mumResult* result);
									MUDEF muSpinlock mu_spinlock_destroy(mumResult* result, muSpinlock spinlock);

									MUDEF void mu_spinlock_lock(mumResult* result, muSpinlock spinlock);
									MUDEF void mu_spinlock_unlock(mumResult* result, muSpinlock spinlock);

							#ifdef __cplusplus
							}
							#endif

						#endif
					#endif

					#ifdef __cplusplus
					extern "C" { // }
					#endif

					#define MUS_VERSION_MAJOR 1
					#define MUS_VERSION_MINOR 0
					#define MUS_VERSION_PATCH 0

					/* C standard library dependencies */

						#if !defined(mu_log10) || \
							!defined(mu_floor) || \
							!defined(mu_pow)   || \
							!defined(mu_fmod)

							#include <math.h>

							#ifndef mu_log10
								#define mu_log10 log10
							#endif

							#ifndef mu_floor
								#define mu_floor floor
							#endif

							#ifndef mu_pow
								#define mu_pow pow
							#endif

							#ifndef mu_fmod
								#define mu_fmod fmod
							#endif

						#endif

					/* Incomplete types */

						typedef struct musContext musContext;

					/* Global variables */

						MUDEF musContext* mus_global_context;

					/* Macros */

						#define muCodePoint size_m
						#define muString size_m

					/* Enums */

						MU_ENUM(musResult,
							MUS_SUCCESS,

							MUS_ALREADY_INITIALIZED,
							MUS_ALLOCATION_FAILED,
							MUS_ALREADY_TERMINATED,
							MUS_NOT_YET_INITIALIZED,

							MUS_UNKNOWN_CHARACTER_ENCODING,

							MUS_CHARACTER_CANNOT_BE_ENCODED,

							MUS_INVALID_CHARACTER_ENCODING,
							MUS_INVALID_CODE_POINT_SIZE,
							MUS_INVALID_DATA_SIZE,
							MUS_INVALID_DATA_POINTER,
							MUS_INVALID_OFFSET,
							MUS_INVALID_ID,
							MUS_INVALID_DATA,

							MUS_INSUFFICIENT_DATA_SIZE,

							MUS_NONMATCHING_CHARACTER_ENCODING,

							MUS_OVERFLOW,

							MUS_MUMA_SUCCESS,
							MUS_MUMA_FAILED_TO_ALLOCATE,
							MUS_MUMA_INVALID_INDEX,
							MUS_MUMA_INVALID_SHIFT_AMOUNT,
							MUS_MUMA_NOT_FOUND
						)

						MU_ENUM(muCharacterEncoding,
							MU_UNKNOWN_CHARACTER_ENCODING,
							MU_ASCII,
							MU_UTF8,
						)

					/* Functions */

						/* Names */

							#ifdef MUS_NAMES
								MUDEF const char* mus_result_get_name(musResult result);
							#endif

						/* Initiation / Termination */

							MUDEF void mus_init(musResult* result);
							MUDEF void mus_term(musResult* result);

						/* String functions */

							/* Creation / Destruction */

								MUDEF muString mu_string_create(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size);
								MUDEF muString mu_string_destroy(musResult* result, muString string);
								MUDEF muString mu_string_duplicate(musResult* result, muString string);

							/* Data */

								MUDEF muByte* mu_string_get_raw_data(musResult* result, muString string, size_m* size);

							/* Character encoding */

								MUDEF muCharacterEncoding mu_string_get_character_encoding(musResult* result, muString string);
								MUDEF void mu_string_convert_character_encoding(musResult* result, muString string, muCharacterEncoding desired_encoding);

							/* Code point */

								MUDEF size_m mu_string_get_code_point_length(musResult* result, muString string);

								MUDEF size_m mu_string_get_code_point_offset(musResult* result, muString string, size_m offset, size_m index);

								MUDEF muCodePoint mu_string_get_code_point(musResult* result, muString string, size_m offset);
								MUDEF void mu_string_set_code_point(musResult* result, muString string, muCodePoint code_point, size_m offset);

							/* Insert */

								MUDEF void mu_string_insert_raw_string(musResult* result, muString string, muCharacterEncoding encoding, muByte* data, size_m data_size, size_m offset);

								MUDEF void mu_string_insert_integer(musResult* result, muString string, int64_m i, size_m offset);
								MUDEF void mu_string_insert_float(musResult* result, muString string, float d, size_m decimal_places, size_m offset);
								MUDEF void mu_string_insert_double(musResult* result, muString string, double d, size_m decimal_places, size_m offset);

						/* Raw string functions */

							/* Conversion */

								MUDEF size_m mu_raw_string_get_character_encoding_conversion_size(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, muCharacterEncoding desired_encoding);
								MUDEF void mu_raw_string_convert_character_encoding(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, muCharacterEncoding output_encoding, muByte* output_data, size_m output_data_size);

							/* Integer/Float/Double conversion */

								MUDEF size_m mu_raw_string_get_integer_conversion_size(musResult* result, muCharacterEncoding encoding, int64_m i);
								MUDEF void mu_raw_string_convert_to_integer(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, int64_m i);
								MUDEF int64_m mu_raw_string_get_integer(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size);

								MUDEF size_m mu_raw_string_get_float_conversion_size(musResult* result, muCharacterEncoding encoding, float d, size_m decimal_places);
								MUDEF void mu_raw_string_convert_to_float(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, float d, size_m decimal_places);
								MUDEF float mu_raw_string_get_float(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size);

								MUDEF size_m mu_raw_string_get_double_conversion_size(musResult* result, muCharacterEncoding encoding, double d, size_m decimal_places);
								MUDEF void mu_raw_string_convert_to_double(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, double d, size_m decimal_places);
								MUDEF double mu_raw_string_get_double(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size);

						/* Cross-encoding functions */

							MUDEF size_m mu_character_encoding_get_code_point_size(musResult* result, muCharacterEncoding encoding, muCodePoint code_point);
							MUDEF muCodePoint mu_character_encoding_get_code_point(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size);
							MUDEF void mu_character_encoding_set_code_point(musResult* result, muCharacterEncoding encoding, muCodePoint code_point, muByte* data, size_m data_size);

							MUDEF muBool mu_character_encoding_verify_raw_string(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size);
							MUDEF size_m mu_character_encoding_get_raw_string_code_point_length(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size);
							MUDEF size_m mu_character_encoding_get_raw_string_code_point_offset(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, size_m offset, size_m index);

						/* Encoding-specific functions */

							/* ASCII */

								MUDEF size_m mu_ASCII_get_code_point_size(musResult* result, muCodePoint code_point);
								MUDEF muCodePoint mu_ASCII_get_code_point(musResult* result, muByte* data, size_m data_size);
								MUDEF void mu_ASCII_set_code_point(musResult* result, muCodePoint code_point, muByte* data, size_m data_size);

								MUDEF muBool mu_ASCII_verify_raw_string(musResult* result, muByte* data, size_m data_size);
								MUDEF size_m mu_ASCII_get_raw_string_first_code_point_index(musResult* result, muByte* data, size_m data_size);
								MUDEF size_m mu_ASCII_get_raw_string_code_point_length(musResult* result, muByte* data, size_m data_size);
								MUDEF size_m mu_ASCII_get_raw_string_code_point_offset(musResult* result, muByte* data, size_m data_size, size_m offset, size_m index);

							/* UTF-8 */

								MUDEF size_m mu_UTF8_get_code_point_size(musResult* result, muCodePoint code_point);
								MUDEF muCodePoint mu_UTF8_get_code_point(musResult* result, muByte* data, size_m data_size);
								MUDEF void mu_UTF8_set_code_point(musResult* result, muCodePoint code_point, muByte* data, size_m data_size);

								MUDEF muBool mu_UTF8_verify_raw_string(musResult* result, muByte* data, size_m data_size);
								MUDEF size_m mu_UTF8_get_raw_string_code_point_length(musResult* result, muByte* data, size_m data_size);
								MUDEF size_m mu_UTF8_get_raw_string_code_point_offset(musResult* result, muByte* data, size_m data_size, size_m offset, size_m index);

						/* Code point */

							/* Uppercase/Lowercase */

								MUDEF muCodePoint mu_code_point_lowercase(musResult* result, muCharacterEncoding encoding, muCodePoint code_point);
								MUDEF muCodePoint mu_code_point_uppercase(musResult* result, muCharacterEncoding encoding, muCodePoint code_point);

					#ifdef __cplusplus
					}
					#endif
				#endif /* MUS_H */

			#ifdef __cplusplus
			extern "C" { // }
			#endif

			#define MUCOSA_VERSION_MAJOR 1
			#define MUCOSA_VERSION_MINOR 0
			#define MUCOSA_VERSION_PATCH 0

			/* C standard library dependencies */

				#if !defined(mu_strlen) || \
					!defined(mu_strcmp)

					#include <string.h>

					#ifndef mu_strlen
						#define mu_strlen strlen
					#endif

					#ifndef mu_strcmp
						#define mu_strcmp strcmp
					#endif

				#endif

				#if !defined(mu_setlocale)

					#include <locale.h>

					#ifndef mu_setlocale
						#define mu_setlocale setlocale
					#endif

				#endif

				#if !defined(mu_fflush) || \
					!defined(mu_stdout)

					#include <stdio.h>

					#ifndef mu_fflush
						#define mu_fflush fflush
					#endif

					#ifndef mu_stdout
						#define mu_stdout stdout
					#endif

				#endif

			/* Incomplete types */

				typedef struct muCOSAContext muCOSAContext;

			/* Global variables */

				MUDEF muCOSAContext* muCOSA_global_context;

			/* Macros */

				/* Objects */

					#define muWindow size_m

				/* States */

					#define muButtonState muBool
					#define MU_BUTTON_STATE_RELEASED 0
					#define MU_BUTTON_STATE_HELD 1

					#define muState muBool
					#define MU_ON 1
					#define MU_OFF 0

				/* OS macros */

					#ifndef MUCOSA_NO_AUTOMATIC_API

						#ifdef MU_UNIX
							#define MUCOSA_X11
						#endif

						#ifdef MU_WIN32
							#define MUCOSA_WIN32
						#endif

					#endif

					#if defined(MUCOSA_VULKAN) && !defined(MUCOSA_NO_INCLUDE_VULKAN)
						#ifdef MUCOSA_WIN32
							#define VK_USE_PLATFORM_WIN32_KHR
						#elif defined(MUCOSA_X11)
							#define VK_USE_PLATFORM_XLIB_KHR
						#endif
					#endif

			/* Enums */

				MU_ENUM(muCOSAResult,
					MUCOSA_SUCCESS,

					MUCOSA_ALREADY_INITIALIZED,
					MUCOSA_ALREADY_TERMINATED,
					MUCOSA_ALREADY_ACTIVE,
					MUCOSA_ALREADY_INACTIVE,

					MUCOSA_NOT_YET_INITIALIZED,

					MUCOSA_ALLOCATION_FAILED,

					MUCOSA_UNKNOWN_WINDOW_SYSTEM,
					MUCOSA_UNKNOWN_GRAPHICS_API,
					MUCOSA_UNKNOWN_KEYBOARD_KEY,
					MUCOSA_UNKNOWN_KEYBOARD_STATE,
					MUCOSA_UNKNOWN_MOUSE_BUTTON,
					MUCOSA_UNKNOWN_WINDOW_HANDLE,

					MUCOSA_UNSUPPORTED_WINDOW_SYSTEM,
					MUCOSA_UNSUPPORTED_FEATURE, // Could mean that it rather can't be (or hasn't been) implemented, or that
					// the specific thing you're trying to do won't work on this device/OS for some reason (for example, on X11,
					// an Atom needed for that task can't be found).
					MUCOSA_UNSUPPORTED_OPENGL_FEATURE, // Something relating to OpenGL isn't supported or couldn't be found.
					MUCOSA_UNSUPPORTED_GRAPHICS_API, // Graphics API function was called when that API
					// wasn't explicity defined.

					MUCOSA_FAILED_CONNECTION_TO_SERVER,
					MUCOSA_FAILED_CREATE_WINDOW,
					MUCOSA_FAILED_LOAD_FUNCTIONS,
					MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER, // Not fatal
					MUCOSA_FAILED_CREATE_OPENGL_CONTEXT,
					MUCOSA_FAILED_LOAD_OPENGL_CONTEXT,
					MUCOSA_FAILED_USE_PIXEL_FORMAT, // Not fatal
					MUCOSA_FAILED_JOIN_THREAD,
					MUCOSA_FAILED_CREATE_THREAD,
					MUCOSA_FAILED_CREATE_INPUT_METHOD, // (X11)
					MUCOSA_FAILED_GET_INPUT_STYLES, // (X11)
					MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE, // (X11)
					MUCOSA_FAILED_CREATE_INPUT_CONTEXT, // (X11)
					MUCOSA_FAILED_REGISTER_WINDOW_CLASS, // (Win32)
					MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR, // (Win32)
					MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8, // (Win32)
					MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS, // (Win32)
					MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW, // (Win32)
					MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT, // (Win32)
					MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT, // (Win32)
					MUCOSA_FAILED_SET_PIXEL_FORMAT, // (Win32)
					MUCOSA_FAILED_QUERY_WINDOW_INFO, // (Win32)
					MUCOSA_FAILED_SET_WINDOW_INFO, // (Win32)
					MUCOSA_FAILED_GET_IMM_CONTEXT, // (Win32)
					MUCOSA_FAILED_LET_IMM_CONTEXT, // (Win32)
					MUCOSA_FAILED_GLOBAL_ALLOCATION, // (Win32)
					MUCOSA_FAILED_GLOBAL_LOCK, // (Win32)
					MUCOSA_FAILED_HOLD_CLIPBOARD, // (Win32)
					MUCOSA_FAILED_SET_CLIPBOARD, // (Win32)

					MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS,
					MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS,
					MUCOSA_INVALID_ID,
					MUCOSA_INVALID_SAMPLE_COUNT,
					MUCOSA_INVALID_DIMENSIONS, // Often caused by width/height being outside of min/max width/height
					MUCOSA_INVALID_POINTER, // Like if you pass in a null pointer when a real pointer is
					// expected.
					MUCOSA_INVALID_WINDOW_STATE, // For example, when you try to focus a window that is
					// invisible or minimized in X11 (but only sometimes, IT'S COMPLICATED).
					MUCOSA_INVALID_TIME, // Like if you try passing a negative value to sleep for example.

					MUCOSA_NONEXISTENT_DEVICE, // For example, you requested the position of the cursor,
					// but there is no cursor. For whatever reason, lmao.

					MUCOSA_OVERSIZED_CLIPBOARD, // Clipboard was too big to copy. As of right now, on X11,
					// this is triggered by INCR not being implemented, which is my bad and should be done
					// at some point.

					MUCOSA_WINDOW_NON_RESIZABLE,

					MUCOSA_MUMA_SUCCESS,
					MUCOSA_MUMA_FAILED_TO_ALLOCATE,
					MUCOSA_MUMA_INVALID_INDEX,
					MUCOSA_MUMA_INVALID_SHIFT_AMOUNT,
					MUCOSA_MUMA_NOT_FOUND,
				)

				MU_ENUM(muWindowSystem,
					MU_WINDOW_SYSTEM_UNKNOWN,

					MU_WINDOW_SYSTEM_AUTO,
					MU_WINDOW_SYSTEM_X11,
					MU_WINDOW_SYSTEM_WIN32,
				)

				MU_ENUM(muWindowHandle,
					MU_WINDOWS_HWND,
					MU_X11_DISPLAY,
					MU_X11_WINDOW,
					MU_X11_PARENT_WINDOW,
				)

				MU_ENUM(muGraphicsAPI,
					MU_NO_GRAPHICS_API,

					MU_OPENGL_1_0,
					MU_OPENGL_1_1,
					MU_OPENGL_1_2,
					MU_OPENGL_1_2_1,
					MU_OPENGL_1_3,
					MU_OPENGL_1_4,
					MU_OPENGL_1_5,
					MU_OPENGL_2_0,
					MU_OPENGL_2_1,
					MU_OPENGL_3_0,
					MU_OPENGL_3_1,
					MU_OPENGL_3_2_CORE,
					MU_OPENGL_3_2_COMPATIBILITY,
					MU_OPENGL_3_3_CORE,
					MU_OPENGL_3_3_COMPATIBILITY,
					MU_OPENGL_4_0_CORE,
					MU_OPENGL_4_0_COMPATIBILITY,
					MU_OPENGL_4_1_CORE,
					MU_OPENGL_4_1_COMPATIBILITY,
					MU_OPENGL_4_2_CORE,
					MU_OPENGL_4_2_COMPATIBILITY,
					MU_OPENGL_4_3_CORE,
					MU_OPENGL_4_3_COMPATIBILITY,
					MU_OPENGL_4_4_CORE,
					MU_OPENGL_4_4_COMPATIBILITY,
					MU_OPENGL_4_5_CORE,
					MU_OPENGL_4_5_COMPATIBILITY,
					MU_OPENGL_4_6_CORE,
					MU_OPENGL_4_6_COMPATIBILITY
				)
				#define MUCOSA_OPENGL_FIRST MU_OPENGL_1_0
				#define MUCOSA_OPENGL_LAST MU_OPENGL_4_6_COMPATIBILITY

				MU_ENUM(muCursorStyle,
					MU_CURSOR_STYLE_UNKNOWN=0,

					// Taken from LÖVE
					// https://love2d.org/wiki/CursorType
					// @TODO Add invisible
					MU_CURSOR_STYLE_DEFAULT,
					MU_CURSOR_STYLE_ARROW,
					MU_CURSOR_STYLE_IBEAM,
					MU_CURSOR_STYLE_WAIT,
					MU_CURSOR_STYLE_WAIT_ARROW,
					MU_CURSOR_STYLE_CROSSHAIR,
					MU_CURSOR_STYLE_HAND,
					MU_CURSOR_STYLE_SIZE_EAST_WEST,
					MU_CURSOR_STYLE_SIZE_NORTH_SOUTH,
					MU_CURSOR_STYLE_SIZE_NORTH_EAST_SOUTH_WEST,
					MU_CURSOR_STYLE_SIZE_NORTH_WEST_SOUTH_EAST,
					MU_CURSOR_STYLE_SIZE_ALL,
					MU_CURSOR_STYLE_NO
				)

				MU_ENUM(muKeyboardKey,
					MU_KEYBOARD_KEY_UNKNOWN,

					// Note: this list is by no means complete;
					// missing many basic ASCII characters like:
					// ~ \ [] ; . /
					// Plan to add more later.

					MU_KEYBOARD_KEY_BACKSPACE,
					MU_KEYBOARD_KEY_TAB,
					MU_KEYBOARD_KEY_CLEAR,
					MU_KEYBOARD_KEY_RETURN,
					MU_KEYBOARD_KEY_PAUSE,
					MU_KEYBOARD_KEY_ESCAPE,
					MU_KEYBOARD_KEY_MODECHANGE,
					MU_KEYBOARD_KEY_SPACE,
					MU_KEYBOARD_KEY_PRIOR,
					MU_KEYBOARD_KEY_NEXT,
					MU_KEYBOARD_KEY_END,
					MU_KEYBOARD_KEY_HOME,
					MU_KEYBOARD_KEY_LEFT,
					MU_KEYBOARD_KEY_UP,
					MU_KEYBOARD_KEY_RIGHT,
					MU_KEYBOARD_KEY_DOWN,
					MU_KEYBOARD_KEY_SELECT,
					MU_KEYBOARD_KEY_PRINT,
					MU_KEYBOARD_KEY_EXECUTE,
					MU_KEYBOARD_KEY_INSERT,
					MU_KEYBOARD_KEY_DELETE,
					MU_KEYBOARD_KEY_HELP,
					MU_KEYBOARD_KEY_0,
					MU_KEYBOARD_KEY_1,
					MU_KEYBOARD_KEY_2,
					MU_KEYBOARD_KEY_3,
					MU_KEYBOARD_KEY_4,
					MU_KEYBOARD_KEY_5,
					MU_KEYBOARD_KEY_6,
					MU_KEYBOARD_KEY_7,
					MU_KEYBOARD_KEY_8,
					MU_KEYBOARD_KEY_9,
					MU_KEYBOARD_KEY_A,
					MU_KEYBOARD_KEY_B,
					MU_KEYBOARD_KEY_C,
					MU_KEYBOARD_KEY_D,
					MU_KEYBOARD_KEY_E,
					MU_KEYBOARD_KEY_F,
					MU_KEYBOARD_KEY_G,
					MU_KEYBOARD_KEY_H,
					MU_KEYBOARD_KEY_I,
					MU_KEYBOARD_KEY_J,
					MU_KEYBOARD_KEY_K,
					MU_KEYBOARD_KEY_L,
					MU_KEYBOARD_KEY_M,
					MU_KEYBOARD_KEY_N,
					MU_KEYBOARD_KEY_O,
					MU_KEYBOARD_KEY_P,
					MU_KEYBOARD_KEY_Q,
					MU_KEYBOARD_KEY_R,
					MU_KEYBOARD_KEY_S,
					MU_KEYBOARD_KEY_T,
					MU_KEYBOARD_KEY_U,
					MU_KEYBOARD_KEY_V,
					MU_KEYBOARD_KEY_W,
					MU_KEYBOARD_KEY_X,
					MU_KEYBOARD_KEY_Y,
					MU_KEYBOARD_KEY_Z,
					MU_KEYBOARD_KEY_LEFT_WINDOWS,
					MU_KEYBOARD_KEY_RIGHT_WINDOWS,
					MU_KEYBOARD_KEY_NUMPAD_0,
					MU_KEYBOARD_KEY_NUMPAD_1,
					MU_KEYBOARD_KEY_NUMPAD_2,
					MU_KEYBOARD_KEY_NUMPAD_3,
					MU_KEYBOARD_KEY_NUMPAD_4,
					MU_KEYBOARD_KEY_NUMPAD_5,
					MU_KEYBOARD_KEY_NUMPAD_6,
					MU_KEYBOARD_KEY_NUMPAD_7,
					MU_KEYBOARD_KEY_NUMPAD_8,
					MU_KEYBOARD_KEY_NUMPAD_9,
					MU_KEYBOARD_KEY_MULTIPLY,
					MU_KEYBOARD_KEY_ADD,
					MU_KEYBOARD_KEY_SEPARATOR,
					MU_KEYBOARD_KEY_SUBTRACT,
					MU_KEYBOARD_KEY_DECIMAL,
					MU_KEYBOARD_KEY_DIVIDE,
					MU_KEYBOARD_KEY_F1,
					MU_KEYBOARD_KEY_F2,
					MU_KEYBOARD_KEY_F3,
					MU_KEYBOARD_KEY_F4,
					MU_KEYBOARD_KEY_F5,
					MU_KEYBOARD_KEY_F6,
					MU_KEYBOARD_KEY_F7,
					MU_KEYBOARD_KEY_F8,
					MU_KEYBOARD_KEY_F9,
					MU_KEYBOARD_KEY_F10,
					MU_KEYBOARD_KEY_F11,
					MU_KEYBOARD_KEY_F12,
					MU_KEYBOARD_KEY_F13,
					MU_KEYBOARD_KEY_F14,
					MU_KEYBOARD_KEY_F15,
					MU_KEYBOARD_KEY_F16,
					MU_KEYBOARD_KEY_F17,
					MU_KEYBOARD_KEY_F18,
					MU_KEYBOARD_KEY_F19,
					MU_KEYBOARD_KEY_F20,
					MU_KEYBOARD_KEY_F21,
					MU_KEYBOARD_KEY_F22,
					MU_KEYBOARD_KEY_F23,
					MU_KEYBOARD_KEY_F24,
					MU_KEYBOARD_KEY_NUMLOCK,
					MU_KEYBOARD_KEY_SCROLL,
					MU_KEYBOARD_KEY_LEFT_SHIFT,
					MU_KEYBOARD_KEY_RIGHT_SHIFT,
					MU_KEYBOARD_KEY_LEFT_CONTROL,
					MU_KEYBOARD_KEY_RIGHT_CONTROL,
					MU_KEYBOARD_KEY_LEFT_MENU,
					MU_KEYBOARD_KEY_RIGHT_MENU,
					MU_KEYBOARD_KEY_ATTN,
					MU_KEYBOARD_KEY_CRSEL,
					MU_KEYBOARD_KEY_EXSEL,
					MU_KEYBOARD_KEY_EREOF,
					MU_KEYBOARD_KEY_PLAY,
					MU_KEYBOARD_KEY_PA1,
				)
				#define MU_KEYBOARD_KEY_FIRST MU_KEYBOARD_KEY_BACKSPACE
				#define MU_KEYBOARD_KEY_LAST MU_KEYBOARD_KEY_PA1

				MU_ENUM(muKeyboardState,
					MU_KEYBOARD_STATE_UNKNOWN,

					MU_KEYBOARD_STATE_CAPS_LOCK,
					MU_KEYBOARD_STATE_SCROLL_LOCK,
					MU_KEYBOARD_STATE_NUM_LOCK,
				)
				#define MU_KEYBOARD_STATE_FIRST MU_KEYBOARD_STATE_CAPS_LOCK
				#define MU_KEYBOARD_STATE_LAST MU_KEYBOARD_STATE_NUM_LOCK

				MU_ENUM(muMouseButton,
					MU_MOUSE_BUTTON_UNKNOWN,

					MU_MOUSE_BUTTON_LEFT,
					MU_MOUSE_BUTTON_RIGHT,
					MU_MOUSE_BUTTON_MIDDLE,
				)
				#define MU_MOUSE_BUTTON_FIRST MU_MOUSE_BUTTON_LEFT
				#define MU_MOUSE_BUTTON_LAST MU_MOUSE_BUTTON_MIDDLE

			/* Struct */

				struct muPixelFormat {
					uint16_m red_bits;
					uint16_m green_bits;
					uint16_m blue_bits;
					uint16_m alpha_bits;

					uint16_m depth_bits;
					uint16_m stencil_bits;

					uint8_m samples; // Max: 16, must be a power of 2
				};
				typedef struct muPixelFormat muPixelFormat;

				struct muWindowCreateInfo {
					muPixelFormat pixel_format;

					muBool visible;
					muBool resizable;

					muBool minimized;
					muBool maximized;

					int32_m x;
					int32_m y;

					uint32_m min_width;
					uint32_m min_height;
					uint32_m max_width;
					uint32_m max_height;

					muCursorStyle cursor_style; // <-- Not permanant, only existing as the style first used upon the window's creation

					void (*dimensions_callback)(muWindow window, uint32_m width, uint32_m height);
					void (*position_callback)(muWindow window, int32_m x, int32_m y);
					void (*focus_callback)(muWindow window, muBool focused);
					void (*maximize_callback)(muWindow window, muBool maximized);
					void (*minimize_callback)(muWindow window, muBool minimized);

					void (*keyboard_key_callback)(muWindow window, muKeyboardKey keyboard_key, muButtonState state);
					void (*keyboard_state_callback)(muWindow window, muKeyboardState keyboard_state, muState state);

					void (*cursor_position_callback)(muWindow window, int32_m x, int32_m y);
					void (*mouse_button_callback)(muWindow window, muMouseButton mouse_button, muButtonState state);
					void (*scroll_callback)(muWindow window, int32_m scroll_level_add);
				};
				typedef struct muWindowCreateInfo muWindowCreateInfo;

			/* Functions */

				/* Names */

					#ifdef MUCOSA_NAMES
						MUDEF const char* muCOSA_result_get_name(muCOSAResult result);

						MUDEF const char* mu_window_system_get_name(muWindowSystem system);
						MUDEF const char* mu_window_system_get_nice_name(muWindowSystem system);

						MUDEF const char* mu_window_handle_get_name(muWindowHandle handle);
						MUDEF const char* mu_window_handle_get_nice_name(muWindowHandle handle);

						MUDEF const char* mu_graphics_api_get_name(muGraphicsAPI api);
						MUDEF const char* mu_graphics_api_get_nice_name(muGraphicsAPI api);

						MUDEF const char* mu_cursor_style_get_name(muCursorStyle style);
						MUDEF const char* mu_cursor_style_get_nice_name(muCursorStyle style);

						MUDEF const char* mu_keyboard_key_get_name(muKeyboardKey key);
						MUDEF const char* mu_keyboard_key_get_nice_name(muKeyboardKey key);

						MUDEF const char* mu_keyboard_state_get_name(muKeyboardState state);
						MUDEF const char* mu_keyboard_state_get_nice_name(muKeyboardState state);

						MUDEF const char* mu_mouse_button_get_name(muMouseButton button);
						MUDEF const char* mu_mouse_button_get_nice_name(muMouseButton button);
					#endif

				/* Initiation / Termination */

					MUDEF void muCOSA_init(muCOSAResult* result, muWindowSystem window_system);
					MUDEF void muCOSA_term(muCOSAResult* result);

					MUDEF muWindowSystem muCOSA_get_current_window_system(muCOSAResult* result);

				/* Window */

					/* Creation / Destruction */

						MUDEF muWindowCreateInfo mu_window_default_create_info(void);

						MUDEF muWindow mu_window_create(muCOSAResult* result, 
							muGraphicsAPI api, muBool (*load_functions)(void),
							muByte* name, uint16_m width, uint16_m height,
							muWindowCreateInfo create_info
						);

						MUDEF muWindow mu_window_destroy(muCOSAResult* result, muWindow window);

					/* Main loop */

						MUDEF muBool mu_window_get_closed(muCOSAResult* result, muWindow window);
						MUDEF void mu_window_close(muCOSAResult* result, muWindow window);

						// "Update" gathers input and such, should be called first and THEN frame logic
						MUDEF void mu_window_update(muCOSAResult* result, muWindow window);
						// "Swap buffers" simply puts what's been drawing on frames
						MUDEF void mu_window_swap_buffers(muCOSAResult* result, muWindow window);

					/* Get / Set */

						MUDEF muBool mu_window_get_focused(muCOSAResult* result, muWindow window);
						MUDEF void mu_window_focus(muCOSAResult* result, muWindow window);

						MUDEF muBool mu_window_get_visible(muCOSAResult* result, muWindow window);
						MUDEF void mu_window_set_visible(muCOSAResult* result, muWindow window, muBool visible);

						MUDEF void mu_window_get_position(muCOSAResult* result, muWindow window, int32_m* x, int32_m* y);
						MUDEF void mu_window_set_position(muCOSAResult* result, muWindow window, int32_m x, int32_m y);

						MUDEF void mu_window_get_dimensions(muCOSAResult* result, muWindow window, uint32_m* width, uint32_m* height);
						MUDEF void mu_window_set_dimensions(muCOSAResult* result, muWindow window, uint32_m width, uint32_m height);

						MUDEF muBool mu_window_get_maximized(muCOSAResult* result, muWindow window);
						MUDEF void mu_window_set_maximized(muCOSAResult* result, muWindow window, muBool maximized);

						MUDEF muBool mu_window_get_minimized(muCOSAResult* result, muWindow window);
						MUDEF void mu_window_set_minimized(muCOSAResult* result, muWindow window, muBool minimized);

						MUDEF void mu_window_get_minimum_dimensions(muCOSAResult* result, muWindow window, uint32_m* min_width, uint32_m* min_height);
						MUDEF void mu_window_set_minimum_dimensions(muCOSAResult* result, muWindow window, uint32_m min_width, uint32_m min_height);
						MUDEF void mu_window_get_maximum_dimensions(muCOSAResult* result, muWindow window, uint32_m* max_width, uint32_m* max_height);
						MUDEF void mu_window_set_maximum_dimensions(muCOSAResult* result, muWindow window, uint32_m max_width, uint32_m max_height);

						MUDEF void mu_window_get_cursor_position(muCOSAResult* result, muWindow window, int32_m* x, int32_m* y);
						MUDEF void mu_window_set_cursor_position(muCOSAResult* result, muWindow window, int32_m x, int32_m y);

						MUDEF muCursorStyle mu_window_get_cursor_style(muCOSAResult* result, muWindow window);
						MUDEF void mu_window_set_cursor_style(muCOSAResult* result, muWindow window, muCursorStyle style);

						MUDEF int32_m mu_window_get_scroll_level(muCOSAResult* result, muWindow window);
						MUDEF void mu_window_set_scroll_level(muCOSAResult* result, muWindow window, int32_m scroll_level);

					/* Get / Let */

						MUDEF void mu_window_get_text_input_focus(muCOSAResult* result, muWindow window, int32_m text_cursor_x, int32_m text_cursor_y, void (*callback)(muWindow window, muByte* input));
						MUDEF void mu_window_update_text_cursor(muCOSAResult* result, muWindow window, int32_m x, int32_m y);
						MUDEF void mu_window_let_text_input_focus(muCOSAResult* result, muWindow window);

					/* Get */

						MUDEF void mu_window_get_frame_extents(muCOSAResult* result, muWindow window, uint32_m* left, uint32_m* right, uint32_m* top, uint32_m* bottom);

						MUDEF muButtonState mu_window_get_keyboard_key_state(muCOSAResult* result, muWindow window, muKeyboardKey key);
						MUDEF muState mu_window_get_keyboard_state_state(muCOSAResult* result, muWindow window, muKeyboardState state);

						MUDEF muButtonState mu_window_get_mouse_button_state(muCOSAResult* result, muWindow window, muMouseButton button);

					/* Set */

						MUDEF void mu_window_set_title(muCOSAResult* result, muWindow window, muByte* title);

						MUDEF void mu_window_set_dimensions_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, uint32_m width, uint32_m height));
						MUDEF void mu_window_set_position_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, int32_m x, int32_m y));
						MUDEF void mu_window_set_focus_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muBool focused));
						MUDEF void mu_window_set_maximize_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muBool maximized));
						MUDEF void mu_window_set_minimize_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muBool minimized));

						MUDEF void mu_window_set_keyboard_key_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muKeyboardKey keyboard_key, muButtonState state));
						MUDEF void mu_window_set_keyboard_state_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muKeyboardState keyboard_state, muState state));

						MUDEF void mu_window_set_cursor_position_callback(muCOSAResult* result, muWindow win, void (*callback)(muWindow window, int32_m x, int32_m y));
						MUDEF void mu_window_set_mouse_button_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muMouseButton mouse_button, muButtonState state));
						MUDEF void mu_window_set_scroll_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, int32_m scroll_level_add));

				/* Time */

					MUDEF double mu_time_get(muCOSAResult* result);
					MUDEF void mu_time_set(muCOSAResult* result, double time);

					MUDEF void mu_sleep(muCOSAResult* result, double time);

				/* Clipboard */

					MUDEF muByte* mu_clipboard_get(muCOSAResult* result);
					MUDEF void mu_clipboard_set(muCOSAResult* result, muByte* text, size_m text_size);

				/* OS functions */

					MUDEF void* mu_os_get_window_handle(muCOSAResult* result, muWindow window, muWindowHandle handle);

				/* OpenGL */

					MUDEF void mu_opengl_bind_window(muCOSAResult* result, muWindow window);

					// Note: not necessarily UTF-8, dependent on get proc address, maybe ASCII?
					MUDEF void* mu_opengl_get_function_address(const muByte* name);

					MUDEF void mu_opengl_window_swap_interval(muCOSAResult* result, muWindow window, int interval);

				/* Vulkan */

					// Note: also not necessarily UTF-8
					MUDEF const char** mu_vulkan_get_surface_instance_extensions(muCOSAResult* result, size_m* count);

					// vk_result interpreted as VkResult*, instance as VkInstance*, allocator as const VkAllocationCallbacks*, and surface as VkSurfaceKHR*
					MUDEF void mu_vulkan_create_window_surface(muCOSAResult* result, muWindow window, void* vk_result, void* instance, void* allocator, void* surface);

			#ifdef __cplusplus
			}
			#endif
		#endif /* MUCOSA_H */

	#ifdef __cplusplus
	extern "C" { // }
	#endif

	#define MUG_VERSION_MAJOR 1
	#define MUG_VERSION_MINOR 0
	#define MUG_VERSION_PATCH 0

	/* C standard library dependencies */

		#if !defined(MU_UINT32_MAX) || \
			!defined(MU_UINT64_MAX)

			#include <stdint.h>

			#ifndef MU_UINT32_MAX
				#define MU_UINT32_MAX UINT32_MAX
			#endif

			#ifndef MU_UINT64_MAX
				#define MU_UINT64_MAX UINT64_MAX
			#endif

		#endif

		#if !defined(mu_sin) || \
			!defined(mu_cos)

			#include <math.h>

			#ifndef mu_sin
				#define mu_sin sin
			#endif

			#ifndef mu_cos
				#define mu_cos cos
			#endif

		#endif

	/* Incomplete types */

		typedef struct mugContext mugContext;

	/* Global variables */

		MUDEF mugContext* mug_global_context;

	/* Enums */

		MU_ENUM(mugResult,
			MUG_SUCCESS,

			MUG_ALREADY_INITIATED,
			MUG_ALREADY_TERMINATED,
			MUG_ALREADY_RENDERED_BUFFER,

			MUG_NOT_YET_INITIALIZED,

			MUG_FAILED_ALLOCATE,
			MUG_FAILED_LOAD_GRAPHICS_API,

			// Vulkan
			MUG_FAILED_CREATE_VK_INSTANCE,
			MUG_FAILED_CREATE_VK_SURFACE,
			MUG_FAILED_FIND_VALID_PHYSICAL_DEVICE,
			MUG_FAILED_FIND_COMPATIBLE_PHYSICAL_DEVICE,
			MUG_FAILED_GET_QUEUE_FAMILY_PROPERTIES,
			MUG_FAILED_FIND_NECESSARY_QUEUE_FAMILIES,
			MUG_FAILED_CREATE_VK_DEVICE,
			MUG_FAILED_GET_VK_SURFACE_INFO,
			MUG_FAILED_CREATE_VK_SWAPCHAIN,
			MUG_FAILED_GET_VK_SWAPCHAIN_INFO,
			MUG_FAILED_CREATE_VK_SWAPCHAIN_IMAGE_VIEWS,
			MUG_FAILED_CREATE_VK_COMMAND_POOL,
			MUG_FAILED_ALLOCATE_VK_COMMAND_BUFFERS,
			MUG_FAILED_CREATE_VK_SEMAPHORE,
			MUG_FAILED_CREATE_VK_FENCE,
			MUG_FAILED_CREATE_VK_RENDER_PASS,
			MUG_FAILED_CREATE_VK_FRAMEBUFFERS,
			MUG_FAILED_WAIT_FOR_VK_FENCE,
			MUG_FAILED_RESET_VK_FENCE,
			MUG_FAILED_RESET_VK_COMMAND_BUFFER,
			MUG_FAILED_BEGIN_VK_COMMAND_BUFFER,
			MUG_FAILED_END_VK_COMMAND_BUFFER,
			MUG_FAILED_SUBMIT_VK_QUEUE,
			MUG_FAILED_PRESENT_VK_QUEUE,
			MUG_FAILED_GET_NEXT_VK_SWAPCHAIN_IMAGE,
			MUG_FAILED_CREATE_VK_BUFFER,
			MUG_FAILED_FIND_VALID_VK_MEMORY_TYPE,
			MUG_FAILED_ALLOCATE_VK_MEMORY,
			MUG_FAILED_MAP_VK_MEMORY,
			MUG_FAILED_CREATE_VK_SHADER_MODULE,
			MUG_FAILED_CREATE_VK_PIPELINE_LAYOUT,
			MUG_FAILED_CREATE_VK_PIPELINE,
			MUG_FAILED_CREATE_VK_DESCRIPTOR_SET_LAYOUT,
			MUG_FAILED_CREATE_VK_DESCRIPTOR_POOL,
			MUG_FAILED_ALLOCATE_VK_DESCRIPTOR_SETS,

			// OpenGL
			MUG_FAILED_CREATE_GL_VERTEX_ARRAY,
			MUG_FAILED_CREATE_GL_BUFFER,
			MUG_FAILED_COMPILE_GL_SHADERS,

			MUG_NO_RENDER_CALLS_YET,

			MUG_UNKNOWN_GRAPHIC_API,

			MUG_INVALID_ID,
			MUG_INVALID_BUFFER_ID,

			MUG_MUCOSA_SUCCESS,
			MUG_MUCOSA_ALREADY_INITIALIZED,
			MUG_MUCOSA_ALREADY_TERMINATED,
			MUG_MUCOSA_ALREADY_ACTIVE,
			MUG_MUCOSA_ALREADY_INACTIVE,
			MUG_MUCOSA_NOT_YET_INITIALIZED,
			MUG_MUCOSA_ALLOCATION_FAILED,
			MUG_MUCOSA_UNKNOWN_WINDOW_SYSTEM,
			MUG_MUCOSA_UNKNOWN_GRAPHICS_API,
			MUG_MUCOSA_UNKNOWN_KEYBOARD_KEY,
			MUG_MUCOSA_UNKNOWN_KEYBOARD_STATE,
			MUG_MUCOSA_UNKNOWN_MOUSE_BUTTON,
			MUG_MUCOSA_UNKNOWN_WINDOW_HANDLE,
			MUG_MUCOSA_UNSUPPORTED_WINDOW_SYSTEM,
			MUG_MUCOSA_UNSUPPORTED_FEATURE,
			MUG_MUCOSA_UNSUPPORTED_OPENGL_FEATURE,
			MUG_MUCOSA_UNSUPPORTED_GRAPHICS_API,
			MUG_MUCOSA_FAILED_CONNECTION_TO_SERVER,
			MUG_MUCOSA_FAILED_CREATE_WINDOW,
			MUG_MUCOSA_FAILED_LOAD_FUNCTIONS,
			MUG_MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER,
			MUG_MUCOSA_FAILED_CREATE_OPENGL_CONTEXT,
			MUG_MUCOSA_FAILED_LOAD_OPENGL_CONTEXT,
			MUG_MUCOSA_FAILED_USE_PIXEL_FORMAT,
			MUG_MUCOSA_FAILED_JOIN_THREAD,
			MUG_MUCOSA_FAILED_CREATE_THREAD,
			MUG_MUCOSA_FAILED_CREATE_INPUT_METHOD,
			MUG_MUCOSA_FAILED_GET_INPUT_STYLES,
			MUG_MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE,
			MUG_MUCOSA_FAILED_CREATE_INPUT_CONTEXT,
			MUG_MUCOSA_FAILED_REGISTER_WINDOW_CLASS,
			MUG_MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR,
			MUG_MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8,
			MUG_MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS,
			MUG_MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW,
			MUG_MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT,
			MUG_MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT,
			MUG_MUCOSA_FAILED_SET_PIXEL_FORMAT,
			MUG_MUCOSA_FAILED_QUERY_WINDOW_INFO,
			MUG_MUCOSA_FAILED_SET_WINDOW_INFO,
			MUG_MUCOSA_FAILED_GET_IMM_CONTEXT,
			MUG_MUCOSA_FAILED_LET_IMM_CONTEXT,
			MUG_MUCOSA_FAILED_GLOBAL_ALLOCATION,
			MUG_MUCOSA_FAILED_GLOBAL_LOCK,
			MUG_MUCOSA_FAILED_HOLD_CLIPBOARD,
			MUG_MUCOSA_FAILED_SET_CLIPBOARD,
			MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS,
			MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS,
			MUG_MUCOSA_INVALID_ID,
			MUG_MUCOSA_INVALID_SAMPLE_COUNT,
			MUG_MUCOSA_INVALID_DIMENSIONS,
			MUG_MUCOSA_INVALID_POINTER,
			MUG_MUCOSA_INVALID_WINDOW_STATE,
			MUG_MUCOSA_INVALID_TIME,
			MUG_MUCOSA_NONEXISTENT_DEVICE,
			MUG_MUCOSA_OVERSIZED_CLIPBOARD,
			MUG_MUCOSA_WINDOW_NON_RESIZABLE,
			MUG_MUCOSA_MUMA_SUCCESS,
			MUG_MUCOSA_MUMA_FAILED_TO_ALLOCATE,
			MUG_MUCOSA_MUMA_INVALID_INDEX,
			MUG_MUCOSA_MUMA_INVALID_SHIFT_AMOUNT,
			MUG_MUCOSA_MUMA_NOT_FOUND,

			MUG_MUMA_SUCCESS,
			MUG_MUMA_FAILED_TO_ALLOCATE,
			MUG_MUMA_INVALID_INDEX,
			MUG_MUMA_INVALID_SHIFT_AMOUNT,
			MUG_MUMA_NOT_FOUND,
		)

		MU_ENUM(muGraphicAPI,
			MUG_OPENGL,
			MUG_VULKAN,
		)

	/* Macros */

		#define muGraphic size_m

		#define muRectBuffer size_m

	/* Functions */

		/* Names */

			#ifdef MUG_NAMES
				MUDEF const char* mug_result_get_name(mugResult result);
			#endif

		/* Initiation / Termination */

			MUDEF void mug_init(mugResult* result, muWindowSystem window_system);
			MUDEF void mug_term(mugResult* result);

		/* Graphic */

			/* Creation / Destruction */

				MUDEF muGraphic mu_graphic_create_via_window(mugResult* result, muGraphicAPI api, 
					muByte* name, uint16_m width, uint16_m height,
					muWindowCreateInfo create_info
				);

				MUDEF muGraphic mu_graphic_destroy(mugResult* result, muGraphic graphic);

			/* Main loop */

				MUDEF void mu_graphic_clear(mugResult* result, muGraphic graphic, float r, float g, float b, float a);

				MUDEF void mu_graphic_swap_buffers(mugResult* result, muGraphic graphic);

				MUDEF void mu_graphic_update(mugResult* result, muGraphic graphic);

			/* Get */

				MUDEF muWindow mu_graphic_get_window(mugResult* result, muGraphic graphic);

			/* Objects */

				MUDEF void mu_graphic_unload_buffer_types(mugResult* result, muGraphic graphic);

				/* Rect */

					struct muRect {
						float pos[2]; // In the centre of the rect; must be because rotation makes it so that
						// corner positions are not constant.
						float dim[2]; // Width / Height
						float col[4]; // RGBA
						float rotation; // In radians
					};
					typedef struct muRect muRect;

					// NOTE: rects is safe to be 0
					MUDEF muRectBuffer mu_rect_buffer_create(mugResult* result, muGraphic graphic, size_m rect_count, muRect* rects);
					MUDEF muRectBuffer mu_rect_buffer_destroy(mugResult* result, muGraphic graphic, muRectBuffer rb);

					MUDEF void mu_rect_buffer_render(mugResult* result, muGraphic graphic, muRectBuffer rb);

					MUDEF void mu_rect_buffer_fill(mugResult* result, muGraphic graphic, muRectBuffer rb, muRect* rects);
					MUDEF void mu_rect_buffer_subfill(mugResult* result, muGraphic graphic, muRectBuffer rb, size_m rect_count_offset, muRect* rects, size_m rect_count);

					// NOTE: rects is safe to be 0, but if it isn't, it is expected to be 'rect_count' length.
					MUDEF void mu_rect_buffer_resize(mugResult* result, muGraphic graphic, muRectBuffer rb, size_m rect_count, muRect* rects);

					MUDEF void mu_rect_buffer_unload_type(mugResult* result, muGraphic graphic);

	#ifdef __cplusplus
	}
	#endif
#endif /* MUG_H */


#ifdef MUG_IMPLEMENTATION

	/* vkbind v1.3.283.0 header */

		#ifdef MUCOSA_X11
			#define VK_USE_PLATFORM_XLIB_KHR
		#endif

		#ifdef MUCOSA_WIN32
			#define VK_USE_PLATFORM_WIN32_KHR
		#endif

		#ifndef VKBIND_H
		#define VKBIND_H

		#ifdef __cplusplus
		extern "C" {
		#endif

		/*
		vkbind's vk_platform.h implementation. See: https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#boilerplate-platform-specific-calling-conventions

		Here we define VKAPI_ATTR, VKAPI_CALL, VKAPI_PTR and make sure the sized types are defined. Support for more platforms
		will be added later. Let me know what isn't supported properly and I'll look into it.
		*/
		#ifdef _WIN32
		#define VKAPI_ATTR
		#define VKAPI_CALL  __stdcall
		#define VKAPI_PTR   __stdcall
		#else
		#define VKAPI_ATTR
		#define VKAPI_CALL
		#define VKAPI_PTR
		#endif

		/* Here we need to ensure sized types are defined. Only explicitly checking for MSVC for now. */
		#ifndef VK_NO_STDINT_H
		#if defined(_MSC_VER) && (_MSC_VER < 1600)
		    typedef   signed char       int8_t;
		    typedef unsigned char       uint8_t;
		    typedef   signed short      int16_t;
		    typedef unsigned short      uint16_t;
		    typedef   signed int		int32_t;
		    typedef unsigned int		uint32_t;
		    typedef   signed __int64    int64_t;
		    typedef unsigned __int64    uint64_t;
		#else
		    #include <stdint.h>
		#endif
		#endif  /* VK_NO_STDINT_H */

		/* stddef.h is required for size_t */
		#ifndef VK_NO_STDDEF_H
		    #include <stddef.h>
		#endif  /* VK_NO_STDDEF_H */

		#if defined(VK_USE_PLATFORM_WIN32_KHR)
		    #if !defined(VKBIND_NO_WIN32_HEADERS)
				#include <windows.h>
		    #endif
		#endif

		#if defined(VK_USE_PLATFORM_XLIB_KHR)
		    #if !defined(VKBIND_NO_XLIB_HEADERS)
				#include <X11/Xlib.h>
		    #endif
		#endif

		#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
		    #if !defined(VKBIND_NO_XLIB_HEADERS)
				#include <X11/extensions/Xrandr.h>
		    #endif
		#endif

		/* We need to define vkbind_Display and vkbind_Window */
		#if defined(VK_USE_PLATFORM_XLIB_KHR) || defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
		    #if !defined(VKBIND_NO_XLIB_HEADERS)
				typedef Display       vkbind_Display;
				typedef Window		vkbind_Window;
				typedef VisualID      vkbind_VisualID;
		    #else
				typedef void*		 vkbind_Display;
				typedef unsigned long vkbind_Window;
				typedef unsigned long vkbind_VisualID;
		    #endif
		#endif


		#define vulkan_video_codecs_common 1

		#define VK_MAKE_VIDEO_STD_VERSION(major, minor, patch)     ((((uint32_t)(major)) << 22) | (((uint32_t)(minor)) << 12) | ((uint32_t)(patch)))


		#define vulkan_video_codec_h264std 1
		#define STD_VIDEO_H264_CPB_CNT_LIST_SIZE 32
		#define STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS 6
		#define STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS 16
		#define STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS 6
		#define STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS 64
		#define STD_VIDEO_H264_MAX_NUM_LIST_REF 32
		#define STD_VIDEO_H264_MAX_CHROMA_PLANES 2
		#define STD_VIDEO_H264_NO_REFERENCE_PICTURE 0xFF

		typedef enum
		{
		    STD_VIDEO_H264_CHROMA_FORMAT_IDC_MONOCHROME = 0,
		    STD_VIDEO_H264_CHROMA_FORMAT_IDC_420 = 1,
		    STD_VIDEO_H264_CHROMA_FORMAT_IDC_422 = 2,
		    STD_VIDEO_H264_CHROMA_FORMAT_IDC_444 = 3,
		    STD_VIDEO_H264_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264ChromaFormatIdc;

		typedef enum
		{
		    STD_VIDEO_H264_PROFILE_IDC_BASELINE = 66,
		    STD_VIDEO_H264_PROFILE_IDC_MAIN = 77,
		    STD_VIDEO_H264_PROFILE_IDC_HIGH = 100,
		    STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE = 244,
		    STD_VIDEO_H264_PROFILE_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264ProfileIdc;

		typedef enum
		{
		    STD_VIDEO_H264_LEVEL_IDC_1_0 = 0,
		    STD_VIDEO_H264_LEVEL_IDC_1_1 = 1,
		    STD_VIDEO_H264_LEVEL_IDC_1_2 = 2,
		    STD_VIDEO_H264_LEVEL_IDC_1_3 = 3,
		    STD_VIDEO_H264_LEVEL_IDC_2_0 = 4,
		    STD_VIDEO_H264_LEVEL_IDC_2_1 = 5,
		    STD_VIDEO_H264_LEVEL_IDC_2_2 = 6,
		    STD_VIDEO_H264_LEVEL_IDC_3_0 = 7,
		    STD_VIDEO_H264_LEVEL_IDC_3_1 = 8,
		    STD_VIDEO_H264_LEVEL_IDC_3_2 = 9,
		    STD_VIDEO_H264_LEVEL_IDC_4_0 = 10,
		    STD_VIDEO_H264_LEVEL_IDC_4_1 = 11,
		    STD_VIDEO_H264_LEVEL_IDC_4_2 = 12,
		    STD_VIDEO_H264_LEVEL_IDC_5_0 = 13,
		    STD_VIDEO_H264_LEVEL_IDC_5_1 = 14,
		    STD_VIDEO_H264_LEVEL_IDC_5_2 = 15,
		    STD_VIDEO_H264_LEVEL_IDC_6_0 = 16,
		    STD_VIDEO_H264_LEVEL_IDC_6_1 = 17,
		    STD_VIDEO_H264_LEVEL_IDC_6_2 = 18,
		    STD_VIDEO_H264_LEVEL_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_LEVEL_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264LevelIdc;

		typedef enum
		{
		    STD_VIDEO_H264_POC_TYPE_0 = 0,
		    STD_VIDEO_H264_POC_TYPE_1 = 1,
		    STD_VIDEO_H264_POC_TYPE_2 = 2,
		    STD_VIDEO_H264_POC_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_POC_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264PocType;

		typedef enum
		{
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_SQUARE = 1,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_12_11 = 2,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_10_11 = 3,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_16_11 = 4,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_40_33 = 5,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_24_11 = 6,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_20_11 = 7,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_32_11 = 8,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_80_33 = 9,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_18_11 = 10,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_15_11 = 11,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_64_33 = 12,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_160_99 = 13,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_4_3 = 14,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_3_2 = 15,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_2_1 = 16,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
		    STD_VIDEO_H264_ASPECT_RATIO_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_ASPECT_RATIO_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264AspectRatioIdc;

		typedef enum
		{
		    STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_DEFAULT = 0,
		    STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_EXPLICIT = 1,
		    STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_IMPLICIT = 2,
		    STD_VIDEO_H264_WEIGHTED_BIPRED_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_WEIGHTED_BIPRED_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264WeightedBipredIdc;

		typedef enum
		{
		    STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_SUBTRACT = 0,
		    STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_SHORT_TERM_ADD = 1,
		    STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_LONG_TERM = 2,
		    STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_END = 3,
		    STD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_MODIFICATION_OF_PIC_NUMS_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264ModificationOfPicNumsIdc;

		typedef enum
		{
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_END = 0,
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_SHORT_TERM = 1,
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_LONG_TERM = 2,
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_LONG_TERM = 3,
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_SET_MAX_LONG_TERM_INDEX = 4,
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_UNMARK_ALL = 5,
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MARK_CURRENT_AS_LONG_TERM = 6,
		    STD_VIDEO_H264_MEM_MGMT_CONTROL_OP_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_MEM_MGMT_CONTROL_OP_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264MemMgmtControlOp;

		typedef enum
		{
		    STD_VIDEO_H264_CABAC_INIT_IDC_0 = 0,
		    STD_VIDEO_H264_CABAC_INIT_IDC_1 = 1,
		    STD_VIDEO_H264_CABAC_INIT_IDC_2 = 2,
		    STD_VIDEO_H264_CABAC_INIT_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_CABAC_INIT_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264CabacInitIdc;

		typedef enum
		{
		    STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_DISABLED = 0,
		    STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_ENABLED = 1,
		    STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_PARTIAL = 2,
		    STD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_DISABLE_DEBLOCKING_FILTER_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264DisableDeblockingFilterIdc;

		typedef enum
		{
		    STD_VIDEO_H264_SLICE_TYPE_P = 0,
		    STD_VIDEO_H264_SLICE_TYPE_B = 1,
		    STD_VIDEO_H264_SLICE_TYPE_I = 2,
		    STD_VIDEO_H264_SLICE_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264SliceType;

		typedef enum
		{
		    STD_VIDEO_H264_PICTURE_TYPE_P = 0,
		    STD_VIDEO_H264_PICTURE_TYPE_B = 1,
		    STD_VIDEO_H264_PICTURE_TYPE_I = 2,
		    STD_VIDEO_H264_PICTURE_TYPE_IDR = 5,
		    STD_VIDEO_H264_PICTURE_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264PictureType;

		typedef enum
		{
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_SPS = 0,
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_PPS = 1,
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_AUD = 2,
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_PREFIX = 3,
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_SEQUENCE = 4,
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_END_OF_STREAM = 5,
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_PRECODED = 6,
		    STD_VIDEO_H264_NON_VCL_NALU_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H264_NON_VCL_NALU_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH264NonVclNaluType;


		typedef struct StdVideoH264SpsVuiFlags
		{
		    uint32_t aspect_ratio_info_present_flag : 1;
		    uint32_t overscan_info_present_flag : 1;
		    uint32_t overscan_appropriate_flag : 1;
		    uint32_t video_signal_type_present_flag : 1;
		    uint32_t video_full_range_flag : 1;
		    uint32_t color_description_present_flag : 1;
		    uint32_t chroma_loc_info_present_flag : 1;
		    uint32_t timing_info_present_flag : 1;
		    uint32_t fixed_frame_rate_flag : 1;
		    uint32_t bitstream_restriction_flag : 1;
		    uint32_t nal_hrd_parameters_present_flag : 1;
		    uint32_t vcl_hrd_parameters_present_flag : 1;
		} StdVideoH264SpsVuiFlags;

		typedef struct StdVideoH264HrdParameters
		{
		    uint8_t cpb_cnt_minus1;
		    uint8_t bit_rate_scale;
		    uint8_t cpb_size_scale;
		    uint8_t reserved1;
		    uint32_t bit_rate_value_minus1[STD_VIDEO_H264_CPB_CNT_LIST_SIZE];
		    uint32_t cpb_size_value_minus1[STD_VIDEO_H264_CPB_CNT_LIST_SIZE];
		    uint8_t cbr_flag[STD_VIDEO_H264_CPB_CNT_LIST_SIZE];
		    uint32_t initial_cpb_removal_delay_length_minus1;
		    uint32_t cpb_removal_delay_length_minus1;
		    uint32_t dpb_output_delay_length_minus1;
		    uint32_t time_offset_length;
		} StdVideoH264HrdParameters;

		typedef struct StdVideoH264SequenceParameterSetVui
		{
		    StdVideoH264SpsVuiFlags flags;
		    StdVideoH264AspectRatioIdc aspect_ratio_idc;
		    uint16_t sar_width;
		    uint16_t sar_height;
		    uint8_t video_format;
		    uint8_t colour_primaries;
		    uint8_t transfer_characteristics;
		    uint8_t matrix_coefficients;
		    uint32_t num_units_in_tick;
		    uint32_t time_scale;
		    uint8_t max_num_reorder_frames;
		    uint8_t max_dec_frame_buffering;
		    uint8_t chroma_sample_loc_type_top_field;
		    uint8_t chroma_sample_loc_type_bottom_field;
		    uint32_t reserved1;
		    const StdVideoH264HrdParameters* pHrdParameters;
		} StdVideoH264SequenceParameterSetVui;

		typedef struct StdVideoH264SpsFlags
		{
		    uint32_t constraint_set0_flag : 1;
		    uint32_t constraint_set1_flag : 1;
		    uint32_t constraint_set2_flag : 1;
		    uint32_t constraint_set3_flag : 1;
		    uint32_t constraint_set4_flag : 1;
		    uint32_t constraint_set5_flag : 1;
		    uint32_t direct_8x8_inference_flag : 1;
		    uint32_t mb_adaptive_frame_field_flag : 1;
		    uint32_t frame_mbs_only_flag : 1;
		    uint32_t delta_pic_order_always_zero_flag : 1;
		    uint32_t separate_colour_plane_flag : 1;
		    uint32_t gaps_in_frame_num_value_allowed_flag : 1;
		    uint32_t qpprime_y_zero_transform_bypass_flag : 1;
		    uint32_t frame_cropping_flag : 1;
		    uint32_t seq_scaling_matrix_present_flag : 1;
		    uint32_t vui_parameters_present_flag : 1;
		} StdVideoH264SpsFlags;

		typedef struct StdVideoH264ScalingLists
		{
		    uint16_t scaling_list_present_mask;
		    uint16_t use_default_scaling_matrix_mask;
		    uint8_t ScalingList4x4[STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS][STD_VIDEO_H264_SCALING_LIST_4X4_NUM_ELEMENTS];
		    uint8_t ScalingList8x8[STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS][STD_VIDEO_H264_SCALING_LIST_8X8_NUM_ELEMENTS];
		} StdVideoH264ScalingLists;

		typedef struct StdVideoH264SequenceParameterSet
		{
		    StdVideoH264SpsFlags flags;
		    StdVideoH264ProfileIdc profile_idc;
		    StdVideoH264LevelIdc level_idc;
		    StdVideoH264ChromaFormatIdc chroma_format_idc;
		    uint8_t seq_parameter_set_id;
		    uint8_t bit_depth_luma_minus8;
		    uint8_t bit_depth_chroma_minus8;
		    uint8_t log2_max_frame_num_minus4;
		    StdVideoH264PocType pic_order_cnt_type;
		    int32_t offset_for_non_ref_pic;
		    int32_t offset_for_top_to_bottom_field;
		    uint8_t log2_max_pic_order_cnt_lsb_minus4;
		    uint8_t num_ref_frames_in_pic_order_cnt_cycle;
		    uint8_t max_num_ref_frames;
		    uint8_t reserved1;
		    uint32_t pic_width_in_mbs_minus1;
		    uint32_t pic_height_in_map_units_minus1;
		    uint32_t frame_crop_left_offset;
		    uint32_t frame_crop_right_offset;
		    uint32_t frame_crop_top_offset;
		    uint32_t frame_crop_bottom_offset;
		    uint32_t reserved2;
		    const int32_t* pOffsetForRefFrame;
		    const StdVideoH264ScalingLists* pScalingLists;
		    const StdVideoH264SequenceParameterSetVui* pSequenceParameterSetVui;
		} StdVideoH264SequenceParameterSet;

		typedef struct StdVideoH264PpsFlags
		{
		    uint32_t transform_8x8_mode_flag : 1;
		    uint32_t redundant_pic_cnt_present_flag : 1;
		    uint32_t constrained_intra_pred_flag : 1;
		    uint32_t deblocking_filter_control_present_flag : 1;
		    uint32_t weighted_pred_flag : 1;
		    uint32_t bottom_field_pic_order_in_frame_present_flag : 1;
		    uint32_t entropy_coding_mode_flag : 1;
		    uint32_t pic_scaling_matrix_present_flag : 1;
		} StdVideoH264PpsFlags;

		typedef struct StdVideoH264PictureParameterSet
		{
		    StdVideoH264PpsFlags flags;
		    uint8_t seq_parameter_set_id;
		    uint8_t pic_parameter_set_id;
		    uint8_t num_ref_idx_l0_default_active_minus1;
		    uint8_t num_ref_idx_l1_default_active_minus1;
		    StdVideoH264WeightedBipredIdc weighted_bipred_idc;
		    int8_t pic_init_qp_minus26;
		    int8_t pic_init_qs_minus26;
		    int8_t chroma_qp_index_offset;
		    int8_t second_chroma_qp_index_offset;
		    const StdVideoH264ScalingLists* pScalingLists;
		} StdVideoH264PictureParameterSet;


		#define vulkan_video_codec_h264std_decode 1
		#define VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0
		#define VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h264_decode"
		#define STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE 2

		#define VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_API_VERSION_1_0_0 VK_MAKE_VIDEO_STD_VERSION(1, 0, 0)

		typedef enum
		{
		    STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_TOP = 0,
		    STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_BOTTOM = 1,
		    STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_MAX_ENUM = 0x7FFFFFFF
		} StdVideoDecodeH264FieldOrderCount;


		typedef struct StdVideoDecodeH264PictureInfoFlags
		{
		    uint32_t field_pic_flag : 1;
		    uint32_t is_intra : 1;
		    uint32_t IdrPicFlag : 1;
		    uint32_t bottom_field_flag : 1;
		    uint32_t is_reference : 1;
		    uint32_t complementary_field_pair : 1;
		} StdVideoDecodeH264PictureInfoFlags;

		typedef struct StdVideoDecodeH264PictureInfo
		{
		    StdVideoDecodeH264PictureInfoFlags flags;
		    uint8_t seq_parameter_set_id;
		    uint8_t pic_parameter_set_id;
		    uint8_t reserved1;
		    uint8_t reserved2;
		    uint16_t frame_num;
		    uint16_t idr_pic_id;
		    int32_t PicOrderCnt[STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE];
		} StdVideoDecodeH264PictureInfo;

		typedef struct StdVideoDecodeH264ReferenceInfoFlags
		{
		    uint32_t top_field_flag : 1;
		    uint32_t bottom_field_flag : 1;
		    uint32_t used_for_long_term_reference : 1;
		    uint32_t is_non_existing : 1;
		} StdVideoDecodeH264ReferenceInfoFlags;

		typedef struct StdVideoDecodeH264ReferenceInfo
		{
		    StdVideoDecodeH264ReferenceInfoFlags flags;
		    uint16_t FrameNum;
		    uint16_t reserved;
		    int32_t PicOrderCnt[STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE];
		} StdVideoDecodeH264ReferenceInfo;


		#define vulkan_video_codec_h264std_encode 1
		#define VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0
		#define VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h264_encode"

		#define VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_API_VERSION_1_0_0 VK_MAKE_VIDEO_STD_VERSION(1, 0, 0)

		typedef struct StdVideoEncodeH264WeightTableFlags
		{
		    uint32_t luma_weight_l0_flag;
		    uint32_t chroma_weight_l0_flag;
		    uint32_t luma_weight_l1_flag;
		    uint32_t chroma_weight_l1_flag;
		} StdVideoEncodeH264WeightTableFlags;

		typedef struct StdVideoEncodeH264WeightTable
		{
		    StdVideoEncodeH264WeightTableFlags flags;
		    uint8_t luma_log2_weight_denom;
		    uint8_t chroma_log2_weight_denom;
		    int8_t luma_weight_l0[STD_VIDEO_H264_MAX_NUM_LIST_REF];
		    int8_t luma_offset_l0[STD_VIDEO_H264_MAX_NUM_LIST_REF];
		    int8_t chroma_weight_l0[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES];
		    int8_t chroma_offset_l0[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES];
		    int8_t luma_weight_l1[STD_VIDEO_H264_MAX_NUM_LIST_REF];
		    int8_t luma_offset_l1[STD_VIDEO_H264_MAX_NUM_LIST_REF];
		    int8_t chroma_weight_l1[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES];
		    int8_t chroma_offset_l1[STD_VIDEO_H264_MAX_NUM_LIST_REF][STD_VIDEO_H264_MAX_CHROMA_PLANES];
		} StdVideoEncodeH264WeightTable;

		typedef struct StdVideoEncodeH264SliceHeaderFlags
		{
		    uint32_t direct_spatial_mv_pred_flag : 1;
		    uint32_t num_ref_idx_active_override_flag : 1;
		    uint32_t reserved : 30;
		} StdVideoEncodeH264SliceHeaderFlags;

		typedef struct StdVideoEncodeH264PictureInfoFlags
		{
		    uint32_t IdrPicFlag : 1;
		    uint32_t is_reference : 1;
		    uint32_t no_output_of_prior_pics_flag : 1;
		    uint32_t long_term_reference_flag : 1;
		    uint32_t adaptive_ref_pic_marking_mode_flag : 1;
		    uint32_t reserved : 27;
		} StdVideoEncodeH264PictureInfoFlags;

		typedef struct StdVideoEncodeH264ReferenceInfoFlags
		{
		    uint32_t used_for_long_term_reference : 1;
		    uint32_t reserved : 31;
		} StdVideoEncodeH264ReferenceInfoFlags;

		typedef struct StdVideoEncodeH264ReferenceListsInfoFlags
		{
		    uint32_t ref_pic_list_modification_flag_l0 : 1;
		    uint32_t ref_pic_list_modification_flag_l1 : 1;
		    uint32_t reserved : 30;
		} StdVideoEncodeH264ReferenceListsInfoFlags;

		typedef struct StdVideoEncodeH264RefListModEntry
		{
		    StdVideoH264ModificationOfPicNumsIdc modification_of_pic_nums_idc;
		    uint16_t abs_diff_pic_num_minus1;
		    uint16_t long_term_pic_num;
		} StdVideoEncodeH264RefListModEntry;

		typedef struct StdVideoEncodeH264RefPicMarkingEntry
		{
		    StdVideoH264MemMgmtControlOp memory_management_control_operation;
		    uint16_t difference_of_pic_nums_minus1;
		    uint16_t long_term_pic_num;
		    uint16_t long_term_frame_idx;
		    uint16_t max_long_term_frame_idx_plus1;
		} StdVideoEncodeH264RefPicMarkingEntry;

		typedef struct StdVideoEncodeH264ReferenceListsInfo
		{
		    StdVideoEncodeH264ReferenceListsInfoFlags flags;
		    uint8_t num_ref_idx_l0_active_minus1;
		    uint8_t num_ref_idx_l1_active_minus1;
		    uint8_t RefPicList0[STD_VIDEO_H264_MAX_NUM_LIST_REF];
		    uint8_t RefPicList1[STD_VIDEO_H264_MAX_NUM_LIST_REF];
		    uint8_t refList0ModOpCount;
		    uint8_t refList1ModOpCount;
		    uint8_t refPicMarkingOpCount;
		    uint8_t reserved1[7];
		    const StdVideoEncodeH264RefListModEntry* pRefList0ModOperations;
		    const StdVideoEncodeH264RefListModEntry* pRefList1ModOperations;
		    const StdVideoEncodeH264RefPicMarkingEntry* pRefPicMarkingOperations;
		} StdVideoEncodeH264ReferenceListsInfo;

		typedef struct StdVideoEncodeH264PictureInfo
		{
		    StdVideoEncodeH264PictureInfoFlags flags;
		    uint8_t seq_parameter_set_id;
		    uint8_t pic_parameter_set_id;
		    uint16_t idr_pic_id;
		    StdVideoH264PictureType primary_pic_type;
		    uint32_t frame_num;
		    int32_t PicOrderCnt;
		    uint8_t temporal_id;
		    uint8_t reserved1[3];
		    const StdVideoEncodeH264ReferenceListsInfo* pRefLists;
		} StdVideoEncodeH264PictureInfo;

		typedef struct StdVideoEncodeH264ReferenceInfo
		{
		    StdVideoEncodeH264ReferenceInfoFlags flags;
		    StdVideoH264PictureType primary_pic_type;
		    uint32_t FrameNum;
		    int32_t PicOrderCnt;
		    uint16_t long_term_pic_num;
		    uint16_t long_term_frame_idx;
		    uint8_t temporal_id;
		} StdVideoEncodeH264ReferenceInfo;

		typedef struct StdVideoEncodeH264SliceHeader
		{
		    StdVideoEncodeH264SliceHeaderFlags flags;
		    uint32_t first_mb_in_slice;
		    StdVideoH264SliceType slice_type;
		    int8_t slice_alpha_c0_offset_div2;
		    int8_t slice_beta_offset_div2;
		    int8_t slice_qp_delta;
		    uint8_t reserved1;
		    StdVideoH264CabacInitIdc cabac_init_idc;
		    StdVideoH264DisableDeblockingFilterIdc disable_deblocking_filter_idc;
		    const StdVideoEncodeH264WeightTable* pWeightTable;
		} StdVideoEncodeH264SliceHeader;


		#define vulkan_video_codec_h265std 1
		#define STD_VIDEO_H265_CPB_CNT_LIST_SIZE 32
		#define STD_VIDEO_H265_SUBLAYERS_LIST_SIZE 7
		#define STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS 6
		#define STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS 16
		#define STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS 6
		#define STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS 64
		#define STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS 6
		#define STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS 64
		#define STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS 2
		#define STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS 64
		#define STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE 6
		#define STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE 19
		#define STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE 21
		#define STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE 3
		#define STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE 128
		#define STD_VIDEO_H265_MAX_NUM_LIST_REF 15
		#define STD_VIDEO_H265_MAX_CHROMA_PLANES 2
		#define STD_VIDEO_H265_MAX_SHORT_TERM_REF_PIC_SETS 64
		#define STD_VIDEO_H265_MAX_DPB_SIZE 16
		#define STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS 32
		#define STD_VIDEO_H265_MAX_LONG_TERM_PICS 16
		#define STD_VIDEO_H265_MAX_DELTA_POC 48
		#define STD_VIDEO_H265_NO_REFERENCE_PICTURE 0xFF

		typedef enum
		{
		    STD_VIDEO_H265_CHROMA_FORMAT_IDC_MONOCHROME = 0,
		    STD_VIDEO_H265_CHROMA_FORMAT_IDC_420 = 1,
		    STD_VIDEO_H265_CHROMA_FORMAT_IDC_422 = 2,
		    STD_VIDEO_H265_CHROMA_FORMAT_IDC_444 = 3,
		    STD_VIDEO_H265_CHROMA_FORMAT_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H265_CHROMA_FORMAT_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH265ChromaFormatIdc;

		typedef enum
		{
		    STD_VIDEO_H265_PROFILE_IDC_MAIN = 1,
		    STD_VIDEO_H265_PROFILE_IDC_MAIN_10 = 2,
		    STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE = 3,
		    STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS = 4,
		    STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS = 9,
		    STD_VIDEO_H265_PROFILE_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H265_PROFILE_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH265ProfileIdc;

		typedef enum
		{
		    STD_VIDEO_H265_LEVEL_IDC_1_0 = 0,
		    STD_VIDEO_H265_LEVEL_IDC_2_0 = 1,
		    STD_VIDEO_H265_LEVEL_IDC_2_1 = 2,
		    STD_VIDEO_H265_LEVEL_IDC_3_0 = 3,
		    STD_VIDEO_H265_LEVEL_IDC_3_1 = 4,
		    STD_VIDEO_H265_LEVEL_IDC_4_0 = 5,
		    STD_VIDEO_H265_LEVEL_IDC_4_1 = 6,
		    STD_VIDEO_H265_LEVEL_IDC_5_0 = 7,
		    STD_VIDEO_H265_LEVEL_IDC_5_1 = 8,
		    STD_VIDEO_H265_LEVEL_IDC_5_2 = 9,
		    STD_VIDEO_H265_LEVEL_IDC_6_0 = 10,
		    STD_VIDEO_H265_LEVEL_IDC_6_1 = 11,
		    STD_VIDEO_H265_LEVEL_IDC_6_2 = 12,
		    STD_VIDEO_H265_LEVEL_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H265_LEVEL_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH265LevelIdc;

		typedef enum
		{
		    STD_VIDEO_H265_SLICE_TYPE_B = 0,
		    STD_VIDEO_H265_SLICE_TYPE_P = 1,
		    STD_VIDEO_H265_SLICE_TYPE_I = 2,
		    STD_VIDEO_H265_SLICE_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H265_SLICE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH265SliceType;

		typedef enum
		{
		    STD_VIDEO_H265_PICTURE_TYPE_P = 0,
		    STD_VIDEO_H265_PICTURE_TYPE_B = 1,
		    STD_VIDEO_H265_PICTURE_TYPE_I = 2,
		    STD_VIDEO_H265_PICTURE_TYPE_IDR = 3,
		    STD_VIDEO_H265_PICTURE_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H265_PICTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH265PictureType;

		typedef enum
		{
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_UNSPECIFIED = 0,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_SQUARE = 1,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_12_11 = 2,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_10_11 = 3,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_16_11 = 4,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_40_33 = 5,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_24_11 = 6,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_20_11 = 7,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_32_11 = 8,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_80_33 = 9,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_18_11 = 10,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_15_11 = 11,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_64_33 = 12,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_160_99 = 13,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_4_3 = 14,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_3_2 = 15,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_2_1 = 16,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_EXTENDED_SAR = 255,
		    STD_VIDEO_H265_ASPECT_RATIO_IDC_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_H265_ASPECT_RATIO_IDC_MAX_ENUM = 0x7FFFFFFF
		} StdVideoH265AspectRatioIdc;


		typedef struct StdVideoH265DecPicBufMgr
		{
		    uint32_t max_latency_increase_plus1[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE];
		    uint8_t max_dec_pic_buffering_minus1[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE];
		    uint8_t max_num_reorder_pics[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE];
		} StdVideoH265DecPicBufMgr;

		typedef struct StdVideoH265SubLayerHrdParameters
		{
		    uint32_t bit_rate_value_minus1[STD_VIDEO_H265_CPB_CNT_LIST_SIZE];
		    uint32_t cpb_size_value_minus1[STD_VIDEO_H265_CPB_CNT_LIST_SIZE];
		    uint32_t cpb_size_du_value_minus1[STD_VIDEO_H265_CPB_CNT_LIST_SIZE];
		    uint32_t bit_rate_du_value_minus1[STD_VIDEO_H265_CPB_CNT_LIST_SIZE];
		    uint32_t cbr_flag;
		} StdVideoH265SubLayerHrdParameters;

		typedef struct StdVideoH265HrdFlags
		{
		    uint32_t nal_hrd_parameters_present_flag : 1;
		    uint32_t vcl_hrd_parameters_present_flag : 1;
		    uint32_t sub_pic_hrd_params_present_flag : 1;
		    uint32_t sub_pic_cpb_params_in_pic_timing_sei_flag : 1;
		    uint32_t fixed_pic_rate_general_flag : 8;
		    uint32_t fixed_pic_rate_within_cvs_flag : 8;
		    uint32_t low_delay_hrd_flag : 8;
		} StdVideoH265HrdFlags;

		typedef struct StdVideoH265HrdParameters
		{
		    StdVideoH265HrdFlags flags;
		    uint8_t tick_divisor_minus2;
		    uint8_t du_cpb_removal_delay_increment_length_minus1;
		    uint8_t dpb_output_delay_du_length_minus1;
		    uint8_t bit_rate_scale;
		    uint8_t cpb_size_scale;
		    uint8_t cpb_size_du_scale;
		    uint8_t initial_cpb_removal_delay_length_minus1;
		    uint8_t au_cpb_removal_delay_length_minus1;
		    uint8_t dpb_output_delay_length_minus1;
		    uint8_t cpb_cnt_minus1[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE];
		    uint16_t elemental_duration_in_tc_minus1[STD_VIDEO_H265_SUBLAYERS_LIST_SIZE];
		    uint16_t reserved[3];
		    const StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersNal;
		    const StdVideoH265SubLayerHrdParameters* pSubLayerHrdParametersVcl;
		} StdVideoH265HrdParameters;

		typedef struct StdVideoH265VpsFlags
		{
		    uint32_t vps_temporal_id_nesting_flag : 1;
		    uint32_t vps_sub_layer_ordering_info_present_flag : 1;
		    uint32_t vps_timing_info_present_flag : 1;
		    uint32_t vps_poc_proportional_to_timing_flag : 1;
		} StdVideoH265VpsFlags;

		typedef struct StdVideoH265ProfileTierLevelFlags
		{
		    uint32_t general_tier_flag : 1;
		    uint32_t general_progressive_source_flag : 1;
		    uint32_t general_interlaced_source_flag : 1;
		    uint32_t general_non_packed_constraint_flag : 1;
		    uint32_t general_frame_only_constraint_flag : 1;
		} StdVideoH265ProfileTierLevelFlags;

		typedef struct StdVideoH265ProfileTierLevel
		{
		    StdVideoH265ProfileTierLevelFlags flags;
		    StdVideoH265ProfileIdc general_profile_idc;
		    StdVideoH265LevelIdc general_level_idc;
		} StdVideoH265ProfileTierLevel;

		typedef struct StdVideoH265VideoParameterSet
		{
		    StdVideoH265VpsFlags flags;
		    uint8_t vps_video_parameter_set_id;
		    uint8_t vps_max_sub_layers_minus1;
		    uint8_t reserved1;
		    uint8_t reserved2;
		    uint32_t vps_num_units_in_tick;
		    uint32_t vps_time_scale;
		    uint32_t vps_num_ticks_poc_diff_one_minus1;
		    uint32_t reserved3;
		    const StdVideoH265DecPicBufMgr* pDecPicBufMgr;
		    const StdVideoH265HrdParameters* pHrdParameters;
		    const StdVideoH265ProfileTierLevel* pProfileTierLevel;
		} StdVideoH265VideoParameterSet;

		typedef struct StdVideoH265ScalingLists
		{
		    uint8_t ScalingList4x4[STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_4X4_NUM_ELEMENTS];
		    uint8_t ScalingList8x8[STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_8X8_NUM_ELEMENTS];
		    uint8_t ScalingList16x16[STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_16X16_NUM_ELEMENTS];
		    uint8_t ScalingList32x32[STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS][STD_VIDEO_H265_SCALING_LIST_32X32_NUM_ELEMENTS];
		    uint8_t ScalingListDCCoef16x16[STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS];
		    uint8_t ScalingListDCCoef32x32[STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS];
		} StdVideoH265ScalingLists;

		typedef struct StdVideoH265SpsVuiFlags
		{
		    uint32_t aspect_ratio_info_present_flag : 1;
		    uint32_t overscan_info_present_flag : 1;
		    uint32_t overscan_appropriate_flag : 1;
		    uint32_t video_signal_type_present_flag : 1;
		    uint32_t video_full_range_flag : 1;
		    uint32_t colour_description_present_flag : 1;
		    uint32_t chroma_loc_info_present_flag : 1;
		    uint32_t neutral_chroma_indication_flag : 1;
		    uint32_t field_seq_flag : 1;
		    uint32_t frame_field_info_present_flag : 1;
		    uint32_t default_display_window_flag : 1;
		    uint32_t vui_timing_info_present_flag : 1;
		    uint32_t vui_poc_proportional_to_timing_flag : 1;
		    uint32_t vui_hrd_parameters_present_flag : 1;
		    uint32_t bitstream_restriction_flag : 1;
		    uint32_t tiles_fixed_structure_flag : 1;
		    uint32_t motion_vectors_over_pic_boundaries_flag : 1;
		    uint32_t restricted_ref_pic_lists_flag : 1;
		} StdVideoH265SpsVuiFlags;

		typedef struct StdVideoH265SequenceParameterSetVui
		{
		    StdVideoH265SpsVuiFlags flags;
		    StdVideoH265AspectRatioIdc aspect_ratio_idc;
		    uint16_t sar_width;
		    uint16_t sar_height;
		    uint8_t video_format;
		    uint8_t colour_primaries;
		    uint8_t transfer_characteristics;
		    uint8_t matrix_coeffs;
		    uint8_t chroma_sample_loc_type_top_field;
		    uint8_t chroma_sample_loc_type_bottom_field;
		    uint8_t reserved1;
		    uint8_t reserved2;
		    uint16_t def_disp_win_left_offset;
		    uint16_t def_disp_win_right_offset;
		    uint16_t def_disp_win_top_offset;
		    uint16_t def_disp_win_bottom_offset;
		    uint32_t vui_num_units_in_tick;
		    uint32_t vui_time_scale;
		    uint32_t vui_num_ticks_poc_diff_one_minus1;
		    uint16_t min_spatial_segmentation_idc;
		    uint16_t reserved3;
		    uint8_t max_bytes_per_pic_denom;
		    uint8_t max_bits_per_min_cu_denom;
		    uint8_t log2_max_mv_length_horizontal;
		    uint8_t log2_max_mv_length_vertical;
		    const StdVideoH265HrdParameters* pHrdParameters;
		} StdVideoH265SequenceParameterSetVui;

		typedef struct StdVideoH265PredictorPaletteEntries
		{
		    uint16_t PredictorPaletteEntries[STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE][STD_VIDEO_H265_PREDICTOR_PALETTE_COMP_ENTRIES_LIST_SIZE];
		} StdVideoH265PredictorPaletteEntries;

		typedef struct StdVideoH265SpsFlags
		{
		    uint32_t sps_temporal_id_nesting_flag : 1;
		    uint32_t separate_colour_plane_flag : 1;
		    uint32_t conformance_window_flag : 1;
		    uint32_t sps_sub_layer_ordering_info_present_flag : 1;
		    uint32_t scaling_list_enabled_flag : 1;
		    uint32_t sps_scaling_list_data_present_flag : 1;
		    uint32_t amp_enabled_flag : 1;
		    uint32_t sample_adaptive_offset_enabled_flag : 1;
		    uint32_t pcm_enabled_flag : 1;
		    uint32_t pcm_loop_filter_disabled_flag : 1;
		    uint32_t long_term_ref_pics_present_flag : 1;
		    uint32_t sps_temporal_mvp_enabled_flag : 1;
		    uint32_t strong_intra_smoothing_enabled_flag : 1;
		    uint32_t vui_parameters_present_flag : 1;
		    uint32_t sps_extension_present_flag : 1;
		    uint32_t sps_range_extension_flag : 1;
		    uint32_t transform_skip_rotation_enabled_flag : 1;
		    uint32_t transform_skip_context_enabled_flag : 1;
		    uint32_t implicit_rdpcm_enabled_flag : 1;
		    uint32_t explicit_rdpcm_enabled_flag : 1;
		    uint32_t extended_precision_processing_flag : 1;
		    uint32_t intra_smoothing_disabled_flag : 1;
		    uint32_t high_precision_offsets_enabled_flag : 1;
		    uint32_t persistent_rice_adaptation_enabled_flag : 1;
		    uint32_t cabac_bypass_alignment_enabled_flag : 1;
		    uint32_t sps_scc_extension_flag : 1;
		    uint32_t sps_curr_pic_ref_enabled_flag : 1;
		    uint32_t palette_mode_enabled_flag : 1;
		    uint32_t sps_palette_predictor_initializers_present_flag : 1;
		    uint32_t intra_boundary_filtering_disabled_flag : 1;
		} StdVideoH265SpsFlags;

		typedef struct StdVideoH265ShortTermRefPicSetFlags
		{
		    uint32_t inter_ref_pic_set_prediction_flag : 1;
		    uint32_t delta_rps_sign : 1;
		} StdVideoH265ShortTermRefPicSetFlags;

		typedef struct StdVideoH265ShortTermRefPicSet
		{
		    StdVideoH265ShortTermRefPicSetFlags flags;
		    uint32_t delta_idx_minus1;
		    uint16_t use_delta_flag;
		    uint16_t abs_delta_rps_minus1;
		    uint16_t used_by_curr_pic_flag;
		    uint16_t used_by_curr_pic_s0_flag;
		    uint16_t used_by_curr_pic_s1_flag;
		    uint16_t reserved1;
		    uint8_t reserved2;
		    uint8_t reserved3;
		    uint8_t num_negative_pics;
		    uint8_t num_positive_pics;
		    uint16_t delta_poc_s0_minus1[STD_VIDEO_H265_MAX_DPB_SIZE];
		    uint16_t delta_poc_s1_minus1[STD_VIDEO_H265_MAX_DPB_SIZE];
		} StdVideoH265ShortTermRefPicSet;

		typedef struct StdVideoH265LongTermRefPicsSps
		{
		    uint32_t used_by_curr_pic_lt_sps_flag;
		    uint32_t lt_ref_pic_poc_lsb_sps[STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS];
		} StdVideoH265LongTermRefPicsSps;

		typedef struct StdVideoH265SequenceParameterSet
		{
		    StdVideoH265SpsFlags flags;
		    StdVideoH265ChromaFormatIdc chroma_format_idc;
		    uint32_t pic_width_in_luma_samples;
		    uint32_t pic_height_in_luma_samples;
		    uint8_t sps_video_parameter_set_id;
		    uint8_t sps_max_sub_layers_minus1;
		    uint8_t sps_seq_parameter_set_id;
		    uint8_t bit_depth_luma_minus8;
		    uint8_t bit_depth_chroma_minus8;
		    uint8_t log2_max_pic_order_cnt_lsb_minus4;
		    uint8_t log2_min_luma_coding_block_size_minus3;
		    uint8_t log2_diff_max_min_luma_coding_block_size;
		    uint8_t log2_min_luma_transform_block_size_minus2;
		    uint8_t log2_diff_max_min_luma_transform_block_size;
		    uint8_t max_transform_hierarchy_depth_inter;
		    uint8_t max_transform_hierarchy_depth_intra;
		    uint8_t num_short_term_ref_pic_sets;
		    uint8_t num_long_term_ref_pics_sps;
		    uint8_t pcm_sample_bit_depth_luma_minus1;
		    uint8_t pcm_sample_bit_depth_chroma_minus1;
		    uint8_t log2_min_pcm_luma_coding_block_size_minus3;
		    uint8_t log2_diff_max_min_pcm_luma_coding_block_size;
		    uint8_t reserved1;
		    uint8_t reserved2;
		    uint8_t palette_max_size;
		    uint8_t delta_palette_max_predictor_size;
		    uint8_t motion_vector_resolution_control_idc;
		    uint8_t sps_num_palette_predictor_initializers_minus1;
		    uint32_t conf_win_left_offset;
		    uint32_t conf_win_right_offset;
		    uint32_t conf_win_top_offset;
		    uint32_t conf_win_bottom_offset;
		    const StdVideoH265ProfileTierLevel* pProfileTierLevel;
		    const StdVideoH265DecPicBufMgr* pDecPicBufMgr;
		    const StdVideoH265ScalingLists* pScalingLists;
		    const StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet;
		    const StdVideoH265LongTermRefPicsSps* pLongTermRefPicsSps;
		    const StdVideoH265SequenceParameterSetVui* pSequenceParameterSetVui;
		    const StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries;
		} StdVideoH265SequenceParameterSet;

		typedef struct StdVideoH265PpsFlags
		{
		    uint32_t dependent_slice_segments_enabled_flag : 1;
		    uint32_t output_flag_present_flag : 1;
		    uint32_t sign_data_hiding_enabled_flag : 1;
		    uint32_t cabac_init_present_flag : 1;
		    uint32_t constrained_intra_pred_flag : 1;
		    uint32_t transform_skip_enabled_flag : 1;
		    uint32_t cu_qp_delta_enabled_flag : 1;
		    uint32_t pps_slice_chroma_qp_offsets_present_flag : 1;
		    uint32_t weighted_pred_flag : 1;
		    uint32_t weighted_bipred_flag : 1;
		    uint32_t transquant_bypass_enabled_flag : 1;
		    uint32_t tiles_enabled_flag : 1;
		    uint32_t entropy_coding_sync_enabled_flag : 1;
		    uint32_t uniform_spacing_flag : 1;
		    uint32_t loop_filter_across_tiles_enabled_flag : 1;
		    uint32_t pps_loop_filter_across_slices_enabled_flag : 1;
		    uint32_t deblocking_filter_control_present_flag : 1;
		    uint32_t deblocking_filter_override_enabled_flag : 1;
		    uint32_t pps_deblocking_filter_disabled_flag : 1;
		    uint32_t pps_scaling_list_data_present_flag : 1;
		    uint32_t lists_modification_present_flag : 1;
		    uint32_t slice_segment_header_extension_present_flag : 1;
		    uint32_t pps_extension_present_flag : 1;
		    uint32_t cross_component_prediction_enabled_flag : 1;
		    uint32_t chroma_qp_offset_list_enabled_flag : 1;
		    uint32_t pps_curr_pic_ref_enabled_flag : 1;
		    uint32_t residual_adaptive_colour_transform_enabled_flag : 1;
		    uint32_t pps_slice_act_qp_offsets_present_flag : 1;
		    uint32_t pps_palette_predictor_initializers_present_flag : 1;
		    uint32_t monochrome_palette_flag : 1;
		    uint32_t pps_range_extension_flag : 1;
		} StdVideoH265PpsFlags;

		typedef struct StdVideoH265PictureParameterSet
		{
		    StdVideoH265PpsFlags flags;
		    uint8_t pps_pic_parameter_set_id;
		    uint8_t pps_seq_parameter_set_id;
		    uint8_t sps_video_parameter_set_id;
		    uint8_t num_extra_slice_header_bits;
		    uint8_t num_ref_idx_l0_default_active_minus1;
		    uint8_t num_ref_idx_l1_default_active_minus1;
		    int8_t init_qp_minus26;
		    uint8_t diff_cu_qp_delta_depth;
		    int8_t pps_cb_qp_offset;
		    int8_t pps_cr_qp_offset;
		    int8_t pps_beta_offset_div2;
		    int8_t pps_tc_offset_div2;
		    uint8_t log2_parallel_merge_level_minus2;
		    uint8_t log2_max_transform_skip_block_size_minus2;
		    uint8_t diff_cu_chroma_qp_offset_depth;
		    uint8_t chroma_qp_offset_list_len_minus1;
		    int8_t cb_qp_offset_list[STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE];
		    int8_t cr_qp_offset_list[STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE];
		    uint8_t log2_sao_offset_scale_luma;
		    uint8_t log2_sao_offset_scale_chroma;
		    int8_t pps_act_y_qp_offset_plus5;
		    int8_t pps_act_cb_qp_offset_plus5;
		    int8_t pps_act_cr_qp_offset_plus3;
		    uint8_t pps_num_palette_predictor_initializers;
		    uint8_t luma_bit_depth_entry_minus8;
		    uint8_t chroma_bit_depth_entry_minus8;
		    uint8_t num_tile_columns_minus1;
		    uint8_t num_tile_rows_minus1;
		    uint8_t reserved1;
		    uint8_t reserved2;
		    uint16_t column_width_minus1[STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE];
		    uint16_t row_height_minus1[STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE];
		    uint32_t reserved3;
		    const StdVideoH265ScalingLists* pScalingLists;
		    const StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries;
		} StdVideoH265PictureParameterSet;


		#define vulkan_video_codec_h265std_decode 1
		#define VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0
		#define VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h265_decode"
		#define STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE 8

		#define VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_API_VERSION_1_0_0 VK_MAKE_VIDEO_STD_VERSION(1, 0, 0)

		typedef struct StdVideoDecodeH265PictureInfoFlags
		{
		    uint32_t IrapPicFlag : 1;
		    uint32_t IdrPicFlag  : 1;
		    uint32_t IsReference : 1;
		    uint32_t short_term_ref_pic_set_sps_flag : 1;
		} StdVideoDecodeH265PictureInfoFlags;

		typedef struct StdVideoDecodeH265PictureInfo
		{
		    StdVideoDecodeH265PictureInfoFlags flags;
		    uint8_t sps_video_parameter_set_id;
		    uint8_t pps_seq_parameter_set_id;
		    uint8_t pps_pic_parameter_set_id;
		    uint8_t NumDeltaPocsOfRefRpsIdx;
		    int32_t PicOrderCntVal;
		    uint16_t NumBitsForSTRefPicSetInSlice;
		    uint16_t reserved;
		    uint8_t RefPicSetStCurrBefore[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE];
		    uint8_t RefPicSetStCurrAfter[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE];
		    uint8_t RefPicSetLtCurr[STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE];
		} StdVideoDecodeH265PictureInfo;

		typedef struct StdVideoDecodeH265ReferenceInfoFlags
		{
		    uint32_t used_for_long_term_reference : 1;
		    uint32_t unused_for_reference : 1;
		} StdVideoDecodeH265ReferenceInfoFlags;

		typedef struct StdVideoDecodeH265ReferenceInfo
		{
		    StdVideoDecodeH265ReferenceInfoFlags flags;
		    int32_t PicOrderCntVal;
		} StdVideoDecodeH265ReferenceInfo;


		#define vulkan_video_codec_h265std_encode 1
		#define VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0
		#define VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_h265_encode"

		#define VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_API_VERSION_1_0_0 VK_MAKE_VIDEO_STD_VERSION(1, 0, 0)

		typedef struct StdVideoEncodeH265WeightTableFlags
		{
		    uint16_t luma_weight_l0_flag;
		    uint16_t chroma_weight_l0_flag;
		    uint16_t luma_weight_l1_flag;
		    uint16_t chroma_weight_l1_flag;
		} StdVideoEncodeH265WeightTableFlags;

		typedef struct StdVideoEncodeH265WeightTable
		{
		    StdVideoEncodeH265WeightTableFlags flags;
		    uint8_t luma_log2_weight_denom;
		    int8_t delta_chroma_log2_weight_denom;
		    int8_t delta_luma_weight_l0[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		    int8_t luma_offset_l0[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		    int8_t delta_chroma_weight_l0[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES];
		    int8_t delta_chroma_offset_l0[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES];
		    int8_t delta_luma_weight_l1[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		    int8_t luma_offset_l1[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		    int8_t delta_chroma_weight_l1[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES];
		    int8_t delta_chroma_offset_l1[STD_VIDEO_H265_MAX_NUM_LIST_REF][STD_VIDEO_H265_MAX_CHROMA_PLANES];
		} StdVideoEncodeH265WeightTable;

		typedef struct StdVideoEncodeH265SliceSegmentHeaderFlags
		{
		    uint32_t first_slice_segment_in_pic_flag : 1;
		    uint32_t dependent_slice_segment_flag : 1;
		    uint32_t slice_sao_luma_flag : 1;
		    uint32_t slice_sao_chroma_flag : 1;
		    uint32_t num_ref_idx_active_override_flag : 1;
		    uint32_t mvd_l1_zero_flag : 1;
		    uint32_t cabac_init_flag : 1;
		    uint32_t cu_chroma_qp_offset_enabled_flag : 1;
		    uint32_t deblocking_filter_override_flag : 1;
		    uint32_t slice_deblocking_filter_disabled_flag : 1;
		    uint32_t collocated_from_l0_flag : 1;
		    uint32_t slice_loop_filter_across_slices_enabled_flag : 1;
		    uint32_t reserved : 20;
		} StdVideoEncodeH265SliceSegmentHeaderFlags;

		typedef struct StdVideoEncodeH265SliceSegmentHeader
		{
		    StdVideoEncodeH265SliceSegmentHeaderFlags flags;
		    StdVideoH265SliceType slice_type;
		    uint32_t slice_segment_address;
		    uint8_t collocated_ref_idx;
		    uint8_t MaxNumMergeCand;
		    int8_t slice_cb_qp_offset;
		    int8_t slice_cr_qp_offset;
		    int8_t slice_beta_offset_div2;
		    int8_t slice_tc_offset_div2;
		    int8_t slice_act_y_qp_offset;
		    int8_t slice_act_cb_qp_offset;
		    int8_t slice_act_cr_qp_offset;
		    int8_t slice_qp_delta;
		    uint16_t reserved1;
		    const StdVideoEncodeH265WeightTable* pWeightTable;
		} StdVideoEncodeH265SliceSegmentHeader;

		typedef struct StdVideoEncodeH265ReferenceListsInfoFlags
		{
		    uint32_t ref_pic_list_modification_flag_l0 : 1;
		    uint32_t ref_pic_list_modification_flag_l1 : 1;
		    uint32_t reserved : 30;
		} StdVideoEncodeH265ReferenceListsInfoFlags;

		typedef struct StdVideoEncodeH265ReferenceListsInfo
		{
		    StdVideoEncodeH265ReferenceListsInfoFlags flags;
		    uint8_t num_ref_idx_l0_active_minus1;
		    uint8_t num_ref_idx_l1_active_minus1;
		    uint8_t RefPicList0[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		    uint8_t RefPicList1[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		    uint8_t list_entry_l0[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		    uint8_t list_entry_l1[STD_VIDEO_H265_MAX_NUM_LIST_REF];
		} StdVideoEncodeH265ReferenceListsInfo;

		typedef struct StdVideoEncodeH265PictureInfoFlags
		{
		    uint32_t is_reference : 1;
		    uint32_t IrapPicFlag : 1;
		    uint32_t used_for_long_term_reference : 1;
		    uint32_t discardable_flag : 1;
		    uint32_t cross_layer_bla_flag : 1;
		    uint32_t pic_output_flag : 1;
		    uint32_t no_output_of_prior_pics_flag : 1;
		    uint32_t short_term_ref_pic_set_sps_flag : 1;
		    uint32_t slice_temporal_mvp_enabled_flag : 1;
		    uint32_t reserved : 23;
		} StdVideoEncodeH265PictureInfoFlags;

		typedef struct StdVideoEncodeH265LongTermRefPics
		{
		    uint8_t num_long_term_sps;
		    uint8_t num_long_term_pics;
		    uint8_t lt_idx_sps[STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS];
		    uint8_t poc_lsb_lt[STD_VIDEO_H265_MAX_LONG_TERM_PICS];
		    uint16_t used_by_curr_pic_lt_flag;
		    uint8_t delta_poc_msb_present_flag[STD_VIDEO_H265_MAX_DELTA_POC];
		    uint8_t delta_poc_msb_cycle_lt[STD_VIDEO_H265_MAX_DELTA_POC];
		} StdVideoEncodeH265LongTermRefPics;

		typedef struct StdVideoEncodeH265PictureInfo
		{
		    StdVideoEncodeH265PictureInfoFlags flags;
		    StdVideoH265PictureType pic_type;
		    uint8_t sps_video_parameter_set_id;
		    uint8_t pps_seq_parameter_set_id;
		    uint8_t pps_pic_parameter_set_id;
		    uint8_t short_term_ref_pic_set_idx;
		    int32_t PicOrderCntVal;
		    uint8_t TemporalId;
		    uint8_t reserved1[7];
		    const StdVideoEncodeH265ReferenceListsInfo* pRefLists;
		    const StdVideoH265ShortTermRefPicSet* pShortTermRefPicSet;
		    const StdVideoEncodeH265LongTermRefPics* pLongTermRefPics;
		} StdVideoEncodeH265PictureInfo;

		typedef struct StdVideoEncodeH265ReferenceInfoFlags
		{
		    uint32_t used_for_long_term_reference : 1;
		    uint32_t unused_for_reference : 1;
		    uint32_t reserved : 30;
		} StdVideoEncodeH265ReferenceInfoFlags;

		typedef struct StdVideoEncodeH265ReferenceInfo
		{
		    StdVideoEncodeH265ReferenceInfoFlags flags;
		    StdVideoH265PictureType pic_type;
		    int32_t PicOrderCntVal;
		    uint8_t TemporalId;
		} StdVideoEncodeH265ReferenceInfo;


		#define vulkan_video_codec_av1std 1
		#define STD_VIDEO_AV1_NUM_REF_FRAMES 8
		#define STD_VIDEO_AV1_REFS_PER_FRAME 7
		#define STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME 8
		#define STD_VIDEO_AV1_MAX_TILE_COLS 64
		#define STD_VIDEO_AV1_MAX_TILE_ROWS 64
		#define STD_VIDEO_AV1_MAX_SEGMENTS 8
		#define STD_VIDEO_AV1_SEG_LVL_MAX 8
		#define STD_VIDEO_AV1_PRIMARY_REF_NONE 7
		#define STD_VIDEO_AV1_SELECT_INTEGER_MV 2
		#define STD_VIDEO_AV1_SELECT_SCREEN_CONTENT_TOOLS 2
		#define STD_VIDEO_AV1_SKIP_MODE_FRAMES 2
		#define STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS 4
		#define STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS 2
		#define STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS 8
		#define STD_VIDEO_AV1_MAX_NUM_PLANES 3
		#define STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS 6
		#define STD_VIDEO_AV1_MAX_NUM_Y_POINTS 14
		#define STD_VIDEO_AV1_MAX_NUM_CB_POINTS 10
		#define STD_VIDEO_AV1_MAX_NUM_CR_POINTS 10
		#define STD_VIDEO_AV1_MAX_NUM_POS_LUMA 24
		#define STD_VIDEO_AV1_MAX_NUM_POS_CHROMA 25

		typedef enum
		{
		    STD_VIDEO_AV1_PROFILE_MAIN = 0,
		    STD_VIDEO_AV1_PROFILE_HIGH = 1,
		    STD_VIDEO_AV1_PROFILE_PROFESSIONAL = 2,
		    STD_VIDEO_AV1_PROFILE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_PROFILE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1Profile;

		typedef enum
		{
		    STD_VIDEO_AV1_LEVEL_2_0 = 0,
		    STD_VIDEO_AV1_LEVEL_2_1 = 1,
		    STD_VIDEO_AV1_LEVEL_2_2 = 2,
		    STD_VIDEO_AV1_LEVEL_2_3 = 3,
		    STD_VIDEO_AV1_LEVEL_3_0 = 4,
		    STD_VIDEO_AV1_LEVEL_3_1 = 5,
		    STD_VIDEO_AV1_LEVEL_3_2 = 6,
		    STD_VIDEO_AV1_LEVEL_3_3 = 7,
		    STD_VIDEO_AV1_LEVEL_4_0 = 8,
		    STD_VIDEO_AV1_LEVEL_4_1 = 9,
		    STD_VIDEO_AV1_LEVEL_4_2 = 10,
		    STD_VIDEO_AV1_LEVEL_4_3 = 11,
		    STD_VIDEO_AV1_LEVEL_5_0 = 12,
		    STD_VIDEO_AV1_LEVEL_5_1 = 13,
		    STD_VIDEO_AV1_LEVEL_5_2 = 14,
		    STD_VIDEO_AV1_LEVEL_5_3 = 15,
		    STD_VIDEO_AV1_LEVEL_6_0 = 16,
		    STD_VIDEO_AV1_LEVEL_6_1 = 17,
		    STD_VIDEO_AV1_LEVEL_6_2 = 18,
		    STD_VIDEO_AV1_LEVEL_6_3 = 19,
		    STD_VIDEO_AV1_LEVEL_7_0 = 20,
		    STD_VIDEO_AV1_LEVEL_7_1 = 21,
		    STD_VIDEO_AV1_LEVEL_7_2 = 22,
		    STD_VIDEO_AV1_LEVEL_7_3 = 23,
		    STD_VIDEO_AV1_LEVEL_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_LEVEL_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1Level;

		typedef enum
		{
		    STD_VIDEO_AV1_FRAME_TYPE_KEY = 0,
		    STD_VIDEO_AV1_FRAME_TYPE_INTER = 1,
		    STD_VIDEO_AV1_FRAME_TYPE_INTRA_ONLY = 2,
		    STD_VIDEO_AV1_FRAME_TYPE_SWITCH = 3,
		    STD_VIDEO_AV1_FRAME_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_FRAME_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1FrameType;

		typedef enum
		{
		    STD_VIDEO_AV1_REFERENCE_NAME_INTRA_FRAME = 0,
		    STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME = 1,
		    STD_VIDEO_AV1_REFERENCE_NAME_LAST2_FRAME = 2,
		    STD_VIDEO_AV1_REFERENCE_NAME_LAST3_FRAME = 3,
		    STD_VIDEO_AV1_REFERENCE_NAME_GOLDEN_FRAME = 4,
		    STD_VIDEO_AV1_REFERENCE_NAME_BWDREF_FRAME = 5,
		    STD_VIDEO_AV1_REFERENCE_NAME_ALTREF2_FRAME = 6,
		    STD_VIDEO_AV1_REFERENCE_NAME_ALTREF_FRAME = 7,
		    STD_VIDEO_AV1_REFERENCE_NAME_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_REFERENCE_NAME_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1ReferenceName;

		typedef enum
		{
		    STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP = 0,
		    STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
		    STD_VIDEO_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
		    STD_VIDEO_AV1_INTERPOLATION_FILTER_BILINEAR = 3,
		    STD_VIDEO_AV1_INTERPOLATION_FILTER_SWITCHABLE = 4,
		    STD_VIDEO_AV1_INTERPOLATION_FILTER_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_INTERPOLATION_FILTER_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1InterpolationFilter;

		typedef enum
		{
		    STD_VIDEO_AV1_TX_MODE_ONLY_4X4 = 0,
		    STD_VIDEO_AV1_TX_MODE_LARGEST = 1,
		    STD_VIDEO_AV1_TX_MODE_SELECT = 2,
		    STD_VIDEO_AV1_TX_MODE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_TX_MODE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1TxMode;

		typedef enum
		{
		    STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_NONE = 0,
		    STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_WIENER = 1,
		    STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SGRPROJ = 2,
		    STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_SWITCHABLE = 3,
		    STD_VIDEO_AV1_FRAME_RESTORATION_TYPE_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_FRAME_RESTORATION_TYPE_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1FrameRestorationType;

		typedef enum
		{
		    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_709 = 1,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_UNSPECIFIED = 2,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_M = 4,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_470_B_G = 5,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_601 = 6,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_240 = 7,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_GENERIC_FILM = 8,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_BT_2020 = 9,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_XYZ = 10,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_431 = 11,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_SMPTE_432 = 12,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_EBU_3213 = 22,
		    STD_VIDEO_AV1_COLOR_PRIMARIES_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_COLOR_PRIMARIES_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1ColorPrimaries;

		typedef enum
		{
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_0 = 0,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_709 = 1,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_RESERVED_3 = 3,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_M = 4,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_470_B_G = 5,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_601 = 6,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_240 = 7,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LINEAR = 8,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100 = 9,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_LOG_100_SQRT10 = 10,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_IEC_61966 = 11,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_1361 = 12,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SRGB = 13,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_10_BIT = 14,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_BT_2020_12_BIT = 15,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_2084 = 16,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_SMPTE_428 = 17,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_HLG = 18,
		    STD_VIDEO_AV1_TRANSFER_CHARACTERISTICS_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_TRANSFER_CHARACTERISTICS_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1TransferCharacteristics;

		typedef enum
		{
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_IDENTITY = 0,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_709 = 1,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_UNSPECIFIED = 2,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_RESERVED_3 = 3,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_FCC = 4,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_470_B_G = 5,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_601 = 6,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_240 = 7,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_YCGCO = 8,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_NCL = 9,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_BT_2020_CL = 10,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_SMPTE_2085 = 11,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_NCL = 12,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_CHROMAT_CL = 13,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_ICTCP = 14,
		    STD_VIDEO_AV1_MATRIX_COEFFICIENTS_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_MATRIX_COEFFICIENTS_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1MatrixCoefficients;

		typedef enum
		{
		    STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_UNKNOWN = 0,
		    STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_VERTICAL = 1,
		    STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_COLOCATED = 2,
		    STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_RESERVED = 3,
		    STD_VIDEO_AV1_CHROMA_SAMPLE_POSITION_INVALID = 0x7FFFFFFF,
		    VKD_VIDEO_A_V1_CHROMA_SAMPLE_POSITION_MAX_ENUM = 0x7FFFFFFF
		} StdVideoAV1ChromaSamplePosition;


		typedef struct StdVideoAV1ColorConfigFlags
		{
		    uint32_t mono_chrome : 1;
		    uint32_t color_range : 1;
		    uint32_t separate_uv_delta_q : 1;
		    uint32_t color_description_present_flag : 1;
		    uint32_t reserved : 28;
		} StdVideoAV1ColorConfigFlags;

		typedef struct StdVideoAV1ColorConfig
		{
		    StdVideoAV1ColorConfigFlags flags;
		    uint8_t BitDepth;
		    uint8_t subsampling_x;
		    uint8_t subsampling_y;
		    uint8_t reserved1;
		    StdVideoAV1ColorPrimaries color_primaries;
		    StdVideoAV1TransferCharacteristics transfer_characteristics;
		    StdVideoAV1MatrixCoefficients matrix_coefficients;
		    StdVideoAV1ChromaSamplePosition chroma_sample_position;
		} StdVideoAV1ColorConfig;

		typedef struct StdVideoAV1TimingInfoFlags
		{
		    uint32_t equal_picture_interval : 1;
		    uint32_t reserved : 31;
		} StdVideoAV1TimingInfoFlags;

		typedef struct StdVideoAV1TimingInfo
		{
		    StdVideoAV1TimingInfoFlags flags;
		    uint32_t num_units_in_display_tick;
		    uint32_t time_scale;
		    uint32_t num_ticks_per_picture_minus_1;
		} StdVideoAV1TimingInfo;

		typedef struct StdVideoAV1LoopFilterFlags
		{
		    uint32_t loop_filter_delta_enabled : 1;
		    uint32_t loop_filter_delta_update : 1;
		    uint32_t reserved : 30;
		} StdVideoAV1LoopFilterFlags;

		typedef struct StdVideoAV1LoopFilter
		{
		    StdVideoAV1LoopFilterFlags flags;
		    uint8_t loop_filter_level[STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS];
		    uint8_t loop_filter_sharpness;
		    uint8_t update_ref_delta;
		    int8_t loop_filter_ref_deltas[STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME];
		    uint8_t update_mode_delta;
		    int8_t loop_filter_mode_deltas[STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS];
		} StdVideoAV1LoopFilter;

		typedef struct StdVideoAV1QuantizationFlags
		{
		    uint32_t using_qmatrix : 1;
		    uint32_t diff_uv_delta : 1;
		    uint32_t reserved : 30;
		} StdVideoAV1QuantizationFlags;

		typedef struct StdVideoAV1Quantization
		{
		    StdVideoAV1QuantizationFlags flags;
		    uint8_t base_q_idx;
		    int8_t DeltaQYDc;
		    int8_t DeltaQUDc;
		    int8_t DeltaQUAc;
		    int8_t DeltaQVDc;
		    int8_t DeltaQVAc;
		    uint8_t qm_y;
		    uint8_t qm_u;
		    uint8_t qm_v;
		} StdVideoAV1Quantization;

		typedef struct StdVideoAV1Segmentation
		{
		    uint8_t FeatureEnabled[STD_VIDEO_AV1_MAX_SEGMENTS];
		    int16_t FeatureData[STD_VIDEO_AV1_MAX_SEGMENTS][STD_VIDEO_AV1_SEG_LVL_MAX];
		} StdVideoAV1Segmentation;

		typedef struct StdVideoAV1TileInfoFlags
		{
		    uint32_t uniform_tile_spacing_flag : 1;
		    uint32_t reserved : 31;
		} StdVideoAV1TileInfoFlags;

		typedef struct StdVideoAV1TileInfo
		{
		    StdVideoAV1TileInfoFlags flags;
		    uint8_t TileCols;
		    uint8_t TileRows;
		    uint16_t context_update_tile_id;
		    uint8_t tile_size_bytes_minus_1;
		    uint8_t reserved1[7];
		    const uint16_t* pMiColStarts;
		    const uint16_t* pMiRowStarts;
		    const uint16_t* pWidthInSbsMinus1;
		    const uint16_t* pHeightInSbsMinus1;
		} StdVideoAV1TileInfo;

		typedef struct StdVideoAV1CDEF
		{
		    uint8_t cdef_damping_minus_3;
		    uint8_t cdef_bits;
		    uint8_t cdef_y_pri_strength[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS];
		    uint8_t cdef_y_sec_strength[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS];
		    uint8_t cdef_uv_pri_strength[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS];
		    uint8_t cdef_uv_sec_strength[STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS];
		} StdVideoAV1CDEF;

		typedef struct StdVideoAV1LoopRestoration
		{
		    StdVideoAV1FrameRestorationType FrameRestorationType[STD_VIDEO_AV1_MAX_NUM_PLANES];
		    uint16_t LoopRestorationSize[STD_VIDEO_AV1_MAX_NUM_PLANES];
		} StdVideoAV1LoopRestoration;

		typedef struct StdVideoAV1GlobalMotion
		{
		    uint8_t GmType[STD_VIDEO_AV1_NUM_REF_FRAMES];
		    int32_t gm_params[STD_VIDEO_AV1_NUM_REF_FRAMES][STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS];
		} StdVideoAV1GlobalMotion;

		typedef struct StdVideoAV1FilmGrainFlags
		{
		    uint32_t chroma_scaling_from_luma : 1;
		    uint32_t overlap_flag : 1;
		    uint32_t clip_to_restricted_range : 1;
		    uint32_t update_grain : 1;
		    uint32_t reserved : 28;
		} StdVideoAV1FilmGrainFlags;

		typedef struct StdVideoAV1FilmGrain
		{
		    StdVideoAV1FilmGrainFlags flags;
		    uint8_t grain_scaling_minus_8;
		    uint8_t ar_coeff_lag;
		    uint8_t ar_coeff_shift_minus_6;
		    uint8_t grain_scale_shift;
		    uint16_t grain_seed;
		    uint8_t film_grain_params_ref_idx;
		    uint8_t num_y_points;
		    uint8_t point_y_value[STD_VIDEO_AV1_MAX_NUM_Y_POINTS];
		    uint8_t point_y_scaling[STD_VIDEO_AV1_MAX_NUM_Y_POINTS];
		    uint8_t num_cb_points;
		    uint8_t point_cb_value[STD_VIDEO_AV1_MAX_NUM_CB_POINTS];
		    uint8_t point_cb_scaling[STD_VIDEO_AV1_MAX_NUM_CB_POINTS];
		    uint8_t num_cr_points;
		    uint8_t point_cr_value[STD_VIDEO_AV1_MAX_NUM_CR_POINTS];
		    uint8_t point_cr_scaling[STD_VIDEO_AV1_MAX_NUM_CR_POINTS];
		    int8_t ar_coeffs_y_plus_128[STD_VIDEO_AV1_MAX_NUM_POS_LUMA];
		    int8_t ar_coeffs_cb_plus_128[STD_VIDEO_AV1_MAX_NUM_POS_CHROMA];
		    int8_t ar_coeffs_cr_plus_128[STD_VIDEO_AV1_MAX_NUM_POS_CHROMA];
		    uint8_t cb_mult;
		    uint8_t cb_luma_mult;
		    uint16_t cb_offset;
		    uint8_t cr_mult;
		    uint8_t cr_luma_mult;
		    uint16_t cr_offset;
		} StdVideoAV1FilmGrain;

		typedef struct StdVideoAV1SequenceHeaderFlags
		{
		    uint32_t still_picture : 1;
		    uint32_t reduced_still_picture_header : 1;
		    uint32_t use_128x128_superblock : 1;
		    uint32_t enable_filter_intra : 1;
		    uint32_t enable_intra_edge_filter : 1;
		    uint32_t enable_interintra_compound : 1;
		    uint32_t enable_masked_compound : 1;
		    uint32_t enable_warped_motion : 1;
		    uint32_t enable_dual_filter : 1;
		    uint32_t enable_order_hint : 1;
		    uint32_t enable_jnt_comp : 1;
		    uint32_t enable_ref_frame_mvs : 1;
		    uint32_t frame_id_numbers_present_flag : 1;
		    uint32_t enable_superres : 1;
		    uint32_t enable_cdef : 1;
		    uint32_t enable_restoration : 1;
		    uint32_t film_grain_params_present : 1;
		    uint32_t timing_info_present_flag : 1;
		    uint32_t initial_display_delay_present_flag : 1;
		    uint32_t reserved : 13;
		} StdVideoAV1SequenceHeaderFlags;

		typedef struct StdVideoAV1SequenceHeader
		{
		    StdVideoAV1SequenceHeaderFlags flags;
		    StdVideoAV1Profile seq_profile;
		    uint8_t frame_width_bits_minus_1;
		    uint8_t frame_height_bits_minus_1;
		    uint16_t max_frame_width_minus_1;
		    uint16_t max_frame_height_minus_1;
		    uint8_t delta_frame_id_length_minus_2;
		    uint8_t additional_frame_id_length_minus_1;
		    uint8_t order_hint_bits_minus_1;
		    uint8_t seq_force_integer_mv;
		    uint8_t seq_force_screen_content_tools;
		    uint8_t reserved1[5];
		    const StdVideoAV1ColorConfig* pColorConfig;
		    const StdVideoAV1TimingInfo* pTimingInfo;
		} StdVideoAV1SequenceHeader;


		#define vulkan_video_codec_av1std_decode 1
		#define VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0
		#define VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME "VK_STD_vulkan_video_codec_av1_decode"

		#define VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_API_VERSION_1_0_0 VK_MAKE_VIDEO_STD_VERSION(1, 0, 0)

		typedef struct StdVideoDecodeAV1PictureInfoFlags
		{
		    uint32_t error_resilient_mode : 1;
		    uint32_t disable_cdf_update : 1;
		    uint32_t use_superres : 1;
		    uint32_t render_and_frame_size_different : 1;
		    uint32_t allow_screen_content_tools : 1;
		    uint32_t is_filter_switchable : 1;
		    uint32_t force_integer_mv : 1;
		    uint32_t frame_size_override_flag : 1;
		    uint32_t buffer_removal_time_present_flag : 1;
		    uint32_t allow_intrabc : 1;
		    uint32_t frame_refs_short_signaling : 1;
		    uint32_t allow_high_precision_mv : 1;
		    uint32_t is_motion_mode_switchable : 1;
		    uint32_t use_ref_frame_mvs : 1;
		    uint32_t disable_frame_end_update_cdf : 1;
		    uint32_t allow_warped_motion : 1;
		    uint32_t reduced_tx_set : 1;
		    uint32_t reference_select : 1;
		    uint32_t skip_mode_present : 1;
		    uint32_t delta_q_present : 1;
		    uint32_t delta_lf_present : 1;
		    uint32_t delta_lf_multi : 1;
		    uint32_t segmentation_enabled : 1;
		    uint32_t segmentation_update_map : 1;
		    uint32_t segmentation_temporal_update : 1;
		    uint32_t segmentation_update_data : 1;
		    uint32_t UsesLr : 1;
		    uint32_t usesChromaLr : 1;
		    uint32_t apply_grain : 1;
		    uint32_t reserved : 3;
		} StdVideoDecodeAV1PictureInfoFlags;

		typedef struct StdVideoDecodeAV1PictureInfo
		{
		    StdVideoDecodeAV1PictureInfoFlags flags;
		    StdVideoAV1FrameType frame_type;
		    uint32_t current_frame_id;
		    uint8_t OrderHint;
		    uint8_t primary_ref_frame;
		    uint8_t refresh_frame_flags;
		    uint8_t reserved1;
		    StdVideoAV1InterpolationFilter interpolation_filter;
		    StdVideoAV1TxMode TxMode;
		    uint8_t delta_q_res;
		    uint8_t delta_lf_res;
		    uint8_t SkipModeFrame[STD_VIDEO_AV1_SKIP_MODE_FRAMES];
		    uint8_t coded_denom;
		    uint8_t reserved2[3];
		    uint8_t OrderHints[STD_VIDEO_AV1_NUM_REF_FRAMES];
		    uint32_t expectedFrameId[STD_VIDEO_AV1_NUM_REF_FRAMES];
		    const StdVideoAV1TileInfo* pTileInfo;
		    const StdVideoAV1Quantization* pQuantization;
		    const StdVideoAV1Segmentation* pSegmentation;
		    const StdVideoAV1LoopFilter* pLoopFilter;
		    const StdVideoAV1CDEF* pCDEF;
		    const StdVideoAV1LoopRestoration* pLoopRestoration;
		    const StdVideoAV1GlobalMotion* pGlobalMotion;
		    const StdVideoAV1FilmGrain* pFilmGrain;
		} StdVideoDecodeAV1PictureInfo;

		typedef struct StdVideoDecodeAV1ReferenceInfoFlags
		{
		    uint32_t disable_frame_end_update_cdf : 1;
		    uint32_t segmentation_enabled : 1;
		    uint32_t reserved : 30;
		} StdVideoDecodeAV1ReferenceInfoFlags;

		typedef struct StdVideoDecodeAV1ReferenceInfo
		{
		    StdVideoDecodeAV1ReferenceInfoFlags flags;
		    uint8_t frame_type;
		    uint8_t RefFrameSignBias;
		    uint8_t OrderHint;
		    uint8_t SavedOrderHints[STD_VIDEO_AV1_NUM_REF_FRAMES];
		} StdVideoDecodeAV1ReferenceInfo;



		#define VK_VERSION_1_0 1

		#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;
		#ifndef VK_USE_64_BIT_PTR_DEFINES
		    #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__) || (defined(__riscv) && __riscv_xlen == 64)
				#define VK_USE_64_BIT_PTR_DEFINES 1
		    #else
				#define VK_USE_64_BIT_PTR_DEFINES 0
		    #endif
		#endif
		#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
		    #if (VK_USE_64_BIT_PTR_DEFINES==1)
				#if (defined(__cplusplus) && (__cplusplus >= 201103L)) || (defined(_MSVC_LANG) && (_MSVC_LANG >= 201103L))
				    #define VK_NULL_HANDLE nullptr
				#else
				    #define VK_NULL_HANDLE ((void*)0)
				#endif
		    #else
				#define VK_NULL_HANDLE 0ULL
		    #endif
		#endif
		#ifndef VK_NULL_HANDLE
		    #define VK_NULL_HANDLE 0
		#endif
		#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
		    #if (VK_USE_64_BIT_PTR_DEFINES==1)
				#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
		    #else
				#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
		    #endif
		#endif
		#define VK_MAKE_API_VERSION(variant, major, minor, patch)     ((((uint32_t)(variant)) << 29U) | (((uint32_t)(major)) << 22U) | (((uint32_t)(minor)) << 12U) | ((uint32_t)(patch)))
		#define VK_API_VERSION_1_0 VK_MAKE_API_VERSION(0, 1, 0, 0)
		#define VK_HEADER_VERSION 283
		#define VK_HEADER_VERSION_COMPLETE VK_MAKE_API_VERSION(0, 1, 3, VK_HEADER_VERSION)
		#define VK_MAKE_VERSION(major, minor, patch)     ((((uint32_t)(major)) << 22U) | (((uint32_t)(minor)) << 12U) | ((uint32_t)(patch)))
		#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22U)
		#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12U) & 0x3FFU)
		#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xFFFU)
		#define VK_API_VERSION_VARIANT(version) ((uint32_t)(version) >> 29U)
		#define VK_API_VERSION_MAJOR(version) (((uint32_t)(version) >> 22U) & 0x7FU)
		#define VK_API_VERSION_MINOR(version) (((uint32_t)(version) >> 12U) & 0x3FFU)
		#define VK_API_VERSION_PATCH(version) ((uint32_t)(version) & 0xFFFU)

		#define VK_ATTACHMENT_UNUSED (~0U)
		#define VK_FALSE 0
		#define VK_LOD_CLAMP_NONE 1000.0F
		#define VK_QUEUE_FAMILY_IGNORED (~0U)
		#define VK_REMAINING_ARRAY_LAYERS (~0U)
		#define VK_REMAINING_MIP_LEVELS (~0U)
		#define VK_SUBPASS_EXTERNAL (~0U)
		#define VK_TRUE 1
		#define VK_WHOLE_SIZE (~0ULL)
		#define VK_MAX_MEMORY_TYPES 32
		#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256
		#define VK_UUID_SIZE 16
		#define VK_MAX_EXTENSION_NAME_SIZE 256
		#define VK_MAX_DESCRIPTION_SIZE 256
		#define VK_MAX_MEMORY_HEAPS 16

		typedef uint32_t VkBool32;
		typedef uint64_t VkDeviceAddress;
		typedef uint64_t VkDeviceSize;
		typedef uint32_t VkFlags;
		typedef uint32_t VkSampleMask;

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
		VK_DEFINE_HANDLE(VkInstance)
		VK_DEFINE_HANDLE(VkPhysicalDevice)
		VK_DEFINE_HANDLE(VkDevice)
		VK_DEFINE_HANDLE(VkQueue)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
		VK_DEFINE_HANDLE(VkCommandBuffer)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

		typedef enum
		{
		    VK_SUCCESS = 0,
		    VK_NOT_READY = 1,
		    VK_TIMEOUT = 2,
		    VK_EVENT_SET = 3,
		    VK_EVENT_RESET = 4,
		    VK_INCOMPLETE = 5,
		    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
		    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
		    VK_ERROR_INITIALIZATION_FAILED = -3,
		    VK_ERROR_DEVICE_LOST = -4,
		    VK_ERROR_MEMORY_MAP_FAILED = -5,
		    VK_ERROR_LAYER_NOT_PRESENT = -6,
		    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
		    VK_ERROR_FEATURE_NOT_PRESENT = -8,
		    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
		    VK_ERROR_TOO_MANY_OBJECTS = -10,
		    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
		    VK_ERROR_FRAGMENTED_POOL = -12,
		    VK_ERROR_UNKNOWN = -13,
		    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
		    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
		    VK_ERROR_FRAGMENTATION = -1000161000,
		    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
		    VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
		    VK_ERROR_VALIDATION_FAILED = -1000011001,
		    VK_ERROR_INVALID_PIPELINE_CACHE_DATA = -1000298000,
		    VK_ERROR_NO_PIPELINE_MATCH = -1000298001,
		    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
		    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
		    VK_SUBOPTIMAL_KHR = 1000001003,
		    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
		    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
		    VK_ERROR_INVALID_SHADER_NV = -1000012000,
		    VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
		    VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
		    VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
		    VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
		    VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
		    VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
		    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
		    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
		    VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
		    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
		    VK_THREAD_IDLE_KHR = 1000268000,
		    VK_THREAD_DONE_KHR = 1000268001,
		    VK_OPERATION_DEFERRED_KHR = 1000268002,
		    VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
		    VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
		    VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
		    VK_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
		    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
		    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
		    VK_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION,
		    VK_ERROR_NOT_PERMITTED_EXT = VK_ERROR_NOT_PERMITTED_KHR,
		    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
		    VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
		    VK_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
		    VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED,
		    VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT = VK_INCOMPATIBLE_SHADER_BINARY_EXT,
		    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
		} VkResult;

		typedef enum
		{
		    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
		    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
		    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
		    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
		    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
		    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
		    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
		    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
		    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
		    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
		    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
		    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
		    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
		    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
		    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
		    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
		    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
		    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
		    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
		    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
		    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
		    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
		    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
		    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
		    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
		    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
		    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
		    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
		    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
		    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
		    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
		    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
		    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
		    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
		    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
		    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
		    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
		    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
		    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
		    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
		    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
		    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
		    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
		    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
		    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
		    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
		    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
		    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
		    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
		    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
		    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
		    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
		    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
		    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
		    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
		    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
		    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
		    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
		    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
		    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
		    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
		    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
		    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
		    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
		    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
		    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
		    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
		    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
		    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
		    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
		    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
		    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
		    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
		    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
		    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
		    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
		    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
		    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
		    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
		    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
		    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
		    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
		    VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
		    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
		    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
		    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
		    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
		    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
		    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
		    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
		    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
		    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
		    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
		    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
		    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
		    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
		    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
		    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
		    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
		    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
		    VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
		    VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
		    VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
		    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
		    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
		    VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
		    VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
		    VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
		    VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
		    VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
		    VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
		    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
		    VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
		    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
		    VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
		    VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
		    VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
		    VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
		    VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
		    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
		    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
		    VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
		    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
		    VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
		    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
		    VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
		    VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES = 1000298000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES = 1000298001,
		    VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO = 1000298002,
		    VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO = 1000298003,
		    VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION = 1000298004,
		    VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE = 1000298005,
		    VK_STRUCTURE_TYPE_FAULT_DATA = 1000298007,
		    VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO = 1000298008,
		    VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO = 1000298010,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
		    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
		    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
		    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
		    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
		    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
		    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
		    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
		    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
		    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
		    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
		    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
		    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
		    VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
		    VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
		    VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
		    VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
		    VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
		    VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
		    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
		    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
		    VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
		    VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
		    VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
		    VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
		    VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
		    VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
		    VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
		    VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
		    VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000038001,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000038002,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR = 1000038003,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR = 1000038004,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR = 1000038005,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR = 1000038006,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR = 1000038007,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR = 1000038008,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR = 1000038009,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR = 1000038010,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR = 1000038011,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR = 1000038012,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000038013,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR = 1000039000,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000039001,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000039002,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR = 1000039003,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR = 1000039004,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR = 1000039005,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR = 1000039006,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR = 1000039007,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR = 1000039009,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR = 1000039010,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR = 1000039011,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR = 1000039012,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR = 1000039013,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000039014,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
		    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
		    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
		    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
		    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
		    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
		    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
		    VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV = 1000051000,
		    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
		    VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002,
		    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
		    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
		    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
		    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
		    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
		    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
		    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
		    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
		    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
		    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
		    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
		    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
		    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
		    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
		    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
		    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
		    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
		    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
		    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
		    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
		    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
		    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
		    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
		    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
		    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
		    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
		    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
		    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
		    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
		    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG = 1000110000,
		    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
		    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
		    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
		    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
		    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
		    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
		    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
		    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
		    VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
		    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
		    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
		    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR = 1000116007,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
		    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
		    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
		    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
		    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
		    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
		    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
		    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
		    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
		    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
		    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
		    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
		    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
		    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
		    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
		    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
		    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
		    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
		    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
		    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
		    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
		    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
		    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
		    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
		    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
		    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
		    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
		    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX = 1000134000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX = 1000134001,
		    VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX = 1000134002,
		    VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX = 1000134003,
		    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
		    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
		    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
		    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
		    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
		    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
		    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
		    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
		    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
		    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
		    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
		    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
		    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
		    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
		    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
		    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
		    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
		    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
		    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
		    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
		    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
		    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
		    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
		    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
		    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
		    VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
		    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
		    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
		    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
		    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
		    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
		    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
		    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
		    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
		    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
		    VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
		    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001,
		    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
		    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
		    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
		    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
		    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
		    VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
		    VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
		    VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
		    VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
		    VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
		    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
		    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
		    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
		    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
		    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
		    VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
		    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR = 1000232000,
		    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR = 1000232001,
		    VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR = 1000232002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
		    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
		    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
		    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
		    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
		    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
		    VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
		    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
		    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
		    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
		    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
		    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
		    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
		    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
		    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
		    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
		    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT = 1000270000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT = 1000270001,
		    VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT = 1000270002,
		    VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT = 1000270003,
		    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT = 1000270004,
		    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT = 1000270005,
		    VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = 1000270006,
		    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT = 1000270007,
		    VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT = 1000270008,
		    VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = 1000270009,
		    VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = 1000271000,
		    VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = 1000271001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
		    VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
		    VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT = 1000274000,
		    VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT = 1000274001,
		    VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT = 1000274002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT = 1000275000,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT = 1000275001,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT = 1000275002,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT = 1000275003,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT = 1000275004,
		    VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT = 1000275005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
		    VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
		    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
		    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
		    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
		    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
		    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
		    VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
		    VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
		    VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
		    VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
		    VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001,
		    VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
		    VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
		    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
		    VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
		    VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
		    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
		    VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
		    VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV = 1000307000,
		    VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV = 1000307001,
		    VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV = 1000307002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV = 1000307003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV = 1000307004,
		    VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR = 1000308000,
		    VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
		    VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
		    VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
		    VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
		    VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
		    VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
		    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
		    VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
		    VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
		    VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
		    VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
		    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
		    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
		    VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
		    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
		    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
		    VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
		    VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
		    VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
		    VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
		    VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
		    VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
		    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
		    VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
		    VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
		    VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
		    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
		    VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
		    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
		    VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
		    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
		    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
		    VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
		    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
		    VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
		    VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
		    VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
		    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
		    VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
		    VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
		    VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
		    VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV = 1000374000,
		    VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV = 1000374001,
		    VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV = 1000374002,
		    VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV = 1000374003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV = 1000374004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT = 1000375000,
		    VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT = 1000375001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
		    VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
		    VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
		    VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
		    VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
		    VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
		    VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
		    VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
		    VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
		    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
		    VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
		    VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV = 1000397000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV = 1000397001,
		    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV = 1000397002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI = 1000404002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
		    VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR = 1000416000,
		    VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 1000421000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM = 1000424000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM = 1000424001,
		    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM = 1000424002,
		    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM = 1000424003,
		    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM = 1000424004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001,
		    VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
		    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
		    VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR = 1000434000,
		    VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT = 1000435000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT = 1000451000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT = 1000451001,
		    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
		    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
		    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
		    VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
		    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
		    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
		    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
		    VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
		    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
		    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
		    VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
		    VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
		    VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
		    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR = 1000470000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR = 1000470001,
		    VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR = 1000470003,
		    VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR = 1000470004,
		    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR = 1000338002,
		    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR = 1000338003,
		    VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR = 1000470005,
		    VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR = 1000470006,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
		    VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
		    VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
		    VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
		    VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV = 1000489000,
		    VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV = 1000489001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV = 1000489002,
		    VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV = 1000373000,
		    VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV = 1000373001,
		    VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV = 1000373002,
		    VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV = 1000373003,
		    VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV = 1000489003,
		    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373004,
		    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373005,
		    VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV = 1000373006,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV = 1000373007,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV = 1000492000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV = 1000492001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
		    VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
		    VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT = 1000496000,
		    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
		    VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
		    VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
		    VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
		    VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV = 1000505003,
		    VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV = 1000505004,
		    VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV = 1000505005,
		    VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV = 1000505006,
		    VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV = 1000505007,
		    VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV = 1000505008,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
		    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
		    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR = 1000512000,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR = 1000512001,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
		    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
		    VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM = 1000518000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM = 1000518001,
		    VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM = 1000518002,
		    VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM = 1000519000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM = 1000519001,
		    VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM = 1000519002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM = 1000520000,
		    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR = 1000525000,
		    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR = 1000190001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR = 1000190002,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR = 1000528000,
		    VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
		    VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
		    VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
		    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR = 1000265000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR = 1000259000,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR = 1000259001,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR = 1000259002,
		    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR = 1000544000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR = 1000545000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR = 1000545001,
		    VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR = 1000545002,
		    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR = 1000545003,
		    VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR = 1000545004,
		    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR = 1000545005,
		    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR = 1000545006,
		    VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
		    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV = 1000563000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
		    VK_STRUCTURE_TYPE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_INFO,
		    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
		    VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
		    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
		    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
		    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
		    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
		    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
		    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
		    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
		    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
		    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
		    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
		    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
		    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
		    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
		    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
		    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
		    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
		    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
		    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
		    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
		    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
		    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
		    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
		    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
		    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
		    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
		    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
		    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
		    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
		    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
		    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
		    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
		    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
		    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
		    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
		    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
		    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
		    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
		    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
		    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
		    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
		    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
		    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
		    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
		    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
		    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
		    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
		    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
		    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR,
		    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR,
		    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR,
		    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
		    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
		    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
		    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
		    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
		    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
		    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
		    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
		    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
		    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
		    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
		    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
		    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
		    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
		    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
		    VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
		    VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
		    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
		    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
		    VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
		    VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
		    VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
		    VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
		    VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
		    VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2,
		    VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2,
		    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2,
		    VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
		    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
		    VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_COPY_2,
		    VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_IMAGE_COPY_2,
		    VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
		    VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
		    VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
		    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR,
		    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR,
		    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
		    VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
		    VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
		    VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
		    VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
		    VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
		    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR,
		    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR,
		    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR,
		    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
		    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkStructureType;

		typedef enum
		{
		    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
		    VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE = 1000298001,
		    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineCacheHeaderVersion;


		typedef enum
		{
		    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
		    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
		    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
		    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
		    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
		    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
		    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
		    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
		    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
		    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
		    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
		    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
		    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
		    VK_ACCESS_HOST_READ_BIT = 0x00002000,
		    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
		    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
		    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
		    VK_ACCESS_NONE = 0,
		    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
		    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
		    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
		    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
		    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
		    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000,
		    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000,
		    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
		    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000,
		    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000,
		    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000,
		    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
		    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
		    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
		    VK_ACCESS_NONE_KHR = VK_ACCESS_NONE,
		    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkAccessFlagBits;
		typedef VkFlags VkAccessFlags;
		typedef enum
		{
		    VK_IMAGE_LAYOUT_UNDEFINED = 0,
		    VK_IMAGE_LAYOUT_GENERAL = 1,
		    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
		    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
		    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
		    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
		    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
		    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
		    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
		    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
		    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
		    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
		    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
		    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
		    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
		    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
		    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
		    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
		    VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
		    VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
		    VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
		    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
		    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
		    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
		    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR = 1000232000,
		    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
		    VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
		    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
		    VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
		    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
		    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
		    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
		    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
		    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
		    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
		    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
		    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
		    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
		    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
		} VkImageLayout;


		typedef enum
		{
		    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
		    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
		    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
		    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
		    VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
		    VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
		    VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
		    VK_IMAGE_ASPECT_NONE = 0,
		    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
		    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
		    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
		    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
		    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
		    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
		    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
		    VK_IMAGE_ASPECT_NONE_KHR = VK_IMAGE_ASPECT_NONE,
		    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkImageAspectFlagBits;
		typedef VkFlags VkImageAspectFlags;
		typedef enum
		{
		    VK_OBJECT_TYPE_UNKNOWN = 0,
		    VK_OBJECT_TYPE_INSTANCE = 1,
		    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
		    VK_OBJECT_TYPE_DEVICE = 3,
		    VK_OBJECT_TYPE_QUEUE = 4,
		    VK_OBJECT_TYPE_SEMAPHORE = 5,
		    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
		    VK_OBJECT_TYPE_FENCE = 7,
		    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
		    VK_OBJECT_TYPE_BUFFER = 9,
		    VK_OBJECT_TYPE_IMAGE = 10,
		    VK_OBJECT_TYPE_EVENT = 11,
		    VK_OBJECT_TYPE_QUERY_POOL = 12,
		    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
		    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
		    VK_OBJECT_TYPE_SHADER_MODULE = 15,
		    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
		    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
		    VK_OBJECT_TYPE_RENDER_PASS = 18,
		    VK_OBJECT_TYPE_PIPELINE = 19,
		    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
		    VK_OBJECT_TYPE_SAMPLER = 21,
		    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
		    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
		    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
		    VK_OBJECT_TYPE_COMMAND_POOL = 25,
		    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
		    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
		    VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
		    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
		    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
		    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
		    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
		    VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
		    VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
		    VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
		    VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
		    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
		    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
		    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
		    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
		    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
		    VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
		    VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
		    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
		    VK_OBJECT_TYPE_CUDA_MODULE_NV = 1000307000,
		    VK_OBJECT_TYPE_CUDA_FUNCTION_NV = 1000307001,
		    VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
		    VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
		    VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
		    VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
		    VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV = 1000489000,
		    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
		    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
		    VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT,
		    VK_OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkObjectType;

		typedef enum
		{
		    VK_VENDOR_ID_VIV = 0x10001,
		    VK_VENDOR_ID_VSI = 0x10002,
		    VK_VENDOR_ID_KAZAN = 0x10003,
		    VK_VENDOR_ID_CODEPLAY = 0x10004,
		    VK_VENDOR_ID_MESA = 0x10005,
		    VK_VENDOR_ID_POCL = 0x10006,
		    VK_VENDOR_ID_MOBILEYE = 0x10007,
		    VK_VENDOR_ID_MAX_ENUM = 0x7FFFFFFF
		} VkVendorId;

		typedef enum
		{
		    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
		    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
		    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
		    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
		    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
		    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
		} VkSystemAllocationScope;

		typedef enum
		{
		    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
		    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkInternalAllocationType;

		typedef enum
		{
		    VK_FORMAT_UNDEFINED = 0,
		    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
		    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
		    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
		    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
		    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
		    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
		    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
		    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
		    VK_FORMAT_R8_UNORM = 9,
		    VK_FORMAT_R8_SNORM = 10,
		    VK_FORMAT_R8_USCALED = 11,
		    VK_FORMAT_R8_SSCALED = 12,
		    VK_FORMAT_R8_UINT = 13,
		    VK_FORMAT_R8_SINT = 14,
		    VK_FORMAT_R8_SRGB = 15,
		    VK_FORMAT_R8G8_UNORM = 16,
		    VK_FORMAT_R8G8_SNORM = 17,
		    VK_FORMAT_R8G8_USCALED = 18,
		    VK_FORMAT_R8G8_SSCALED = 19,
		    VK_FORMAT_R8G8_UINT = 20,
		    VK_FORMAT_R8G8_SINT = 21,
		    VK_FORMAT_R8G8_SRGB = 22,
		    VK_FORMAT_R8G8B8_UNORM = 23,
		    VK_FORMAT_R8G8B8_SNORM = 24,
		    VK_FORMAT_R8G8B8_USCALED = 25,
		    VK_FORMAT_R8G8B8_SSCALED = 26,
		    VK_FORMAT_R8G8B8_UINT = 27,
		    VK_FORMAT_R8G8B8_SINT = 28,
		    VK_FORMAT_R8G8B8_SRGB = 29,
		    VK_FORMAT_B8G8R8_UNORM = 30,
		    VK_FORMAT_B8G8R8_SNORM = 31,
		    VK_FORMAT_B8G8R8_USCALED = 32,
		    VK_FORMAT_B8G8R8_SSCALED = 33,
		    VK_FORMAT_B8G8R8_UINT = 34,
		    VK_FORMAT_B8G8R8_SINT = 35,
		    VK_FORMAT_B8G8R8_SRGB = 36,
		    VK_FORMAT_R8G8B8A8_UNORM = 37,
		    VK_FORMAT_R8G8B8A8_SNORM = 38,
		    VK_FORMAT_R8G8B8A8_USCALED = 39,
		    VK_FORMAT_R8G8B8A8_SSCALED = 40,
		    VK_FORMAT_R8G8B8A8_UINT = 41,
		    VK_FORMAT_R8G8B8A8_SINT = 42,
		    VK_FORMAT_R8G8B8A8_SRGB = 43,
		    VK_FORMAT_B8G8R8A8_UNORM = 44,
		    VK_FORMAT_B8G8R8A8_SNORM = 45,
		    VK_FORMAT_B8G8R8A8_USCALED = 46,
		    VK_FORMAT_B8G8R8A8_SSCALED = 47,
		    VK_FORMAT_B8G8R8A8_UINT = 48,
		    VK_FORMAT_B8G8R8A8_SINT = 49,
		    VK_FORMAT_B8G8R8A8_SRGB = 50,
		    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
		    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
		    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
		    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
		    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
		    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
		    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
		    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
		    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
		    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
		    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
		    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
		    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
		    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
		    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
		    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
		    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
		    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
		    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
		    VK_FORMAT_R16_UNORM = 70,
		    VK_FORMAT_R16_SNORM = 71,
		    VK_FORMAT_R16_USCALED = 72,
		    VK_FORMAT_R16_SSCALED = 73,
		    VK_FORMAT_R16_UINT = 74,
		    VK_FORMAT_R16_SINT = 75,
		    VK_FORMAT_R16_SFLOAT = 76,
		    VK_FORMAT_R16G16_UNORM = 77,
		    VK_FORMAT_R16G16_SNORM = 78,
		    VK_FORMAT_R16G16_USCALED = 79,
		    VK_FORMAT_R16G16_SSCALED = 80,
		    VK_FORMAT_R16G16_UINT = 81,
		    VK_FORMAT_R16G16_SINT = 82,
		    VK_FORMAT_R16G16_SFLOAT = 83,
		    VK_FORMAT_R16G16B16_UNORM = 84,
		    VK_FORMAT_R16G16B16_SNORM = 85,
		    VK_FORMAT_R16G16B16_USCALED = 86,
		    VK_FORMAT_R16G16B16_SSCALED = 87,
		    VK_FORMAT_R16G16B16_UINT = 88,
		    VK_FORMAT_R16G16B16_SINT = 89,
		    VK_FORMAT_R16G16B16_SFLOAT = 90,
		    VK_FORMAT_R16G16B16A16_UNORM = 91,
		    VK_FORMAT_R16G16B16A16_SNORM = 92,
		    VK_FORMAT_R16G16B16A16_USCALED = 93,
		    VK_FORMAT_R16G16B16A16_SSCALED = 94,
		    VK_FORMAT_R16G16B16A16_UINT = 95,
		    VK_FORMAT_R16G16B16A16_SINT = 96,
		    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
		    VK_FORMAT_R32_UINT = 98,
		    VK_FORMAT_R32_SINT = 99,
		    VK_FORMAT_R32_SFLOAT = 100,
		    VK_FORMAT_R32G32_UINT = 101,
		    VK_FORMAT_R32G32_SINT = 102,
		    VK_FORMAT_R32G32_SFLOAT = 103,
		    VK_FORMAT_R32G32B32_UINT = 104,
		    VK_FORMAT_R32G32B32_SINT = 105,
		    VK_FORMAT_R32G32B32_SFLOAT = 106,
		    VK_FORMAT_R32G32B32A32_UINT = 107,
		    VK_FORMAT_R32G32B32A32_SINT = 108,
		    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
		    VK_FORMAT_R64_UINT = 110,
		    VK_FORMAT_R64_SINT = 111,
		    VK_FORMAT_R64_SFLOAT = 112,
		    VK_FORMAT_R64G64_UINT = 113,
		    VK_FORMAT_R64G64_SINT = 114,
		    VK_FORMAT_R64G64_SFLOAT = 115,
		    VK_FORMAT_R64G64B64_UINT = 116,
		    VK_FORMAT_R64G64B64_SINT = 117,
		    VK_FORMAT_R64G64B64_SFLOAT = 118,
		    VK_FORMAT_R64G64B64A64_UINT = 119,
		    VK_FORMAT_R64G64B64A64_SINT = 120,
		    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
		    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
		    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
		    VK_FORMAT_D16_UNORM = 124,
		    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
		    VK_FORMAT_D32_SFLOAT = 126,
		    VK_FORMAT_S8_UINT = 127,
		    VK_FORMAT_D16_UNORM_S8_UINT = 128,
		    VK_FORMAT_D24_UNORM_S8_UINT = 129,
		    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
		    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
		    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
		    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
		    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
		    VK_FORMAT_BC2_UNORM_BLOCK = 135,
		    VK_FORMAT_BC2_SRGB_BLOCK = 136,
		    VK_FORMAT_BC3_UNORM_BLOCK = 137,
		    VK_FORMAT_BC3_SRGB_BLOCK = 138,
		    VK_FORMAT_BC4_UNORM_BLOCK = 139,
		    VK_FORMAT_BC4_SNORM_BLOCK = 140,
		    VK_FORMAT_BC5_UNORM_BLOCK = 141,
		    VK_FORMAT_BC5_SNORM_BLOCK = 142,
		    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
		    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
		    VK_FORMAT_BC7_UNORM_BLOCK = 145,
		    VK_FORMAT_BC7_SRGB_BLOCK = 146,
		    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
		    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
		    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
		    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
		    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
		    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
		    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
		    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
		    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
		    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
		    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
		    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
		    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
		    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
		    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
		    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
		    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
		    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
		    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
		    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
		    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
		    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
		    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
		    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
		    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
		    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
		    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
		    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
		    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
		    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
		    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
		    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
		    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
		    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
		    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
		    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
		    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
		    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
		    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
		    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
		    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
		    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
		    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
		    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
		    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
		    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
		    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
		    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
		    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
		    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
		    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
		    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
		    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
		    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
		    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
		    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
		    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
		    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
		    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
		    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
		    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
		    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
		    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
		    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
		    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
		    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
		    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
		    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
		    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
		    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
		    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
		    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
		    VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
		    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
		    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
		    VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
		    VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
		    VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
		    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
		    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
		    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
		    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
		    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
		    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
		    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
		    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
		    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
		    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
		    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
		    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
		    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
		    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
		    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
		    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
		    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
		    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
		    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
		    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
		    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
		    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
		    VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
		    VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = 1000470000,
		    VK_FORMAT_A8_UNORM_KHR = 1000470001,
		    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
		    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
		    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
		    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
		    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
		    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
		    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
		    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
		    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
		    VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
		    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
		    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
		    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
		    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
		    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
		    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
		    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
		    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
		    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
		    VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
		    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
		    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
		    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
		    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
		    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
		    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
		    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
		    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
		    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
		    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
		    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
		    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
		    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
		    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
		    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
		    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
		    VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
		    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
		    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
		    VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
		    VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = VK_FORMAT_A4R4G4B4_UNORM_PACK16,
		    VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
		    VK_FORMAT_R16G16_S10_5_NV = VK_FORMAT_R16G16_SFIXED5_NV,
		    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
		} VkFormat;


		typedef enum
		{
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
		    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
		    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
		    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
		    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
		    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
		    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
		    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
		    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
		    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
		    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
		    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
		    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
		    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
		    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
		    VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
		    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000,
		    VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000,
		    VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000,
		    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000,
		    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
		    VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000,
		    VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000,
		    VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
		    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
		    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
		    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
		    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
		    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
		    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
		    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkFormatFeatureFlagBits;
		typedef VkFlags VkFormatFeatureFlags;

		typedef enum
		{
		    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
		    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
		    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
		    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
		    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
		    VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
		    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
		    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
		    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
		    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
		    VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
		    VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
		    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
		    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
		    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
		    VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00010000,
		    VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x00040000,
		    VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x00020000,
		    VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 0x00008000,
		    VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00100000,
		    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
		    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
		    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
		    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
		    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
		    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
		    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkImageCreateFlagBits;
		typedef VkFlags VkImageCreateFlags;

		typedef enum
		{
		    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
		    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
		    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
		    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
		    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
		    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
		    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
		    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSampleCountFlagBits;
		typedef VkFlags VkSampleCountFlags;
		typedef enum
		{
		    VK_IMAGE_TILING_OPTIMAL = 0,
		    VK_IMAGE_TILING_LINEAR = 1,
		    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
		    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
		} VkImageTiling;

		typedef enum
		{
		    VK_IMAGE_TYPE_1D = 0,
		    VK_IMAGE_TYPE_2D = 1,
		    VK_IMAGE_TYPE_3D = 2,
		    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkImageType;


		typedef enum
		{
		    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
		    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
		    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
		    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
		    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
		    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
		    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
		    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
		    VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00000400,
		    VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00000800,
		    VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x00001000,
		    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
		    VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00000100,
		    VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT = 0x00400000,
		    VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00002000,
		    VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00004000,
		    VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x00008000,
		    VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x00080000,
		    VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x00040000,
		    VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x00100000,
		    VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x00200000,
		    VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
		    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkImageUsageFlagBits;
		typedef VkFlags VkImageUsageFlags;

		typedef enum
		{
		    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x00000001,
		    VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkInstanceCreateFlagBits;
		typedef VkFlags VkInstanceCreateFlags;

		typedef enum
		{
		    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
		    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
		    VK_MEMORY_HEAP_SEU_SAFE_BIT = 0x00000004,
		    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
		    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkMemoryHeapFlagBits;
		typedef VkFlags VkMemoryHeapFlags;

		typedef enum
		{
		    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
		    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
		    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
		    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
		    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
		    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
		    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
		    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
		    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
		    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkMemoryPropertyFlagBits;
		typedef VkFlags VkMemoryPropertyFlags;
		typedef enum
		{
		    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
		    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
		    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
		    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
		    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
		    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkPhysicalDeviceType;


		typedef enum
		{
		    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
		    VK_QUEUE_COMPUTE_BIT = 0x00000002,
		    VK_QUEUE_TRANSFER_BIT = 0x00000004,
		    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
		    VK_QUEUE_PROTECTED_BIT = 0x00000010,
		    VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020,
		    VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040,
		    VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x00000100,
		    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkQueueFlagBits;
		typedef VkFlags VkQueueFlags;
		typedef VkFlags VkDeviceCreateFlags;

		typedef enum
		{
		    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
		    VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkDeviceQueueCreateFlagBits;
		typedef VkFlags VkDeviceQueueCreateFlags;

		typedef enum
		{
		    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
		    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
		    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
		    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
		    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
		    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
		    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
		    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
		    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
		    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
		    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
		    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
		    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
		    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
		    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
		    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
		    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
		    VK_PIPELINE_STAGE_NONE = 0,
		    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
		    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
		    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000,
		    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x00200000,
		    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
		    VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000,
		    VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x00020000,
		    VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x00080000,
		    VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x00100000,
		    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
		    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
		    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
		    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,
		    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,
		    VK_PIPELINE_STAGE_NONE_KHR = VK_PIPELINE_STAGE_NONE,
		    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineStageFlagBits;
		typedef VkFlags VkPipelineStageFlags;

		typedef enum
		{
		    VK_MEMORY_MAP_PLACED_BIT_EXT = 0x00000001,
		    VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkMemoryMapFlagBits;
		typedef VkFlags VkMemoryMapFlags;

		typedef enum
		{
		    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
		    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSparseMemoryBindFlagBits;
		typedef VkFlags VkSparseMemoryBindFlags;

		typedef enum
		{
		    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
		    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
		    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
		    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSparseImageFormatFlagBits;
		typedef VkFlags VkSparseImageFormatFlags;

		typedef enum
		{
		    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
		    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkFenceCreateFlagBits;
		typedef VkFlags VkFenceCreateFlags;
		typedef VkFlags VkSemaphoreCreateFlags;

		typedef enum
		{
		    VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x00000001,
		    VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
		    VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkEventCreateFlagBits;
		typedef VkFlags VkEventCreateFlags;

		typedef enum
		{
		    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
		    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
		    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
		    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
		    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
		    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
		    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
		    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
		    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
		    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
		    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
		    VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x00000800,
		    VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x00001000,
		    VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x00002000,
		    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkQueryPipelineStatisticFlagBits;
		typedef VkFlags VkQueryPipelineStatisticFlags;
		typedef VkFlags VkQueryPoolCreateFlags;
		typedef enum
		{
		    VK_QUERY_TYPE_OCCLUSION = 0,
		    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
		    VK_QUERY_TYPE_TIMESTAMP = 2,
		    VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
		    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
		    VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
		    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
		    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
		    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
		    VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
		    VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
		    VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
		    VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
		    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
		    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
		    VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
		    VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
		    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkQueryType;


		typedef enum
		{
		    VK_QUERY_RESULT_64_BIT = 0x00000001,
		    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
		    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
		    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
		    VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x00000010,
		    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkQueryResultFlagBits;
		typedef VkFlags VkQueryResultFlags;

		typedef enum
		{
		    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
		    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
		    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
		    VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
		    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000010,
		    VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000020,
		    VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = 0x00000040,
		    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
		    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
		    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkBufferCreateFlagBits;
		typedef VkFlags VkBufferCreateFlags;

		typedef enum
		{
		    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
		    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
		    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
		    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
		    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
		    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
		    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
		    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
		    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
		    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000,
		    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000,
		    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x00004000,
		    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
		    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
		    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
		    VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x02000000,
		    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000,
		    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000,
		    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400,
		    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000,
		    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000,
		    VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000,
		    VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000,
		    VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000,
		    VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000,
		    VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x01000000,
		    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
		    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
		    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
		    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkBufferUsageFlagBits;
		typedef VkFlags VkBufferUsageFlags;
		typedef enum
		{
		    VK_SHARING_MODE_EXCLUSIVE = 0,
		    VK_SHARING_MODE_CONCURRENT = 1,
		    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
		} VkSharingMode;

		typedef VkFlags VkBufferViewCreateFlags;
		typedef enum
		{
		    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
		    VK_COMPONENT_SWIZZLE_ZERO = 1,
		    VK_COMPONENT_SWIZZLE_ONE = 2,
		    VK_COMPONENT_SWIZZLE_R = 3,
		    VK_COMPONENT_SWIZZLE_G = 4,
		    VK_COMPONENT_SWIZZLE_B = 5,
		    VK_COMPONENT_SWIZZLE_A = 6,
		    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
		} VkComponentSwizzle;


		typedef enum
		{
		    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
		    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000004,
		    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
		    VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkImageViewCreateFlagBits;
		typedef VkFlags VkImageViewCreateFlags;
		typedef enum
		{
		    VK_IMAGE_VIEW_TYPE_1D = 0,
		    VK_IMAGE_VIEW_TYPE_2D = 1,
		    VK_IMAGE_VIEW_TYPE_3D = 2,
		    VK_IMAGE_VIEW_TYPE_CUBE = 3,
		    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
		    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
		    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
		    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkImageViewType;

		typedef VkFlags VkShaderModuleCreateFlags;

		typedef enum
		{
		    VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
		    VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT = 0x00000002,
		    VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT = 0x00000004,
		    VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT,
		    VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineCacheCreateFlagBits;
		typedef VkFlags VkPipelineCacheCreateFlags;
		typedef enum
		{
		    VK_BLEND_FACTOR_ZERO = 0,
		    VK_BLEND_FACTOR_ONE = 1,
		    VK_BLEND_FACTOR_SRC_COLOR = 2,
		    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
		    VK_BLEND_FACTOR_DST_COLOR = 4,
		    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
		    VK_BLEND_FACTOR_SRC_ALPHA = 6,
		    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
		    VK_BLEND_FACTOR_DST_ALPHA = 8,
		    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
		    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
		    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
		    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
		    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
		    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
		    VK_BLEND_FACTOR_SRC1_COLOR = 15,
		    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
		    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
		    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
		    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
		} VkBlendFactor;

		typedef enum
		{
		    VK_BLEND_OP_ADD = 0,
		    VK_BLEND_OP_SUBTRACT = 1,
		    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
		    VK_BLEND_OP_MIN = 3,
		    VK_BLEND_OP_MAX = 4,
		    VK_BLEND_OP_ZERO_EXT = 1000148000,
		    VK_BLEND_OP_SRC_EXT = 1000148001,
		    VK_BLEND_OP_DST_EXT = 1000148002,
		    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
		    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
		    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
		    VK_BLEND_OP_DST_IN_EXT = 1000148006,
		    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
		    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
		    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
		    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
		    VK_BLEND_OP_XOR_EXT = 1000148011,
		    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
		    VK_BLEND_OP_SCREEN_EXT = 1000148013,
		    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
		    VK_BLEND_OP_DARKEN_EXT = 1000148015,
		    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
		    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
		    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
		    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
		    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
		    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
		    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
		    VK_BLEND_OP_INVERT_EXT = 1000148023,
		    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
		    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
		    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
		    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
		    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
		    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
		    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
		    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
		    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
		    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
		    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
		    VK_BLEND_OP_PLUS_EXT = 1000148035,
		    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
		    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
		    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
		    VK_BLEND_OP_MINUS_EXT = 1000148039,
		    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
		    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
		    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
		    VK_BLEND_OP_RED_EXT = 1000148043,
		    VK_BLEND_OP_GREEN_EXT = 1000148044,
		    VK_BLEND_OP_BLUE_EXT = 1000148045,
		    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
		} VkBlendOp;


		typedef enum
		{
		    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
		    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
		    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
		    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
		    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkColorComponentFlagBits;
		typedef VkFlags VkColorComponentFlags;
		typedef enum
		{
		    VK_COMPARE_OP_NEVER = 0,
		    VK_COMPARE_OP_LESS = 1,
		    VK_COMPARE_OP_EQUAL = 2,
		    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
		    VK_COMPARE_OP_GREATER = 4,
		    VK_COMPARE_OP_NOT_EQUAL = 5,
		    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
		    VK_COMPARE_OP_ALWAYS = 7,
		    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
		} VkCompareOp;


		typedef enum
		{
		    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
		    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
		    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
		    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
		    VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x00000010,
		    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x00000100,
		    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x00000200,
		    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000,
		    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000,
		    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000,
		    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000,
		    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000,
		    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000,
		    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000,
		    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000,
		    VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000,
		    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
		    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x00000040,
		    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080,
		    VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00040000,
		    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x00000800,
		    VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000,
		    VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000,
		    VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400,
		    VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000,
		    VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000,
		    VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000,
		    VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000,
		    VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000,
		    VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000,
		    VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000,
		    VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
		    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
		    VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
		    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
		    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
		    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
		    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
		    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineCreateFlagBits;
		typedef VkFlags VkPipelineCreateFlags;

		typedef enum
		{
		    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x00000001,
		    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x00000002,
		    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
		    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
		    VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineShaderStageCreateFlagBits;
		typedef VkFlags VkPipelineShaderStageCreateFlags;

		typedef enum
		{
		    VK_CULL_MODE_NONE = 0,
		    VK_CULL_MODE_FRONT_BIT = 0x00000001,
		    VK_CULL_MODE_BACK_BIT = 0x00000002,
		    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
		    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkCullModeFlagBits;
		typedef VkFlags VkCullModeFlags;
		typedef enum
		{
		    VK_DYNAMIC_STATE_VIEWPORT = 0,
		    VK_DYNAMIC_STATE_SCISSOR = 1,
		    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
		    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
		    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
		    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
		    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
		    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
		    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
		    VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
		    VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
		    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
		    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
		    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
		    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
		    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
		    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
		    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
		    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
		    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
		    VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
		    VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
		    VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
		    VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
		    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
		    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
		    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
		    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
		    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
		    VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
		    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
		    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
		    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
		    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
		    VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
		    VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
		    VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
		    VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
		    VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
		    VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
		    VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
		    VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
		    VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
		    VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
		    VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
		    VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
		    VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
		    VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
		    VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
		    VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
		    VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
		    VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
		    VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
		    VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
		    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
		    VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
		    VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
		    VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
		    VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
		    VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
		    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
		    VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
		    VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
		    VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
		    VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
		    VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
		    VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
		    VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
		    VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
		    VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
		    VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
		    VK_DYNAMIC_STATE_LINE_STIPPLE_KHR = 1000259000,
		    VK_DYNAMIC_STATE_CULL_MODE_EXT = VK_DYNAMIC_STATE_CULL_MODE,
		    VK_DYNAMIC_STATE_FRONT_FACE_EXT = VK_DYNAMIC_STATE_FRONT_FACE,
		    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
		    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
		    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
		    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
		    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
		    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
		    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
		    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
		    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
		    VK_DYNAMIC_STATE_STENCIL_OP_EXT = VK_DYNAMIC_STATE_STENCIL_OP,
		    VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
		    VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
		    VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
		    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = VK_DYNAMIC_STATE_LINE_STIPPLE_KHR,
		    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
		} VkDynamicState;

		typedef enum
		{
		    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
		    VK_FRONT_FACE_CLOCKWISE = 1,
		    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
		} VkFrontFace;

		typedef VkFlags VkPipelineVertexInputStateCreateFlags;
		typedef enum
		{
		    VK_VERTEX_INPUT_RATE_VERTEX = 0,
		    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
		    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
		} VkVertexInputRate;

		typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
		typedef enum
		{
		    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
		    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
		    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
		    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
		    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
		    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
		    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
		    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
		    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
		    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
		    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
		    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
		} VkPrimitiveTopology;

		typedef VkFlags VkPipelineTessellationStateCreateFlags;
		typedef VkFlags VkPipelineViewportStateCreateFlags;
		typedef VkFlags VkPipelineRasterizationStateCreateFlags;
		typedef enum
		{
		    VK_POLYGON_MODE_FILL = 0,
		    VK_POLYGON_MODE_LINE = 1,
		    VK_POLYGON_MODE_POINT = 2,
		    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
		    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
		} VkPolygonMode;

		typedef VkFlags VkPipelineMultisampleStateCreateFlags;

		typedef enum
		{
		    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000001,
		    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000002,
		    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
		    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
		    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineDepthStencilStateCreateFlagBits;
		typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
		typedef enum
		{
		    VK_STENCIL_OP_KEEP = 0,
		    VK_STENCIL_OP_ZERO = 1,
		    VK_STENCIL_OP_REPLACE = 2,
		    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
		    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
		    VK_STENCIL_OP_INVERT = 5,
		    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
		    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
		    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
		} VkStencilOp;


		typedef enum
		{
		    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x00000001,
		    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,
		    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineColorBlendStateCreateFlagBits;
		typedef VkFlags VkPipelineColorBlendStateCreateFlags;
		typedef enum
		{
		    VK_LOGIC_OP_CLEAR = 0,
		    VK_LOGIC_OP_AND = 1,
		    VK_LOGIC_OP_AND_REVERSE = 2,
		    VK_LOGIC_OP_COPY = 3,
		    VK_LOGIC_OP_AND_INVERTED = 4,
		    VK_LOGIC_OP_NO_OP = 5,
		    VK_LOGIC_OP_XOR = 6,
		    VK_LOGIC_OP_OR = 7,
		    VK_LOGIC_OP_NOR = 8,
		    VK_LOGIC_OP_EQUIVALENT = 9,
		    VK_LOGIC_OP_INVERT = 10,
		    VK_LOGIC_OP_OR_REVERSE = 11,
		    VK_LOGIC_OP_COPY_INVERTED = 12,
		    VK_LOGIC_OP_OR_INVERTED = 13,
		    VK_LOGIC_OP_NAND = 14,
		    VK_LOGIC_OP_SET = 15,
		    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
		} VkLogicOp;

		typedef VkFlags VkPipelineDynamicStateCreateFlags;

		typedef enum
		{
		    VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x00000002,
		    VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineLayoutCreateFlagBits;
		typedef VkFlags VkPipelineLayoutCreateFlags;

		typedef enum
		{
		    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
		    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
		    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
		    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
		    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
		    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
		    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
		    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
		    VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x00000100,
		    VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x00000200,
		    VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x00000400,
		    VK_SHADER_STAGE_MISS_BIT_KHR = 0x00000800,
		    VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
		    VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
		    VK_SHADER_STAGE_TASK_BIT_EXT = 0x00000040,
		    VK_SHADER_STAGE_MESH_BIT_EXT = 0x00000080,
		    VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
		    VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x00080000,
		    VK_SHADER_STAGE_RAYGEN_BIT_NV = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
		    VK_SHADER_STAGE_ANY_HIT_BIT_NV = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
		    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
		    VK_SHADER_STAGE_MISS_BIT_NV = VK_SHADER_STAGE_MISS_BIT_KHR,
		    VK_SHADER_STAGE_INTERSECTION_BIT_NV = VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
		    VK_SHADER_STAGE_CALLABLE_BIT_NV = VK_SHADER_STAGE_CALLABLE_BIT_KHR,
		    VK_SHADER_STAGE_TASK_BIT_NV = VK_SHADER_STAGE_TASK_BIT_EXT,
		    VK_SHADER_STAGE_MESH_BIT_NV = VK_SHADER_STAGE_MESH_BIT_EXT,
		    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkShaderStageFlagBits;
		typedef VkFlags VkShaderStageFlags;
		typedef enum
		{
		    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
		    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
		    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
		    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
		    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
		    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
		    VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
		    VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
		    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
		} VkBorderColor;

		typedef enum
		{
		    VK_FILTER_NEAREST = 0,
		    VK_FILTER_LINEAR = 1,
		    VK_FILTER_CUBIC_EXT = 1000015000,
		    VK_FILTER_CUBIC_IMG = VK_FILTER_CUBIC_EXT,
		    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
		} VkFilter;

		typedef enum
		{
		    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
		    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
		    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
		    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
		    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
		    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
		    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
		} VkSamplerAddressMode;


		typedef enum
		{
		    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
		    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
		    VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
		    VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x00000004,
		    VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x00000010,
		    VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSamplerCreateFlagBits;
		typedef VkFlags VkSamplerCreateFlags;
		typedef enum
		{
		    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
		    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
		    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
		} VkSamplerMipmapMode;


		typedef enum
		{
		    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
		    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x00000002,
		    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x00000004,
		    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = 0x00000008,
		    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = 0x00000010,
		    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
		    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT,
		    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkDescriptorPoolCreateFlagBits;
		typedef VkFlags VkDescriptorPoolCreateFlags;
		typedef enum
		{
		    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
		    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
		    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
		    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
		    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
		    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
		    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
		    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
		    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
		    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
		    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
		    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
		    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
		    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
		    VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
		    VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
		    VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
		    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK,
		    VK_DESCRIPTOR_TYPE_MUTABLE_VALVE = VK_DESCRIPTOR_TYPE_MUTABLE_EXT,
		    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkDescriptorType;

		typedef VkFlags VkDescriptorPoolResetFlags;

		typedef enum
		{
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00000010,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x00000020,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x00000080,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x00000004,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV = 0x00000040,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT,
		    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkDescriptorSetLayoutCreateFlagBits;
		typedef VkFlags VkDescriptorSetLayoutCreateFlags;

		typedef enum
		{
		    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
		    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkAttachmentDescriptionFlagBits;
		typedef VkFlags VkAttachmentDescriptionFlags;
		typedef enum
		{
		    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
		    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
		    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
		    VK_ATTACHMENT_LOAD_OP_NONE_KHR = 1000400000,
		    VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE_KHR,
		    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
		} VkAttachmentLoadOp;

		typedef enum
		{
		    VK_ATTACHMENT_STORE_OP_STORE = 0,
		    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
		    VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
		    VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,
		    VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,
		    VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,
		    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
		} VkAttachmentStoreOp;


		typedef enum
		{
		    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
		    VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
		    VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
		    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x00000008,
		    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
		    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
		    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkDependencyFlagBits;
		typedef VkFlags VkDependencyFlags;

		typedef enum
		{
		    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x00000001,
		    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
		    VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkFramebufferCreateFlagBits;
		typedef VkFlags VkFramebufferCreateFlags;
		typedef enum
		{
		    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
		    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
		    VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX = 1000134000,
		    VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
		    VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
		    VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
		    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineBindPoint;


		typedef enum
		{
		    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x00000002,
		    VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkRenderPassCreateFlagBits;
		typedef VkFlags VkRenderPassCreateFlags;

		typedef enum
		{
		    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
		    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
		    VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x00000004,
		    VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x00000008,
		    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x00000010,
		    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x00000020,
		    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x00000040,
		    VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000080,
		    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT,
		    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
		    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
		    VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSubpassDescriptionFlagBits;
		typedef VkFlags VkSubpassDescriptionFlags;

		typedef enum
		{
		    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
		    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
		    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
		    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkCommandPoolCreateFlagBits;
		typedef VkFlags VkCommandPoolCreateFlags;

		typedef enum
		{
		    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
		    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkCommandPoolResetFlagBits;
		typedef VkFlags VkCommandPoolResetFlags;
		typedef enum
		{
		    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
		    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
		    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
		} VkCommandBufferLevel;


		typedef enum
		{
		    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
		    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
		    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
		    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkCommandBufferUsageFlagBits;
		typedef VkFlags VkCommandBufferUsageFlags;

		typedef enum
		{
		    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
		    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkQueryControlFlagBits;
		typedef VkFlags VkQueryControlFlags;

		typedef enum
		{
		    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
		    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkCommandBufferResetFlagBits;
		typedef VkFlags VkCommandBufferResetFlags;
		typedef enum
		{
		    VK_INDEX_TYPE_UINT16 = 0,
		    VK_INDEX_TYPE_UINT32 = 1,
		    VK_INDEX_TYPE_NONE_KHR = 1000165000,
		    VK_INDEX_TYPE_UINT8_KHR = 1000265000,
		    VK_INDEX_TYPE_NONE_NV = VK_INDEX_TYPE_NONE_KHR,
		    VK_INDEX_TYPE_UINT8_EXT = VK_INDEX_TYPE_UINT8_KHR,
		    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkIndexType;


		typedef enum
		{
		    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
		    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
		    VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
		    VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK,
		    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkStencilFaceFlagBits;
		typedef VkFlags VkStencilFaceFlags;
		typedef enum
		{
		    VK_SUBPASS_CONTENTS_INLINE = 0,
		    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
		    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT = 1000451000,
		    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
		} VkSubpassContents;


		typedef struct VkExtent2D
		{
		    uint32_t width;
		    uint32_t height;
		} VkExtent2D;

		typedef struct VkExtent3D
		{
		    uint32_t width;
		    uint32_t height;
		    uint32_t depth;
		} VkExtent3D;

		typedef struct VkOffset2D
		{
		    int32_t x;
		    int32_t y;
		} VkOffset2D;

		typedef struct VkOffset3D
		{
		    int32_t x;
		    int32_t y;
		    int32_t z;
		} VkOffset3D;

		typedef struct VkRect2D
		{
		    VkOffset2D offset;
		    VkExtent2D extent;
		} VkRect2D;

		typedef struct VkBaseInStructure
		{
		    VkStructureType sType;
		    const struct VkBaseInStructure* pNext;
		} VkBaseInStructure;

		typedef struct VkBaseOutStructure
		{
		    VkStructureType sType;
		    struct VkBaseOutStructure* pNext;
		} VkBaseOutStructure;

		typedef struct VkBufferMemoryBarrier
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccessFlags srcAccessMask;
		    VkAccessFlags dstAccessMask;
		    uint32_t srcQueueFamilyIndex;
		    uint32_t dstQueueFamilyIndex;
		    VkBuffer buffer;
		    VkDeviceSize offset;
		    VkDeviceSize size;
		} VkBufferMemoryBarrier;

		typedef struct VkDispatchIndirectCommand
		{
		    uint32_t x;
		    uint32_t y;
		    uint32_t z;
		} VkDispatchIndirectCommand;

		typedef struct VkDrawIndexedIndirectCommand
		{
		    uint32_t indexCount;
		    uint32_t instanceCount;
		    uint32_t firstIndex;
		    int32_t vertexOffset;
		    uint32_t firstInstance;
		} VkDrawIndexedIndirectCommand;

		typedef struct VkDrawIndirectCommand
		{
		    uint32_t vertexCount;
		    uint32_t instanceCount;
		    uint32_t firstVertex;
		    uint32_t firstInstance;
		} VkDrawIndirectCommand;

		typedef struct VkImageSubresourceRange
		{
		    VkImageAspectFlags aspectMask;
		    uint32_t baseMipLevel;
		    uint32_t levelCount;
		    uint32_t baseArrayLayer;
		    uint32_t layerCount;
		} VkImageSubresourceRange;

		typedef struct VkImageMemoryBarrier
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccessFlags srcAccessMask;
		    VkAccessFlags dstAccessMask;
		    VkImageLayout oldLayout;
		    VkImageLayout newLayout;
		    uint32_t srcQueueFamilyIndex;
		    uint32_t dstQueueFamilyIndex;
		    VkImage image;
		    VkImageSubresourceRange subresourceRange;
		} VkImageMemoryBarrier;

		typedef struct VkMemoryBarrier
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccessFlags srcAccessMask;
		    VkAccessFlags dstAccessMask;
		} VkMemoryBarrier;

		typedef struct VkPipelineCacheHeaderVersionOne
		{
		    uint32_t headerSize;
		    VkPipelineCacheHeaderVersion headerVersion;
		    uint32_t vendorID;
		    uint32_t deviceID;
		    uint8_t pipelineCacheUUID[VK_UUID_SIZE];
		} VkPipelineCacheHeaderVersionOne;

		typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(void* pUserData, size_t size, size_t alignment, VkSystemAllocationScope allocationScope);
		typedef void (VKAPI_PTR *PFN_vkFreeFunction)(void* pUserData, void* pMemory);
		typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope);
		typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope);
		typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(void* pUserData, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope);
		typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

		typedef struct VkAllocationCallbacks
		{
		    void* pUserData;
		    PFN_vkAllocationFunction pfnAllocation;
		    PFN_vkReallocationFunction pfnReallocation;
		    PFN_vkFreeFunction pfnFree;
		    PFN_vkInternalAllocationNotification pfnInternalAllocation;
		    PFN_vkInternalFreeNotification pfnInternalFree;
		} VkAllocationCallbacks;

		typedef struct VkApplicationInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    const char* pApplicationName;
		    uint32_t applicationVersion;
		    const char* pEngineName;
		    uint32_t engineVersion;
		    uint32_t apiVersion;
		} VkApplicationInfo;

		typedef struct VkFormatProperties
		{
		    VkFormatFeatureFlags linearTilingFeatures;
		    VkFormatFeatureFlags optimalTilingFeatures;
		    VkFormatFeatureFlags bufferFeatures;
		} VkFormatProperties;

		typedef struct VkImageFormatProperties
		{
		    VkExtent3D maxExtent;
		    uint32_t maxMipLevels;
		    uint32_t maxArrayLayers;
		    VkSampleCountFlags sampleCounts;
		    VkDeviceSize maxResourceSize;
		} VkImageFormatProperties;

		typedef struct VkInstanceCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkInstanceCreateFlags flags;
		    const VkApplicationInfo* pApplicationInfo;
		    uint32_t enabledLayerCount;
		    const char* const* ppEnabledLayerNames;
		    uint32_t enabledExtensionCount;
		    const char* const* ppEnabledExtensionNames;
		} VkInstanceCreateInfo;

		typedef struct VkMemoryHeap
		{
		    VkDeviceSize size;
		    VkMemoryHeapFlags flags;
		} VkMemoryHeap;

		typedef struct VkMemoryType
		{
		    VkMemoryPropertyFlags propertyFlags;
		    uint32_t heapIndex;
		} VkMemoryType;

		typedef struct VkPhysicalDeviceFeatures
		{
		    VkBool32 robustBufferAccess;
		    VkBool32 fullDrawIndexUint32;
		    VkBool32 imageCubeArray;
		    VkBool32 independentBlend;
		    VkBool32 geometryShader;
		    VkBool32 tessellationShader;
		    VkBool32 sampleRateShading;
		    VkBool32 dualSrcBlend;
		    VkBool32 logicOp;
		    VkBool32 multiDrawIndirect;
		    VkBool32 drawIndirectFirstInstance;
		    VkBool32 depthClamp;
		    VkBool32 depthBiasClamp;
		    VkBool32 fillModeNonSolid;
		    VkBool32 depthBounds;
		    VkBool32 wideLines;
		    VkBool32 largePoints;
		    VkBool32 alphaToOne;
		    VkBool32 multiViewport;
		    VkBool32 samplerAnisotropy;
		    VkBool32 textureCompressionETC2;
		    VkBool32 textureCompressionASTC_LDR;
		    VkBool32 textureCompressionBC;
		    VkBool32 occlusionQueryPrecise;
		    VkBool32 pipelineStatisticsQuery;
		    VkBool32 vertexPipelineStoresAndAtomics;
		    VkBool32 fragmentStoresAndAtomics;
		    VkBool32 shaderTessellationAndGeometryPointSize;
		    VkBool32 shaderImageGatherExtended;
		    VkBool32 shaderStorageImageExtendedFormats;
		    VkBool32 shaderStorageImageMultisample;
		    VkBool32 shaderStorageImageReadWithoutFormat;
		    VkBool32 shaderStorageImageWriteWithoutFormat;
		    VkBool32 shaderUniformBufferArrayDynamicIndexing;
		    VkBool32 shaderSampledImageArrayDynamicIndexing;
		    VkBool32 shaderStorageBufferArrayDynamicIndexing;
		    VkBool32 shaderStorageImageArrayDynamicIndexing;
		    VkBool32 shaderClipDistance;
		    VkBool32 shaderCullDistance;
		    VkBool32 shaderFloat64;
		    VkBool32 shaderInt64;
		    VkBool32 shaderInt16;
		    VkBool32 shaderResourceResidency;
		    VkBool32 shaderResourceMinLod;
		    VkBool32 sparseBinding;
		    VkBool32 sparseResidencyBuffer;
		    VkBool32 sparseResidencyImage2D;
		    VkBool32 sparseResidencyImage3D;
		    VkBool32 sparseResidency2Samples;
		    VkBool32 sparseResidency4Samples;
		    VkBool32 sparseResidency8Samples;
		    VkBool32 sparseResidency16Samples;
		    VkBool32 sparseResidencyAliased;
		    VkBool32 variableMultisampleRate;
		    VkBool32 inheritedQueries;
		} VkPhysicalDeviceFeatures;

		typedef struct VkPhysicalDeviceLimits
		{
		    uint32_t maxImageDimension1D;
		    uint32_t maxImageDimension2D;
		    uint32_t maxImageDimension3D;
		    uint32_t maxImageDimensionCube;
		    uint32_t maxImageArrayLayers;
		    uint32_t maxTexelBufferElements;
		    uint32_t maxUniformBufferRange;
		    uint32_t maxStorageBufferRange;
		    uint32_t maxPushConstantsSize;
		    uint32_t maxMemoryAllocationCount;
		    uint32_t maxSamplerAllocationCount;
		    VkDeviceSize bufferImageGranularity;
		    VkDeviceSize sparseAddressSpaceSize;
		    uint32_t maxBoundDescriptorSets;
		    uint32_t maxPerStageDescriptorSamplers;
		    uint32_t maxPerStageDescriptorUniformBuffers;
		    uint32_t maxPerStageDescriptorStorageBuffers;
		    uint32_t maxPerStageDescriptorSampledImages;
		    uint32_t maxPerStageDescriptorStorageImages;
		    uint32_t maxPerStageDescriptorInputAttachments;
		    uint32_t maxPerStageResources;
		    uint32_t maxDescriptorSetSamplers;
		    uint32_t maxDescriptorSetUniformBuffers;
		    uint32_t maxDescriptorSetUniformBuffersDynamic;
		    uint32_t maxDescriptorSetStorageBuffers;
		    uint32_t maxDescriptorSetStorageBuffersDynamic;
		    uint32_t maxDescriptorSetSampledImages;
		    uint32_t maxDescriptorSetStorageImages;
		    uint32_t maxDescriptorSetInputAttachments;
		    uint32_t maxVertexInputAttributes;
		    uint32_t maxVertexInputBindings;
		    uint32_t maxVertexInputAttributeOffset;
		    uint32_t maxVertexInputBindingStride;
		    uint32_t maxVertexOutputComponents;
		    uint32_t maxTessellationGenerationLevel;
		    uint32_t maxTessellationPatchSize;
		    uint32_t maxTessellationControlPerVertexInputComponents;
		    uint32_t maxTessellationControlPerVertexOutputComponents;
		    uint32_t maxTessellationControlPerPatchOutputComponents;
		    uint32_t maxTessellationControlTotalOutputComponents;
		    uint32_t maxTessellationEvaluationInputComponents;
		    uint32_t maxTessellationEvaluationOutputComponents;
		    uint32_t maxGeometryShaderInvocations;
		    uint32_t maxGeometryInputComponents;
		    uint32_t maxGeometryOutputComponents;
		    uint32_t maxGeometryOutputVertices;
		    uint32_t maxGeometryTotalOutputComponents;
		    uint32_t maxFragmentInputComponents;
		    uint32_t maxFragmentOutputAttachments;
		    uint32_t maxFragmentDualSrcAttachments;
		    uint32_t maxFragmentCombinedOutputResources;
		    uint32_t maxComputeSharedMemorySize;
		    uint32_t maxComputeWorkGroupCount[3];
		    uint32_t maxComputeWorkGroupInvocations;
		    uint32_t maxComputeWorkGroupSize[3];
		    uint32_t subPixelPrecisionBits;
		    uint32_t subTexelPrecisionBits;
		    uint32_t mipmapPrecisionBits;
		    uint32_t maxDrawIndexedIndexValue;
		    uint32_t maxDrawIndirectCount;
		    float maxSamplerLodBias;
		    float maxSamplerAnisotropy;
		    uint32_t maxViewports;
		    uint32_t maxViewportDimensions[2];
		    float viewportBoundsRange[2];
		    uint32_t viewportSubPixelBits;
		    size_t minMemoryMapAlignment;
		    VkDeviceSize minTexelBufferOffsetAlignment;
		    VkDeviceSize minUniformBufferOffsetAlignment;
		    VkDeviceSize minStorageBufferOffsetAlignment;
		    int32_t minTexelOffset;
		    uint32_t maxTexelOffset;
		    int32_t minTexelGatherOffset;
		    uint32_t maxTexelGatherOffset;
		    float minInterpolationOffset;
		    float maxInterpolationOffset;
		    uint32_t subPixelInterpolationOffsetBits;
		    uint32_t maxFramebufferWidth;
		    uint32_t maxFramebufferHeight;
		    uint32_t maxFramebufferLayers;
		    VkSampleCountFlags framebufferColorSampleCounts;
		    VkSampleCountFlags framebufferDepthSampleCounts;
		    VkSampleCountFlags framebufferStencilSampleCounts;
		    VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
		    uint32_t maxColorAttachments;
		    VkSampleCountFlags sampledImageColorSampleCounts;
		    VkSampleCountFlags sampledImageIntegerSampleCounts;
		    VkSampleCountFlags sampledImageDepthSampleCounts;
		    VkSampleCountFlags sampledImageStencilSampleCounts;
		    VkSampleCountFlags storageImageSampleCounts;
		    uint32_t maxSampleMaskWords;
		    VkBool32 timestampComputeAndGraphics;
		    float timestampPeriod;
		    uint32_t maxClipDistances;
		    uint32_t maxCullDistances;
		    uint32_t maxCombinedClipAndCullDistances;
		    uint32_t discreteQueuePriorities;
		    float pointSizeRange[2];
		    float lineWidthRange[2];
		    float pointSizeGranularity;
		    float lineWidthGranularity;
		    VkBool32 strictLines;
		    VkBool32 standardSampleLocations;
		    VkDeviceSize optimalBufferCopyOffsetAlignment;
		    VkDeviceSize optimalBufferCopyRowPitchAlignment;
		    VkDeviceSize nonCoherentAtomSize;
		} VkPhysicalDeviceLimits;

		typedef struct VkPhysicalDeviceMemoryProperties
		{
		    uint32_t memoryTypeCount;
		    VkMemoryType memoryTypes[VK_MAX_MEMORY_TYPES];
		    uint32_t memoryHeapCount;
		    VkMemoryHeap memoryHeaps[VK_MAX_MEMORY_HEAPS];
		} VkPhysicalDeviceMemoryProperties;

		typedef struct VkPhysicalDeviceSparseProperties
		{
		    VkBool32 residencyStandard2DBlockShape;
		    VkBool32 residencyStandard2DMultisampleBlockShape;
		    VkBool32 residencyStandard3DBlockShape;
		    VkBool32 residencyAlignedMipSize;
		    VkBool32 residencyNonResidentStrict;
		} VkPhysicalDeviceSparseProperties;

		typedef struct VkPhysicalDeviceProperties
		{
		    uint32_t apiVersion;
		    uint32_t driverVersion;
		    uint32_t vendorID;
		    uint32_t deviceID;
		    VkPhysicalDeviceType deviceType;
		    char deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
		    uint8_t pipelineCacheUUID[VK_UUID_SIZE];
		    VkPhysicalDeviceLimits limits;
		    VkPhysicalDeviceSparseProperties sparseProperties;
		} VkPhysicalDeviceProperties;

		typedef struct VkQueueFamilyProperties
		{
		    VkQueueFlags queueFlags;
		    uint32_t queueCount;
		    uint32_t timestampValidBits;
		    VkExtent3D minImageTransferGranularity;
		} VkQueueFamilyProperties;

		typedef struct VkDeviceQueueCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceQueueCreateFlags flags;
		    uint32_t queueFamilyIndex;
		    uint32_t queueCount;
		    const float* pQueuePriorities;
		} VkDeviceQueueCreateInfo;

		typedef struct VkDeviceCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceCreateFlags flags;
		    uint32_t queueCreateInfoCount;
		    const VkDeviceQueueCreateInfo* pQueueCreateInfos;
		    uint32_t enabledLayerCount;
		    const char* const* ppEnabledLayerNames;
		    uint32_t enabledExtensionCount;
		    const char* const* ppEnabledExtensionNames;
		    const VkPhysicalDeviceFeatures* pEnabledFeatures;
		} VkDeviceCreateInfo;

		typedef struct VkExtensionProperties
		{
		    char extensionName[VK_MAX_EXTENSION_NAME_SIZE];
		    uint32_t specVersion;
		} VkExtensionProperties;

		typedef struct VkLayerProperties
		{
		    char layerName[VK_MAX_EXTENSION_NAME_SIZE];
		    uint32_t specVersion;
		    uint32_t implementationVersion;
		    char description[VK_MAX_DESCRIPTION_SIZE];
		} VkLayerProperties;

		typedef struct VkSubmitInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t waitSemaphoreCount;
		    const VkSemaphore* pWaitSemaphores;
		    const VkPipelineStageFlags* pWaitDstStageMask;
		    uint32_t commandBufferCount;
		    const VkCommandBuffer* pCommandBuffers;
		    uint32_t signalSemaphoreCount;
		    const VkSemaphore* pSignalSemaphores;
		} VkSubmitInfo;

		typedef struct VkMappedMemoryRange
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		    VkDeviceSize offset;
		    VkDeviceSize size;
		} VkMappedMemoryRange;

		typedef struct VkMemoryAllocateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize allocationSize;
		    uint32_t memoryTypeIndex;
		} VkMemoryAllocateInfo;

		typedef struct VkMemoryRequirements
		{
		    VkDeviceSize size;
		    VkDeviceSize alignment;
		    uint32_t memoryTypeBits;
		} VkMemoryRequirements;

		typedef struct VkSparseMemoryBind
		{
		    VkDeviceSize resourceOffset;
		    VkDeviceSize size;
		    VkDeviceMemory memory;
		    VkDeviceSize memoryOffset;
		    VkSparseMemoryBindFlags flags;
		} VkSparseMemoryBind;

		typedef struct VkSparseBufferMemoryBindInfo
		{
		    VkBuffer buffer;
		    uint32_t bindCount;
		    const VkSparseMemoryBind* pBinds;
		} VkSparseBufferMemoryBindInfo;

		typedef struct VkSparseImageOpaqueMemoryBindInfo
		{
		    VkImage image;
		    uint32_t bindCount;
		    const VkSparseMemoryBind* pBinds;
		} VkSparseImageOpaqueMemoryBindInfo;

		typedef struct VkImageSubresource
		{
		    VkImageAspectFlags aspectMask;
		    uint32_t mipLevel;
		    uint32_t arrayLayer;
		} VkImageSubresource;

		typedef struct VkSparseImageMemoryBind
		{
		    VkImageSubresource subresource;
		    VkOffset3D offset;
		    VkExtent3D extent;
		    VkDeviceMemory memory;
		    VkDeviceSize memoryOffset;
		    VkSparseMemoryBindFlags flags;
		} VkSparseImageMemoryBind;

		typedef struct VkSparseImageMemoryBindInfo
		{
		    VkImage image;
		    uint32_t bindCount;
		    const VkSparseImageMemoryBind* pBinds;
		} VkSparseImageMemoryBindInfo;

		typedef struct VkBindSparseInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t waitSemaphoreCount;
		    const VkSemaphore* pWaitSemaphores;
		    uint32_t bufferBindCount;
		    const VkSparseBufferMemoryBindInfo* pBufferBinds;
		    uint32_t imageOpaqueBindCount;
		    const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds;
		    uint32_t imageBindCount;
		    const VkSparseImageMemoryBindInfo* pImageBinds;
		    uint32_t signalSemaphoreCount;
		    const VkSemaphore* pSignalSemaphores;
		} VkBindSparseInfo;

		typedef struct VkSparseImageFormatProperties
		{
		    VkImageAspectFlags aspectMask;
		    VkExtent3D imageGranularity;
		    VkSparseImageFormatFlags flags;
		} VkSparseImageFormatProperties;

		typedef struct VkSparseImageMemoryRequirements
		{
		    VkSparseImageFormatProperties formatProperties;
		    uint32_t imageMipTailFirstLod;
		    VkDeviceSize imageMipTailSize;
		    VkDeviceSize imageMipTailOffset;
		    VkDeviceSize imageMipTailStride;
		} VkSparseImageMemoryRequirements;

		typedef struct VkFenceCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFenceCreateFlags flags;
		} VkFenceCreateInfo;

		typedef struct VkSemaphoreCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphoreCreateFlags flags;
		} VkSemaphoreCreateInfo;

		typedef struct VkEventCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkEventCreateFlags flags;
		} VkEventCreateInfo;

		typedef struct VkQueryPoolCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkQueryPoolCreateFlags flags;
		    VkQueryType queryType;
		    uint32_t queryCount;
		    VkQueryPipelineStatisticFlags pipelineStatistics;
		} VkQueryPoolCreateInfo;

		typedef struct VkBufferCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferCreateFlags flags;
		    VkDeviceSize size;
		    VkBufferUsageFlags usage;
		    VkSharingMode sharingMode;
		    uint32_t queueFamilyIndexCount;
		    const uint32_t* pQueueFamilyIndices;
		} VkBufferCreateInfo;

		typedef struct VkBufferViewCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferViewCreateFlags flags;
		    VkBuffer buffer;
		    VkFormat format;
		    VkDeviceSize offset;
		    VkDeviceSize range;
		} VkBufferViewCreateInfo;

		typedef struct VkImageCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageCreateFlags flags;
		    VkImageType imageType;
		    VkFormat format;
		    VkExtent3D extent;
		    uint32_t mipLevels;
		    uint32_t arrayLayers;
		    VkSampleCountFlagBits samples;
		    VkImageTiling tiling;
		    VkImageUsageFlags usage;
		    VkSharingMode sharingMode;
		    uint32_t queueFamilyIndexCount;
		    const uint32_t* pQueueFamilyIndices;
		    VkImageLayout initialLayout;
		} VkImageCreateInfo;

		typedef struct VkSubresourceLayout
		{
		    VkDeviceSize offset;
		    VkDeviceSize size;
		    VkDeviceSize rowPitch;
		    VkDeviceSize arrayPitch;
		    VkDeviceSize depthPitch;
		} VkSubresourceLayout;

		typedef struct VkComponentMapping
		{
		    VkComponentSwizzle r;
		    VkComponentSwizzle g;
		    VkComponentSwizzle b;
		    VkComponentSwizzle a;
		} VkComponentMapping;

		typedef struct VkImageViewCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageViewCreateFlags flags;
		    VkImage image;
		    VkImageViewType viewType;
		    VkFormat format;
		    VkComponentMapping components;
		    VkImageSubresourceRange subresourceRange;
		} VkImageViewCreateInfo;

		typedef struct VkShaderModuleCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkShaderModuleCreateFlags flags;
		    size_t codeSize;
		    const uint32_t* pCode;
		} VkShaderModuleCreateInfo;

		typedef struct VkPipelineCacheCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCacheCreateFlags flags;
		    size_t initialDataSize;
		    const void* pInitialData;
		} VkPipelineCacheCreateInfo;

		typedef struct VkSpecializationMapEntry
		{
		    uint32_t constantID;
		    uint32_t offset;
		    size_t size;
		} VkSpecializationMapEntry;

		typedef struct VkSpecializationInfo
		{
		    uint32_t mapEntryCount;
		    const VkSpecializationMapEntry* pMapEntries;
		    size_t dataSize;
		    const void* pData;
		} VkSpecializationInfo;

		typedef struct VkPipelineShaderStageCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineShaderStageCreateFlags flags;
		    VkShaderStageFlagBits stage;
		    VkShaderModule module;
		    const char* pName;
		    const VkSpecializationInfo* pSpecializationInfo;
		} VkPipelineShaderStageCreateInfo;

		typedef struct VkComputePipelineCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCreateFlags flags;
		    VkPipelineShaderStageCreateInfo stage;
		    VkPipelineLayout layout;
		    VkPipeline basePipelineHandle;
		    int32_t basePipelineIndex;
		} VkComputePipelineCreateInfo;

		typedef struct VkVertexInputBindingDescription
		{
		    uint32_t binding;
		    uint32_t stride;
		    VkVertexInputRate inputRate;
		} VkVertexInputBindingDescription;

		typedef struct VkVertexInputAttributeDescription
		{
		    uint32_t location;
		    uint32_t binding;
		    VkFormat format;
		    uint32_t offset;
		} VkVertexInputAttributeDescription;

		typedef struct VkPipelineVertexInputStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineVertexInputStateCreateFlags flags;
		    uint32_t vertexBindingDescriptionCount;
		    const VkVertexInputBindingDescription* pVertexBindingDescriptions;
		    uint32_t vertexAttributeDescriptionCount;
		    const VkVertexInputAttributeDescription* pVertexAttributeDescriptions;
		} VkPipelineVertexInputStateCreateInfo;

		typedef struct VkPipelineInputAssemblyStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineInputAssemblyStateCreateFlags flags;
		    VkPrimitiveTopology topology;
		    VkBool32 primitiveRestartEnable;
		} VkPipelineInputAssemblyStateCreateInfo;

		typedef struct VkPipelineTessellationStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineTessellationStateCreateFlags flags;
		    uint32_t patchControlPoints;
		} VkPipelineTessellationStateCreateInfo;

		typedef struct VkViewport
		{
		    float x;
		    float y;
		    float width;
		    float height;
		    float minDepth;
		    float maxDepth;
		} VkViewport;

		typedef struct VkPipelineViewportStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineViewportStateCreateFlags flags;
		    uint32_t viewportCount;
		    const VkViewport* pViewports;
		    uint32_t scissorCount;
		    const VkRect2D* pScissors;
		} VkPipelineViewportStateCreateInfo;

		typedef struct VkPipelineRasterizationStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineRasterizationStateCreateFlags flags;
		    VkBool32 depthClampEnable;
		    VkBool32 rasterizerDiscardEnable;
		    VkPolygonMode polygonMode;
		    VkCullModeFlags cullMode;
		    VkFrontFace frontFace;
		    VkBool32 depthBiasEnable;
		    float depthBiasConstantFactor;
		    float depthBiasClamp;
		    float depthBiasSlopeFactor;
		    float lineWidth;
		} VkPipelineRasterizationStateCreateInfo;

		typedef struct VkPipelineMultisampleStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineMultisampleStateCreateFlags flags;
		    VkSampleCountFlagBits rasterizationSamples;
		    VkBool32 sampleShadingEnable;
		    float minSampleShading;
		    const VkSampleMask* pSampleMask;
		    VkBool32 alphaToCoverageEnable;
		    VkBool32 alphaToOneEnable;
		} VkPipelineMultisampleStateCreateInfo;

		typedef struct VkStencilOpState
		{
		    VkStencilOp failOp;
		    VkStencilOp passOp;
		    VkStencilOp depthFailOp;
		    VkCompareOp compareOp;
		    uint32_t compareMask;
		    uint32_t writeMask;
		    uint32_t reference;
		} VkStencilOpState;

		typedef struct VkPipelineDepthStencilStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineDepthStencilStateCreateFlags flags;
		    VkBool32 depthTestEnable;
		    VkBool32 depthWriteEnable;
		    VkCompareOp depthCompareOp;
		    VkBool32 depthBoundsTestEnable;
		    VkBool32 stencilTestEnable;
		    VkStencilOpState front;
		    VkStencilOpState back;
		    float minDepthBounds;
		    float maxDepthBounds;
		} VkPipelineDepthStencilStateCreateInfo;

		typedef struct VkPipelineColorBlendAttachmentState
		{
		    VkBool32 blendEnable;
		    VkBlendFactor srcColorBlendFactor;
		    VkBlendFactor dstColorBlendFactor;
		    VkBlendOp colorBlendOp;
		    VkBlendFactor srcAlphaBlendFactor;
		    VkBlendFactor dstAlphaBlendFactor;
		    VkBlendOp alphaBlendOp;
		    VkColorComponentFlags colorWriteMask;
		} VkPipelineColorBlendAttachmentState;

		typedef struct VkPipelineColorBlendStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineColorBlendStateCreateFlags flags;
		    VkBool32 logicOpEnable;
		    VkLogicOp logicOp;
		    uint32_t attachmentCount;
		    const VkPipelineColorBlendAttachmentState* pAttachments;
		    float blendConstants[4];
		} VkPipelineColorBlendStateCreateInfo;

		typedef struct VkPipelineDynamicStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineDynamicStateCreateFlags flags;
		    uint32_t dynamicStateCount;
		    const VkDynamicState* pDynamicStates;
		} VkPipelineDynamicStateCreateInfo;

		typedef struct VkGraphicsPipelineCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCreateFlags flags;
		    uint32_t stageCount;
		    const VkPipelineShaderStageCreateInfo* pStages;
		    const VkPipelineVertexInputStateCreateInfo* pVertexInputState;
		    const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState;
		    const VkPipelineTessellationStateCreateInfo* pTessellationState;
		    const VkPipelineViewportStateCreateInfo* pViewportState;
		    const VkPipelineRasterizationStateCreateInfo* pRasterizationState;
		    const VkPipelineMultisampleStateCreateInfo* pMultisampleState;
		    const VkPipelineDepthStencilStateCreateInfo* pDepthStencilState;
		    const VkPipelineColorBlendStateCreateInfo* pColorBlendState;
		    const VkPipelineDynamicStateCreateInfo* pDynamicState;
		    VkPipelineLayout layout;
		    VkRenderPass renderPass;
		    uint32_t subpass;
		    VkPipeline basePipelineHandle;
		    int32_t basePipelineIndex;
		} VkGraphicsPipelineCreateInfo;

		typedef struct VkPushConstantRange
		{
		    VkShaderStageFlags stageFlags;
		    uint32_t offset;
		    uint32_t size;
		} VkPushConstantRange;

		typedef struct VkPipelineLayoutCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineLayoutCreateFlags flags;
		    uint32_t setLayoutCount;
		    const VkDescriptorSetLayout* pSetLayouts;
		    uint32_t pushConstantRangeCount;
		    const VkPushConstantRange* pPushConstantRanges;
		} VkPipelineLayoutCreateInfo;

		typedef struct VkSamplerCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSamplerCreateFlags flags;
		    VkFilter magFilter;
		    VkFilter minFilter;
		    VkSamplerMipmapMode mipmapMode;
		    VkSamplerAddressMode addressModeU;
		    VkSamplerAddressMode addressModeV;
		    VkSamplerAddressMode addressModeW;
		    float mipLodBias;
		    VkBool32 anisotropyEnable;
		    float maxAnisotropy;
		    VkBool32 compareEnable;
		    VkCompareOp compareOp;
		    float minLod;
		    float maxLod;
		    VkBorderColor borderColor;
		    VkBool32 unnormalizedCoordinates;
		} VkSamplerCreateInfo;

		typedef struct VkCopyDescriptorSet
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorSet srcSet;
		    uint32_t srcBinding;
		    uint32_t srcArrayElement;
		    VkDescriptorSet dstSet;
		    uint32_t dstBinding;
		    uint32_t dstArrayElement;
		    uint32_t descriptorCount;
		} VkCopyDescriptorSet;

		typedef struct VkDescriptorBufferInfo
		{
		    VkBuffer buffer;
		    VkDeviceSize offset;
		    VkDeviceSize range;
		} VkDescriptorBufferInfo;

		typedef struct VkDescriptorImageInfo
		{
		    VkSampler sampler;
		    VkImageView imageView;
		    VkImageLayout imageLayout;
		} VkDescriptorImageInfo;

		typedef struct VkDescriptorPoolSize
		{
		    VkDescriptorType type;
		    uint32_t descriptorCount;
		} VkDescriptorPoolSize;

		typedef struct VkDescriptorPoolCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorPoolCreateFlags flags;
		    uint32_t maxSets;
		    uint32_t poolSizeCount;
		    const VkDescriptorPoolSize* pPoolSizes;
		} VkDescriptorPoolCreateInfo;

		typedef struct VkDescriptorSetAllocateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorPool descriptorPool;
		    uint32_t descriptorSetCount;
		    const VkDescriptorSetLayout* pSetLayouts;
		} VkDescriptorSetAllocateInfo;

		typedef struct VkDescriptorSetLayoutBinding
		{
		    uint32_t binding;
		    VkDescriptorType descriptorType;
		    uint32_t descriptorCount;
		    VkShaderStageFlags stageFlags;
		    const VkSampler* pImmutableSamplers;
		} VkDescriptorSetLayoutBinding;

		typedef struct VkDescriptorSetLayoutCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorSetLayoutCreateFlags flags;
		    uint32_t bindingCount;
		    const VkDescriptorSetLayoutBinding* pBindings;
		} VkDescriptorSetLayoutCreateInfo;

		typedef struct VkWriteDescriptorSet
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorSet dstSet;
		    uint32_t dstBinding;
		    uint32_t dstArrayElement;
		    uint32_t descriptorCount;
		    VkDescriptorType descriptorType;
		    const VkDescriptorImageInfo* pImageInfo;
		    const VkDescriptorBufferInfo* pBufferInfo;
		    const VkBufferView* pTexelBufferView;
		} VkWriteDescriptorSet;

		typedef struct VkAttachmentDescription
		{
		    VkAttachmentDescriptionFlags flags;
		    VkFormat format;
		    VkSampleCountFlagBits samples;
		    VkAttachmentLoadOp loadOp;
		    VkAttachmentStoreOp storeOp;
		    VkAttachmentLoadOp stencilLoadOp;
		    VkAttachmentStoreOp stencilStoreOp;
		    VkImageLayout initialLayout;
		    VkImageLayout finalLayout;
		} VkAttachmentDescription;

		typedef struct VkAttachmentReference
		{
		    uint32_t attachment;
		    VkImageLayout layout;
		} VkAttachmentReference;

		typedef struct VkFramebufferCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFramebufferCreateFlags flags;
		    VkRenderPass renderPass;
		    uint32_t attachmentCount;
		    const VkImageView* pAttachments;
		    uint32_t width;
		    uint32_t height;
		    uint32_t layers;
		} VkFramebufferCreateInfo;

		typedef struct VkSubpassDescription
		{
		    VkSubpassDescriptionFlags flags;
		    VkPipelineBindPoint pipelineBindPoint;
		    uint32_t inputAttachmentCount;
		    const VkAttachmentReference* pInputAttachments;
		    uint32_t colorAttachmentCount;
		    const VkAttachmentReference* pColorAttachments;
		    const VkAttachmentReference* pResolveAttachments;
		    const VkAttachmentReference* pDepthStencilAttachment;
		    uint32_t preserveAttachmentCount;
		    const uint32_t* pPreserveAttachments;
		} VkSubpassDescription;

		typedef struct VkSubpassDependency
		{
		    uint32_t srcSubpass;
		    uint32_t dstSubpass;
		    VkPipelineStageFlags srcStageMask;
		    VkPipelineStageFlags dstStageMask;
		    VkAccessFlags srcAccessMask;
		    VkAccessFlags dstAccessMask;
		    VkDependencyFlags dependencyFlags;
		} VkSubpassDependency;

		typedef struct VkRenderPassCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderPassCreateFlags flags;
		    uint32_t attachmentCount;
		    const VkAttachmentDescription* pAttachments;
		    uint32_t subpassCount;
		    const VkSubpassDescription* pSubpasses;
		    uint32_t dependencyCount;
		    const VkSubpassDependency* pDependencies;
		} VkRenderPassCreateInfo;

		typedef struct VkCommandPoolCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCommandPoolCreateFlags flags;
		    uint32_t queueFamilyIndex;
		} VkCommandPoolCreateInfo;

		typedef struct VkCommandBufferAllocateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCommandPool commandPool;
		    VkCommandBufferLevel level;
		    uint32_t commandBufferCount;
		} VkCommandBufferAllocateInfo;

		typedef struct VkCommandBufferInheritanceInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderPass renderPass;
		    uint32_t subpass;
		    VkFramebuffer framebuffer;
		    VkBool32 occlusionQueryEnable;
		    VkQueryControlFlags queryFlags;
		    VkQueryPipelineStatisticFlags pipelineStatistics;
		} VkCommandBufferInheritanceInfo;

		typedef struct VkCommandBufferBeginInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCommandBufferUsageFlags flags;
		    const VkCommandBufferInheritanceInfo* pInheritanceInfo;
		} VkCommandBufferBeginInfo;

		typedef struct VkBufferCopy
		{
		    VkDeviceSize srcOffset;
		    VkDeviceSize dstOffset;
		    VkDeviceSize size;
		} VkBufferCopy;

		typedef struct VkImageSubresourceLayers
		{
		    VkImageAspectFlags aspectMask;
		    uint32_t mipLevel;
		    uint32_t baseArrayLayer;
		    uint32_t layerCount;
		} VkImageSubresourceLayers;

		typedef struct VkBufferImageCopy
		{
		    VkDeviceSize bufferOffset;
		    uint32_t bufferRowLength;
		    uint32_t bufferImageHeight;
		    VkImageSubresourceLayers imageSubresource;
		    VkOffset3D imageOffset;
		    VkExtent3D imageExtent;
		} VkBufferImageCopy;

		typedef union VkClearColorValue
		{
		    float float32[4];
		    int32_t int32[4];
		    uint32_t uint32[4];
		} VkClearColorValue;

		typedef struct VkClearDepthStencilValue
		{
		    float depth;
		    uint32_t stencil;
		} VkClearDepthStencilValue;

		typedef union VkClearValue
		{
		    VkClearColorValue color;
		    VkClearDepthStencilValue depthStencil;
		} VkClearValue;

		typedef struct VkClearAttachment
		{
		    VkImageAspectFlags aspectMask;
		    uint32_t colorAttachment;
		    VkClearValue clearValue;
		} VkClearAttachment;

		typedef struct VkClearRect
		{
		    VkRect2D rect;
		    uint32_t baseArrayLayer;
		    uint32_t layerCount;
		} VkClearRect;

		typedef struct VkImageBlit
		{
		    VkImageSubresourceLayers srcSubresource;
		    VkOffset3D srcOffsets[2];
		    VkImageSubresourceLayers dstSubresource;
		    VkOffset3D dstOffsets[2];
		} VkImageBlit;

		typedef struct VkImageCopy
		{
		    VkImageSubresourceLayers srcSubresource;
		    VkOffset3D srcOffset;
		    VkImageSubresourceLayers dstSubresource;
		    VkOffset3D dstOffset;
		    VkExtent3D extent;
		} VkImageCopy;

		typedef struct VkImageResolve
		{
		    VkImageSubresourceLayers srcSubresource;
		    VkOffset3D srcOffset;
		    VkImageSubresourceLayers dstSubresource;
		    VkOffset3D dstOffset;
		    VkExtent3D extent;
		} VkImageResolve;

		typedef struct VkRenderPassBeginInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderPass renderPass;
		    VkFramebuffer framebuffer;
		    VkRect2D renderArea;
		    uint32_t clearValueCount;
		    const VkClearValue* pClearValues;
		} VkRenderPassBeginInfo;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
		typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
		typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
		typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, const char* pName);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
		typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
		typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence);
		typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
		typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
		typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
		typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
		typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
		typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
		typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
		typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
		typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
		typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
		typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences);
		typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
		typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
		typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
		typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
		typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
		typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
		typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
		typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView);
		typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage);
		typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView);
		typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
		typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
		typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
		typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
		typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
		typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
		typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
		typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
		typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
		typedef VkResult (VKAPI_PTR *PFN_vkAllocateDescriptorSets)(VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets);
		typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets);
		typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
		typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
		typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
		typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
		typedef VkResult (VKAPI_PTR *PFN_vkAllocateCommandBuffers)(VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers);
		typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);
		typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
		typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
		typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
		typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports);
		typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors);
		typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
		typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, const float blendConstants[4]);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
		typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
		typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
		typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
		typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);
		typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
		typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets);
		typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
		typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions);
		typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions);
		typedef void (VKAPI_PTR *PFN_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData);
		typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
		typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
		typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges);
		typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects);
		typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions);
		typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
		typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
		typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
		typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
		typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
		typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
		typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
		typedef void (VKAPI_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
		typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
		typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
		typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers);

		#define VK_VERSION_1_1 1

		#define VK_API_VERSION_1_1 VK_MAKE_API_VERSION(0, 1, 1, 0)

		#define VK_MAX_DEVICE_GROUP_SIZE 32
		#define VK_LUID_SIZE 8
		#define VK_QUEUE_FAMILY_EXTERNAL (~1U)

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSamplerYcbcrConversion)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)


		typedef enum
		{
		    VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
		    VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
		    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
		    VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
		    VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
		    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
		    VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
		    VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
		    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
		    VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR = 0x00000200,
		    VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR = 0x00000400,
		    VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSubgroupFeatureFlagBits;
		typedef VkFlags VkSubgroupFeatureFlags;

		typedef enum
		{
		    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
		    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
		    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
		    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
		    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
		    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
		    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
		    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
		    VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPeerMemoryFeatureFlagBits;
		typedef VkFlags VkPeerMemoryFeatureFlags;

		typedef enum
		{
		    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
		    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x00000002,
		    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x00000004,
		    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
		    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
		    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
		    VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkMemoryAllocateFlagBits;
		typedef VkFlags VkMemoryAllocateFlags;
		typedef VkFlags VkCommandPoolTrimFlags;
		typedef enum
		{
		    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
		    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
		    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
		    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
		    VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF
		} VkPointClippingBehavior;

		typedef enum
		{
		    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
		    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
		    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
		    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
		    VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF
		} VkTessellationDomainOrigin;

		typedef enum
		{
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
		    VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF
		} VkSamplerYcbcrModelConversion;

		typedef enum
		{
		    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
		    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
		    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
		    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
		    VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF
		} VkSamplerYcbcrRange;

		typedef enum
		{
		    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
		    VK_CHROMA_LOCATION_MIDPOINT = 1,
		    VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
		    VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT,
		    VK_CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF
		} VkChromaLocation;

		typedef VkFlags VkDescriptorUpdateTemplateCreateFlags;
		typedef enum
		{
		    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
		    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
		    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
		    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkDescriptorUpdateTemplateType;


		typedef enum
		{
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x00000800,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x00001000,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV = 0x00002000,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x00004000,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkExternalMemoryHandleTypeFlagBits;
		typedef VkFlags VkExternalMemoryHandleTypeFlags;

		typedef enum
		{
		    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
		    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
		    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
		    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
		    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
		    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
		    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkExternalMemoryFeatureFlagBits;
		typedef VkFlags VkExternalMemoryFeatureFlags;

		typedef enum
		{
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = 0x00000010,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV = 0x00000020,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
		    VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkExternalFenceHandleTypeFlagBits;
		typedef VkFlags VkExternalFenceHandleTypeFlags;

		typedef enum
		{
		    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
		    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
		    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
		    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
		    VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkExternalFenceFeatureFlagBits;
		typedef VkFlags VkExternalFenceFeatureFlags;

		typedef enum
		{
		    VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
		    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT,
		    VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkFenceImportFlagBits;
		typedef VkFlags VkFenceImportFlags;

		typedef enum
		{
		    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
		    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
		    VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSemaphoreImportFlagBits;
		typedef VkFlags VkSemaphoreImportFlags;

		typedef enum
		{
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x00000080,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = 0x00000020,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
		    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkExternalSemaphoreHandleTypeFlagBits;
		typedef VkFlags VkExternalSemaphoreHandleTypeFlags;

		typedef enum
		{
		    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
		    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
		    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
		    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
		    VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkExternalSemaphoreFeatureFlagBits;
		typedef VkFlags VkExternalSemaphoreFeatureFlags;

		typedef struct VkPhysicalDeviceSubgroupProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t subgroupSize;
		    VkShaderStageFlags supportedStages;
		    VkSubgroupFeatureFlags supportedOperations;
		    VkBool32 quadOperationsInAllStages;
		} VkPhysicalDeviceSubgroupProperties;

		typedef struct VkBindBufferMemoryInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer buffer;
		    VkDeviceMemory memory;
		    VkDeviceSize memoryOffset;
		} VkBindBufferMemoryInfo;

		typedef struct VkBindImageMemoryInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		    VkDeviceMemory memory;
		    VkDeviceSize memoryOffset;
		} VkBindImageMemoryInfo;

		typedef struct VkPhysicalDevice16BitStorageFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 storageBuffer16BitAccess;
		    VkBool32 uniformAndStorageBuffer16BitAccess;
		    VkBool32 storagePushConstant16;
		    VkBool32 storageInputOutput16;
		} VkPhysicalDevice16BitStorageFeatures;

		typedef struct VkMemoryDedicatedRequirements
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 prefersDedicatedAllocation;
		    VkBool32 requiresDedicatedAllocation;
		} VkMemoryDedicatedRequirements;

		typedef struct VkMemoryDedicatedAllocateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		    VkBuffer buffer;
		} VkMemoryDedicatedAllocateInfo;

		typedef struct VkMemoryAllocateFlagsInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMemoryAllocateFlags flags;
		    uint32_t deviceMask;
		} VkMemoryAllocateFlagsInfo;

		typedef struct VkDeviceGroupRenderPassBeginInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t deviceMask;
		    uint32_t deviceRenderAreaCount;
		    const VkRect2D* pDeviceRenderAreas;
		} VkDeviceGroupRenderPassBeginInfo;

		typedef struct VkDeviceGroupCommandBufferBeginInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t deviceMask;
		} VkDeviceGroupCommandBufferBeginInfo;

		typedef struct VkDeviceGroupSubmitInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t waitSemaphoreCount;
		    const uint32_t* pWaitSemaphoreDeviceIndices;
		    uint32_t commandBufferCount;
		    const uint32_t* pCommandBufferDeviceMasks;
		    uint32_t signalSemaphoreCount;
		    const uint32_t* pSignalSemaphoreDeviceIndices;
		} VkDeviceGroupSubmitInfo;

		typedef struct VkDeviceGroupBindSparseInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t resourceDeviceIndex;
		    uint32_t memoryDeviceIndex;
		} VkDeviceGroupBindSparseInfo;

		typedef struct VkBindBufferMemoryDeviceGroupInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t deviceIndexCount;
		    const uint32_t* pDeviceIndices;
		} VkBindBufferMemoryDeviceGroupInfo;

		typedef struct VkBindImageMemoryDeviceGroupInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t deviceIndexCount;
		    const uint32_t* pDeviceIndices;
		    uint32_t splitInstanceBindRegionCount;
		    const VkRect2D* pSplitInstanceBindRegions;
		} VkBindImageMemoryDeviceGroupInfo;

		typedef struct VkPhysicalDeviceGroupProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t physicalDeviceCount;
		    VkPhysicalDevice physicalDevices[VK_MAX_DEVICE_GROUP_SIZE];
		    VkBool32 subsetAllocation;
		} VkPhysicalDeviceGroupProperties;

		typedef struct VkDeviceGroupDeviceCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t physicalDeviceCount;
		    const VkPhysicalDevice* pPhysicalDevices;
		} VkDeviceGroupDeviceCreateInfo;

		typedef struct VkBufferMemoryRequirementsInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer buffer;
		} VkBufferMemoryRequirementsInfo2;

		typedef struct VkImageMemoryRequirementsInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		} VkImageMemoryRequirementsInfo2;

		typedef struct VkImageSparseMemoryRequirementsInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		} VkImageSparseMemoryRequirementsInfo2;

		typedef struct VkMemoryRequirements2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkMemoryRequirements memoryRequirements;
		} VkMemoryRequirements2;

		typedef struct VkSparseImageMemoryRequirements2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSparseImageMemoryRequirements memoryRequirements;
		} VkSparseImageMemoryRequirements2;

		typedef struct VkPhysicalDeviceFeatures2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPhysicalDeviceFeatures features;
		} VkPhysicalDeviceFeatures2;

		typedef struct VkPhysicalDeviceProperties2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPhysicalDeviceProperties properties;
		} VkPhysicalDeviceProperties2;

		typedef struct VkFormatProperties2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormatProperties formatProperties;
		} VkFormatProperties2;

		typedef struct VkImageFormatProperties2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkImageFormatProperties imageFormatProperties;
		} VkImageFormatProperties2;

		typedef struct VkPhysicalDeviceImageFormatInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFormat format;
		    VkImageType type;
		    VkImageTiling tiling;
		    VkImageUsageFlags usage;
		    VkImageCreateFlags flags;
		} VkPhysicalDeviceImageFormatInfo2;

		typedef struct VkQueueFamilyProperties2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkQueueFamilyProperties queueFamilyProperties;
		} VkQueueFamilyProperties2;

		typedef struct VkPhysicalDeviceMemoryProperties2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPhysicalDeviceMemoryProperties memoryProperties;
		} VkPhysicalDeviceMemoryProperties2;

		typedef struct VkSparseImageFormatProperties2
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSparseImageFormatProperties properties;
		} VkSparseImageFormatProperties2;

		typedef struct VkPhysicalDeviceSparseImageFormatInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFormat format;
		    VkImageType type;
		    VkSampleCountFlagBits samples;
		    VkImageUsageFlags usage;
		    VkImageTiling tiling;
		} VkPhysicalDeviceSparseImageFormatInfo2;

		typedef struct VkPhysicalDevicePointClippingProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPointClippingBehavior pointClippingBehavior;
		} VkPhysicalDevicePointClippingProperties;

		typedef struct VkInputAttachmentAspectReference
		{
		    uint32_t subpass;
		    uint32_t inputAttachmentIndex;
		    VkImageAspectFlags aspectMask;
		} VkInputAttachmentAspectReference;

		typedef struct VkRenderPassInputAttachmentAspectCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t aspectReferenceCount;
		    const VkInputAttachmentAspectReference* pAspectReferences;
		} VkRenderPassInputAttachmentAspectCreateInfo;

		typedef struct VkImageViewUsageCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageUsageFlags usage;
		} VkImageViewUsageCreateInfo;

		typedef struct VkPipelineTessellationDomainOriginStateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkTessellationDomainOrigin domainOrigin;
		} VkPipelineTessellationDomainOriginStateCreateInfo;

		typedef struct VkRenderPassMultiviewCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t subpassCount;
		    const uint32_t* pViewMasks;
		    uint32_t dependencyCount;
		    const int32_t* pViewOffsets;
		    uint32_t correlationMaskCount;
		    const uint32_t* pCorrelationMasks;
		} VkRenderPassMultiviewCreateInfo;

		typedef struct VkPhysicalDeviceMultiviewFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 multiview;
		    VkBool32 multiviewGeometryShader;
		    VkBool32 multiviewTessellationShader;
		} VkPhysicalDeviceMultiviewFeatures;

		typedef struct VkPhysicalDeviceMultiviewProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxMultiviewViewCount;
		    uint32_t maxMultiviewInstanceIndex;
		} VkPhysicalDeviceMultiviewProperties;

		typedef struct VkPhysicalDeviceVariablePointersFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 variablePointersStorageBuffer;
		    VkBool32 variablePointers;
		} VkPhysicalDeviceVariablePointersFeatures;

		typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointerFeatures;

		typedef struct VkPhysicalDeviceProtectedMemoryFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 protectedMemory;
		} VkPhysicalDeviceProtectedMemoryFeatures;

		typedef struct VkPhysicalDeviceProtectedMemoryProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 protectedNoFault;
		} VkPhysicalDeviceProtectedMemoryProperties;

		typedef struct VkDeviceQueueInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceQueueCreateFlags flags;
		    uint32_t queueFamilyIndex;
		    uint32_t queueIndex;
		} VkDeviceQueueInfo2;

		typedef struct VkProtectedSubmitInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 protectedSubmit;
		} VkProtectedSubmitInfo;

		typedef struct VkSamplerYcbcrConversionCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFormat format;
		    VkSamplerYcbcrModelConversion ycbcrModel;
		    VkSamplerYcbcrRange ycbcrRange;
		    VkComponentMapping components;
		    VkChromaLocation xChromaOffset;
		    VkChromaLocation yChromaOffset;
		    VkFilter chromaFilter;
		    VkBool32 forceExplicitReconstruction;
		} VkSamplerYcbcrConversionCreateInfo;

		typedef struct VkSamplerYcbcrConversionInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSamplerYcbcrConversion conversion;
		} VkSamplerYcbcrConversionInfo;

		typedef struct VkBindImagePlaneMemoryInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageAspectFlagBits planeAspect;
		} VkBindImagePlaneMemoryInfo;

		typedef struct VkImagePlaneMemoryRequirementsInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageAspectFlagBits planeAspect;
		} VkImagePlaneMemoryRequirementsInfo;

		typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 samplerYcbcrConversion;
		} VkPhysicalDeviceSamplerYcbcrConversionFeatures;

		typedef struct VkSamplerYcbcrConversionImageFormatProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t combinedImageSamplerDescriptorCount;
		} VkSamplerYcbcrConversionImageFormatProperties;

		typedef struct VkDescriptorUpdateTemplateEntry
		{
		    uint32_t dstBinding;
		    uint32_t dstArrayElement;
		    uint32_t descriptorCount;
		    VkDescriptorType descriptorType;
		    size_t offset;
		    size_t stride;
		} VkDescriptorUpdateTemplateEntry;

		typedef struct VkDescriptorUpdateTemplateCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorUpdateTemplateCreateFlags flags;
		    uint32_t descriptorUpdateEntryCount;
		    const VkDescriptorUpdateTemplateEntry* pDescriptorUpdateEntries;
		    VkDescriptorUpdateTemplateType templateType;
		    VkDescriptorSetLayout descriptorSetLayout;
		    VkPipelineBindPoint pipelineBindPoint;
		    VkPipelineLayout pipelineLayout;
		    uint32_t set;
		} VkDescriptorUpdateTemplateCreateInfo;

		typedef struct VkExternalMemoryProperties
		{
		    VkExternalMemoryFeatureFlags externalMemoryFeatures;
		    VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes;
		    VkExternalMemoryHandleTypeFlags compatibleHandleTypes;
		} VkExternalMemoryProperties;

		typedef struct VkPhysicalDeviceExternalImageFormatInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		} VkPhysicalDeviceExternalImageFormatInfo;

		typedef struct VkExternalImageFormatProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExternalMemoryProperties externalMemoryProperties;
		} VkExternalImageFormatProperties;

		typedef struct VkPhysicalDeviceExternalBufferInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferCreateFlags flags;
		    VkBufferUsageFlags usage;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		} VkPhysicalDeviceExternalBufferInfo;

		typedef struct VkExternalBufferProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExternalMemoryProperties externalMemoryProperties;
		} VkExternalBufferProperties;

		typedef struct VkPhysicalDeviceIDProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint8_t deviceUUID[VK_UUID_SIZE];
		    uint8_t driverUUID[VK_UUID_SIZE];
		    uint8_t deviceLUID[VK_LUID_SIZE];
		    uint32_t deviceNodeMask;
		    VkBool32 deviceLUIDValid;
		} VkPhysicalDeviceIDProperties;

		typedef struct VkExternalMemoryImageCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlags handleTypes;
		} VkExternalMemoryImageCreateInfo;

		typedef struct VkExternalMemoryBufferCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlags handleTypes;
		} VkExternalMemoryBufferCreateInfo;

		typedef struct VkExportMemoryAllocateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlags handleTypes;
		} VkExportMemoryAllocateInfo;

		typedef struct VkPhysicalDeviceExternalFenceInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalFenceHandleTypeFlagBits handleType;
		} VkPhysicalDeviceExternalFenceInfo;

		typedef struct VkExternalFenceProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes;
		    VkExternalFenceHandleTypeFlags compatibleHandleTypes;
		    VkExternalFenceFeatureFlags externalFenceFeatures;
		} VkExternalFenceProperties;

		typedef struct VkExportFenceCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalFenceHandleTypeFlags handleTypes;
		} VkExportFenceCreateInfo;

		typedef struct VkExportSemaphoreCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalSemaphoreHandleTypeFlags handleTypes;
		} VkExportSemaphoreCreateInfo;

		typedef struct VkPhysicalDeviceExternalSemaphoreInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		} VkPhysicalDeviceExternalSemaphoreInfo;

		typedef struct VkExternalSemaphoreProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes;
		    VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes;
		    VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures;
		} VkExternalSemaphoreProperties;

		typedef struct VkPhysicalDeviceMaintenance3Properties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxPerSetDescriptors;
		    VkDeviceSize maxMemoryAllocationSize;
		} VkPhysicalDeviceMaintenance3Properties;

		typedef struct VkDescriptorSetLayoutSupport
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 supported;
		} VkDescriptorSetLayoutSupport;

		typedef struct VkPhysicalDeviceShaderDrawParametersFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderDrawParameters;
		} VkPhysicalDeviceShaderDrawParametersFeatures;

		typedef VkPhysicalDeviceShaderDrawParametersFeatures VkPhysicalDeviceShaderDrawParameterFeatures;


		typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceVersion)(uint32_t* pApiVersion);
		typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos);
		typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceGroupPeerMemoryFeatures)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDeviceMask)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
		typedef void (VKAPI_PTR *PFN_vkCmdDispatchBase)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
		typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDeviceGroups)(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
		typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements2)(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements2)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties2)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties2)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);
		typedef void (VKAPI_PTR *PFN_vkTrimCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue2)(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateSamplerYcbcrConversion)(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
		typedef void (VKAPI_PTR *PFN_vkDestroySamplerYcbcrConversion)(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorUpdateTemplate)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
		typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorUpdateTemplate)(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSetWithTemplate)(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalFenceProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties);
		typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutSupport)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport);

		#define VK_VERSION_1_2 1

		#define VK_API_VERSION_1_2 VK_MAKE_API_VERSION(0, 1, 2, 0)

		#define VK_MAX_DRIVER_NAME_SIZE 256
		#define VK_MAX_DRIVER_INFO_SIZE 256

		typedef enum
		{
		    VK_DRIVER_ID_AMD_PROPRIETARY = 1,
		    VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
		    VK_DRIVER_ID_MESA_RADV = 3,
		    VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
		    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
		    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
		    VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
		    VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
		    VK_DRIVER_ID_ARM_PROPRIETARY = 9,
		    VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
		    VK_DRIVER_ID_GGP_PROPRIETARY = 11,
		    VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
		    VK_DRIVER_ID_MESA_LLVMPIPE = 13,
		    VK_DRIVER_ID_MOLTENVK = 14,
		    VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
		    VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
		    VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
		    VK_DRIVER_ID_MESA_TURNIP = 18,
		    VK_DRIVER_ID_MESA_V3DV = 19,
		    VK_DRIVER_ID_MESA_PANVK = 20,
		    VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
		    VK_DRIVER_ID_MESA_VENUS = 22,
		    VK_DRIVER_ID_MESA_DOZEN = 23,
		    VK_DRIVER_ID_MESA_NVK = 24,
		    VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
		    VK_DRIVER_ID_MESA_AGXV = 26,
		    VK_DRIVER_ID_AMD_PROPRIETARY_KHR = VK_DRIVER_ID_AMD_PROPRIETARY,
		    VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = VK_DRIVER_ID_AMD_OPEN_SOURCE,
		    VK_DRIVER_ID_MESA_RADV_KHR = VK_DRIVER_ID_MESA_RADV,
		    VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = VK_DRIVER_ID_NVIDIA_PROPRIETARY,
		    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
		    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
		    VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
		    VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
		    VK_DRIVER_ID_ARM_PROPRIETARY_KHR = VK_DRIVER_ID_ARM_PROPRIETARY,
		    VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
		    VK_DRIVER_ID_GGP_PROPRIETARY_KHR = VK_DRIVER_ID_GGP_PROPRIETARY,
		    VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = VK_DRIVER_ID_BROADCOM_PROPRIETARY,
		    VK_DRIVER_ID_MAX_ENUM = 0x7FFFFFFF
		} VkDriverId;

		typedef enum
		{
		    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
		    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
		    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
		    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
		    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
		    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
		    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 0x7FFFFFFF
		} VkShaderFloatControlsIndependence;


		typedef enum
		{
		    VK_RESOLVE_MODE_NONE = 0,
		    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x00000001,
		    VK_RESOLVE_MODE_AVERAGE_BIT = 0x00000002,
		    VK_RESOLVE_MODE_MIN_BIT = 0x00000004,
		    VK_RESOLVE_MODE_MAX_BIT = 0x00000008,
		    VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID = 0x00000010,
		    VK_RESOLVE_MODE_NONE_KHR = VK_RESOLVE_MODE_NONE,
		    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
		    VK_RESOLVE_MODE_AVERAGE_BIT_KHR = VK_RESOLVE_MODE_AVERAGE_BIT,
		    VK_RESOLVE_MODE_MIN_BIT_KHR = VK_RESOLVE_MODE_MIN_BIT,
		    VK_RESOLVE_MODE_MAX_BIT_KHR = VK_RESOLVE_MODE_MAX_BIT,
		    VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkResolveModeFlagBits;
		typedef VkFlags VkResolveModeFlags;

		typedef enum
		{
		    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x00000001,
		    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x00000002,
		    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x00000004,
		    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x00000008,
		    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
		    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
		    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
		    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
		    VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkDescriptorBindingFlagBits;
		typedef VkFlags VkDescriptorBindingFlags;
		typedef enum
		{
		    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
		    VK_SAMPLER_REDUCTION_MODE_MIN = 1,
		    VK_SAMPLER_REDUCTION_MODE_MAX = 2,
		    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM = 1000521000,
		    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
		    VK_SAMPLER_REDUCTION_MODE_MIN_EXT = VK_SAMPLER_REDUCTION_MODE_MIN,
		    VK_SAMPLER_REDUCTION_MODE_MAX_EXT = VK_SAMPLER_REDUCTION_MODE_MAX,
		    VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = 0x7FFFFFFF
		} VkSamplerReductionMode;

		typedef enum
		{
		    VK_SEMAPHORE_TYPE_BINARY = 0,
		    VK_SEMAPHORE_TYPE_TIMELINE = 1,
		    VK_SEMAPHORE_TYPE_BINARY_KHR = VK_SEMAPHORE_TYPE_BINARY,
		    VK_SEMAPHORE_TYPE_TIMELINE_KHR = VK_SEMAPHORE_TYPE_TIMELINE,
		    VK_SEMAPHORE_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkSemaphoreType;


		typedef enum
		{
		    VK_SEMAPHORE_WAIT_ANY_BIT = 0x00000001,
		    VK_SEMAPHORE_WAIT_ANY_BIT_KHR = VK_SEMAPHORE_WAIT_ANY_BIT,
		    VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSemaphoreWaitFlagBits;
		typedef VkFlags VkSemaphoreWaitFlags;

		typedef struct VkPhysicalDeviceVulkan11Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 storageBuffer16BitAccess;
		    VkBool32 uniformAndStorageBuffer16BitAccess;
		    VkBool32 storagePushConstant16;
		    VkBool32 storageInputOutput16;
		    VkBool32 multiview;
		    VkBool32 multiviewGeometryShader;
		    VkBool32 multiviewTessellationShader;
		    VkBool32 variablePointersStorageBuffer;
		    VkBool32 variablePointers;
		    VkBool32 protectedMemory;
		    VkBool32 samplerYcbcrConversion;
		    VkBool32 shaderDrawParameters;
		} VkPhysicalDeviceVulkan11Features;

		typedef struct VkPhysicalDeviceVulkan11Properties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint8_t deviceUUID[VK_UUID_SIZE];
		    uint8_t driverUUID[VK_UUID_SIZE];
		    uint8_t deviceLUID[VK_LUID_SIZE];
		    uint32_t deviceNodeMask;
		    VkBool32 deviceLUIDValid;
		    uint32_t subgroupSize;
		    VkShaderStageFlags subgroupSupportedStages;
		    VkSubgroupFeatureFlags subgroupSupportedOperations;
		    VkBool32 subgroupQuadOperationsInAllStages;
		    VkPointClippingBehavior pointClippingBehavior;
		    uint32_t maxMultiviewViewCount;
		    uint32_t maxMultiviewInstanceIndex;
		    VkBool32 protectedNoFault;
		    uint32_t maxPerSetDescriptors;
		    VkDeviceSize maxMemoryAllocationSize;
		} VkPhysicalDeviceVulkan11Properties;

		typedef struct VkPhysicalDeviceVulkan12Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 samplerMirrorClampToEdge;
		    VkBool32 drawIndirectCount;
		    VkBool32 storageBuffer8BitAccess;
		    VkBool32 uniformAndStorageBuffer8BitAccess;
		    VkBool32 storagePushConstant8;
		    VkBool32 shaderBufferInt64Atomics;
		    VkBool32 shaderSharedInt64Atomics;
		    VkBool32 shaderFloat16;
		    VkBool32 shaderInt8;
		    VkBool32 descriptorIndexing;
		    VkBool32 shaderInputAttachmentArrayDynamicIndexing;
		    VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
		    VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
		    VkBool32 shaderUniformBufferArrayNonUniformIndexing;
		    VkBool32 shaderSampledImageArrayNonUniformIndexing;
		    VkBool32 shaderStorageBufferArrayNonUniformIndexing;
		    VkBool32 shaderStorageImageArrayNonUniformIndexing;
		    VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
		    VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
		    VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
		    VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
		    VkBool32 descriptorBindingSampledImageUpdateAfterBind;
		    VkBool32 descriptorBindingStorageImageUpdateAfterBind;
		    VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
		    VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
		    VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
		    VkBool32 descriptorBindingUpdateUnusedWhilePending;
		    VkBool32 descriptorBindingPartiallyBound;
		    VkBool32 descriptorBindingVariableDescriptorCount;
		    VkBool32 runtimeDescriptorArray;
		    VkBool32 samplerFilterMinmax;
		    VkBool32 scalarBlockLayout;
		    VkBool32 imagelessFramebuffer;
		    VkBool32 uniformBufferStandardLayout;
		    VkBool32 shaderSubgroupExtendedTypes;
		    VkBool32 separateDepthStencilLayouts;
		    VkBool32 hostQueryReset;
		    VkBool32 timelineSemaphore;
		    VkBool32 bufferDeviceAddress;
		    VkBool32 bufferDeviceAddressCaptureReplay;
		    VkBool32 bufferDeviceAddressMultiDevice;
		    VkBool32 vulkanMemoryModel;
		    VkBool32 vulkanMemoryModelDeviceScope;
		    VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
		    VkBool32 shaderOutputViewportIndex;
		    VkBool32 shaderOutputLayer;
		    VkBool32 subgroupBroadcastDynamicId;
		} VkPhysicalDeviceVulkan12Features;

		typedef struct VkConformanceVersion
		{
		    uint8_t major;
		    uint8_t minor;
		    uint8_t subminor;
		    uint8_t patch;
		} VkConformanceVersion;

		typedef struct VkPhysicalDeviceVulkan12Properties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDriverId driverID;
		    char driverName[VK_MAX_DRIVER_NAME_SIZE];
		    char driverInfo[VK_MAX_DRIVER_INFO_SIZE];
		    VkConformanceVersion conformanceVersion;
		    VkShaderFloatControlsIndependence denormBehaviorIndependence;
		    VkShaderFloatControlsIndependence roundingModeIndependence;
		    VkBool32 shaderSignedZeroInfNanPreserveFloat16;
		    VkBool32 shaderSignedZeroInfNanPreserveFloat32;
		    VkBool32 shaderSignedZeroInfNanPreserveFloat64;
		    VkBool32 shaderDenormPreserveFloat16;
		    VkBool32 shaderDenormPreserveFloat32;
		    VkBool32 shaderDenormPreserveFloat64;
		    VkBool32 shaderDenormFlushToZeroFloat16;
		    VkBool32 shaderDenormFlushToZeroFloat32;
		    VkBool32 shaderDenormFlushToZeroFloat64;
		    VkBool32 shaderRoundingModeRTEFloat16;
		    VkBool32 shaderRoundingModeRTEFloat32;
		    VkBool32 shaderRoundingModeRTEFloat64;
		    VkBool32 shaderRoundingModeRTZFloat16;
		    VkBool32 shaderRoundingModeRTZFloat32;
		    VkBool32 shaderRoundingModeRTZFloat64;
		    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
		    VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
		    VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
		    VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
		    VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
		    VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
		    VkBool32 robustBufferAccessUpdateAfterBind;
		    VkBool32 quadDivergentImplicitLod;
		    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
		    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
		    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
		    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
		    uint32_t maxPerStageUpdateAfterBindResources;
		    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
		    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
		    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
		    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
		    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
		    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
		    VkResolveModeFlags supportedDepthResolveModes;
		    VkResolveModeFlags supportedStencilResolveModes;
		    VkBool32 independentResolveNone;
		    VkBool32 independentResolve;
		    VkBool32 filterMinmaxSingleComponentFormats;
		    VkBool32 filterMinmaxImageComponentMapping;
		    uint64_t maxTimelineSemaphoreValueDifference;
		    VkSampleCountFlags framebufferIntegerColorSampleCounts;
		} VkPhysicalDeviceVulkan12Properties;

		typedef struct VkImageFormatListCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t viewFormatCount;
		    const VkFormat* pViewFormats;
		} VkImageFormatListCreateInfo;

		typedef struct VkAttachmentDescription2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAttachmentDescriptionFlags flags;
		    VkFormat format;
		    VkSampleCountFlagBits samples;
		    VkAttachmentLoadOp loadOp;
		    VkAttachmentStoreOp storeOp;
		    VkAttachmentLoadOp stencilLoadOp;
		    VkAttachmentStoreOp stencilStoreOp;
		    VkImageLayout initialLayout;
		    VkImageLayout finalLayout;
		} VkAttachmentDescription2;

		typedef struct VkAttachmentReference2
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t attachment;
		    VkImageLayout layout;
		    VkImageAspectFlags aspectMask;
		} VkAttachmentReference2;

		typedef struct VkSubpassDescription2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSubpassDescriptionFlags flags;
		    VkPipelineBindPoint pipelineBindPoint;
		    uint32_t viewMask;
		    uint32_t inputAttachmentCount;
		    const VkAttachmentReference2* pInputAttachments;
		    uint32_t colorAttachmentCount;
		    const VkAttachmentReference2* pColorAttachments;
		    const VkAttachmentReference2* pResolveAttachments;
		    const VkAttachmentReference2* pDepthStencilAttachment;
		    uint32_t preserveAttachmentCount;
		    const uint32_t* pPreserveAttachments;
		} VkSubpassDescription2;

		typedef struct VkSubpassDependency2
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t srcSubpass;
		    uint32_t dstSubpass;
		    VkPipelineStageFlags srcStageMask;
		    VkPipelineStageFlags dstStageMask;
		    VkAccessFlags srcAccessMask;
		    VkAccessFlags dstAccessMask;
		    VkDependencyFlags dependencyFlags;
		    int32_t viewOffset;
		} VkSubpassDependency2;

		typedef struct VkRenderPassCreateInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderPassCreateFlags flags;
		    uint32_t attachmentCount;
		    const VkAttachmentDescription2* pAttachments;
		    uint32_t subpassCount;
		    const VkSubpassDescription2* pSubpasses;
		    uint32_t dependencyCount;
		    const VkSubpassDependency2* pDependencies;
		    uint32_t correlatedViewMaskCount;
		    const uint32_t* pCorrelatedViewMasks;
		} VkRenderPassCreateInfo2;

		typedef struct VkSubpassBeginInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSubpassContents contents;
		} VkSubpassBeginInfo;

		typedef struct VkSubpassEndInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		} VkSubpassEndInfo;

		typedef struct VkPhysicalDevice8BitStorageFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 storageBuffer8BitAccess;
		    VkBool32 uniformAndStorageBuffer8BitAccess;
		    VkBool32 storagePushConstant8;
		} VkPhysicalDevice8BitStorageFeatures;

		typedef struct VkPhysicalDeviceDriverProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDriverId driverID;
		    char driverName[VK_MAX_DRIVER_NAME_SIZE];
		    char driverInfo[VK_MAX_DRIVER_INFO_SIZE];
		    VkConformanceVersion conformanceVersion;
		} VkPhysicalDeviceDriverProperties;

		typedef struct VkPhysicalDeviceShaderAtomicInt64Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderBufferInt64Atomics;
		    VkBool32 shaderSharedInt64Atomics;
		} VkPhysicalDeviceShaderAtomicInt64Features;

		typedef struct VkPhysicalDeviceShaderFloat16Int8Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderFloat16;
		    VkBool32 shaderInt8;
		} VkPhysicalDeviceShaderFloat16Int8Features;

		typedef struct VkPhysicalDeviceFloatControlsProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkShaderFloatControlsIndependence denormBehaviorIndependence;
		    VkShaderFloatControlsIndependence roundingModeIndependence;
		    VkBool32 shaderSignedZeroInfNanPreserveFloat16;
		    VkBool32 shaderSignedZeroInfNanPreserveFloat32;
		    VkBool32 shaderSignedZeroInfNanPreserveFloat64;
		    VkBool32 shaderDenormPreserveFloat16;
		    VkBool32 shaderDenormPreserveFloat32;
		    VkBool32 shaderDenormPreserveFloat64;
		    VkBool32 shaderDenormFlushToZeroFloat16;
		    VkBool32 shaderDenormFlushToZeroFloat32;
		    VkBool32 shaderDenormFlushToZeroFloat64;
		    VkBool32 shaderRoundingModeRTEFloat16;
		    VkBool32 shaderRoundingModeRTEFloat32;
		    VkBool32 shaderRoundingModeRTEFloat64;
		    VkBool32 shaderRoundingModeRTZFloat16;
		    VkBool32 shaderRoundingModeRTZFloat32;
		    VkBool32 shaderRoundingModeRTZFloat64;
		} VkPhysicalDeviceFloatControlsProperties;

		typedef struct VkDescriptorSetLayoutBindingFlagsCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t bindingCount;
		    const VkDescriptorBindingFlags* pBindingFlags;
		} VkDescriptorSetLayoutBindingFlagsCreateInfo;

		typedef struct VkPhysicalDeviceDescriptorIndexingFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderInputAttachmentArrayDynamicIndexing;
		    VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
		    VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
		    VkBool32 shaderUniformBufferArrayNonUniformIndexing;
		    VkBool32 shaderSampledImageArrayNonUniformIndexing;
		    VkBool32 shaderStorageBufferArrayNonUniformIndexing;
		    VkBool32 shaderStorageImageArrayNonUniformIndexing;
		    VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
		    VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
		    VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
		    VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
		    VkBool32 descriptorBindingSampledImageUpdateAfterBind;
		    VkBool32 descriptorBindingStorageImageUpdateAfterBind;
		    VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
		    VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
		    VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
		    VkBool32 descriptorBindingUpdateUnusedWhilePending;
		    VkBool32 descriptorBindingPartiallyBound;
		    VkBool32 descriptorBindingVariableDescriptorCount;
		    VkBool32 runtimeDescriptorArray;
		} VkPhysicalDeviceDescriptorIndexingFeatures;

		typedef struct VkPhysicalDeviceDescriptorIndexingProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
		    VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
		    VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
		    VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
		    VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
		    VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
		    VkBool32 robustBufferAccessUpdateAfterBind;
		    VkBool32 quadDivergentImplicitLod;
		    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
		    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
		    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
		    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
		    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
		    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
		    uint32_t maxPerStageUpdateAfterBindResources;
		    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
		    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
		    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
		    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
		    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
		    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
		    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
		    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
		} VkPhysicalDeviceDescriptorIndexingProperties;

		typedef struct VkDescriptorSetVariableDescriptorCountAllocateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t descriptorSetCount;
		    const uint32_t* pDescriptorCounts;
		} VkDescriptorSetVariableDescriptorCountAllocateInfo;

		typedef struct VkDescriptorSetVariableDescriptorCountLayoutSupport
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxVariableDescriptorCount;
		} VkDescriptorSetVariableDescriptorCountLayoutSupport;

		typedef struct VkSubpassDescriptionDepthStencilResolve
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkResolveModeFlagBits depthResolveMode;
		    VkResolveModeFlagBits stencilResolveMode;
		    const VkAttachmentReference2* pDepthStencilResolveAttachment;
		} VkSubpassDescriptionDepthStencilResolve;

		typedef struct VkPhysicalDeviceDepthStencilResolveProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkResolveModeFlags supportedDepthResolveModes;
		    VkResolveModeFlags supportedStencilResolveModes;
		    VkBool32 independentResolveNone;
		    VkBool32 independentResolve;
		} VkPhysicalDeviceDepthStencilResolveProperties;

		typedef struct VkPhysicalDeviceScalarBlockLayoutFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 scalarBlockLayout;
		} VkPhysicalDeviceScalarBlockLayoutFeatures;

		typedef struct VkImageStencilUsageCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageUsageFlags stencilUsage;
		} VkImageStencilUsageCreateInfo;

		typedef struct VkSamplerReductionModeCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSamplerReductionMode reductionMode;
		} VkSamplerReductionModeCreateInfo;

		typedef struct VkPhysicalDeviceSamplerFilterMinmaxProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 filterMinmaxSingleComponentFormats;
		    VkBool32 filterMinmaxImageComponentMapping;
		} VkPhysicalDeviceSamplerFilterMinmaxProperties;

		typedef struct VkPhysicalDeviceVulkanMemoryModelFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 vulkanMemoryModel;
		    VkBool32 vulkanMemoryModelDeviceScope;
		    VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
		} VkPhysicalDeviceVulkanMemoryModelFeatures;

		typedef struct VkPhysicalDeviceImagelessFramebufferFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 imagelessFramebuffer;
		} VkPhysicalDeviceImagelessFramebufferFeatures;

		typedef struct VkFramebufferAttachmentImageInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageCreateFlags flags;
		    VkImageUsageFlags usage;
		    uint32_t width;
		    uint32_t height;
		    uint32_t layerCount;
		    uint32_t viewFormatCount;
		    const VkFormat* pViewFormats;
		} VkFramebufferAttachmentImageInfo;

		typedef struct VkFramebufferAttachmentsCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t attachmentImageInfoCount;
		    const VkFramebufferAttachmentImageInfo* pAttachmentImageInfos;
		} VkFramebufferAttachmentsCreateInfo;

		typedef struct VkRenderPassAttachmentBeginInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t attachmentCount;
		    const VkImageView* pAttachments;
		} VkRenderPassAttachmentBeginInfo;

		typedef struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 uniformBufferStandardLayout;
		} VkPhysicalDeviceUniformBufferStandardLayoutFeatures;

		typedef struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderSubgroupExtendedTypes;
		} VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;

		typedef struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 separateDepthStencilLayouts;
		} VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;

		typedef struct VkAttachmentReferenceStencilLayout
		{
		    VkStructureType sType;
		    void* pNext;
		    VkImageLayout stencilLayout;
		} VkAttachmentReferenceStencilLayout;

		typedef struct VkAttachmentDescriptionStencilLayout
		{
		    VkStructureType sType;
		    void* pNext;
		    VkImageLayout stencilInitialLayout;
		    VkImageLayout stencilFinalLayout;
		} VkAttachmentDescriptionStencilLayout;

		typedef struct VkPhysicalDeviceHostQueryResetFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 hostQueryReset;
		} VkPhysicalDeviceHostQueryResetFeatures;

		typedef struct VkPhysicalDeviceTimelineSemaphoreFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 timelineSemaphore;
		} VkPhysicalDeviceTimelineSemaphoreFeatures;

		typedef struct VkPhysicalDeviceTimelineSemaphoreProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint64_t maxTimelineSemaphoreValueDifference;
		} VkPhysicalDeviceTimelineSemaphoreProperties;

		typedef struct VkSemaphoreTypeCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphoreType semaphoreType;
		    uint64_t initialValue;
		} VkSemaphoreTypeCreateInfo;

		typedef struct VkTimelineSemaphoreSubmitInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t waitSemaphoreValueCount;
		    const uint64_t* pWaitSemaphoreValues;
		    uint32_t signalSemaphoreValueCount;
		    const uint64_t* pSignalSemaphoreValues;
		} VkTimelineSemaphoreSubmitInfo;

		typedef struct VkSemaphoreWaitInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphoreWaitFlags flags;
		    uint32_t semaphoreCount;
		    const VkSemaphore* pSemaphores;
		    const uint64_t* pValues;
		} VkSemaphoreWaitInfo;

		typedef struct VkSemaphoreSignalInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    uint64_t value;
		} VkSemaphoreSignalInfo;

		typedef struct VkPhysicalDeviceBufferDeviceAddressFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 bufferDeviceAddress;
		    VkBool32 bufferDeviceAddressCaptureReplay;
		    VkBool32 bufferDeviceAddressMultiDevice;
		} VkPhysicalDeviceBufferDeviceAddressFeatures;

		typedef struct VkBufferDeviceAddressInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer buffer;
		} VkBufferDeviceAddressInfo;

		typedef struct VkBufferOpaqueCaptureAddressCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t opaqueCaptureAddress;
		} VkBufferOpaqueCaptureAddressCreateInfo;

		typedef struct VkMemoryOpaqueCaptureAddressAllocateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t opaqueCaptureAddress;
		} VkMemoryOpaqueCaptureAddressAllocateInfo;

		typedef struct VkDeviceMemoryOpaqueCaptureAddressInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		} VkDeviceMemoryOpaqueCaptureAddressInfo;


		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCount)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCount)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass2)(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass2)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass2)(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass2)(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo);
		typedef void (VKAPI_PTR *PFN_vkResetQueryPool)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
		typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValue)(VkDevice device, VkSemaphore semaphore, uint64_t* pValue);
		typedef VkResult (VKAPI_PTR *PFN_vkWaitSemaphores)(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout);
		typedef VkResult (VKAPI_PTR *PFN_vkSignalSemaphore)(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo);
		typedef VkDeviceAddress (VKAPI_PTR *PFN_vkGetBufferDeviceAddress)(VkDevice device, const VkBufferDeviceAddressInfo* pInfo);
		typedef uint64_t (VKAPI_PTR *PFN_vkGetBufferOpaqueCaptureAddress)(VkDevice device, const VkBufferDeviceAddressInfo* pInfo);
		typedef uint64_t (VKAPI_PTR *PFN_vkGetDeviceMemoryOpaqueCaptureAddress)(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo);

		#define VK_VERSION_1_3 1

		#define VK_API_VERSION_1_3 VK_MAKE_API_VERSION(0, 1, 3, 0)

		typedef uint64_t VkFlags64;

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPrivateDataSlot)


		typedef enum
		{
		    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x00000001,
		    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
		    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x00000002,
		    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
		    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x00000004,
		    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
		    VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineCreationFeedbackFlagBits;
		typedef VkFlags VkPipelineCreationFeedbackFlags;

		typedef enum
		{
		    VK_TOOL_PURPOSE_VALIDATION_BIT = 0x00000001,
		    VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = VK_TOOL_PURPOSE_VALIDATION_BIT,
		    VK_TOOL_PURPOSE_PROFILING_BIT = 0x00000002,
		    VK_TOOL_PURPOSE_PROFILING_BIT_EXT = VK_TOOL_PURPOSE_PROFILING_BIT,
		    VK_TOOL_PURPOSE_TRACING_BIT = 0x00000004,
		    VK_TOOL_PURPOSE_TRACING_BIT_EXT = VK_TOOL_PURPOSE_TRACING_BIT,
		    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x00000008,
		    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
		    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x00000010,
		    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
		    VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x00000020,
		    VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x00000040,
		    VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkToolPurposeFlagBits;
		typedef VkFlags VkToolPurposeFlags;
		typedef VkFlags VkPrivateDataSlotCreateFlags;

		typedef VkFlags64 VkPipelineStageFlagBits2;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE = 0;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_NONE_KHR = 0;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 0x00000001;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 0x00000001;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 0x00000002;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 0x00000002;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 0x00000004;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 0x00000004;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 0x00000008;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 0x00000008;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 0x00000010;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 0x00000020;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 0x00000040;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 0x00000040;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 0x00000080;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 0x00000080;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 0x00000100;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 0x00000100;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 0x00000200;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 0x00000200;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 0x00000400;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 0x00000800;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 0x00000800;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 0x00001000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 0x00001000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT = 0x00001000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 0x00001000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 0x00002000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 0x00002000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT = 0x00004000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_HOST_BIT_KHR = 0x00004000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 0x00008000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 0x00008000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 0x00010000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 0x00010000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000001 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COPY_BIT_KHR = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000001 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000002 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000002 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000004 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000004 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000008 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000008 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000010 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000010 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000020 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000020 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000040 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000040 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 0x04000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 0x08000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 0x00020000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00400000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x02000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 0x00200000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 0x00080000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 0x00100000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000080 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000100 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 0x10000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 0x40000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000200 << 32) | (0x00000000));
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 0x20000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 0x00400000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 0x00200000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 0x00080000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 0x00100000;
		static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = (VkPipelineStageFlagBits2)(((VkPipelineStageFlagBits2)0x00000080 << 32) | (0x00000000));
		typedef VkFlags64 VkPipelineStageFlags2;

		typedef VkFlags64 VkAccessFlagBits2;
		static const VkAccessFlagBits2 VK_ACCESS_2_NONE = 0;
		static const VkAccessFlagBits2 VK_ACCESS_2_NONE_KHR = 0;
		static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = 0x00000001;
		static const VkAccessFlagBits2 VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 0x00000001;
		static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT = 0x00000002;
		static const VkAccessFlagBits2 VK_ACCESS_2_INDEX_READ_BIT_KHR = 0x00000002;
		static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004;
		static const VkAccessFlagBits2 VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 0x00000004;
		static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT = 0x00000008;
		static const VkAccessFlagBits2 VK_ACCESS_2_UNIFORM_READ_BIT_KHR = 0x00000008;
		static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 0x00000010;
		static const VkAccessFlagBits2 VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 0x00000010;
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT = 0x00000020;
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_READ_BIT_KHR = 0x00000020;
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT = 0x00000040;
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_WRITE_BIT_KHR = 0x00000040;
		static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 0x00000080;
		static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 0x00000080;
		static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100;
		static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 0x00000100;
		static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200;
		static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 0x00000200;
		static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400;
		static const VkAccessFlagBits2 VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 0x00000400;
		static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT = 0x00000800;
		static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_READ_BIT_KHR = 0x00000800;
		static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT = 0x00001000;
		static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = 0x00001000;
		static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT = 0x00002000;
		static const VkAccessFlagBits2 VK_ACCESS_2_HOST_READ_BIT_KHR = 0x00002000;
		static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT = 0x00004000;
		static const VkAccessFlagBits2 VK_ACCESS_2_HOST_WRITE_BIT_KHR = 0x00004000;
		static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT = 0x00008000;
		static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_READ_BIT_KHR = 0x00008000;
		static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT = 0x00010000;
		static const VkAccessFlagBits2 VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = 0x00010000;
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000001 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000001 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000002 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000002 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000004 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000004 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000008 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000010 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000020 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000040 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000;
		static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000;
		static const VkAccessFlagBits2 VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000;
		static const VkAccessFlagBits2 VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000;
		static const VkAccessFlagBits2 VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 0x00020000;
		static const VkAccessFlagBits2 VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x00040000;
		static const VkAccessFlagBits2 VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x00800000;
		static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x00200000;
		static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x00400000;
		static const VkAccessFlagBits2 VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000;
		static const VkAccessFlagBits2 VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000;
		static const VkAccessFlagBits2 VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000200 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000080 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000100 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_MICROMAP_READ_BIT_EXT = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00001000 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00002000 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000400 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = (VkAccessFlagBits2)(((VkAccessFlagBits2)0x00000800 << 32) | (0x00000000));
		static const VkAccessFlagBits2 VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000;
		static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000;
		static const VkAccessFlagBits2 VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000;
		typedef VkFlags64 VkAccessFlags2;

		typedef enum
		{
		    VK_SUBMIT_PROTECTED_BIT = 0x00000001,
		    VK_SUBMIT_PROTECTED_BIT_KHR = VK_SUBMIT_PROTECTED_BIT,
		    VK_SUBMIT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkSubmitFlagBits;
		typedef VkFlags VkSubmitFlags;

		typedef enum
		{
		    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x00000001,
		    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
		    VK_RENDERING_SUSPENDING_BIT = 0x00000002,
		    VK_RENDERING_SUSPENDING_BIT_KHR = VK_RENDERING_SUSPENDING_BIT,
		    VK_RENDERING_RESUMING_BIT = 0x00000004,
		    VK_RENDERING_RESUMING_BIT_KHR = VK_RENDERING_RESUMING_BIT,
		    VK_RENDERING_CONTENTS_INLINE_BIT_EXT = 0x00000010,
		    VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x00000008,
		    VK_RENDERING_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
		} VkRenderingFlagBits;
		typedef VkFlags VkRenderingFlags;

		typedef VkFlags64 VkFormatFeatureFlagBits2;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 0x00000001;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 0x00000001;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 0x00000002;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 0x00000002;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 0x00000004;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000008;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = 0x00000010;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000010;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 0x00000020;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 0x00000040;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 0x00000040;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 0x00000080;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 0x00000080;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 0x00000100;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 0x00000200;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = 0x00000400;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 0x00000400;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT = 0x00000800;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 0x00000800;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 0x00001000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 0x00002000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x00002000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 0x00004000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 0x00004000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = 0x00008000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 0x00008000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x00010000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 0x00010000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x00020000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x00040000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x00080000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x00100000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x00200000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT = 0x00400000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 0x00400000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = 0x00800000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x00800000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = 0x80000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 0x80000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000001 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000001 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000002 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000002 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x02000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 0x04000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00004000 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 0x08000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 0x10000000;
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000040 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000004 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000008 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000010 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000020 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000100 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000200 << 32) | (0x00000000));
		static const VkFormatFeatureFlagBits2 VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = (VkFormatFeatureFlagBits2)(((VkFormatFeatureFlagBits2)0x00000400 << 32) | (0x00000000));
		typedef VkFlags64 VkFormatFeatureFlags2;

		typedef struct VkPhysicalDeviceVulkan13Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 robustImageAccess;
		    VkBool32 inlineUniformBlock;
		    VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
		    VkBool32 pipelineCreationCacheControl;
		    VkBool32 privateData;
		    VkBool32 shaderDemoteToHelperInvocation;
		    VkBool32 shaderTerminateInvocation;
		    VkBool32 subgroupSizeControl;
		    VkBool32 computeFullSubgroups;
		    VkBool32 synchronization2;
		    VkBool32 textureCompressionASTC_HDR;
		    VkBool32 shaderZeroInitializeWorkgroupMemory;
		    VkBool32 dynamicRendering;
		    VkBool32 shaderIntegerDotProduct;
		    VkBool32 maintenance4;
		} VkPhysicalDeviceVulkan13Features;

		typedef struct VkPhysicalDeviceVulkan13Properties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t minSubgroupSize;
		    uint32_t maxSubgroupSize;
		    uint32_t maxComputeWorkgroupSubgroups;
		    VkShaderStageFlags requiredSubgroupSizeStages;
		    uint32_t maxInlineUniformBlockSize;
		    uint32_t maxPerStageDescriptorInlineUniformBlocks;
		    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
		    uint32_t maxDescriptorSetInlineUniformBlocks;
		    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
		    uint32_t maxInlineUniformTotalSize;
		    VkBool32 integerDotProduct8BitUnsignedAccelerated;
		    VkBool32 integerDotProduct8BitSignedAccelerated;
		    VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
		    VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
		    VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
		    VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
		    VkBool32 integerDotProduct16BitUnsignedAccelerated;
		    VkBool32 integerDotProduct16BitSignedAccelerated;
		    VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
		    VkBool32 integerDotProduct32BitUnsignedAccelerated;
		    VkBool32 integerDotProduct32BitSignedAccelerated;
		    VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
		    VkBool32 integerDotProduct64BitUnsignedAccelerated;
		    VkBool32 integerDotProduct64BitSignedAccelerated;
		    VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
		    VkDeviceSize storageTexelBufferOffsetAlignmentBytes;
		    VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
		    VkDeviceSize uniformTexelBufferOffsetAlignmentBytes;
		    VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
		    VkDeviceSize maxBufferSize;
		} VkPhysicalDeviceVulkan13Properties;

		typedef struct VkPipelineCreationFeedback
		{
		    VkPipelineCreationFeedbackFlags flags;
		    uint64_t duration;
		} VkPipelineCreationFeedback;

		typedef struct VkPipelineCreationFeedbackCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCreationFeedback* pPipelineCreationFeedback;
		    uint32_t pipelineStageCreationFeedbackCount;
		    VkPipelineCreationFeedback* pPipelineStageCreationFeedbacks;
		} VkPipelineCreationFeedbackCreateInfo;

		typedef struct VkPhysicalDeviceShaderTerminateInvocationFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderTerminateInvocation;
		} VkPhysicalDeviceShaderTerminateInvocationFeatures;

		typedef struct VkPhysicalDeviceToolProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    char name[VK_MAX_EXTENSION_NAME_SIZE];
		    char version[VK_MAX_EXTENSION_NAME_SIZE];
		    VkToolPurposeFlags purposes;
		    char description[VK_MAX_DESCRIPTION_SIZE];
		    char layer[VK_MAX_EXTENSION_NAME_SIZE];
		} VkPhysicalDeviceToolProperties;

		typedef struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderDemoteToHelperInvocation;
		} VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;

		typedef struct VkPhysicalDevicePrivateDataFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 privateData;
		} VkPhysicalDevicePrivateDataFeatures;

		typedef struct VkDevicePrivateDataCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t privateDataSlotRequestCount;
		} VkDevicePrivateDataCreateInfo;

		typedef struct VkPrivateDataSlotCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPrivateDataSlotCreateFlags flags;
		} VkPrivateDataSlotCreateInfo;

		typedef struct VkPhysicalDevicePipelineCreationCacheControlFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pipelineCreationCacheControl;
		} VkPhysicalDevicePipelineCreationCacheControlFeatures;

		typedef struct VkMemoryBarrier2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineStageFlags2 srcStageMask;
		    VkAccessFlags2 srcAccessMask;
		    VkPipelineStageFlags2 dstStageMask;
		    VkAccessFlags2 dstAccessMask;
		} VkMemoryBarrier2;

		typedef struct VkBufferMemoryBarrier2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineStageFlags2 srcStageMask;
		    VkAccessFlags2 srcAccessMask;
		    VkPipelineStageFlags2 dstStageMask;
		    VkAccessFlags2 dstAccessMask;
		    uint32_t srcQueueFamilyIndex;
		    uint32_t dstQueueFamilyIndex;
		    VkBuffer buffer;
		    VkDeviceSize offset;
		    VkDeviceSize size;
		} VkBufferMemoryBarrier2;

		typedef struct VkImageMemoryBarrier2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineStageFlags2 srcStageMask;
		    VkAccessFlags2 srcAccessMask;
		    VkPipelineStageFlags2 dstStageMask;
		    VkAccessFlags2 dstAccessMask;
		    VkImageLayout oldLayout;
		    VkImageLayout newLayout;
		    uint32_t srcQueueFamilyIndex;
		    uint32_t dstQueueFamilyIndex;
		    VkImage image;
		    VkImageSubresourceRange subresourceRange;
		} VkImageMemoryBarrier2;

		typedef struct VkDependencyInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDependencyFlags dependencyFlags;
		    uint32_t memoryBarrierCount;
		    const VkMemoryBarrier2* pMemoryBarriers;
		    uint32_t bufferMemoryBarrierCount;
		    const VkBufferMemoryBarrier2* pBufferMemoryBarriers;
		    uint32_t imageMemoryBarrierCount;
		    const VkImageMemoryBarrier2* pImageMemoryBarriers;
		} VkDependencyInfo;

		typedef struct VkSemaphoreSubmitInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    uint64_t value;
		    VkPipelineStageFlags2 stageMask;
		    uint32_t deviceIndex;
		} VkSemaphoreSubmitInfo;

		typedef struct VkCommandBufferSubmitInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCommandBuffer commandBuffer;
		    uint32_t deviceMask;
		} VkCommandBufferSubmitInfo;

		typedef struct VkSubmitInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSubmitFlags flags;
		    uint32_t waitSemaphoreInfoCount;
		    const VkSemaphoreSubmitInfo* pWaitSemaphoreInfos;
		    uint32_t commandBufferInfoCount;
		    const VkCommandBufferSubmitInfo* pCommandBufferInfos;
		    uint32_t signalSemaphoreInfoCount;
		    const VkSemaphoreSubmitInfo* pSignalSemaphoreInfos;
		} VkSubmitInfo2;

		typedef struct VkPhysicalDeviceSynchronization2Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 synchronization2;
		} VkPhysicalDeviceSynchronization2Features;

		typedef struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderZeroInitializeWorkgroupMemory;
		} VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;

		typedef struct VkPhysicalDeviceImageRobustnessFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 robustImageAccess;
		} VkPhysicalDeviceImageRobustnessFeatures;

		typedef struct VkBufferCopy2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize srcOffset;
		    VkDeviceSize dstOffset;
		    VkDeviceSize size;
		} VkBufferCopy2;

		typedef struct VkCopyBufferInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer srcBuffer;
		    VkBuffer dstBuffer;
		    uint32_t regionCount;
		    const VkBufferCopy2* pRegions;
		} VkCopyBufferInfo2;

		typedef struct VkImageCopy2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageSubresourceLayers srcSubresource;
		    VkOffset3D srcOffset;
		    VkImageSubresourceLayers dstSubresource;
		    VkOffset3D dstOffset;
		    VkExtent3D extent;
		} VkImageCopy2;

		typedef struct VkCopyImageInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage srcImage;
		    VkImageLayout srcImageLayout;
		    VkImage dstImage;
		    VkImageLayout dstImageLayout;
		    uint32_t regionCount;
		    const VkImageCopy2* pRegions;
		} VkCopyImageInfo2;

		typedef struct VkBufferImageCopy2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize bufferOffset;
		    uint32_t bufferRowLength;
		    uint32_t bufferImageHeight;
		    VkImageSubresourceLayers imageSubresource;
		    VkOffset3D imageOffset;
		    VkExtent3D imageExtent;
		} VkBufferImageCopy2;

		typedef struct VkCopyBufferToImageInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer srcBuffer;
		    VkImage dstImage;
		    VkImageLayout dstImageLayout;
		    uint32_t regionCount;
		    const VkBufferImageCopy2* pRegions;
		} VkCopyBufferToImageInfo2;

		typedef struct VkCopyImageToBufferInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage srcImage;
		    VkImageLayout srcImageLayout;
		    VkBuffer dstBuffer;
		    uint32_t regionCount;
		    const VkBufferImageCopy2* pRegions;
		} VkCopyImageToBufferInfo2;

		typedef struct VkImageBlit2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageSubresourceLayers srcSubresource;
		    VkOffset3D srcOffsets[2];
		    VkImageSubresourceLayers dstSubresource;
		    VkOffset3D dstOffsets[2];
		} VkImageBlit2;

		typedef struct VkBlitImageInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage srcImage;
		    VkImageLayout srcImageLayout;
		    VkImage dstImage;
		    VkImageLayout dstImageLayout;
		    uint32_t regionCount;
		    const VkImageBlit2* pRegions;
		    VkFilter filter;
		} VkBlitImageInfo2;

		typedef struct VkImageResolve2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageSubresourceLayers srcSubresource;
		    VkOffset3D srcOffset;
		    VkImageSubresourceLayers dstSubresource;
		    VkOffset3D dstOffset;
		    VkExtent3D extent;
		} VkImageResolve2;

		typedef struct VkResolveImageInfo2
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage srcImage;
		    VkImageLayout srcImageLayout;
		    VkImage dstImage;
		    VkImageLayout dstImageLayout;
		    uint32_t regionCount;
		    const VkImageResolve2* pRegions;
		} VkResolveImageInfo2;

		typedef struct VkPhysicalDeviceSubgroupSizeControlFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 subgroupSizeControl;
		    VkBool32 computeFullSubgroups;
		} VkPhysicalDeviceSubgroupSizeControlFeatures;

		typedef struct VkPhysicalDeviceSubgroupSizeControlProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t minSubgroupSize;
		    uint32_t maxSubgroupSize;
		    uint32_t maxComputeWorkgroupSubgroups;
		    VkShaderStageFlags requiredSubgroupSizeStages;
		} VkPhysicalDeviceSubgroupSizeControlProperties;

		typedef struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t requiredSubgroupSize;
		} VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;

		typedef struct VkPhysicalDeviceInlineUniformBlockFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 inlineUniformBlock;
		    VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
		} VkPhysicalDeviceInlineUniformBlockFeatures;

		typedef struct VkPhysicalDeviceInlineUniformBlockProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxInlineUniformBlockSize;
		    uint32_t maxPerStageDescriptorInlineUniformBlocks;
		    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
		    uint32_t maxDescriptorSetInlineUniformBlocks;
		    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
		} VkPhysicalDeviceInlineUniformBlockProperties;

		typedef struct VkWriteDescriptorSetInlineUniformBlock
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t dataSize;
		    const void* pData;
		} VkWriteDescriptorSetInlineUniformBlock;

		typedef struct VkDescriptorPoolInlineUniformBlockCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxInlineUniformBlockBindings;
		} VkDescriptorPoolInlineUniformBlockCreateInfo;

		typedef struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 textureCompressionASTC_HDR;
		} VkPhysicalDeviceTextureCompressionASTCHDRFeatures;

		typedef struct VkRenderingAttachmentInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageView imageView;
		    VkImageLayout imageLayout;
		    VkResolveModeFlagBits resolveMode;
		    VkImageView resolveImageView;
		    VkImageLayout resolveImageLayout;
		    VkAttachmentLoadOp loadOp;
		    VkAttachmentStoreOp storeOp;
		    VkClearValue clearValue;
		} VkRenderingAttachmentInfo;

		typedef struct VkRenderingInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderingFlags flags;
		    VkRect2D renderArea;
		    uint32_t layerCount;
		    uint32_t viewMask;
		    uint32_t colorAttachmentCount;
		    const VkRenderingAttachmentInfo* pColorAttachments;
		    const VkRenderingAttachmentInfo* pDepthAttachment;
		    const VkRenderingAttachmentInfo* pStencilAttachment;
		} VkRenderingInfo;

		typedef struct VkPipelineRenderingCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t viewMask;
		    uint32_t colorAttachmentCount;
		    const VkFormat* pColorAttachmentFormats;
		    VkFormat depthAttachmentFormat;
		    VkFormat stencilAttachmentFormat;
		} VkPipelineRenderingCreateInfo;

		typedef struct VkPhysicalDeviceDynamicRenderingFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 dynamicRendering;
		} VkPhysicalDeviceDynamicRenderingFeatures;

		typedef struct VkCommandBufferInheritanceRenderingInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderingFlags flags;
		    uint32_t viewMask;
		    uint32_t colorAttachmentCount;
		    const VkFormat* pColorAttachmentFormats;
		    VkFormat depthAttachmentFormat;
		    VkFormat stencilAttachmentFormat;
		    VkSampleCountFlagBits rasterizationSamples;
		} VkCommandBufferInheritanceRenderingInfo;

		typedef struct VkPhysicalDeviceShaderIntegerDotProductFeatures
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderIntegerDotProduct;
		} VkPhysicalDeviceShaderIntegerDotProductFeatures;

		typedef struct VkPhysicalDeviceShaderIntegerDotProductProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 integerDotProduct8BitUnsignedAccelerated;
		    VkBool32 integerDotProduct8BitSignedAccelerated;
		    VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
		    VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
		    VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
		    VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
		    VkBool32 integerDotProduct16BitUnsignedAccelerated;
		    VkBool32 integerDotProduct16BitSignedAccelerated;
		    VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
		    VkBool32 integerDotProduct32BitUnsignedAccelerated;
		    VkBool32 integerDotProduct32BitSignedAccelerated;
		    VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
		    VkBool32 integerDotProduct64BitUnsignedAccelerated;
		    VkBool32 integerDotProduct64BitSignedAccelerated;
		    VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
		    VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
		} VkPhysicalDeviceShaderIntegerDotProductProperties;

		typedef struct VkPhysicalDeviceTexelBufferAlignmentProperties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize storageTexelBufferOffsetAlignmentBytes;
		    VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
		    VkDeviceSize uniformTexelBufferOffsetAlignmentBytes;
		    VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
		} VkPhysicalDeviceTexelBufferAlignmentProperties;

		typedef struct VkFormatProperties3
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormatFeatureFlags2 linearTilingFeatures;
		    VkFormatFeatureFlags2 optimalTilingFeatures;
		    VkFormatFeatureFlags2 bufferFeatures;
		} VkFormatProperties3;

		typedef struct VkPhysicalDeviceMaintenance4Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 maintenance4;
		} VkPhysicalDeviceMaintenance4Features;

		typedef struct VkPhysicalDeviceMaintenance4Properties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize maxBufferSize;
		} VkPhysicalDeviceMaintenance4Properties;

		typedef struct VkDeviceBufferMemoryRequirements
		{
		    VkStructureType sType;
		    const void* pNext;
		    const VkBufferCreateInfo* pCreateInfo;
		} VkDeviceBufferMemoryRequirements;

		typedef struct VkDeviceImageMemoryRequirements
		{
		    VkStructureType sType;
		    const void* pNext;
		    const VkImageCreateInfo* pCreateInfo;
		    VkImageAspectFlagBits planeAspect;
		} VkDeviceImageMemoryRequirements;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceToolProperties)(VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkCreatePrivateDataSlot)(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot);
		typedef void (VKAPI_PTR *PFN_vkDestroyPrivateDataSlot)(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkSetPrivateData)(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data);
		typedef void (VKAPI_PTR *PFN_vkGetPrivateData)(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData);
		typedef void (VKAPI_PTR *PFN_vkCmdSetEvent2)(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdResetEvent2)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask);
		typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents2)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos);
		typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier2)(VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp2)(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query);
		typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit2)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer2)(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyImage2)(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage2)(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer2)(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdBlitImage2)(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdResolveImage2)(VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginRendering)(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdEndRendering)(VkCommandBuffer commandBuffer);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCullMode)(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode);
		typedef void (VKAPI_PTR *PFN_vkCmdSetFrontFace)(VkCommandBuffer commandBuffer, VkFrontFace frontFace);
		typedef void (VKAPI_PTR *PFN_vkCmdSetPrimitiveTopology)(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology);
		typedef void (VKAPI_PTR *PFN_vkCmdSetViewportWithCount)(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports);
		typedef void (VKAPI_PTR *PFN_vkCmdSetScissorWithCount)(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors);
		typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers2)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthTestEnable)(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthWriteEnable)(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthCompareOp)(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBoundsTestEnable)(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetStencilTestEnable)(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetStencilOp)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp);
		typedef void (VKAPI_PTR *PFN_vkCmdSetRasterizerDiscardEnable)(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBiasEnable)(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetPrimitiveRestartEnable)(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceBufferMemoryRequirements)(VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceImageMemoryRequirements)(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceImageSparseMemoryRequirements)(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);

		#define VKSC_VERSION_1_0 1

		#define VKSC_API_VARIANT 1
		#define VKSC_API_VERSION_1_0 VK_MAKE_API_VERSION(VKSC_API_VARIANT, 1, 0, 0)

		typedef enum
		{
		    VK_FAULT_LEVEL_UNASSIGNED = 0,
		    VK_FAULT_LEVEL_CRITICAL = 1,
		    VK_FAULT_LEVEL_RECOVERABLE = 2,
		    VK_FAULT_LEVEL_WARNING = 3,
		    VK_FAULT_LEVEL_MAX_ENUM = 0x7FFFFFFF
		} VkFaultLevel;

		typedef enum
		{
		    VK_FAULT_TYPE_INVALID = 0,
		    VK_FAULT_TYPE_UNASSIGNED = 1,
		    VK_FAULT_TYPE_IMPLEMENTATION = 2,
		    VK_FAULT_TYPE_SYSTEM = 3,
		    VK_FAULT_TYPE_PHYSICAL_DEVICE = 4,
		    VK_FAULT_TYPE_COMMAND_BUFFER_FULL = 5,
		    VK_FAULT_TYPE_INVALID_API_USAGE = 6,
		    VK_FAULT_TYPE_MAX_ENUM = 0x7FFFFFFF
		} VkFaultType;

		typedef enum
		{
		    VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS = 0,
		    VK_FAULT_QUERY_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF
		} VkFaultQueryBehavior;

		typedef enum
		{
		    VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH = 0,
		    VK_PIPELINE_MATCH_CONTROL_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineMatchControl;

		typedef enum
		{
		    VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE = 1,
		    VK_PIPELINE_CACHE_VALIDATION_VERSION_MAX_ENUM = 0x7FFFFFFF
		} VkPipelineCacheValidationVersion;


		typedef struct VkPhysicalDeviceVulkanSC10Features
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderAtomicInstructions;
		} VkPhysicalDeviceVulkanSC10Features;

		typedef struct VkPhysicalDeviceVulkanSC10Properties
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 deviceNoDynamicHostAllocations;
		    VkBool32 deviceDestroyFreesMemory;
		    VkBool32 commandPoolMultipleCommandBuffersRecording;
		    VkBool32 commandPoolResetCommandBuffer;
		    VkBool32 commandBufferSimultaneousUse;
		    VkBool32 secondaryCommandBufferNullOrImagelessFramebuffer;
		    VkBool32 recycleDescriptorSetMemory;
		    VkBool32 recyclePipelineMemory;
		    uint32_t maxRenderPassSubpasses;
		    uint32_t maxRenderPassDependencies;
		    uint32_t maxSubpassInputAttachments;
		    uint32_t maxSubpassPreserveAttachments;
		    uint32_t maxFramebufferAttachments;
		    uint32_t maxDescriptorSetLayoutBindings;
		    uint32_t maxQueryFaultCount;
		    uint32_t maxCallbackFaultCount;
		    uint32_t maxCommandPoolCommandBuffers;
		    VkDeviceSize maxCommandBufferSize;
		} VkPhysicalDeviceVulkanSC10Properties;

		typedef struct VkPipelinePoolSize
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize poolEntrySize;
		    uint32_t poolEntryCount;
		} VkPipelinePoolSize;

		typedef struct VkDeviceObjectReservationCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t pipelineCacheCreateInfoCount;
		    const VkPipelineCacheCreateInfo* pPipelineCacheCreateInfos;
		    uint32_t pipelinePoolSizeCount;
		    const VkPipelinePoolSize* pPipelinePoolSizes;
		    uint32_t semaphoreRequestCount;
		    uint32_t commandBufferRequestCount;
		    uint32_t fenceRequestCount;
		    uint32_t deviceMemoryRequestCount;
		    uint32_t bufferRequestCount;
		    uint32_t imageRequestCount;
		    uint32_t eventRequestCount;
		    uint32_t queryPoolRequestCount;
		    uint32_t bufferViewRequestCount;
		    uint32_t imageViewRequestCount;
		    uint32_t layeredImageViewRequestCount;
		    uint32_t pipelineCacheRequestCount;
		    uint32_t pipelineLayoutRequestCount;
		    uint32_t renderPassRequestCount;
		    uint32_t graphicsPipelineRequestCount;
		    uint32_t computePipelineRequestCount;
		    uint32_t descriptorSetLayoutRequestCount;
		    uint32_t samplerRequestCount;
		    uint32_t descriptorPoolRequestCount;
		    uint32_t descriptorSetRequestCount;
		    uint32_t framebufferRequestCount;
		    uint32_t commandPoolRequestCount;
		    uint32_t samplerYcbcrConversionRequestCount;
		    uint32_t surfaceRequestCount;
		    uint32_t swapchainRequestCount;
		    uint32_t displayModeRequestCount;
		    uint32_t subpassDescriptionRequestCount;
		    uint32_t attachmentDescriptionRequestCount;
		    uint32_t descriptorSetLayoutBindingRequestCount;
		    uint32_t descriptorSetLayoutBindingLimit;
		    uint32_t maxImageViewMipLevels;
		    uint32_t maxImageViewArrayLayers;
		    uint32_t maxLayeredImageViewMipLevels;
		    uint32_t maxOcclusionQueriesPerPool;
		    uint32_t maxPipelineStatisticsQueriesPerPool;
		    uint32_t maxTimestampQueriesPerPool;
		    uint32_t maxImmutableSamplersPerDescriptorSetLayout;
		} VkDeviceObjectReservationCreateInfo;

		typedef struct VkCommandPoolMemoryReservationCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize commandPoolReservedSize;
		    uint32_t commandPoolMaxCommandBuffers;
		} VkCommandPoolMemoryReservationCreateInfo;

		typedef struct VkCommandPoolMemoryConsumption
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize commandPoolAllocated;
		    VkDeviceSize commandPoolReservedSize;
		    VkDeviceSize commandBufferAllocated;
		} VkCommandPoolMemoryConsumption;

		typedef struct VkFaultData
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFaultLevel faultLevel;
		    VkFaultType faultType;
		} VkFaultData;

		typedef void (VKAPI_PTR *PFN_vkFaultCallbackFunction)(VkBool32 unrecordedFaults, uint32_t faultCount, const VkFaultData* pFaults);

		typedef struct VkFaultCallbackInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t faultCount;
		    VkFaultData* pFaults;
		    PFN_vkFaultCallbackFunction pfnFaultCallback;
		} VkFaultCallbackInfo;

		typedef struct VkPipelineOfflineCreateInfo
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint8_t pipelineIdentifier[VK_UUID_SIZE];
		    VkPipelineMatchControl matchControl;
		    VkDeviceSize poolEntrySize;
		} VkPipelineOfflineCreateInfo;

		typedef struct VkPipelineCacheStageValidationIndexEntry
		{
		    uint64_t codeSize;
		    uint64_t codeOffset;
		} VkPipelineCacheStageValidationIndexEntry;

		typedef struct VkPipelineCacheSafetyCriticalIndexEntry
		{
		    uint8_t pipelineIdentifier[VK_UUID_SIZE];
		    uint64_t pipelineMemorySize;
		    uint64_t jsonSize;
		    uint64_t jsonOffset;
		    uint32_t stageIndexCount;
		    uint32_t stageIndexStride;
		    uint64_t stageIndexOffset;
		} VkPipelineCacheSafetyCriticalIndexEntry;

		typedef struct VkPipelineCacheHeaderVersionSafetyCriticalOne
		{
		    VkPipelineCacheHeaderVersionOne headerVersionOne;
		    VkPipelineCacheValidationVersion validationVersion;
		    uint32_t implementationData;
		    uint32_t pipelineIndexCount;
		    uint32_t pipelineIndexStride;
		    uint64_t pipelineIndexOffset;
		} VkPipelineCacheHeaderVersionSafetyCriticalOne;


		typedef void (VKAPI_PTR *PFN_vkGetCommandPoolMemoryConsumption)(VkDevice device, VkCommandPool commandPool, VkCommandBuffer commandBuffer, VkCommandPoolMemoryConsumption* pConsumption);
		typedef VkResult (VKAPI_PTR *PFN_vkGetFaultData)(VkDevice device, VkFaultQueryBehavior faultQueryBehavior, VkBool32* pUnrecordedFaults, uint32_t* pFaultCount, VkFaultData* pFaults);

		#define VK_KHR_surface 1
		#define VK_KHR_SURFACE_SPEC_VERSION 25
		#define VK_KHR_SURFACE_EXTENSION_NAME "VK_KHR_surface"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

		typedef enum
		{
		    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
		    VK_PRESENT_MODE_MAILBOX_KHR = 1,
		    VK_PRESENT_MODE_FIFO_KHR = 2,
		    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
		    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
		    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
		    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkPresentModeKHR;

		typedef enum
		{
		    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
		    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
		    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
		    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
		    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
		    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
		    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
		    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
		    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
		    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
		    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
		    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
		    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
		    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
		    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
		    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
		    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
		    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
		    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkColorSpaceKHR;


		typedef enum
		{
		    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
		    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
		    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
		    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
		    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkCompositeAlphaFlagBitsKHR;
		typedef VkFlags VkCompositeAlphaFlagsKHR;

		typedef enum
		{
		    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
		    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
		    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
		    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
		    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
		    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
		    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
		    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
		    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
		    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkSurfaceTransformFlagBitsKHR;
		typedef VkFlags VkSurfaceTransformFlagsKHR;

		typedef struct VkSurfaceCapabilitiesKHR
		{
		    uint32_t minImageCount;
		    uint32_t maxImageCount;
		    VkExtent2D currentExtent;
		    VkExtent2D minImageExtent;
		    VkExtent2D maxImageExtent;
		    uint32_t maxImageArrayLayers;
		    VkSurfaceTransformFlagsKHR supportedTransforms;
		    VkSurfaceTransformFlagBitsKHR currentTransform;
		    VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
		    VkImageUsageFlags supportedUsageFlags;
		} VkSurfaceCapabilitiesKHR;

		typedef struct VkSurfaceFormatKHR
		{
		    VkFormat format;
		    VkColorSpaceKHR colorSpace;
		} VkSurfaceFormatKHR;


		typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);


		#define VK_KHR_swapchain 1
		#define VK_KHR_SWAPCHAIN_SPEC_VERSION 70
		#define VK_KHR_SWAPCHAIN_EXTENSION_NAME "VK_KHR_swapchain"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)


		typedef enum
		{
		    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
		    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002,
		    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004,
		    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = 0x00000008,
		    VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkSwapchainCreateFlagBitsKHR;
		typedef VkFlags VkSwapchainCreateFlagsKHR;

		typedef enum
		{
		    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001,
		    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002,
		    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004,
		    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
		    VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkDeviceGroupPresentModeFlagBitsKHR;
		typedef VkFlags VkDeviceGroupPresentModeFlagsKHR;

		typedef struct VkSwapchainCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSwapchainCreateFlagsKHR flags;
		    VkSurfaceKHR surface;
		    uint32_t minImageCount;
		    VkFormat imageFormat;
		    VkColorSpaceKHR imageColorSpace;
		    VkExtent2D imageExtent;
		    uint32_t imageArrayLayers;
		    VkImageUsageFlags imageUsage;
		    VkSharingMode imageSharingMode;
		    uint32_t queueFamilyIndexCount;
		    const uint32_t* pQueueFamilyIndices;
		    VkSurfaceTransformFlagBitsKHR preTransform;
		    VkCompositeAlphaFlagBitsKHR compositeAlpha;
		    VkPresentModeKHR presentMode;
		    VkBool32 clipped;
		    VkSwapchainKHR oldSwapchain;
		} VkSwapchainCreateInfoKHR;

		typedef struct VkPresentInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t waitSemaphoreCount;
		    const VkSemaphore* pWaitSemaphores;
		    uint32_t swapchainCount;
		    const VkSwapchainKHR* pSwapchains;
		    const uint32_t* pImageIndices;
		    VkResult* pResults;
		} VkPresentInfoKHR;

		typedef struct VkImageSwapchainCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSwapchainKHR swapchain;
		} VkImageSwapchainCreateInfoKHR;

		typedef struct VkBindImageMemorySwapchainInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSwapchainKHR swapchain;
		    uint32_t imageIndex;
		} VkBindImageMemorySwapchainInfoKHR;

		typedef struct VkAcquireNextImageInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSwapchainKHR swapchain;
		    uint64_t timeout;
		    VkSemaphore semaphore;
		    VkFence fence;
		    uint32_t deviceMask;
		} VkAcquireNextImageInfoKHR;

		typedef struct VkDeviceGroupPresentCapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t presentMask[VK_MAX_DEVICE_GROUP_SIZE];
		    VkDeviceGroupPresentModeFlagsKHR modes;
		} VkDeviceGroupPresentCapabilitiesKHR;

		typedef struct VkDeviceGroupPresentInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t swapchainCount;
		    const uint32_t* pDeviceMasks;
		    VkDeviceGroupPresentModeFlagBitsKHR mode;
		} VkDeviceGroupPresentInfoKHR;

		typedef struct VkDeviceGroupSwapchainCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceGroupPresentModeFlagsKHR modes;
		} VkDeviceGroupSwapchainCreateInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
		typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
		typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
		typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, const VkPresentInfoKHR* pPresentInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceGroupPresentCapabilitiesKHR)(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceGroupSurfacePresentModesKHR)(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects);
		typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImage2KHR)(VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex);


		#define VK_KHR_display 1
		#define VK_KHR_DISPLAY_SPEC_VERSION 23
		#define VK_KHR_DISPLAY_EXTENSION_NAME "VK_KHR_display"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

		typedef VkFlags VkDisplayModeCreateFlagsKHR;

		typedef enum
		{
		    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
		    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
		    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
		    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
		    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkDisplayPlaneAlphaFlagBitsKHR;
		typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
		typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

		typedef struct VkDisplayModeParametersKHR
		{
		    VkExtent2D visibleRegion;
		    uint32_t refreshRate;
		} VkDisplayModeParametersKHR;

		typedef struct VkDisplayModeCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDisplayModeCreateFlagsKHR flags;
		    VkDisplayModeParametersKHR parameters;
		} VkDisplayModeCreateInfoKHR;

		typedef struct VkDisplayModePropertiesKHR
		{
		    VkDisplayModeKHR displayMode;
		    VkDisplayModeParametersKHR parameters;
		} VkDisplayModePropertiesKHR;

		typedef struct VkDisplayPlaneCapabilitiesKHR
		{
		    VkDisplayPlaneAlphaFlagsKHR supportedAlpha;
		    VkOffset2D minSrcPosition;
		    VkOffset2D maxSrcPosition;
		    VkExtent2D minSrcExtent;
		    VkExtent2D maxSrcExtent;
		    VkOffset2D minDstPosition;
		    VkOffset2D maxDstPosition;
		    VkExtent2D minDstExtent;
		    VkExtent2D maxDstExtent;
		} VkDisplayPlaneCapabilitiesKHR;

		typedef struct VkDisplayPlanePropertiesKHR
		{
		    VkDisplayKHR currentDisplay;
		    uint32_t currentStackIndex;
		} VkDisplayPlanePropertiesKHR;

		typedef struct VkDisplayPropertiesKHR
		{
		    VkDisplayKHR display;
		    const char* displayName;
		    VkExtent2D physicalDimensions;
		    VkExtent2D physicalResolution;
		    VkSurfaceTransformFlagsKHR supportedTransforms;
		    VkBool32 planeReorderPossible;
		    VkBool32 persistentContent;
		} VkDisplayPropertiesKHR;

		typedef struct VkDisplaySurfaceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDisplaySurfaceCreateFlagsKHR flags;
		    VkDisplayModeKHR displayMode;
		    uint32_t planeIndex;
		    uint32_t planeStackIndex;
		    VkSurfaceTransformFlagBitsKHR transform;
		    float globalAlpha;
		    VkDisplayPlaneAlphaFlagBitsKHR alphaMode;
		    VkExtent2D imageExtent;
		} VkDisplaySurfaceCreateInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);


		#define VK_KHR_display_swapchain 1
		#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 10
		#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

		typedef struct VkDisplayPresentInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRect2D srcRect;
		    VkRect2D dstRect;
		    VkBool32 persistent;
		} VkDisplayPresentInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);


		#define VK_NV_glsl_shader 1
		#define VK_NV_GLSL_SHADER_SPEC_VERSION 1
		#define VK_NV_GLSL_SHADER_EXTENSION_NAME "VK_NV_glsl_shader"


		#define VK_EXT_depth_range_unrestricted 1
		#define VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION 1
		#define VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME "VK_EXT_depth_range_unrestricted"


		#define VK_KHR_sampler_mirror_clamp_to_edge 1
		#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 3
		#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"


		#define VK_IMG_filter_cubic 1
		#define VK_IMG_FILTER_CUBIC_SPEC_VERSION 1
		#define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"


		#define VK_AMD_rasterization_order 1
		#define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION 1
		#define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"

		typedef enum
		{
		    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
		    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
		    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
		} VkRasterizationOrderAMD;


		typedef struct VkPipelineRasterizationStateRasterizationOrderAMD
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRasterizationOrderAMD rasterizationOrder;
		} VkPipelineRasterizationStateRasterizationOrderAMD;


		#define VK_AMD_shader_trinary_minmax 1
		#define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
		#define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"


		#define VK_AMD_shader_explicit_vertex_parameter 1
		#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
		#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"


		#define VK_KHR_video_queue 1
		#define VK_KHR_VIDEO_QUEUE_SPEC_VERSION 8
		#define VK_KHR_VIDEO_QUEUE_EXTENSION_NAME "VK_KHR_video_queue"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkVideoSessionKHR)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkVideoSessionParametersKHR)


		typedef enum
		{
		    VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0,
		    VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR = 0x00010000,
		    VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR = 0x00020000,
		    VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x00000001,
		    VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x00000002,
		    VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR = 0x00000004,
		    VK_VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoCodecOperationFlagBitsKHR;
		typedef VkFlags VkVideoCodecOperationFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
		    VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x00000001,
		    VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x00000002,
		    VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x00000004,
		    VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x00000008,
		    VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoChromaSubsamplingFlagBitsKHR;
		typedef VkFlags VkVideoChromaSubsamplingFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
		    VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x00000001,
		    VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x00000004,
		    VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x00000010,
		    VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoComponentBitDepthFlagBitsKHR;
		typedef VkFlags VkVideoComponentBitDepthFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
		    VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x00000002,
		    VK_VIDEO_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoCapabilityFlagBitsKHR;
		typedef VkFlags VkVideoCapabilityFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x00000001,
		    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x00000002,
		    VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR = 0x00000004,
		    VK_VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoSessionCreateFlagBitsKHR;
		typedef VkFlags VkVideoSessionCreateFlagsKHR;
		typedef VkFlags VkVideoSessionParametersCreateFlagsKHR;
		typedef VkFlags VkVideoBeginCodingFlagsKHR;
		typedef VkFlags VkVideoEndCodingFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x00000001,
		    VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 0x00000002,
		    VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = 0x00000004,
		    VK_VIDEO_CODING_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoCodingControlFlagBitsKHR;
		typedef VkFlags VkVideoCodingControlFlagsKHR;
		typedef enum
		{
		    VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
		    VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
		    VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
		    VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR = -1000299000,
		    VK_QUERY_RESULT_STATUS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkQueryResultStatusKHR;


		typedef struct VkQueueFamilyQueryResultStatusPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 queryResultStatusSupport;
		} VkQueueFamilyQueryResultStatusPropertiesKHR;

		typedef struct VkQueueFamilyVideoPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoCodecOperationFlagsKHR videoCodecOperations;
		} VkQueueFamilyVideoPropertiesKHR;

		typedef struct VkVideoProfileInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoCodecOperationFlagBitsKHR videoCodecOperation;
		    VkVideoChromaSubsamplingFlagsKHR chromaSubsampling;
		    VkVideoComponentBitDepthFlagsKHR lumaBitDepth;
		    VkVideoComponentBitDepthFlagsKHR chromaBitDepth;
		} VkVideoProfileInfoKHR;

		typedef struct VkVideoProfileListInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t profileCount;
		    const VkVideoProfileInfoKHR* pProfiles;
		} VkVideoProfileListInfoKHR;

		typedef struct VkVideoCapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoCapabilityFlagsKHR flags;
		    VkDeviceSize minBitstreamBufferOffsetAlignment;
		    VkDeviceSize minBitstreamBufferSizeAlignment;
		    VkExtent2D pictureAccessGranularity;
		    VkExtent2D minCodedExtent;
		    VkExtent2D maxCodedExtent;
		    uint32_t maxDpbSlots;
		    uint32_t maxActiveReferencePictures;
		    VkExtensionProperties stdHeaderVersion;
		} VkVideoCapabilitiesKHR;

		typedef struct VkPhysicalDeviceVideoFormatInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageUsageFlags imageUsage;
		} VkPhysicalDeviceVideoFormatInfoKHR;

		typedef struct VkVideoFormatPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormat format;
		    VkComponentMapping componentMapping;
		    VkImageCreateFlags imageCreateFlags;
		    VkImageType imageType;
		    VkImageTiling imageTiling;
		    VkImageUsageFlags imageUsageFlags;
		} VkVideoFormatPropertiesKHR;

		typedef struct VkVideoPictureResourceInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkOffset2D codedOffset;
		    VkExtent2D codedExtent;
		    uint32_t baseArrayLayer;
		    VkImageView imageViewBinding;
		} VkVideoPictureResourceInfoKHR;

		typedef struct VkVideoReferenceSlotInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    int32_t slotIndex;
		    const VkVideoPictureResourceInfoKHR* pPictureResource;
		} VkVideoReferenceSlotInfoKHR;

		typedef struct VkVideoSessionMemoryRequirementsKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t memoryBindIndex;
		    VkMemoryRequirements memoryRequirements;
		} VkVideoSessionMemoryRequirementsKHR;

		typedef struct VkBindVideoSessionMemoryInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t memoryBindIndex;
		    VkDeviceMemory memory;
		    VkDeviceSize memoryOffset;
		    VkDeviceSize memorySize;
		} VkBindVideoSessionMemoryInfoKHR;

		typedef struct VkVideoSessionCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t queueFamilyIndex;
		    VkVideoSessionCreateFlagsKHR flags;
		    const VkVideoProfileInfoKHR* pVideoProfile;
		    VkFormat pictureFormat;
		    VkExtent2D maxCodedExtent;
		    VkFormat referencePictureFormat;
		    uint32_t maxDpbSlots;
		    uint32_t maxActiveReferencePictures;
		    const VkExtensionProperties* pStdHeaderVersion;
		} VkVideoSessionCreateInfoKHR;

		typedef struct VkVideoSessionParametersCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoSessionParametersCreateFlagsKHR flags;
		    VkVideoSessionParametersKHR videoSessionParametersTemplate;
		    VkVideoSessionKHR videoSession;
		} VkVideoSessionParametersCreateInfoKHR;

		typedef struct VkVideoSessionParametersUpdateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t updateSequenceCount;
		} VkVideoSessionParametersUpdateInfoKHR;

		typedef struct VkVideoBeginCodingInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoBeginCodingFlagsKHR flags;
		    VkVideoSessionKHR videoSession;
		    VkVideoSessionParametersKHR videoSessionParameters;
		    uint32_t referenceSlotCount;
		    const VkVideoReferenceSlotInfoKHR* pReferenceSlots;
		} VkVideoBeginCodingInfoKHR;

		typedef struct VkVideoEndCodingInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoEndCodingFlagsKHR flags;
		} VkVideoEndCodingInfoKHR;

		typedef struct VkVideoCodingControlInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoCodingControlFlagsKHR flags;
		} VkVideoCodingControlInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR* pVideoProfile, VkVideoCapabilitiesKHR* pCapabilities);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateVideoSessionKHR)(VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession);
		typedef void (VKAPI_PTR *PFN_vkDestroyVideoSessionKHR)(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetVideoSessionMemoryRequirementsKHR)(VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements);
		typedef VkResult (VKAPI_PTR *PFN_vkBindVideoSessionMemoryKHR)(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateVideoSessionParametersKHR)(VkDevice device, const VkVideoSessionParametersCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionParametersKHR* pVideoSessionParameters);
		typedef VkResult (VKAPI_PTR *PFN_vkUpdateVideoSessionParametersKHR)(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo);
		typedef void (VKAPI_PTR *PFN_vkDestroyVideoSessionParametersKHR)(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginVideoCodingKHR)(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR* pBeginInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdEndVideoCodingKHR)(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR* pEndCodingInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdControlVideoCodingKHR)(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR* pCodingControlInfo);


		#define VK_KHR_video_decode_queue 1
		#define VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION 8
		#define VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME "VK_KHR_video_decode_queue"


		typedef enum
		{
		    VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 0x00000001,
		    VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 0x00000002,
		    VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoDecodeCapabilityFlagBitsKHR;
		typedef VkFlags VkVideoDecodeCapabilityFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
		    VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
		    VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 0x00000002,
		    VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 0x00000004,
		    VK_VIDEO_DECODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoDecodeUsageFlagBitsKHR;
		typedef VkFlags VkVideoDecodeUsageFlagsKHR;
		typedef VkFlags VkVideoDecodeFlagsKHR;

		typedef struct VkVideoDecodeCapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoDecodeCapabilityFlagsKHR flags;
		} VkVideoDecodeCapabilitiesKHR;

		typedef struct VkVideoDecodeUsageInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoDecodeUsageFlagsKHR videoUsageHints;
		} VkVideoDecodeUsageInfoKHR;

		typedef struct VkVideoDecodeInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoDecodeFlagsKHR flags;
		    VkBuffer srcBuffer;
		    VkDeviceSize srcBufferOffset;
		    VkDeviceSize srcBufferRange;
		    VkVideoPictureResourceInfoKHR dstPictureResource;
		    const VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot;
		    uint32_t referenceSlotCount;
		    const VkVideoReferenceSlotInfoKHR* pReferenceSlots;
		} VkVideoDecodeInfoKHR;


		typedef void (VKAPI_PTR *PFN_vkCmdDecodeVideoKHR)(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo);


		#define VK_AMD_gcn_shader 1
		#define VK_AMD_GCN_SHADER_SPEC_VERSION 1
		#define VK_AMD_GCN_SHADER_EXTENSION_NAME "VK_AMD_gcn_shader"


		#define VK_EXT_transform_feedback 1
		#define VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION 1
		#define VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME "VK_EXT_transform_feedback"

		typedef VkFlags VkPipelineRasterizationStateStreamCreateFlagsEXT;
		typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 transformFeedback;
		    VkBool32 geometryStreams;
		} VkPhysicalDeviceTransformFeedbackFeaturesEXT;

		typedef struct VkPhysicalDeviceTransformFeedbackPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxTransformFeedbackStreams;
		    uint32_t maxTransformFeedbackBuffers;
		    VkDeviceSize maxTransformFeedbackBufferSize;
		    uint32_t maxTransformFeedbackStreamDataSize;
		    uint32_t maxTransformFeedbackBufferDataSize;
		    uint32_t maxTransformFeedbackBufferDataStride;
		    VkBool32 transformFeedbackQueries;
		    VkBool32 transformFeedbackStreamsLinesTriangles;
		    VkBool32 transformFeedbackRasterizationStreamSelect;
		    VkBool32 transformFeedbackDraw;
		} VkPhysicalDeviceTransformFeedbackPropertiesEXT;

		typedef struct VkPipelineRasterizationStateStreamCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineRasterizationStateStreamCreateFlagsEXT flags;
		    uint32_t rasterizationStream;
		} VkPipelineRasterizationStateStreamCreateInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdBindTransformFeedbackBuffersEXT)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginTransformFeedbackEXT)(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets);
		typedef void (VKAPI_PTR *PFN_vkCmdEndTransformFeedbackEXT)(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginQueryIndexedEXT)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index);
		typedef void (VKAPI_PTR *PFN_vkCmdEndQueryIndexedEXT)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectByteCountEXT)(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride);


		#define VK_NVX_binary_import 1
		#define VK_NVX_BINARY_IMPORT_SPEC_VERSION 1
		#define VK_NVX_BINARY_IMPORT_EXTENSION_NAME "VK_NVX_binary_import"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCuModuleNVX)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCuFunctionNVX)

		typedef struct VkCuModuleCreateInfoNVX
		{
		    VkStructureType sType;
		    const void* pNext;
		    size_t dataSize;
		    const void* pData;
		} VkCuModuleCreateInfoNVX;

		typedef struct VkCuFunctionCreateInfoNVX
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCuModuleNVX module;
		    const char* pName;
		} VkCuFunctionCreateInfoNVX;

		typedef struct VkCuLaunchInfoNVX
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCuFunctionNVX function;
		    uint32_t gridDimX;
		    uint32_t gridDimY;
		    uint32_t gridDimZ;
		    uint32_t blockDimX;
		    uint32_t blockDimY;
		    uint32_t blockDimZ;
		    uint32_t sharedMemBytes;
		    size_t paramCount;
		    const void* const * pParams;
		    size_t extraCount;
		    const void* const * pExtras;
		} VkCuLaunchInfoNVX;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateCuModuleNVX)(VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateCuFunctionNVX)(VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction);
		typedef void (VKAPI_PTR *PFN_vkDestroyCuModuleNVX)(VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkDestroyCuFunctionNVX)(VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkCmdCuLaunchKernelNVX)(VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo);


		#define VK_NVX_image_view_handle 1
		#define VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION 2
		#define VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME "VK_NVX_image_view_handle"

		typedef struct VkImageViewHandleInfoNVX
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageView imageView;
		    VkDescriptorType descriptorType;
		    VkSampler sampler;
		} VkImageViewHandleInfoNVX;

		typedef struct VkImageViewAddressPropertiesNVX
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceAddress deviceAddress;
		    VkDeviceSize size;
		} VkImageViewAddressPropertiesNVX;


		typedef uint32_t (VKAPI_PTR *PFN_vkGetImageViewHandleNVX)(VkDevice device, const VkImageViewHandleInfoNVX* pInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewAddressNVX)(VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties);


		#define VK_AMD_negative_viewport_height 1
		#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION 1
		#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME "VK_AMD_negative_viewport_height"


		#define VK_AMD_shader_ballot 1
		#define VK_AMD_SHADER_BALLOT_SPEC_VERSION 1
		#define VK_AMD_SHADER_BALLOT_EXTENSION_NAME "VK_AMD_shader_ballot"


		#define VK_KHR_video_encode_h264 1
		#define VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION 14
		#define VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME "VK_KHR_video_encode_h264"


		typedef enum
		{
		    VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR = 0x00000080,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR = 0x00000100,
		    VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH264CapabilityFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH264CapabilityFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR = 0x00000010,
		    VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
		    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
		    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR = 0x00000080,
		    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR = 0x00000100,
		    VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR = 0x00000200,
		    VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR = 0x00000400,
		    VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR = 0x00000800,
		    VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR = 0x00001000,
		    VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR = 0x00002000,
		    VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
		    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR = 0x00008000,
		    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR = 0x00010000,
		    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR = 0x00020000,
		    VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
		    VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
		    VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH264StdFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH264StdFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
		    VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH264RateControlFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH264RateControlFlagsKHR;

		typedef struct VkVideoEncodeH264CapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoEncodeH264CapabilityFlagsKHR flags;
		    StdVideoH264LevelIdc maxLevelIdc;
		    uint32_t maxSliceCount;
		    uint32_t maxPPictureL0ReferenceCount;
		    uint32_t maxBPictureL0ReferenceCount;
		    uint32_t maxL1ReferenceCount;
		    uint32_t maxTemporalLayerCount;
		    VkBool32 expectDyadicTemporalLayerPattern;
		    int32_t minQp;
		    int32_t maxQp;
		    VkBool32 prefersGopRemainingFrames;
		    VkBool32 requiresGopRemainingFrames;
		    VkVideoEncodeH264StdFlagsKHR stdSyntaxFlags;
		} VkVideoEncodeH264CapabilitiesKHR;

		typedef struct VkVideoEncodeH264QpKHR
		{
		    int32_t qpI;
		    int32_t qpP;
		    int32_t qpB;
		} VkVideoEncodeH264QpKHR;

		typedef struct VkVideoEncodeH264QualityLevelPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoEncodeH264RateControlFlagsKHR preferredRateControlFlags;
		    uint32_t preferredGopFrameCount;
		    uint32_t preferredIdrPeriod;
		    uint32_t preferredConsecutiveBFrameCount;
		    uint32_t preferredTemporalLayerCount;
		    VkVideoEncodeH264QpKHR preferredConstantQp;
		    uint32_t preferredMaxL0ReferenceCount;
		    uint32_t preferredMaxL1ReferenceCount;
		    VkBool32 preferredStdEntropyCodingModeFlag;
		} VkVideoEncodeH264QualityLevelPropertiesKHR;

		typedef struct VkVideoEncodeH264SessionCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 useMaxLevelIdc;
		    StdVideoH264LevelIdc maxLevelIdc;
		} VkVideoEncodeH264SessionCreateInfoKHR;

		typedef struct VkVideoEncodeH264SessionParametersAddInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t stdSPSCount;
		    const StdVideoH264SequenceParameterSet* pStdSPSs;
		    uint32_t stdPPSCount;
		    const StdVideoH264PictureParameterSet* pStdPPSs;
		} VkVideoEncodeH264SessionParametersAddInfoKHR;

		typedef struct VkVideoEncodeH264SessionParametersCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxStdSPSCount;
		    uint32_t maxStdPPSCount;
		    const VkVideoEncodeH264SessionParametersAddInfoKHR* pParametersAddInfo;
		} VkVideoEncodeH264SessionParametersCreateInfoKHR;

		typedef struct VkVideoEncodeH264SessionParametersGetInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 writeStdSPS;
		    VkBool32 writeStdPPS;
		    uint32_t stdSPSId;
		    uint32_t stdPPSId;
		} VkVideoEncodeH264SessionParametersGetInfoKHR;

		typedef struct VkVideoEncodeH264SessionParametersFeedbackInfoKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 hasStdSPSOverrides;
		    VkBool32 hasStdPPSOverrides;
		} VkVideoEncodeH264SessionParametersFeedbackInfoKHR;

		typedef struct VkVideoEncodeH264NaluSliceInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    int32_t constantQp;
		    const StdVideoEncodeH264SliceHeader* pStdSliceHeader;
		} VkVideoEncodeH264NaluSliceInfoKHR;

		typedef struct VkVideoEncodeH264PictureInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t naluSliceEntryCount;
		    const VkVideoEncodeH264NaluSliceInfoKHR* pNaluSliceEntries;
		    const StdVideoEncodeH264PictureInfo* pStdPictureInfo;
		    VkBool32 generatePrefixNalu;
		} VkVideoEncodeH264PictureInfoKHR;

		typedef struct VkVideoEncodeH264DpbSlotInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoEncodeH264ReferenceInfo* pStdReferenceInfo;
		} VkVideoEncodeH264DpbSlotInfoKHR;

		typedef struct VkVideoEncodeH264ProfileInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    StdVideoH264ProfileIdc stdProfileIdc;
		} VkVideoEncodeH264ProfileInfoKHR;

		typedef struct VkVideoEncodeH264RateControlInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoEncodeH264RateControlFlagsKHR flags;
		    uint32_t gopFrameCount;
		    uint32_t idrPeriod;
		    uint32_t consecutiveBFrameCount;
		    uint32_t temporalLayerCount;
		} VkVideoEncodeH264RateControlInfoKHR;

		typedef struct VkVideoEncodeH264FrameSizeKHR
		{
		    uint32_t frameISize;
		    uint32_t framePSize;
		    uint32_t frameBSize;
		} VkVideoEncodeH264FrameSizeKHR;

		typedef struct VkVideoEncodeH264RateControlLayerInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 useMinQp;
		    VkVideoEncodeH264QpKHR minQp;
		    VkBool32 useMaxQp;
		    VkVideoEncodeH264QpKHR maxQp;
		    VkBool32 useMaxFrameSize;
		    VkVideoEncodeH264FrameSizeKHR maxFrameSize;
		} VkVideoEncodeH264RateControlLayerInfoKHR;

		typedef struct VkVideoEncodeH264GopRemainingFrameInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 useGopRemainingFrames;
		    uint32_t gopRemainingI;
		    uint32_t gopRemainingP;
		    uint32_t gopRemainingB;
		} VkVideoEncodeH264GopRemainingFrameInfoKHR;


		#define VK_KHR_video_encode_h265 1
		#define VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION 14
		#define VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME "VK_KHR_video_encode_h265"


		typedef enum
		{
		    VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = 0x00000010,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = 0x00000020,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = 0x00000040,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR = 0x00000080,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR = 0x00000100,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR = 0x00000200,
		    VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH265CapabilityFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH265CapabilityFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR = 0x00000010,
		    VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR = 0x00000020,
		    VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = 0x00000040,
		    VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR = 0x00000080,
		    VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR = 0x00000100,
		    VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR = 0x00000200,
		    VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR = 0x00000400,
		    VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR = 0x00000800,
		    VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR = 0x00001000,
		    VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR = 0x00002000,
		    VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = 0x00004000,
		    VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR = 0x00008000,
		    VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR = 0x00010000,
		    VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR = 0x00020000,
		    VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR = 0x00040000,
		    VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR = 0x00080000,
		    VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = 0x00100000,
		    VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH265StdFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH265StdFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH265CtbSizeFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH265CtbSizeFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH265TransformBlockSizeFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH265TransformBlockSizeFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR = 0x00000010,
		    VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeH265RateControlFlagBitsKHR;
		typedef VkFlags VkVideoEncodeH265RateControlFlagsKHR;

		typedef struct VkVideoEncodeH265CapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoEncodeH265CapabilityFlagsKHR flags;
		    StdVideoH265LevelIdc maxLevelIdc;
		    uint32_t maxSliceSegmentCount;
		    VkExtent2D maxTiles;
		    VkVideoEncodeH265CtbSizeFlagsKHR ctbSizes;
		    VkVideoEncodeH265TransformBlockSizeFlagsKHR transformBlockSizes;
		    uint32_t maxPPictureL0ReferenceCount;
		    uint32_t maxBPictureL0ReferenceCount;
		    uint32_t maxL1ReferenceCount;
		    uint32_t maxSubLayerCount;
		    VkBool32 expectDyadicTemporalSubLayerPattern;
		    int32_t minQp;
		    int32_t maxQp;
		    VkBool32 prefersGopRemainingFrames;
		    VkBool32 requiresGopRemainingFrames;
		    VkVideoEncodeH265StdFlagsKHR stdSyntaxFlags;
		} VkVideoEncodeH265CapabilitiesKHR;

		typedef struct VkVideoEncodeH265SessionCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 useMaxLevelIdc;
		    StdVideoH265LevelIdc maxLevelIdc;
		} VkVideoEncodeH265SessionCreateInfoKHR;

		typedef struct VkVideoEncodeH265QpKHR
		{
		    int32_t qpI;
		    int32_t qpP;
		    int32_t qpB;
		} VkVideoEncodeH265QpKHR;

		typedef struct VkVideoEncodeH265QualityLevelPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoEncodeH265RateControlFlagsKHR preferredRateControlFlags;
		    uint32_t preferredGopFrameCount;
		    uint32_t preferredIdrPeriod;
		    uint32_t preferredConsecutiveBFrameCount;
		    uint32_t preferredSubLayerCount;
		    VkVideoEncodeH265QpKHR preferredConstantQp;
		    uint32_t preferredMaxL0ReferenceCount;
		    uint32_t preferredMaxL1ReferenceCount;
		} VkVideoEncodeH265QualityLevelPropertiesKHR;

		typedef struct VkVideoEncodeH265SessionParametersAddInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t stdVPSCount;
		    const StdVideoH265VideoParameterSet* pStdVPSs;
		    uint32_t stdSPSCount;
		    const StdVideoH265SequenceParameterSet* pStdSPSs;
		    uint32_t stdPPSCount;
		    const StdVideoH265PictureParameterSet* pStdPPSs;
		} VkVideoEncodeH265SessionParametersAddInfoKHR;

		typedef struct VkVideoEncodeH265SessionParametersCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxStdVPSCount;
		    uint32_t maxStdSPSCount;
		    uint32_t maxStdPPSCount;
		    const VkVideoEncodeH265SessionParametersAddInfoKHR* pParametersAddInfo;
		} VkVideoEncodeH265SessionParametersCreateInfoKHR;

		typedef struct VkVideoEncodeH265SessionParametersGetInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 writeStdVPS;
		    VkBool32 writeStdSPS;
		    VkBool32 writeStdPPS;
		    uint32_t stdVPSId;
		    uint32_t stdSPSId;
		    uint32_t stdPPSId;
		} VkVideoEncodeH265SessionParametersGetInfoKHR;

		typedef struct VkVideoEncodeH265SessionParametersFeedbackInfoKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 hasStdVPSOverrides;
		    VkBool32 hasStdSPSOverrides;
		    VkBool32 hasStdPPSOverrides;
		} VkVideoEncodeH265SessionParametersFeedbackInfoKHR;

		typedef struct VkVideoEncodeH265NaluSliceSegmentInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    int32_t constantQp;
		    const StdVideoEncodeH265SliceSegmentHeader* pStdSliceSegmentHeader;
		} VkVideoEncodeH265NaluSliceSegmentInfoKHR;

		typedef struct VkVideoEncodeH265PictureInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t naluSliceSegmentEntryCount;
		    const VkVideoEncodeH265NaluSliceSegmentInfoKHR* pNaluSliceSegmentEntries;
		    const StdVideoEncodeH265PictureInfo* pStdPictureInfo;
		} VkVideoEncodeH265PictureInfoKHR;

		typedef struct VkVideoEncodeH265DpbSlotInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoEncodeH265ReferenceInfo* pStdReferenceInfo;
		} VkVideoEncodeH265DpbSlotInfoKHR;

		typedef struct VkVideoEncodeH265ProfileInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    StdVideoH265ProfileIdc stdProfileIdc;
		} VkVideoEncodeH265ProfileInfoKHR;

		typedef struct VkVideoEncodeH265RateControlInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoEncodeH265RateControlFlagsKHR flags;
		    uint32_t gopFrameCount;
		    uint32_t idrPeriod;
		    uint32_t consecutiveBFrameCount;
		    uint32_t subLayerCount;
		} VkVideoEncodeH265RateControlInfoKHR;

		typedef struct VkVideoEncodeH265FrameSizeKHR
		{
		    uint32_t frameISize;
		    uint32_t framePSize;
		    uint32_t frameBSize;
		} VkVideoEncodeH265FrameSizeKHR;

		typedef struct VkVideoEncodeH265RateControlLayerInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 useMinQp;
		    VkVideoEncodeH265QpKHR minQp;
		    VkBool32 useMaxQp;
		    VkVideoEncodeH265QpKHR maxQp;
		    VkBool32 useMaxFrameSize;
		    VkVideoEncodeH265FrameSizeKHR maxFrameSize;
		} VkVideoEncodeH265RateControlLayerInfoKHR;

		typedef struct VkVideoEncodeH265GopRemainingFrameInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 useGopRemainingFrames;
		    uint32_t gopRemainingI;
		    uint32_t gopRemainingP;
		    uint32_t gopRemainingB;
		} VkVideoEncodeH265GopRemainingFrameInfoKHR;


		#define VK_KHR_video_decode_h264 1
		#define VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION 9
		#define VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME "VK_KHR_video_decode_h264"


		typedef enum
		{
		    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR = 0,
		    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = 0x00000001,
		    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = 0x00000002,
		    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoDecodeH264PictureLayoutFlagBitsKHR;
		typedef VkFlags VkVideoDecodeH264PictureLayoutFlagsKHR;

		typedef struct VkVideoDecodeH264ProfileInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    StdVideoH264ProfileIdc stdProfileIdc;
		    VkVideoDecodeH264PictureLayoutFlagBitsKHR pictureLayout;
		} VkVideoDecodeH264ProfileInfoKHR;

		typedef struct VkVideoDecodeH264CapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    StdVideoH264LevelIdc maxLevelIdc;
		    VkOffset2D fieldOffsetGranularity;
		} VkVideoDecodeH264CapabilitiesKHR;

		typedef struct VkVideoDecodeH264SessionParametersAddInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t stdSPSCount;
		    const StdVideoH264SequenceParameterSet* pStdSPSs;
		    uint32_t stdPPSCount;
		    const StdVideoH264PictureParameterSet* pStdPPSs;
		} VkVideoDecodeH264SessionParametersAddInfoKHR;

		typedef struct VkVideoDecodeH264SessionParametersCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxStdSPSCount;
		    uint32_t maxStdPPSCount;
		    const VkVideoDecodeH264SessionParametersAddInfoKHR* pParametersAddInfo;
		} VkVideoDecodeH264SessionParametersCreateInfoKHR;

		typedef struct VkVideoDecodeH264PictureInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoDecodeH264PictureInfo* pStdPictureInfo;
		    uint32_t sliceCount;
		    const uint32_t* pSliceOffsets;
		} VkVideoDecodeH264PictureInfoKHR;

		typedef struct VkVideoDecodeH264DpbSlotInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoDecodeH264ReferenceInfo* pStdReferenceInfo;
		} VkVideoDecodeH264DpbSlotInfoKHR;


		#define VK_AMD_texture_gather_bias_lod 1
		#define VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION 1
		#define VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME "VK_AMD_texture_gather_bias_lod"

		typedef struct VkTextureLODGatherFormatPropertiesAMD
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 supportsTextureGatherLODBiasAMD;
		} VkTextureLODGatherFormatPropertiesAMD;


		#define VK_AMD_shader_info 1
		#define VK_AMD_SHADER_INFO_SPEC_VERSION 1
		#define VK_AMD_SHADER_INFO_EXTENSION_NAME "VK_AMD_shader_info"

		typedef enum
		{
		    VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
		    VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
		    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
		    VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7FFFFFFF
		} VkShaderInfoTypeAMD;


		typedef struct VkShaderResourceUsageAMD
		{
		    uint32_t numUsedVgprs;
		    uint32_t numUsedSgprs;
		    uint32_t ldsSizePerLocalWorkGroup;
		    size_t ldsUsageSizeInBytes;
		    size_t scratchMemUsageInBytes;
		} VkShaderResourceUsageAMD;

		typedef struct VkShaderStatisticsInfoAMD
		{
		    VkShaderStageFlags shaderStageMask;
		    VkShaderResourceUsageAMD resourceUsage;
		    uint32_t numPhysicalVgprs;
		    uint32_t numPhysicalSgprs;
		    uint32_t numAvailableVgprs;
		    uint32_t numAvailableSgprs;
		    uint32_t computeWorkGroupSize[3];
		} VkShaderStatisticsInfoAMD;


		typedef VkResult (VKAPI_PTR *PFN_vkGetShaderInfoAMD)(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo);


		#define VK_KHR_dynamic_rendering 1
		#define VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION 1
		#define VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME "VK_KHR_dynamic_rendering"

		typedef VkRenderingFlags VkRenderingFlagsKHR;
		typedef VkRenderingFlagBits VkRenderingFlagBitsKHR;
		typedef VkRenderingInfo VkRenderingInfoKHR;

		typedef VkRenderingAttachmentInfo VkRenderingAttachmentInfoKHR;

		typedef VkPipelineRenderingCreateInfo VkPipelineRenderingCreateInfoKHR;

		typedef VkPhysicalDeviceDynamicRenderingFeatures VkPhysicalDeviceDynamicRenderingFeaturesKHR;

		typedef VkCommandBufferInheritanceRenderingInfo VkCommandBufferInheritanceRenderingInfoKHR;

		typedef struct VkRenderingFragmentShadingRateAttachmentInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageView imageView;
		    VkImageLayout imageLayout;
		    VkExtent2D shadingRateAttachmentTexelSize;
		} VkRenderingFragmentShadingRateAttachmentInfoKHR;

		typedef struct VkRenderingFragmentDensityMapAttachmentInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageView imageView;
		    VkImageLayout imageLayout;
		} VkRenderingFragmentDensityMapAttachmentInfoEXT;

		typedef struct VkAttachmentSampleCountInfoAMD
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t colorAttachmentCount;
		    const VkSampleCountFlagBits* pColorAttachmentSamples;
		    VkSampleCountFlagBits depthStencilAttachmentSamples;
		} VkAttachmentSampleCountInfoAMD;

		typedef VkAttachmentSampleCountInfoAMD VkAttachmentSampleCountInfoNV;

		typedef struct VkMultiviewPerViewAttributesInfoNVX
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 perViewAttributes;
		    VkBool32 perViewAttributesPositionXOnly;
		} VkMultiviewPerViewAttributesInfoNVX;


		typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderingKHR)(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdEndRenderingKHR)(VkCommandBuffer commandBuffer);


		#define VK_AMD_shader_image_load_store_lod 1
		#define VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION 1
		#define VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME "VK_AMD_shader_image_load_store_lod"


		#define VK_NV_corner_sampled_image 1
		#define VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION 2
		#define VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME "VK_NV_corner_sampled_image"

		typedef struct VkPhysicalDeviceCornerSampledImageFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 cornerSampledImage;
		} VkPhysicalDeviceCornerSampledImageFeaturesNV;


		#define VK_NV_private_vendor_info 1
		#define VK_NV_PRIVATE_VENDOR_INFO_SPEC_VERSION 2
		#define VK_NV_PRIVATE_VENDOR_INFO_EXTENSION_NAME "VK_NV_private_vendor_info"


		#define VK_KHR_multiview 1
		#define VK_KHR_MULTIVIEW_SPEC_VERSION 1
		#define VK_KHR_MULTIVIEW_EXTENSION_NAME "VK_KHR_multiview"

		typedef VkRenderPassMultiviewCreateInfo VkRenderPassMultiviewCreateInfoKHR;

		typedef VkPhysicalDeviceMultiviewFeatures VkPhysicalDeviceMultiviewFeaturesKHR;

		typedef VkPhysicalDeviceMultiviewProperties VkPhysicalDeviceMultiviewPropertiesKHR;


		#define VK_IMG_format_pvrtc 1
		#define VK_IMG_FORMAT_PVRTC_SPEC_VERSION 1
		#define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"


		#define VK_KHR_get_physical_device_properties2 1
		#define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION 2
		#define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_physical_device_properties2"

		typedef VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2KHR;

		typedef VkPhysicalDeviceProperties2 VkPhysicalDeviceProperties2KHR;

		typedef VkFormatProperties2 VkFormatProperties2KHR;

		typedef VkImageFormatProperties2 VkImageFormatProperties2KHR;

		typedef VkPhysicalDeviceImageFormatInfo2 VkPhysicalDeviceImageFormatInfo2KHR;

		typedef VkQueueFamilyProperties2 VkQueueFamilyProperties2KHR;

		typedef VkPhysicalDeviceMemoryProperties2 VkPhysicalDeviceMemoryProperties2KHR;

		typedef VkSparseImageFormatProperties2 VkSparseImageFormatProperties2KHR;

		typedef VkPhysicalDeviceSparseImageFormatInfo2 VkPhysicalDeviceSparseImageFormatInfo2KHR;

		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties2KHR)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);


		#define VK_KHR_device_group 1
		#define VK_KHR_DEVICE_GROUP_SPEC_VERSION 4
		#define VK_KHR_DEVICE_GROUP_EXTENSION_NAME "VK_KHR_device_group"

		typedef VkPeerMemoryFeatureFlags VkPeerMemoryFeatureFlagsKHR;
		typedef VkPeerMemoryFeatureFlagBits VkPeerMemoryFeatureFlagBitsKHR;
		typedef VkMemoryAllocateFlags VkMemoryAllocateFlagsKHR;
		typedef VkMemoryAllocateFlagBits VkMemoryAllocateFlagBitsKHR;
		typedef VkMemoryAllocateFlagsInfo VkMemoryAllocateFlagsInfoKHR;

		typedef VkDeviceGroupRenderPassBeginInfo VkDeviceGroupRenderPassBeginInfoKHR;

		typedef VkDeviceGroupCommandBufferBeginInfo VkDeviceGroupCommandBufferBeginInfoKHR;

		typedef VkDeviceGroupSubmitInfo VkDeviceGroupSubmitInfoKHR;

		typedef VkDeviceGroupBindSparseInfo VkDeviceGroupBindSparseInfoKHR;

		typedef VkBindBufferMemoryDeviceGroupInfo VkBindBufferMemoryDeviceGroupInfoKHR;

		typedef VkBindImageMemoryDeviceGroupInfo VkBindImageMemoryDeviceGroupInfoKHR;

		typedef void (VKAPI_PTR *PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDeviceMaskKHR)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
		typedef void (VKAPI_PTR *PFN_vkCmdDispatchBaseKHR)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);


		#define VK_KHR_shader_draw_parameters 1
		#define VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION 1
		#define VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME "VK_KHR_shader_draw_parameters"


		#define VK_EXT_shader_subgroup_ballot 1
		#define VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION 1
		#define VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME "VK_EXT_shader_subgroup_ballot"


		#define VK_EXT_shader_subgroup_vote 1
		#define VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION 1
		#define VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME "VK_EXT_shader_subgroup_vote"


		#define VK_EXT_texture_compression_astc_hdr 1
		#define VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION 1
		#define VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME "VK_EXT_texture_compression_astc_hdr"

		typedef VkPhysicalDeviceTextureCompressionASTCHDRFeatures VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;


		#define VK_EXT_astc_decode_mode 1
		#define VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION 1
		#define VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME "VK_EXT_astc_decode_mode"

		typedef struct VkImageViewASTCDecodeModeEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFormat decodeMode;
		} VkImageViewASTCDecodeModeEXT;

		typedef struct VkPhysicalDeviceASTCDecodeFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 decodeModeSharedExponent;
		} VkPhysicalDeviceASTCDecodeFeaturesEXT;


		#define VK_EXT_pipeline_robustness 1
		#define VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION 1
		#define VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME "VK_EXT_pipeline_robustness"

		typedef enum
		{
		    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
		    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = 1,
		    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = 2,
		    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = 3,
		    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkPipelineRobustnessBufferBehaviorEXT;

		typedef enum
		{
		    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
		    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = 1,
		    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = 2,
		    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = 3,
		    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkPipelineRobustnessImageBehaviorEXT;


		typedef struct VkPhysicalDevicePipelineRobustnessFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pipelineRobustness;
		} VkPhysicalDevicePipelineRobustnessFeaturesEXT;

		typedef struct VkPhysicalDevicePipelineRobustnessPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPipelineRobustnessBufferBehaviorEXT defaultRobustnessStorageBuffers;
		    VkPipelineRobustnessBufferBehaviorEXT defaultRobustnessUniformBuffers;
		    VkPipelineRobustnessBufferBehaviorEXT defaultRobustnessVertexInputs;
		    VkPipelineRobustnessImageBehaviorEXT defaultRobustnessImages;
		} VkPhysicalDevicePipelineRobustnessPropertiesEXT;

		typedef struct VkPipelineRobustnessCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineRobustnessBufferBehaviorEXT storageBuffers;
		    VkPipelineRobustnessBufferBehaviorEXT uniformBuffers;
		    VkPipelineRobustnessBufferBehaviorEXT vertexInputs;
		    VkPipelineRobustnessImageBehaviorEXT images;
		} VkPipelineRobustnessCreateInfoEXT;


		#define VK_KHR_maintenance1 1
		#define VK_KHR_MAINTENANCE_1_SPEC_VERSION 2
		#define VK_KHR_MAINTENANCE_1_EXTENSION_NAME "VK_KHR_maintenance1"

		typedef VkCommandPoolTrimFlags VkCommandPoolTrimFlagsKHR;
		typedef void (VKAPI_PTR *PFN_vkTrimCommandPoolKHR)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags);


		#define VK_KHR_device_group_creation 1
		#define VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION 1
		#define VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME "VK_KHR_device_group_creation"

		#define VK_MAX_DEVICE_GROUP_SIZE_KHR VK_MAX_DEVICE_GROUP_SIZE

		typedef VkPhysicalDeviceGroupProperties VkPhysicalDeviceGroupPropertiesKHR;

		typedef VkDeviceGroupDeviceCreateInfo VkDeviceGroupDeviceCreateInfoKHR;

		typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDeviceGroupsKHR)(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);


		#define VK_KHR_external_memory_capabilities 1
		#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_memory_capabilities"

		#define VK_LUID_SIZE_KHR VK_LUID_SIZE

		typedef VkExternalMemoryHandleTypeFlags VkExternalMemoryHandleTypeFlagsKHR;
		typedef VkExternalMemoryHandleTypeFlagBits VkExternalMemoryHandleTypeFlagBitsKHR;
		typedef VkExternalMemoryFeatureFlags VkExternalMemoryFeatureFlagsKHR;
		typedef VkExternalMemoryFeatureFlagBits VkExternalMemoryFeatureFlagBitsKHR;
		typedef VkExternalMemoryProperties VkExternalMemoryPropertiesKHR;

		typedef VkPhysicalDeviceExternalImageFormatInfo VkPhysicalDeviceExternalImageFormatInfoKHR;

		typedef VkExternalImageFormatProperties VkExternalImageFormatPropertiesKHR;

		typedef VkPhysicalDeviceExternalBufferInfo VkPhysicalDeviceExternalBufferInfoKHR;

		typedef VkExternalBufferProperties VkExternalBufferPropertiesKHR;

		typedef VkPhysicalDeviceIDProperties VkPhysicalDeviceIDPropertiesKHR;

		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties);


		#define VK_NV_external_memory_capabilities 1
		#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
		#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"


		typedef enum
		{
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
		    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkExternalMemoryHandleTypeFlagBitsNV;
		typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;

		typedef enum
		{
		    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
		    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
		    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
		    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkExternalMemoryFeatureFlagBitsNV;
		typedef VkFlags VkExternalMemoryFeatureFlagsNV;

		typedef struct VkExternalImageFormatPropertiesNV
		{
		    VkImageFormatProperties imageFormatProperties;
		    VkExternalMemoryFeatureFlagsNV externalMemoryFeatures;
		    VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes;
		    VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes;
		} VkExternalImageFormatPropertiesNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);


		#define VK_KHR_external_memory 1
		#define VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"

		#define VK_QUEUE_FAMILY_EXTERNAL_KHR VK_QUEUE_FAMILY_EXTERNAL

		typedef VkExternalMemoryImageCreateInfo VkExternalMemoryImageCreateInfoKHR;

		typedef VkExternalMemoryBufferCreateInfo VkExternalMemoryBufferCreateInfoKHR;

		typedef VkExportMemoryAllocateInfo VkExportMemoryAllocateInfoKHR;


		#define VK_NV_external_memory 1
		#define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
		#define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

		typedef struct VkExternalMemoryImageCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagsNV handleTypes;
		} VkExternalMemoryImageCreateInfoNV;

		typedef struct VkExportMemoryAllocateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagsNV handleTypes;
		} VkExportMemoryAllocateInfoNV;


		#define VK_KHR_external_memory_fd 1
		#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"

		typedef struct VkImportMemoryFdInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		    int fd;
		} VkImportMemoryFdInfoKHR;

		typedef struct VkMemoryFdPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t memoryTypeBits;
		} VkMemoryFdPropertiesKHR;

		typedef struct VkMemoryGetFdInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		} VkMemoryGetFdInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd);
		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties);


		#define VK_KHR_external_semaphore_capabilities 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"

		typedef VkExternalSemaphoreHandleTypeFlags VkExternalSemaphoreHandleTypeFlagsKHR;
		typedef VkExternalSemaphoreHandleTypeFlagBits VkExternalSemaphoreHandleTypeFlagBitsKHR;
		typedef VkExternalSemaphoreFeatureFlags VkExternalSemaphoreFeatureFlagsKHR;
		typedef VkExternalSemaphoreFeatureFlagBits VkExternalSemaphoreFeatureFlagBitsKHR;
		typedef VkPhysicalDeviceExternalSemaphoreInfo VkPhysicalDeviceExternalSemaphoreInfoKHR;

		typedef VkExternalSemaphoreProperties VkExternalSemaphorePropertiesKHR;

		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties);


		#define VK_KHR_external_semaphore 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"

		typedef VkSemaphoreImportFlags VkSemaphoreImportFlagsKHR;
		typedef VkSemaphoreImportFlagBits VkSemaphoreImportFlagBitsKHR;
		typedef VkExportSemaphoreCreateInfo VkExportSemaphoreCreateInfoKHR;


		#define VK_KHR_external_semaphore_fd 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"

		typedef struct VkImportSemaphoreFdInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkSemaphoreImportFlags flags;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		    int fd;
		} VkImportSemaphoreFdInfoKHR;

		typedef struct VkSemaphoreGetFdInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		} VkSemaphoreGetFdInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);


		#define VK_KHR_push_descriptor 1
		#define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
		#define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"

		typedef struct VkPhysicalDevicePushDescriptorPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxPushDescriptors;
		} VkPhysicalDevicePushDescriptorPropertiesKHR;


		typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetKHR)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites);
		typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetWithTemplateKHR)(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData);


		#define VK_EXT_conditional_rendering 1
		#define VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION 2
		#define VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME "VK_EXT_conditional_rendering"


		typedef enum
		{
		    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001,
		    VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkConditionalRenderingFlagBitsEXT;
		typedef VkFlags VkConditionalRenderingFlagsEXT;

		typedef struct VkConditionalRenderingBeginInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer buffer;
		    VkDeviceSize offset;
		    VkConditionalRenderingFlagsEXT flags;
		} VkConditionalRenderingBeginInfoEXT;

		typedef struct VkPhysicalDeviceConditionalRenderingFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 conditionalRendering;
		    VkBool32 inheritedConditionalRendering;
		} VkPhysicalDeviceConditionalRenderingFeaturesEXT;

		typedef struct VkCommandBufferInheritanceConditionalRenderingInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 conditionalRenderingEnable;
		} VkCommandBufferInheritanceConditionalRenderingInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdBeginConditionalRenderingEXT)(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin);
		typedef void (VKAPI_PTR *PFN_vkCmdEndConditionalRenderingEXT)(VkCommandBuffer commandBuffer);


		#define VK_KHR_shader_float16_int8 1
		#define VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION 1
		#define VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME "VK_KHR_shader_float16_int8"

		typedef VkPhysicalDeviceShaderFloat16Int8Features VkPhysicalDeviceShaderFloat16Int8FeaturesKHR;

		typedef VkPhysicalDeviceShaderFloat16Int8Features VkPhysicalDeviceFloat16Int8FeaturesKHR;


		#define VK_AMD_gpu_shader_half_float 1
		#define VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION 2
		#define VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME "VK_AMD_gpu_shader_half_float"


		#define VK_KHR_16bit_storage 1
		#define VK_KHR_16BIT_STORAGE_SPEC_VERSION 1
		#define VK_KHR_16BIT_STORAGE_EXTENSION_NAME "VK_KHR_16bit_storage"

		typedef VkPhysicalDevice16BitStorageFeatures VkPhysicalDevice16BitStorageFeaturesKHR;


		#define VK_KHR_incremental_present 1
		#define VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION 2
		#define VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME "VK_KHR_incremental_present"

		typedef struct VkRectLayerKHR
		{
		    VkOffset2D offset;
		    VkExtent2D extent;
		    uint32_t layer;
		} VkRectLayerKHR;

		typedef struct VkPresentRegionKHR
		{
		    uint32_t rectangleCount;
		    const VkRectLayerKHR* pRectangles;
		} VkPresentRegionKHR;

		typedef struct VkPresentRegionsKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t swapchainCount;
		    const VkPresentRegionKHR* pRegions;
		} VkPresentRegionsKHR;


		#define VK_KHR_descriptor_update_template 1
		#define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION 1
		#define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME "VK_KHR_descriptor_update_template"

		typedef VkDescriptorUpdateTemplate VkDescriptorUpdateTemplateKHR;
		typedef VkDescriptorUpdateTemplateCreateFlags VkDescriptorUpdateTemplateCreateFlagsKHR;
		typedef VkDescriptorUpdateTemplateType VkDescriptorUpdateTemplateTypeKHR;
		typedef VkDescriptorUpdateTemplateEntry VkDescriptorUpdateTemplateEntryKHR;

		typedef VkDescriptorUpdateTemplateCreateInfo VkDescriptorUpdateTemplateCreateInfoKHR;

		typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorUpdateTemplateKHR)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);
		typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorUpdateTemplateKHR)(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSetWithTemplateKHR)(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData);


		#define VK_NV_clip_space_w_scaling 1
		#define VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION 1
		#define VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME "VK_NV_clip_space_w_scaling"

		typedef struct VkViewportWScalingNV
		{
		    float xcoeff;
		    float ycoeff;
		} VkViewportWScalingNV;

		typedef struct VkPipelineViewportWScalingStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 viewportWScalingEnable;
		    uint32_t viewportCount;
		    const VkViewportWScalingNV* pViewportWScalings;
		} VkPipelineViewportWScalingStateCreateInfoNV;


		typedef void (VKAPI_PTR *PFN_vkCmdSetViewportWScalingNV)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings);


		#define VK_EXT_direct_mode_display 1
		#define VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION 1
		#define VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME "VK_EXT_direct_mode_display"

		typedef VkResult (VKAPI_PTR *PFN_vkReleaseDisplayEXT)(VkPhysicalDevice physicalDevice, VkDisplayKHR display);


		#define VK_EXT_display_surface_counter 1
		#define VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION 1
		#define VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME "VK_EXT_display_surface_counter"


		typedef enum
		{
		    VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x00000001,
		    VK_SURFACE_COUNTER_VBLANK_EXT = VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
		    VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkSurfaceCounterFlagBitsEXT;
		typedef VkFlags VkSurfaceCounterFlagsEXT;

		typedef struct VkSurfaceCapabilities2EXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t minImageCount;
		    uint32_t maxImageCount;
		    VkExtent2D currentExtent;
		    VkExtent2D minImageExtent;
		    VkExtent2D maxImageExtent;
		    uint32_t maxImageArrayLayers;
		    VkSurfaceTransformFlagsKHR supportedTransforms;
		    VkSurfaceTransformFlagBitsKHR currentTransform;
		    VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
		    VkImageUsageFlags supportedUsageFlags;
		    VkSurfaceCounterFlagsEXT supportedSurfaceCounters;
		} VkSurfaceCapabilities2EXT;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities);


		#define VK_EXT_display_control 1
		#define VK_EXT_DISPLAY_CONTROL_SPEC_VERSION 1
		#define VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME "VK_EXT_display_control"

		typedef enum
		{
		    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
		    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
		    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
		    VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDisplayPowerStateEXT;

		typedef enum
		{
		    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
		    VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDeviceEventTypeEXT;

		typedef enum
		{
		    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
		    VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDisplayEventTypeEXT;


		typedef struct VkDisplayPowerInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDisplayPowerStateEXT powerState;
		} VkDisplayPowerInfoEXT;

		typedef struct VkDeviceEventInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceEventTypeEXT deviceEvent;
		} VkDeviceEventInfoEXT;

		typedef struct VkDisplayEventInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDisplayEventTypeEXT displayEvent;
		} VkDisplayEventInfoEXT;

		typedef struct VkSwapchainCounterCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSurfaceCounterFlagsEXT surfaceCounters;
		} VkSwapchainCounterCreateInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkDisplayPowerControlEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkRegisterDeviceEventEXT)(VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
		typedef VkResult (VKAPI_PTR *PFN_vkRegisterDisplayEventEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence);
		typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainCounterEXT)(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue);


		#define VK_GOOGLE_display_timing 1
		#define VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION 1
		#define VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME "VK_GOOGLE_display_timing"

		typedef struct VkRefreshCycleDurationGOOGLE
		{
		    uint64_t refreshDuration;
		} VkRefreshCycleDurationGOOGLE;

		typedef struct VkPastPresentationTimingGOOGLE
		{
		    uint32_t presentID;
		    uint64_t desiredPresentTime;
		    uint64_t actualPresentTime;
		    uint64_t earliestPresentTime;
		    uint64_t presentMargin;
		} VkPastPresentationTimingGOOGLE;

		typedef struct VkPresentTimeGOOGLE
		{
		    uint32_t presentID;
		    uint64_t desiredPresentTime;
		} VkPresentTimeGOOGLE;

		typedef struct VkPresentTimesInfoGOOGLE
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t swapchainCount;
		    const VkPresentTimeGOOGLE* pTimes;
		} VkPresentTimesInfoGOOGLE;


		typedef VkResult (VKAPI_PTR *PFN_vkGetRefreshCycleDurationGOOGLE)(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPastPresentationTimingGOOGLE)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings);


		#define VK_NV_sample_mask_override_coverage 1
		#define VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION 1
		#define VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME "VK_NV_sample_mask_override_coverage"


		#define VK_NV_geometry_shader_passthrough 1
		#define VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION 1
		#define VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME "VK_NV_geometry_shader_passthrough"


		#define VK_NV_viewport_array2 1
		#define VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION 1
		#define VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME "VK_NV_viewport_array2"


		#define VK_NVX_multiview_per_view_attributes 1
		#define VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION 1
		#define VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME "VK_NVX_multiview_per_view_attributes"

		typedef struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 perViewPositionAllComponents;
		} VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;


		#define VK_NV_viewport_swizzle 1
		#define VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION 1
		#define VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME "VK_NV_viewport_swizzle"

		typedef enum
		{
		    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
		    VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkViewportCoordinateSwizzleNV;

		typedef VkFlags VkPipelineViewportSwizzleStateCreateFlagsNV;

		typedef struct VkViewportSwizzleNV
		{
		    VkViewportCoordinateSwizzleNV x;
		    VkViewportCoordinateSwizzleNV y;
		    VkViewportCoordinateSwizzleNV z;
		    VkViewportCoordinateSwizzleNV w;
		} VkViewportSwizzleNV;

		typedef struct VkPipelineViewportSwizzleStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineViewportSwizzleStateCreateFlagsNV flags;
		    uint32_t viewportCount;
		    const VkViewportSwizzleNV* pViewportSwizzles;
		} VkPipelineViewportSwizzleStateCreateInfoNV;


		#define VK_EXT_discard_rectangles 1
		#define VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION 2
		#define VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME "VK_EXT_discard_rectangles"

		typedef VkFlags VkPipelineDiscardRectangleStateCreateFlagsEXT;
		typedef enum
		{
		    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
		    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
		    VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDiscardRectangleModeEXT;


		typedef struct VkPhysicalDeviceDiscardRectanglePropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxDiscardRectangles;
		} VkPhysicalDeviceDiscardRectanglePropertiesEXT;

		typedef struct VkPipelineDiscardRectangleStateCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineDiscardRectangleStateCreateFlagsEXT flags;
		    VkDiscardRectangleModeEXT discardRectangleMode;
		    uint32_t discardRectangleCount;
		    const VkRect2D* pDiscardRectangles;
		} VkPipelineDiscardRectangleStateCreateInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetDiscardRectangleEXT)(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDiscardRectangleEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDiscardRectangleModeEXT)(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode);


		#define VK_EXT_conservative_rasterization 1
		#define VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION 1
		#define VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME "VK_EXT_conservative_rasterization"

		typedef VkFlags VkPipelineRasterizationConservativeStateCreateFlagsEXT;
		typedef enum
		{
		    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
		    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
		    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
		    VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkConservativeRasterizationModeEXT;


		typedef struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    float primitiveOverestimationSize;
		    float maxExtraPrimitiveOverestimationSize;
		    float extraPrimitiveOverestimationSizeGranularity;
		    VkBool32 primitiveUnderestimation;
		    VkBool32 conservativePointAndLineRasterization;
		    VkBool32 degenerateTrianglesRasterized;
		    VkBool32 degenerateLinesRasterized;
		    VkBool32 fullyCoveredFragmentShaderInputVariable;
		    VkBool32 conservativeRasterizationPostDepthCoverage;
		} VkPhysicalDeviceConservativeRasterizationPropertiesEXT;

		typedef struct VkPipelineRasterizationConservativeStateCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineRasterizationConservativeStateCreateFlagsEXT flags;
		    VkConservativeRasterizationModeEXT conservativeRasterizationMode;
		    float extraPrimitiveOverestimationSize;
		} VkPipelineRasterizationConservativeStateCreateInfoEXT;


		#define VK_EXT_depth_clip_enable 1
		#define VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION 1
		#define VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME "VK_EXT_depth_clip_enable"

		typedef VkFlags VkPipelineRasterizationDepthClipStateCreateFlagsEXT;
		typedef struct VkPhysicalDeviceDepthClipEnableFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 depthClipEnable;
		} VkPhysicalDeviceDepthClipEnableFeaturesEXT;

		typedef struct VkPipelineRasterizationDepthClipStateCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags;
		    VkBool32 depthClipEnable;
		} VkPipelineRasterizationDepthClipStateCreateInfoEXT;


		#define VK_EXT_swapchain_colorspace 1
		#define VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION 4
		#define VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME "VK_EXT_swapchain_colorspace"


		#define VK_EXT_hdr_metadata 1
		#define VK_EXT_HDR_METADATA_SPEC_VERSION 2
		#define VK_EXT_HDR_METADATA_EXTENSION_NAME "VK_EXT_hdr_metadata"

		typedef struct VkXYColorEXT
		{
		    float x;
		    float y;
		} VkXYColorEXT;

		typedef struct VkHdrMetadataEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkXYColorEXT displayPrimaryRed;
		    VkXYColorEXT displayPrimaryGreen;
		    VkXYColorEXT displayPrimaryBlue;
		    VkXYColorEXT whitePoint;
		    float maxLuminance;
		    float minLuminance;
		    float maxContentLightLevel;
		    float maxFrameAverageLightLevel;
		} VkHdrMetadataEXT;


		typedef void (VKAPI_PTR *PFN_vkSetHdrMetadataEXT)(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata);


		#define VK_KHR_imageless_framebuffer 1
		#define VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION 1
		#define VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME "VK_KHR_imageless_framebuffer"

		typedef VkPhysicalDeviceImagelessFramebufferFeatures VkPhysicalDeviceImagelessFramebufferFeaturesKHR;

		typedef VkFramebufferAttachmentsCreateInfo VkFramebufferAttachmentsCreateInfoKHR;

		typedef VkFramebufferAttachmentImageInfo VkFramebufferAttachmentImageInfoKHR;

		typedef VkRenderPassAttachmentBeginInfo VkRenderPassAttachmentBeginInfoKHR;


		#define VK_KHR_create_renderpass2 1
		#define VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION 1
		#define VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME "VK_KHR_create_renderpass2"

		typedef VkRenderPassCreateInfo2 VkRenderPassCreateInfo2KHR;

		typedef VkAttachmentDescription2 VkAttachmentDescription2KHR;

		typedef VkAttachmentReference2 VkAttachmentReference2KHR;

		typedef VkSubpassDescription2 VkSubpassDescription2KHR;

		typedef VkSubpassDependency2 VkSubpassDependency2KHR;

		typedef VkSubpassBeginInfo VkSubpassBeginInfoKHR;

		typedef VkSubpassEndInfo VkSubpassEndInfoKHR;

		typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass2KHR)(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass2KHR)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass2KHR)(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass2KHR)(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo);


		#define VK_IMG_relaxed_line_rasterization 1
		#define VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION 1
		#define VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME "VK_IMG_relaxed_line_rasterization"

		typedef struct VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 relaxedLineRasterization;
		} VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG;


		#define VK_KHR_shared_presentable_image 1
		#define VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION 1
		#define VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME "VK_KHR_shared_presentable_image"

		typedef struct VkSharedPresentSurfaceCapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkImageUsageFlags sharedPresentSupportedUsageFlags;
		} VkSharedPresentSurfaceCapabilitiesKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainStatusKHR)(VkDevice device, VkSwapchainKHR swapchain);


		#define VK_KHR_external_fence_capabilities 1
		#define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"

		typedef VkExternalFenceHandleTypeFlags VkExternalFenceHandleTypeFlagsKHR;
		typedef VkExternalFenceHandleTypeFlagBits VkExternalFenceHandleTypeFlagBitsKHR;
		typedef VkExternalFenceFeatureFlags VkExternalFenceFeatureFlagsKHR;
		typedef VkExternalFenceFeatureFlagBits VkExternalFenceFeatureFlagBitsKHR;
		typedef VkPhysicalDeviceExternalFenceInfo VkPhysicalDeviceExternalFenceInfoKHR;

		typedef VkExternalFenceProperties VkExternalFencePropertiesKHR;

		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties);


		#define VK_KHR_external_fence 1
		#define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"

		typedef VkFenceImportFlags VkFenceImportFlagsKHR;
		typedef VkFenceImportFlagBits VkFenceImportFlagBitsKHR;
		typedef VkExportFenceCreateInfo VkExportFenceCreateInfoKHR;


		#define VK_KHR_external_fence_fd 1
		#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"

		typedef struct VkImportFenceFdInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFence fence;
		    VkFenceImportFlags flags;
		    VkExternalFenceHandleTypeFlagBits handleType;
		    int fd;
		} VkImportFenceFdInfoKHR;

		typedef struct VkFenceGetFdInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFence fence;
		    VkExternalFenceHandleTypeFlagBits handleType;
		} VkFenceGetFdInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd);


		#define VK_KHR_performance_query 1
		#define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
		#define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"

		typedef enum
		{
		    VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
		    VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
		    VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
		    VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
		    VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
		    VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
		    VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
		    VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
		    VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
		    VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
		    VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
		    VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkPerformanceCounterUnitKHR;

		typedef enum
		{
		    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
		    VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
		    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
		    VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
		    VK_QUERY_SCOPE_RENDER_PASS_KHR = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
		    VK_QUERY_SCOPE_COMMAND_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
		    VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkPerformanceCounterScopeKHR;

		typedef enum
		{
		    VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
		    VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
		    VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
		    VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
		    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
		    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
		    VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkPerformanceCounterStorageKHR;


		typedef enum
		{
		    VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x00000001,
		    VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
		    VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x00000002,
		    VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
		    VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkPerformanceCounterDescriptionFlagBitsKHR;
		typedef VkFlags VkPerformanceCounterDescriptionFlagsKHR;

		typedef enum
		{
		    VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkAcquireProfilingLockFlagBitsKHR;
		typedef VkFlags VkAcquireProfilingLockFlagsKHR;

		typedef struct VkPhysicalDevicePerformanceQueryFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 performanceCounterQueryPools;
		    VkBool32 performanceCounterMultipleQueryPools;
		} VkPhysicalDevicePerformanceQueryFeaturesKHR;

		typedef struct VkPhysicalDevicePerformanceQueryPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 allowCommandBufferQueryCopies;
		} VkPhysicalDevicePerformanceQueryPropertiesKHR;

		typedef struct VkPerformanceCounterKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPerformanceCounterUnitKHR unit;
		    VkPerformanceCounterScopeKHR scope;
		    VkPerformanceCounterStorageKHR storage;
		    uint8_t uuid[VK_UUID_SIZE];
		} VkPerformanceCounterKHR;

		typedef struct VkPerformanceCounterDescriptionKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPerformanceCounterDescriptionFlagsKHR flags;
		    char name[VK_MAX_DESCRIPTION_SIZE];
		    char category[VK_MAX_DESCRIPTION_SIZE];
		    char description[VK_MAX_DESCRIPTION_SIZE];
		} VkPerformanceCounterDescriptionKHR;

		typedef struct VkQueryPoolPerformanceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t queueFamilyIndex;
		    uint32_t counterIndexCount;
		    const uint32_t* pCounterIndices;
		} VkQueryPoolPerformanceCreateInfoKHR;

		typedef union VkPerformanceCounterResultKHR
		{
		    int32_t int32;
		    int64_t int64;
		    uint32_t uint32;
		    uint64_t uint64;
		    float float32;
		    double float64;
		} VkPerformanceCounterResultKHR;

		typedef struct VkAcquireProfilingLockInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAcquireProfilingLockFlagsKHR flags;
		    uint64_t timeout;
		} VkAcquireProfilingLockInfoKHR;

		typedef struct VkPerformanceQuerySubmitInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t counterPassIndex;
		} VkPerformanceQuerySubmitInfoKHR;

		typedef struct VkPerformanceQueryReservationInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxPerformanceQueriesPerPool;
		} VkPerformanceQueryReservationInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses);
		typedef VkResult (VKAPI_PTR *PFN_vkAcquireProfilingLockKHR)(VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo);
		typedef void (VKAPI_PTR *PFN_vkReleaseProfilingLockKHR)(VkDevice device);


		#define VK_KHR_maintenance2 1
		#define VK_KHR_MAINTENANCE_2_SPEC_VERSION 1
		#define VK_KHR_MAINTENANCE_2_EXTENSION_NAME "VK_KHR_maintenance2"

		typedef VkPointClippingBehavior VkPointClippingBehaviorKHR;
		typedef VkTessellationDomainOrigin VkTessellationDomainOriginKHR;
		typedef VkPhysicalDevicePointClippingProperties VkPhysicalDevicePointClippingPropertiesKHR;

		typedef VkRenderPassInputAttachmentAspectCreateInfo VkRenderPassInputAttachmentAspectCreateInfoKHR;

		typedef VkInputAttachmentAspectReference VkInputAttachmentAspectReferenceKHR;

		typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;

		typedef VkPipelineTessellationDomainOriginStateCreateInfo VkPipelineTessellationDomainOriginStateCreateInfoKHR;


		#define VK_KHR_get_surface_capabilities2 1
		#define VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION 1
		#define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"

		typedef struct VkPhysicalDeviceSurfaceInfo2KHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSurfaceKHR surface;
		} VkPhysicalDeviceSurfaceInfo2KHR;

		typedef struct VkSurfaceCapabilities2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSurfaceCapabilitiesKHR surfaceCapabilities;
		} VkSurfaceCapabilities2KHR;

		typedef struct VkSurfaceFormat2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSurfaceFormatKHR surfaceFormat;
		} VkSurfaceFormat2KHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats);


		#define VK_KHR_variable_pointers 1
		#define VK_KHR_VARIABLE_POINTERS_SPEC_VERSION 1
		#define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"

		typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointerFeaturesKHR;

		typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointersFeaturesKHR;


		#define VK_KHR_get_display_properties2 1
		#define VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION 1
		#define VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_display_properties2"

		typedef struct VkDisplayProperties2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDisplayPropertiesKHR displayProperties;
		} VkDisplayProperties2KHR;

		typedef struct VkDisplayPlaneProperties2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDisplayPlanePropertiesKHR displayPlaneProperties;
		} VkDisplayPlaneProperties2KHR;

		typedef struct VkDisplayModeProperties2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDisplayModePropertiesKHR displayModeProperties;
		} VkDisplayModeProperties2KHR;

		typedef struct VkDisplayPlaneInfo2KHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDisplayModeKHR mode;
		    uint32_t planeIndex;
		} VkDisplayPlaneInfo2KHR;

		typedef struct VkDisplayPlaneCapabilities2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDisplayPlaneCapabilitiesKHR capabilities;
		} VkDisplayPlaneCapabilities2KHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModeProperties2KHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilities2KHR)(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities);


		#define VK_EXT_external_memory_dma_buf 1
		#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
		#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"


		#define VK_EXT_queue_family_foreign 1
		#define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
		#define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"

		#define VK_QUEUE_FAMILY_FOREIGN_EXT (~2U)


		#define VK_KHR_dedicated_allocation 1
		#define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
		#define VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_KHR_dedicated_allocation"

		typedef VkMemoryDedicatedRequirements VkMemoryDedicatedRequirementsKHR;

		typedef VkMemoryDedicatedAllocateInfo VkMemoryDedicatedAllocateInfoKHR;


		#define VK_NV_dedicated_allocation 1
		#define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
		#define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

		typedef struct VkDedicatedAllocationImageCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 dedicatedAllocation;
		} VkDedicatedAllocationImageCreateInfoNV;

		typedef struct VkDedicatedAllocationBufferCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 dedicatedAllocation;
		} VkDedicatedAllocationBufferCreateInfoNV;

		typedef struct VkDedicatedAllocationMemoryAllocateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		    VkBuffer buffer;
		} VkDedicatedAllocationMemoryAllocateInfoNV;


		#define VK_EXT_debug_utils 1
		#define VK_EXT_DEBUG_UTILS_SPEC_VERSION 2
		#define VK_EXT_DEBUG_UTILS_EXTENSION_NAME "VK_EXT_debug_utils"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugUtilsMessengerEXT)


		typedef enum
		{
		    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001,
		    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002,
		    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004,
		    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x00000008,
		    VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDebugUtilsMessageTypeFlagBitsEXT;
		typedef VkFlags VkDebugUtilsMessageTypeFlagsEXT;
		typedef VkFlags VkDebugUtilsMessengerCallbackDataFlagsEXT;

		typedef enum
		{
		    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001,
		    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010,
		    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100,
		    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000,
		    VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDebugUtilsMessageSeverityFlagBitsEXT;
		typedef VkFlags VkDebugUtilsMessageSeverityFlagsEXT;
		typedef VkFlags VkDebugUtilsMessengerCreateFlagsEXT;

		typedef struct VkDebugUtilsLabelEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    const char* pLabelName;
		    float color[4];
		} VkDebugUtilsLabelEXT;

		typedef struct VkDebugUtilsObjectNameInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkObjectType objectType;
		    uint64_t objectHandle;
		    const char* pObjectName;
		} VkDebugUtilsObjectNameInfoEXT;

		typedef struct VkDebugUtilsMessengerCallbackDataEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDebugUtilsMessengerCallbackDataFlagsEXT flags;
		    const char* pMessageIdName;
		    int32_t messageIdNumber;
		    const char* pMessage;
		    uint32_t queueLabelCount;
		    const VkDebugUtilsLabelEXT* pQueueLabels;
		    uint32_t cmdBufLabelCount;
		    const VkDebugUtilsLabelEXT* pCmdBufLabels;
		    uint32_t objectCount;
		    const VkDebugUtilsObjectNameInfoEXT* pObjects;
		} VkDebugUtilsMessengerCallbackDataEXT;

		typedef VkBool32 (VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData);

		typedef struct VkDebugUtilsMessengerCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDebugUtilsMessengerCreateFlagsEXT flags;
		    VkDebugUtilsMessageSeverityFlagsEXT messageSeverity;
		    VkDebugUtilsMessageTypeFlagsEXT messageType;
		    PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback;
		    void* pUserData;
		} VkDebugUtilsMessengerCreateInfoEXT;

		typedef struct VkDebugUtilsObjectTagInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkObjectType objectType;
		    uint64_t objectHandle;
		    uint64_t tagName;
		    size_t tagSize;
		    const void* pTag;
		} VkDebugUtilsObjectTagInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkSetDebugUtilsObjectNameEXT)(VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkSetDebugUtilsObjectTagEXT)(VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo);
		typedef void (VKAPI_PTR *PFN_vkQueueBeginDebugUtilsLabelEXT)(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo);
		typedef void (VKAPI_PTR *PFN_vkQueueEndDebugUtilsLabelEXT)(VkQueue queue);
		typedef void (VKAPI_PTR *PFN_vkQueueInsertDebugUtilsLabelEXT)(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdBeginDebugUtilsLabelEXT)(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdEndDebugUtilsLabelEXT)(VkCommandBuffer commandBuffer);
		typedef void (VKAPI_PTR *PFN_vkCmdInsertDebugUtilsLabelEXT)(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugUtilsMessengerEXT)(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger);
		typedef void (VKAPI_PTR *PFN_vkDestroyDebugUtilsMessengerEXT)(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkSubmitDebugUtilsMessageEXT)(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData);


		#define VK_EXT_debug_marker 1
		#define VK_EXT_DEBUG_MARKER_SPEC_VERSION 4
		#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

		typedef enum
		{
		    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
		    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
		    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
		    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
		    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
		    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
		    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
		    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
		    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
		    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
		    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
		    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
		    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
		    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
		    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
		    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
		    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
		    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
		    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
		    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
		    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
		    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
		    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
		    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
		    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
		    VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
		    VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
		    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
		    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
		    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
		    VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT = 1000307000,
		    VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT = 1000307001,
		    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
		    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
		    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
		    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDebugReportObjectTypeEXT;


		typedef struct VkDebugMarkerObjectNameInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDebugReportObjectTypeEXT objectType;
		    uint64_t object;
		    const char* pObjectName;
		} VkDebugMarkerObjectNameInfoEXT;

		typedef struct VkDebugMarkerObjectTagInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDebugReportObjectTypeEXT objectType;
		    uint64_t object;
		    uint64_t tagName;
		    size_t tagSize;
		    const void* pTag;
		} VkDebugMarkerObjectTagInfoEXT;

		typedef struct VkDebugMarkerMarkerInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    const char* pMarkerName;
		    float color[4];
		} VkDebugMarkerMarkerInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
		typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo);


		#define VK_EXT_debug_report 1
		#define VK_EXT_DEBUG_REPORT_SPEC_VERSION 10
		#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)


		typedef enum
		{
		    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
		    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
		    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
		    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
		    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
		    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDebugReportFlagBitsEXT;
		typedef VkFlags VkDebugReportFlagsEXT;

		typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, void* pUserData);

		typedef struct VkDebugReportCallbackCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDebugReportFlagsEXT flags;
		    PFN_vkDebugReportCallbackEXT pfnCallback;
		    void* pUserData;
		} VkDebugReportCallbackCreateInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
		typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage);


		#define VK_EXT_sampler_filter_minmax 1
		#define VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION 2
		#define VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME "VK_EXT_sampler_filter_minmax"

		typedef VkSamplerReductionMode VkSamplerReductionModeEXT;
		typedef VkSamplerReductionModeCreateInfo VkSamplerReductionModeCreateInfoEXT;

		typedef VkPhysicalDeviceSamplerFilterMinmaxProperties VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;


		#define VK_KHR_storage_buffer_storage_class 1
		#define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION 1
		#define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME "VK_KHR_storage_buffer_storage_class"


		#define VK_AMD_gpu_shader_int16 1
		#define VK_AMD_GPU_SHADER_INT16_SPEC_VERSION 2
		#define VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME "VK_AMD_gpu_shader_int16"


		#define VK_AMD_mixed_attachment_samples 1
		#define VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION 1
		#define VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME "VK_AMD_mixed_attachment_samples"


		#define VK_AMD_shader_fragment_mask 1
		#define VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION 1
		#define VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME "VK_AMD_shader_fragment_mask"


		#define VK_EXT_inline_uniform_block 1
		#define VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION 1
		#define VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME "VK_EXT_inline_uniform_block"

		typedef VkPhysicalDeviceInlineUniformBlockFeatures VkPhysicalDeviceInlineUniformBlockFeaturesEXT;

		typedef VkPhysicalDeviceInlineUniformBlockProperties VkPhysicalDeviceInlineUniformBlockPropertiesEXT;

		typedef VkWriteDescriptorSetInlineUniformBlock VkWriteDescriptorSetInlineUniformBlockEXT;

		typedef VkDescriptorPoolInlineUniformBlockCreateInfo VkDescriptorPoolInlineUniformBlockCreateInfoEXT;


		#define VK_EXT_shader_stencil_export 1
		#define VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION 1
		#define VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME "VK_EXT_shader_stencil_export"


		#define VK_EXT_sample_locations 1
		#define VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION 1
		#define VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME "VK_EXT_sample_locations"

		typedef struct VkSampleLocationEXT
		{
		    float x;
		    float y;
		} VkSampleLocationEXT;

		typedef struct VkSampleLocationsInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSampleCountFlagBits sampleLocationsPerPixel;
		    VkExtent2D sampleLocationGridSize;
		    uint32_t sampleLocationsCount;
		    const VkSampleLocationEXT* pSampleLocations;
		} VkSampleLocationsInfoEXT;

		typedef struct VkAttachmentSampleLocationsEXT
		{
		    uint32_t attachmentIndex;
		    VkSampleLocationsInfoEXT sampleLocationsInfo;
		} VkAttachmentSampleLocationsEXT;

		typedef struct VkSubpassSampleLocationsEXT
		{
		    uint32_t subpassIndex;
		    VkSampleLocationsInfoEXT sampleLocationsInfo;
		} VkSubpassSampleLocationsEXT;

		typedef struct VkRenderPassSampleLocationsBeginInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t attachmentInitialSampleLocationsCount;
		    const VkAttachmentSampleLocationsEXT* pAttachmentInitialSampleLocations;
		    uint32_t postSubpassSampleLocationsCount;
		    const VkSubpassSampleLocationsEXT* pPostSubpassSampleLocations;
		} VkRenderPassSampleLocationsBeginInfoEXT;

		typedef struct VkPipelineSampleLocationsStateCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 sampleLocationsEnable;
		    VkSampleLocationsInfoEXT sampleLocationsInfo;
		} VkPipelineSampleLocationsStateCreateInfoEXT;

		typedef struct VkPhysicalDeviceSampleLocationsPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSampleCountFlags sampleLocationSampleCounts;
		    VkExtent2D maxSampleLocationGridSize;
		    float sampleLocationCoordinateRange[2];
		    uint32_t sampleLocationSubPixelBits;
		    VkBool32 variableSampleLocations;
		} VkPhysicalDeviceSampleLocationsPropertiesEXT;

		typedef struct VkMultisamplePropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent2D maxSampleLocationGridSize;
		} VkMultisamplePropertiesEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetSampleLocationsEXT)(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo);
		typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties);


		#define VK_KHR_relaxed_block_layout 1
		#define VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION 1
		#define VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME "VK_KHR_relaxed_block_layout"


		#define VK_KHR_get_memory_requirements2 1
		#define VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION 1
		#define VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME "VK_KHR_get_memory_requirements2"

		typedef VkBufferMemoryRequirementsInfo2 VkBufferMemoryRequirementsInfo2KHR;

		typedef VkImageMemoryRequirementsInfo2 VkImageMemoryRequirementsInfo2KHR;

		typedef VkImageSparseMemoryRequirementsInfo2 VkImageSparseMemoryRequirementsInfo2KHR;

		typedef VkMemoryRequirements2 VkMemoryRequirements2KHR;

		typedef VkSparseImageMemoryRequirements2 VkSparseImageMemoryRequirements2KHR;

		typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements2KHR)(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements2KHR)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);


		#define VK_KHR_image_format_list 1
		#define VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION 1
		#define VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME "VK_KHR_image_format_list"

		typedef VkImageFormatListCreateInfo VkImageFormatListCreateInfoKHR;


		#define VK_EXT_blend_operation_advanced 1
		#define VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION 2
		#define VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME "VK_EXT_blend_operation_advanced"

		typedef enum
		{
		    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
		    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
		    VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
		    VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkBlendOverlapEXT;


		typedef struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 advancedBlendCoherentOperations;
		} VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;

		typedef struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t advancedBlendMaxColorAttachments;
		    VkBool32 advancedBlendIndependentBlend;
		    VkBool32 advancedBlendNonPremultipliedSrcColor;
		    VkBool32 advancedBlendNonPremultipliedDstColor;
		    VkBool32 advancedBlendCorrelatedOverlap;
		    VkBool32 advancedBlendAllOperations;
		} VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;

		typedef struct VkPipelineColorBlendAdvancedStateCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 srcPremultiplied;
		    VkBool32 dstPremultiplied;
		    VkBlendOverlapEXT blendOverlap;
		} VkPipelineColorBlendAdvancedStateCreateInfoEXT;


		#define VK_NV_fragment_coverage_to_color 1
		#define VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION 1
		#define VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME "VK_NV_fragment_coverage_to_color"

		typedef VkFlags VkPipelineCoverageToColorStateCreateFlagsNV;
		typedef struct VkPipelineCoverageToColorStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCoverageToColorStateCreateFlagsNV flags;
		    VkBool32 coverageToColorEnable;
		    uint32_t coverageToColorLocation;
		} VkPipelineCoverageToColorStateCreateInfoNV;


		#define VK_KHR_acceleration_structure 1
		#define VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION 13
		#define VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME "VK_KHR_acceleration_structure"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureKHR)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeferredOperationKHR)

		typedef enum
		{
		    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
		    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
		    VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
		    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
		    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
		    VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkAccelerationStructureTypeKHR;


		typedef enum
		{
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x00000001,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x00000002,
		    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x00000004,
		    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x00000008,
		    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x00000010,
		    VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x00000020,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = 0x00000040,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = 0x00000080,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = 0x00000100,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV = 0x00000200,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR = 0x00000800,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
		    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
		    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
		    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
		    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
		    VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkBuildAccelerationStructureFlagBitsKHR;
		typedef VkFlags VkBuildAccelerationStructureFlagsKHR;
		typedef enum
		{
		    VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
		    VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
		    VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkBuildAccelerationStructureModeKHR;

		typedef enum
		{
		    VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
		    VK_GEOMETRY_TYPE_AABBS_KHR = 1,
		    VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
		    VK_GEOMETRY_TYPE_TRIANGLES_NV = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
		    VK_GEOMETRY_TYPE_AABBS_NV = VK_GEOMETRY_TYPE_AABBS_KHR,
		    VK_GEOMETRY_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkGeometryTypeKHR;


		typedef enum
		{
		    VK_GEOMETRY_OPAQUE_BIT_KHR = 0x00000001,
		    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x00000002,
		    VK_GEOMETRY_OPAQUE_BIT_NV = VK_GEOMETRY_OPAQUE_BIT_KHR,
		    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
		    VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkGeometryFlagBitsKHR;
		typedef VkFlags VkGeometryFlagsKHR;
		typedef enum
		{
		    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
		    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
		    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
		    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkAccelerationStructureBuildTypeKHR;


		typedef enum
		{
		    VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x00000001,
		    VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x00000002,
		    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x00000004,
		    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x00000008,
		    VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
		    VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = 0x00000010,
		    VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = 0x00000020,
		    VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
		    VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
		    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
		    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
		    VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkGeometryInstanceFlagBitsKHR;
		typedef VkFlags VkGeometryInstanceFlagsKHR;

		typedef enum
		{
		    VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x00000001,
		    VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000008,
		    VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x00000004,
		    VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkAccelerationStructureCreateFlagBitsKHR;
		typedef VkFlags VkAccelerationStructureCreateFlagsKHR;
		typedef enum
		{
		    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
		    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
		    VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
		    VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
		    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
		    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
		    VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkCopyAccelerationStructureModeKHR;

		typedef enum
		{
		    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
		    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
		    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkAccelerationStructureCompatibilityKHR;


		typedef union VkDeviceOrHostAddressKHR
		{
		    VkDeviceAddress deviceAddress;
		    void* hostAddress;
		} VkDeviceOrHostAddressKHR;

		typedef union VkDeviceOrHostAddressConstKHR
		{
		    VkDeviceAddress deviceAddress;
		    const void* hostAddress;
		} VkDeviceOrHostAddressConstKHR;

		typedef struct VkAccelerationStructureBuildRangeInfoKHR
		{
		    uint32_t primitiveCount;
		    uint32_t primitiveOffset;
		    uint32_t firstVertex;
		    uint32_t transformOffset;
		} VkAccelerationStructureBuildRangeInfoKHR;

		typedef struct VkAabbPositionsKHR
		{
		    float minX;
		    float minY;
		    float minZ;
		    float maxX;
		    float maxY;
		    float maxZ;
		} VkAabbPositionsKHR;

		typedef struct VkAccelerationStructureGeometryTrianglesDataKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFormat vertexFormat;
		    VkDeviceOrHostAddressConstKHR vertexData;
		    VkDeviceSize vertexStride;
		    uint32_t maxVertex;
		    VkIndexType indexType;
		    VkDeviceOrHostAddressConstKHR indexData;
		    VkDeviceOrHostAddressConstKHR transformData;
		} VkAccelerationStructureGeometryTrianglesDataKHR;

		typedef struct VkTransformMatrixKHR
		{
		    float matrix[3][4];
		} VkTransformMatrixKHR;

		typedef struct VkAccelerationStructureGeometryAabbsDataKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceOrHostAddressConstKHR data;
		    VkDeviceSize stride;
		} VkAccelerationStructureGeometryAabbsDataKHR;

		typedef struct VkAccelerationStructureGeometryInstancesDataKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 arrayOfPointers;
		    VkDeviceOrHostAddressConstKHR data;
		} VkAccelerationStructureGeometryInstancesDataKHR;

		typedef union VkAccelerationStructureGeometryDataKHR
		{
		    VkAccelerationStructureGeometryTrianglesDataKHR triangles;
		    VkAccelerationStructureGeometryAabbsDataKHR aabbs;
		    VkAccelerationStructureGeometryInstancesDataKHR instances;
		} VkAccelerationStructureGeometryDataKHR;

		typedef struct VkAccelerationStructureGeometryKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkGeometryTypeKHR geometryType;
		    VkAccelerationStructureGeometryDataKHR geometry;
		    VkGeometryFlagsKHR flags;
		} VkAccelerationStructureGeometryKHR;

		typedef struct VkAccelerationStructureBuildGeometryInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureTypeKHR type;
		    VkBuildAccelerationStructureFlagsKHR flags;
		    VkBuildAccelerationStructureModeKHR mode;
		    VkAccelerationStructureKHR srcAccelerationStructure;
		    VkAccelerationStructureKHR dstAccelerationStructure;
		    uint32_t geometryCount;
		    const VkAccelerationStructureGeometryKHR* pGeometries;
		    const VkAccelerationStructureGeometryKHR* const* ppGeometries;
		    VkDeviceOrHostAddressKHR scratchData;
		} VkAccelerationStructureBuildGeometryInfoKHR;

		typedef struct VkAccelerationStructureInstanceKHR
		{
		    VkTransformMatrixKHR transform;
		    uint32_t instanceCustomIndex:24;
		    uint32_t mask:8;
		    uint32_t instanceShaderBindingTableRecordOffset:24;
		    VkGeometryInstanceFlagsKHR flags:8;
		    uint64_t accelerationStructureReference;
		} VkAccelerationStructureInstanceKHR;

		typedef struct VkAccelerationStructureCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureCreateFlagsKHR createFlags;
		    VkBuffer buffer;
		    VkDeviceSize offset;
		    VkDeviceSize size;
		    VkAccelerationStructureTypeKHR type;
		    VkDeviceAddress deviceAddress;
		} VkAccelerationStructureCreateInfoKHR;

		typedef struct VkWriteDescriptorSetAccelerationStructureKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t accelerationStructureCount;
		    const VkAccelerationStructureKHR* pAccelerationStructures;
		} VkWriteDescriptorSetAccelerationStructureKHR;

		typedef struct VkPhysicalDeviceAccelerationStructureFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 accelerationStructure;
		    VkBool32 accelerationStructureCaptureReplay;
		    VkBool32 accelerationStructureIndirectBuild;
		    VkBool32 accelerationStructureHostCommands;
		    VkBool32 descriptorBindingAccelerationStructureUpdateAfterBind;
		} VkPhysicalDeviceAccelerationStructureFeaturesKHR;

		typedef struct VkPhysicalDeviceAccelerationStructurePropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint64_t maxGeometryCount;
		    uint64_t maxInstanceCount;
		    uint64_t maxPrimitiveCount;
		    uint32_t maxPerStageDescriptorAccelerationStructures;
		    uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
		    uint32_t maxDescriptorSetAccelerationStructures;
		    uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures;
		    uint32_t minAccelerationStructureScratchOffsetAlignment;
		} VkPhysicalDeviceAccelerationStructurePropertiesKHR;

		typedef struct VkAccelerationStructureDeviceAddressInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureKHR accelerationStructure;
		} VkAccelerationStructureDeviceAddressInfoKHR;

		typedef struct VkAccelerationStructureVersionInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const uint8_t* pVersionData;
		} VkAccelerationStructureVersionInfoKHR;

		typedef struct VkCopyAccelerationStructureToMemoryInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureKHR src;
		    VkDeviceOrHostAddressKHR dst;
		    VkCopyAccelerationStructureModeKHR mode;
		} VkCopyAccelerationStructureToMemoryInfoKHR;

		typedef struct VkCopyMemoryToAccelerationStructureInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceOrHostAddressConstKHR src;
		    VkAccelerationStructureKHR dst;
		    VkCopyAccelerationStructureModeKHR mode;
		} VkCopyMemoryToAccelerationStructureInfoKHR;

		typedef struct VkCopyAccelerationStructureInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureKHR src;
		    VkAccelerationStructureKHR dst;
		    VkCopyAccelerationStructureModeKHR mode;
		} VkCopyAccelerationStructureInfoKHR;

		typedef struct VkAccelerationStructureBuildSizesInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize accelerationStructureSize;
		    VkDeviceSize updateScratchSize;
		    VkDeviceSize buildScratchSize;
		} VkAccelerationStructureBuildSizesInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateAccelerationStructureKHR)(VkDevice device, const VkAccelerationStructureCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureKHR* pAccelerationStructure);
		typedef void (VKAPI_PTR *PFN_vkDestroyAccelerationStructureKHR)(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkCmdBuildAccelerationStructuresKHR)(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos);
		typedef void (VKAPI_PTR *PFN_vkCmdBuildAccelerationStructuresIndirectKHR)(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts);
		typedef VkResult (VKAPI_PTR *PFN_vkBuildAccelerationStructuresKHR)(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyAccelerationStructureKHR)(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR* pInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyAccelerationStructureToMemoryKHR)(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyMemoryToAccelerationStructureKHR)(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkWriteAccelerationStructuresPropertiesKHR)(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, size_t dataSize, void* pData, size_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyAccelerationStructureKHR)(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyAccelerationStructureToMemoryKHR)(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyMemoryToAccelerationStructureKHR)(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo);
		typedef VkDeviceAddress (VKAPI_PTR *PFN_vkGetAccelerationStructureDeviceAddressKHR)(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR* pInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)(VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility);
		typedef void (VKAPI_PTR *PFN_vkGetAccelerationStructureBuildSizesKHR)(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, const uint32_t* pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo);


		#define VK_KHR_ray_tracing_pipeline 1
		#define VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION 1
		#define VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME "VK_KHR_ray_tracing_pipeline"

		#define VK_SHADER_UNUSED_KHR (~0U)

		typedef enum
		{
		    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
		    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
		    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
		    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
		    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
		    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
		    VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkRayTracingShaderGroupTypeKHR;

		typedef enum
		{
		    VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
		    VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
		    VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
		    VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
		    VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkShaderGroupShaderKHR;


		typedef struct VkRayTracingShaderGroupCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRayTracingShaderGroupTypeKHR type;
		    uint32_t generalShader;
		    uint32_t closestHitShader;
		    uint32_t anyHitShader;
		    uint32_t intersectionShader;
		    const void* pShaderGroupCaptureReplayHandle;
		} VkRayTracingShaderGroupCreateInfoKHR;

		typedef struct VkPipelineLibraryCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t libraryCount;
		    const VkPipeline* pLibraries;
		} VkPipelineLibraryCreateInfoKHR;

		typedef struct VkRayTracingPipelineInterfaceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxPipelineRayPayloadSize;
		    uint32_t maxPipelineRayHitAttributeSize;
		} VkRayTracingPipelineInterfaceCreateInfoKHR;

		typedef struct VkRayTracingPipelineCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCreateFlags flags;
		    uint32_t stageCount;
		    const VkPipelineShaderStageCreateInfo* pStages;
		    uint32_t groupCount;
		    const VkRayTracingShaderGroupCreateInfoKHR* pGroups;
		    uint32_t maxPipelineRayRecursionDepth;
		    const VkPipelineLibraryCreateInfoKHR* pLibraryInfo;
		    const VkRayTracingPipelineInterfaceCreateInfoKHR* pLibraryInterface;
		    const VkPipelineDynamicStateCreateInfo* pDynamicState;
		    VkPipelineLayout layout;
		    VkPipeline basePipelineHandle;
		    int32_t basePipelineIndex;
		} VkRayTracingPipelineCreateInfoKHR;

		typedef struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rayTracingPipeline;
		    VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplay;
		    VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
		    VkBool32 rayTracingPipelineTraceRaysIndirect;
		    VkBool32 rayTraversalPrimitiveCulling;
		} VkPhysicalDeviceRayTracingPipelineFeaturesKHR;

		typedef struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t shaderGroupHandleSize;
		    uint32_t maxRayRecursionDepth;
		    uint32_t maxShaderGroupStride;
		    uint32_t shaderGroupBaseAlignment;
		    uint32_t shaderGroupHandleCaptureReplaySize;
		    uint32_t maxRayDispatchInvocationCount;
		    uint32_t shaderGroupHandleAlignment;
		    uint32_t maxRayHitAttributeSize;
		} VkPhysicalDeviceRayTracingPipelinePropertiesKHR;

		typedef struct VkStridedDeviceAddressRegionKHR
		{
		    VkDeviceAddress deviceAddress;
		    VkDeviceSize stride;
		    VkDeviceSize size;
		} VkStridedDeviceAddressRegionKHR;

		typedef struct VkTraceRaysIndirectCommandKHR
		{
		    uint32_t width;
		    uint32_t height;
		    uint32_t depth;
		} VkTraceRaysIndirectCommandKHR;


		typedef void (VKAPI_PTR *PFN_vkCmdTraceRaysKHR)(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateRayTracingPipelinesKHR)(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
		typedef VkResult (VKAPI_PTR *PFN_vkGetRayTracingShaderGroupHandlesKHR)(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData);
		typedef VkResult (VKAPI_PTR *PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData);
		typedef void (VKAPI_PTR *PFN_vkCmdTraceRaysIndirectKHR)(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress);
		typedef VkDeviceSize (VKAPI_PTR *PFN_vkGetRayTracingShaderGroupStackSizeKHR)(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader);
		typedef void (VKAPI_PTR *PFN_vkCmdSetRayTracingPipelineStackSizeKHR)(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize);


		#define VK_KHR_ray_query 1
		#define VK_KHR_RAY_QUERY_SPEC_VERSION 1
		#define VK_KHR_RAY_QUERY_EXTENSION_NAME "VK_KHR_ray_query"

		typedef struct VkPhysicalDeviceRayQueryFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rayQuery;
		} VkPhysicalDeviceRayQueryFeaturesKHR;


		#define VK_NV_framebuffer_mixed_samples 1
		#define VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION 1
		#define VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME "VK_NV_framebuffer_mixed_samples"

		typedef VkFlags VkPipelineCoverageModulationStateCreateFlagsNV;
		typedef enum
		{
		    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
		    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
		    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
		    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
		    VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkCoverageModulationModeNV;


		typedef struct VkPipelineCoverageModulationStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCoverageModulationStateCreateFlagsNV flags;
		    VkCoverageModulationModeNV coverageModulationMode;
		    VkBool32 coverageModulationTableEnable;
		    uint32_t coverageModulationTableCount;
		    const float* pCoverageModulationTable;
		} VkPipelineCoverageModulationStateCreateInfoNV;


		#define VK_NV_fill_rectangle 1
		#define VK_NV_FILL_RECTANGLE_SPEC_VERSION 1
		#define VK_NV_FILL_RECTANGLE_EXTENSION_NAME "VK_NV_fill_rectangle"


		#define VK_NV_shader_sm_builtins 1
		#define VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION 1
		#define VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME "VK_NV_shader_sm_builtins"

		typedef struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t shaderSMCount;
		    uint32_t shaderWarpsPerSM;
		} VkPhysicalDeviceShaderSMBuiltinsPropertiesNV;

		typedef struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderSMBuiltins;
		} VkPhysicalDeviceShaderSMBuiltinsFeaturesNV;


		#define VK_EXT_post_depth_coverage 1
		#define VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION 1
		#define VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME "VK_EXT_post_depth_coverage"


		#define VK_KHR_sampler_ycbcr_conversion 1
		#define VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION 14
		#define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"

		typedef VkSamplerYcbcrConversion VkSamplerYcbcrConversionKHR;
		typedef VkSamplerYcbcrModelConversion VkSamplerYcbcrModelConversionKHR;
		typedef VkSamplerYcbcrRange VkSamplerYcbcrRangeKHR;
		typedef VkChromaLocation VkChromaLocationKHR;
		typedef VkSamplerYcbcrConversionCreateInfo VkSamplerYcbcrConversionCreateInfoKHR;

		typedef VkSamplerYcbcrConversionInfo VkSamplerYcbcrConversionInfoKHR;

		typedef VkBindImagePlaneMemoryInfo VkBindImagePlaneMemoryInfoKHR;

		typedef VkImagePlaneMemoryRequirementsInfo VkImagePlaneMemoryRequirementsInfoKHR;

		typedef VkPhysicalDeviceSamplerYcbcrConversionFeatures VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;

		typedef VkSamplerYcbcrConversionImageFormatProperties VkSamplerYcbcrConversionImageFormatPropertiesKHR;

		typedef VkResult (VKAPI_PTR *PFN_vkCreateSamplerYcbcrConversionKHR)(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
		typedef void (VKAPI_PTR *PFN_vkDestroySamplerYcbcrConversionKHR)(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator);


		#define VK_KHR_bind_memory2 1
		#define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
		#define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"

		typedef VkBindBufferMemoryInfo VkBindBufferMemoryInfoKHR;

		typedef VkBindImageMemoryInfo VkBindImageMemoryInfoKHR;

		typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos);
		typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos);


		#define VK_EXT_image_drm_format_modifier 1
		#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION 2
		#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"

		typedef struct VkDrmFormatModifierPropertiesEXT
		{
		    uint64_t drmFormatModifier;
		    uint32_t drmFormatModifierPlaneCount;
		    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
		} VkDrmFormatModifierPropertiesEXT;

		typedef struct VkDrmFormatModifierPropertiesListEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t drmFormatModifierCount;
		    VkDrmFormatModifierPropertiesEXT* pDrmFormatModifierProperties;
		} VkDrmFormatModifierPropertiesListEXT;

		typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t drmFormatModifier;
		    VkSharingMode sharingMode;
		    uint32_t queueFamilyIndexCount;
		    const uint32_t* pQueueFamilyIndices;
		} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;

		typedef struct VkImageDrmFormatModifierListCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t drmFormatModifierCount;
		    const uint64_t* pDrmFormatModifiers;
		} VkImageDrmFormatModifierListCreateInfoEXT;

		typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t drmFormatModifier;
		    uint32_t drmFormatModifierPlaneCount;
		    const VkSubresourceLayout* pPlaneLayouts;
		} VkImageDrmFormatModifierExplicitCreateInfoEXT;

		typedef struct VkImageDrmFormatModifierPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint64_t drmFormatModifier;
		} VkImageDrmFormatModifierPropertiesEXT;

		typedef struct VkDrmFormatModifierProperties2EXT
		{
		    uint64_t drmFormatModifier;
		    uint32_t drmFormatModifierPlaneCount;
		    VkFormatFeatureFlags2 drmFormatModifierTilingFeatures;
		} VkDrmFormatModifierProperties2EXT;

		typedef struct VkDrmFormatModifierPropertiesList2EXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t drmFormatModifierCount;
		    VkDrmFormatModifierProperties2EXT* pDrmFormatModifierProperties;
		} VkDrmFormatModifierPropertiesList2EXT;


		typedef VkResult (VKAPI_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties);


		#define VK_EXT_validation_cache 1
		#define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
		#define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkValidationCacheEXT)

		typedef VkFlags VkValidationCacheCreateFlagsEXT;
		typedef enum
		{
		    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
		    VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkValidationCacheHeaderVersionEXT;


		typedef struct VkValidationCacheCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkValidationCacheCreateFlagsEXT flags;
		    size_t initialDataSize;
		    const void* pInitialData;
		} VkValidationCacheCreateInfoEXT;

		typedef struct VkShaderModuleValidationCacheCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkValidationCacheEXT validationCache;
		} VkShaderModuleValidationCacheCreateInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateValidationCacheEXT)(VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache);
		typedef void (VKAPI_PTR *PFN_vkDestroyValidationCacheEXT)(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkMergeValidationCachesEXT)(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches);
		typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData);


		#define VK_EXT_descriptor_indexing 1
		#define VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION 2
		#define VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME "VK_EXT_descriptor_indexing"

		typedef VkDescriptorBindingFlagBits VkDescriptorBindingFlagBitsEXT;
		typedef VkDescriptorBindingFlags VkDescriptorBindingFlagsEXT;
		typedef VkDescriptorSetLayoutBindingFlagsCreateInfo VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;

		typedef VkPhysicalDeviceDescriptorIndexingFeatures VkPhysicalDeviceDescriptorIndexingFeaturesEXT;

		typedef VkPhysicalDeviceDescriptorIndexingProperties VkPhysicalDeviceDescriptorIndexingPropertiesEXT;

		typedef VkDescriptorSetVariableDescriptorCountAllocateInfo VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;

		typedef VkDescriptorSetVariableDescriptorCountLayoutSupport VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;


		#define VK_EXT_shader_viewport_index_layer 1
		#define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION 1
		#define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME "VK_EXT_shader_viewport_index_layer"


		#define VK_NV_shading_rate_image 1
		#define VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION 3
		#define VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME "VK_NV_shading_rate_image"

		typedef enum
		{
		    VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
		    VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
		    VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
		    VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
		    VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
		    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
		    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
		    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
		    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
		    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
		    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
		    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
		    VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7FFFFFFF
		} VkShadingRatePaletteEntryNV;

		typedef enum
		{
		    VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
		    VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
		    VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
		    VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
		    VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkCoarseSampleOrderTypeNV;


		typedef struct VkShadingRatePaletteNV
		{
		    uint32_t shadingRatePaletteEntryCount;
		    const VkShadingRatePaletteEntryNV* pShadingRatePaletteEntries;
		} VkShadingRatePaletteNV;

		typedef struct VkPipelineViewportShadingRateImageStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 shadingRateImageEnable;
		    uint32_t viewportCount;
		    const VkShadingRatePaletteNV* pShadingRatePalettes;
		} VkPipelineViewportShadingRateImageStateCreateInfoNV;

		typedef struct VkPhysicalDeviceShadingRateImageFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shadingRateImage;
		    VkBool32 shadingRateCoarseSampleOrder;
		} VkPhysicalDeviceShadingRateImageFeaturesNV;

		typedef struct VkPhysicalDeviceShadingRateImagePropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent2D shadingRateTexelSize;
		    uint32_t shadingRatePaletteSize;
		    uint32_t shadingRateMaxCoarseSamples;
		} VkPhysicalDeviceShadingRateImagePropertiesNV;

		typedef struct VkCoarseSampleLocationNV
		{
		    uint32_t pixelX;
		    uint32_t pixelY;
		    uint32_t sample;
		} VkCoarseSampleLocationNV;

		typedef struct VkCoarseSampleOrderCustomNV
		{
		    VkShadingRatePaletteEntryNV shadingRate;
		    uint32_t sampleCount;
		    uint32_t sampleLocationCount;
		    const VkCoarseSampleLocationNV* pSampleLocations;
		} VkCoarseSampleOrderCustomNV;

		typedef struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCoarseSampleOrderTypeNV sampleOrderType;
		    uint32_t customSampleOrderCount;
		    const VkCoarseSampleOrderCustomNV* pCustomSampleOrders;
		} VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;


		typedef void (VKAPI_PTR *PFN_vkCmdBindShadingRateImageNV)(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);
		typedef void (VKAPI_PTR *PFN_vkCmdSetViewportShadingRatePaletteNV)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCoarseSampleOrderNV)(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders);


		#define VK_NV_ray_tracing 1
		#define VK_NV_RAY_TRACING_SPEC_VERSION 3
		#define VK_NV_RAY_TRACING_EXTENSION_NAME "VK_NV_ray_tracing"

		#define VK_SHADER_UNUSED_NV VK_SHADER_UNUSED_KHR

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureNV)

		typedef VkRayTracingShaderGroupTypeKHR VkRayTracingShaderGroupTypeNV;
		typedef VkGeometryTypeKHR VkGeometryTypeNV;
		typedef VkAccelerationStructureTypeKHR VkAccelerationStructureTypeNV;
		typedef VkGeometryFlagsKHR VkGeometryFlagsNV;
		typedef VkGeometryFlagBitsKHR VkGeometryFlagBitsNV;
		typedef VkGeometryInstanceFlagsKHR VkGeometryInstanceFlagsNV;
		typedef VkGeometryInstanceFlagBitsKHR VkGeometryInstanceFlagBitsNV;
		typedef VkBuildAccelerationStructureFlagsKHR VkBuildAccelerationStructureFlagsNV;
		typedef VkBuildAccelerationStructureFlagBitsKHR VkBuildAccelerationStructureFlagBitsNV;
		typedef VkCopyAccelerationStructureModeKHR VkCopyAccelerationStructureModeNV;
		typedef enum
		{
		    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
		    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
		    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
		    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkAccelerationStructureMemoryRequirementsTypeNV;


		typedef struct VkRayTracingShaderGroupCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRayTracingShaderGroupTypeKHR type;
		    uint32_t generalShader;
		    uint32_t closestHitShader;
		    uint32_t anyHitShader;
		    uint32_t intersectionShader;
		} VkRayTracingShaderGroupCreateInfoNV;

		typedef struct VkRayTracingPipelineCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCreateFlags flags;
		    uint32_t stageCount;
		    const VkPipelineShaderStageCreateInfo* pStages;
		    uint32_t groupCount;
		    const VkRayTracingShaderGroupCreateInfoNV* pGroups;
		    uint32_t maxRecursionDepth;
		    VkPipelineLayout layout;
		    VkPipeline basePipelineHandle;
		    int32_t basePipelineIndex;
		} VkRayTracingPipelineCreateInfoNV;

		typedef struct VkGeometryTrianglesNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer vertexData;
		    VkDeviceSize vertexOffset;
		    uint32_t vertexCount;
		    VkDeviceSize vertexStride;
		    VkFormat vertexFormat;
		    VkBuffer indexData;
		    VkDeviceSize indexOffset;
		    uint32_t indexCount;
		    VkIndexType indexType;
		    VkBuffer transformData;
		    VkDeviceSize transformOffset;
		} VkGeometryTrianglesNV;

		typedef struct VkGeometryAABBNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer aabbData;
		    uint32_t numAABBs;
		    uint32_t stride;
		    VkDeviceSize offset;
		} VkGeometryAABBNV;

		typedef struct VkGeometryDataNV
		{
		    VkGeometryTrianglesNV triangles;
		    VkGeometryAABBNV aabbs;
		} VkGeometryDataNV;

		typedef struct VkGeometryNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkGeometryTypeKHR geometryType;
		    VkGeometryDataNV geometry;
		    VkGeometryFlagsKHR flags;
		} VkGeometryNV;

		typedef struct VkAccelerationStructureInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureTypeNV type;
		    VkBuildAccelerationStructureFlagsNV flags;
		    uint32_t instanceCount;
		    uint32_t geometryCount;
		    const VkGeometryNV* pGeometries;
		} VkAccelerationStructureInfoNV;

		typedef struct VkAccelerationStructureCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize compactedSize;
		    VkAccelerationStructureInfoNV info;
		} VkAccelerationStructureCreateInfoNV;

		typedef struct VkBindAccelerationStructureMemoryInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureNV accelerationStructure;
		    VkDeviceMemory memory;
		    VkDeviceSize memoryOffset;
		    uint32_t deviceIndexCount;
		    const uint32_t* pDeviceIndices;
		} VkBindAccelerationStructureMemoryInfoNV;

		typedef struct VkWriteDescriptorSetAccelerationStructureNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t accelerationStructureCount;
		    const VkAccelerationStructureNV* pAccelerationStructures;
		} VkWriteDescriptorSetAccelerationStructureNV;

		typedef struct VkAccelerationStructureMemoryRequirementsInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureMemoryRequirementsTypeNV type;
		    VkAccelerationStructureNV accelerationStructure;
		} VkAccelerationStructureMemoryRequirementsInfoNV;

		typedef struct VkPhysicalDeviceRayTracingPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t shaderGroupHandleSize;
		    uint32_t maxRecursionDepth;
		    uint32_t maxShaderGroupStride;
		    uint32_t shaderGroupBaseAlignment;
		    uint64_t maxGeometryCount;
		    uint64_t maxInstanceCount;
		    uint64_t maxTriangleCount;
		    uint32_t maxDescriptorSetAccelerationStructures;
		} VkPhysicalDeviceRayTracingPropertiesNV;

		typedef VkTransformMatrixKHR VkTransformMatrixNV;

		typedef VkAabbPositionsKHR VkAabbPositionsNV;

		typedef VkAccelerationStructureInstanceKHR VkAccelerationStructureInstanceNV;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateAccelerationStructureNV)(VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure);
		typedef void (VKAPI_PTR *PFN_vkDestroyAccelerationStructureNV)(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkGetAccelerationStructureMemoryRequirementsNV)(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements);
		typedef VkResult (VKAPI_PTR *PFN_vkBindAccelerationStructureMemoryNV)(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos);
		typedef void (VKAPI_PTR *PFN_vkCmdBuildAccelerationStructureNV)(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyAccelerationStructureNV)(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode);
		typedef void (VKAPI_PTR *PFN_vkCmdTraceRaysNV)(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateRayTracingPipelinesNV)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
		typedef VkResult (VKAPI_PTR *PFN_vkGetRayTracingShaderGroupHandlesNV)(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData);
		typedef VkResult (VKAPI_PTR *PFN_vkGetAccelerationStructureHandleNV)(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData);
		typedef void (VKAPI_PTR *PFN_vkCmdWriteAccelerationStructuresPropertiesNV)(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery);
		typedef VkResult (VKAPI_PTR *PFN_vkCompileDeferredNV)(VkDevice device, VkPipeline pipeline, uint32_t shader);


		#define VK_NV_representative_fragment_test 1
		#define VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION 2
		#define VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME "VK_NV_representative_fragment_test"

		typedef struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 representativeFragmentTest;
		} VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;

		typedef struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 representativeFragmentTestEnable;
		} VkPipelineRepresentativeFragmentTestStateCreateInfoNV;


		#define VK_KHR_maintenance3 1
		#define VK_KHR_MAINTENANCE_3_SPEC_VERSION 1
		#define VK_KHR_MAINTENANCE_3_EXTENSION_NAME "VK_KHR_maintenance3"

		typedef VkPhysicalDeviceMaintenance3Properties VkPhysicalDeviceMaintenance3PropertiesKHR;

		typedef VkDescriptorSetLayoutSupport VkDescriptorSetLayoutSupportKHR;

		typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutSupportKHR)(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport);


		#define VK_KHR_draw_indirect_count 1
		#define VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
		#define VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_KHR_draw_indirect_count"

		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountKHR)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountKHR)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);


		#define VK_AMD_draw_indirect_count 1
		#define VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION 2
		#define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);


		#define VK_EXT_filter_cubic 1
		#define VK_EXT_FILTER_CUBIC_SPEC_VERSION 3
		#define VK_EXT_FILTER_CUBIC_EXTENSION_NAME "VK_EXT_filter_cubic"

		typedef struct VkPhysicalDeviceImageViewImageFormatInfoEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkImageViewType imageViewType;
		} VkPhysicalDeviceImageViewImageFormatInfoEXT;

		typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 filterCubic;
		    VkBool32 filterCubicMinmax;
		} VkFilterCubicImageViewImageFormatPropertiesEXT;


		#define VK_QCOM_render_pass_shader_resolve 1
		#define VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION 4
		#define VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME "VK_QCOM_render_pass_shader_resolve"


		#define VK_KHR_shader_subgroup_extended_types 1
		#define VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION 1
		#define VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME "VK_KHR_shader_subgroup_extended_types"

		typedef VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR;


		#define VK_KHR_8bit_storage 1
		#define VK_KHR_8BIT_STORAGE_SPEC_VERSION 1
		#define VK_KHR_8BIT_STORAGE_EXTENSION_NAME "VK_KHR_8bit_storage"

		typedef VkPhysicalDevice8BitStorageFeatures VkPhysicalDevice8BitStorageFeaturesKHR;


		#define VK_EXT_external_memory_host 1
		#define VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION 1
		#define VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME "VK_EXT_external_memory_host"

		typedef struct VkImportMemoryHostPointerInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		    void* pHostPointer;
		} VkImportMemoryHostPointerInfoEXT;

		typedef struct VkMemoryHostPointerPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t memoryTypeBits;
		} VkMemoryHostPointerPropertiesEXT;

		typedef struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize minImportedHostPointerAlignment;
		} VkPhysicalDeviceExternalMemoryHostPropertiesEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryHostPointerPropertiesEXT)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties);


		#define VK_AMD_buffer_marker 1
		#define VK_AMD_BUFFER_MARKER_SPEC_VERSION 1
		#define VK_AMD_BUFFER_MARKER_EXTENSION_NAME "VK_AMD_buffer_marker"

		typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarkerAMD)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker);


		#define VK_KHR_shader_atomic_int64 1
		#define VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION 1
		#define VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME "VK_KHR_shader_atomic_int64"

		typedef VkPhysicalDeviceShaderAtomicInt64Features VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;


		#define VK_KHR_shader_clock 1
		#define VK_KHR_SHADER_CLOCK_SPEC_VERSION 1
		#define VK_KHR_SHADER_CLOCK_EXTENSION_NAME "VK_KHR_shader_clock"

		typedef struct VkPhysicalDeviceShaderClockFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderSubgroupClock;
		    VkBool32 shaderDeviceClock;
		} VkPhysicalDeviceShaderClockFeaturesKHR;


		#define VK_AMD_pipeline_compiler_control 1
		#define VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION 1
		#define VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME "VK_AMD_pipeline_compiler_control"


		typedef enum
		{
		    VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF
		} VkPipelineCompilerControlFlagBitsAMD;
		typedef VkFlags VkPipelineCompilerControlFlagsAMD;

		typedef struct VkPipelineCompilerControlCreateInfoAMD
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCompilerControlFlagsAMD compilerControlFlags;
		} VkPipelineCompilerControlCreateInfoAMD;


		#define VK_AMD_shader_core_properties 1
		#define VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION 2
		#define VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME "VK_AMD_shader_core_properties"

		typedef struct VkPhysicalDeviceShaderCorePropertiesAMD
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t shaderEngineCount;
		    uint32_t shaderArraysPerEngineCount;
		    uint32_t computeUnitsPerShaderArray;
		    uint32_t simdPerComputeUnit;
		    uint32_t wavefrontsPerSimd;
		    uint32_t wavefrontSize;
		    uint32_t sgprsPerSimd;
		    uint32_t minSgprAllocation;
		    uint32_t maxSgprAllocation;
		    uint32_t sgprAllocationGranularity;
		    uint32_t vgprsPerSimd;
		    uint32_t minVgprAllocation;
		    uint32_t maxVgprAllocation;
		    uint32_t vgprAllocationGranularity;
		} VkPhysicalDeviceShaderCorePropertiesAMD;


		#define VK_KHR_video_decode_h265 1
		#define VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION 8
		#define VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME "VK_KHR_video_decode_h265"

		typedef struct VkVideoDecodeH265ProfileInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    StdVideoH265ProfileIdc stdProfileIdc;
		} VkVideoDecodeH265ProfileInfoKHR;

		typedef struct VkVideoDecodeH265CapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    StdVideoH265LevelIdc maxLevelIdc;
		} VkVideoDecodeH265CapabilitiesKHR;

		typedef struct VkVideoDecodeH265SessionParametersAddInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t stdVPSCount;
		    const StdVideoH265VideoParameterSet* pStdVPSs;
		    uint32_t stdSPSCount;
		    const StdVideoH265SequenceParameterSet* pStdSPSs;
		    uint32_t stdPPSCount;
		    const StdVideoH265PictureParameterSet* pStdPPSs;
		} VkVideoDecodeH265SessionParametersAddInfoKHR;

		typedef struct VkVideoDecodeH265SessionParametersCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxStdVPSCount;
		    uint32_t maxStdSPSCount;
		    uint32_t maxStdPPSCount;
		    const VkVideoDecodeH265SessionParametersAddInfoKHR* pParametersAddInfo;
		} VkVideoDecodeH265SessionParametersCreateInfoKHR;

		typedef struct VkVideoDecodeH265PictureInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoDecodeH265PictureInfo* pStdPictureInfo;
		    uint32_t sliceSegmentCount;
		    const uint32_t* pSliceSegmentOffsets;
		} VkVideoDecodeH265PictureInfoKHR;

		typedef struct VkVideoDecodeH265DpbSlotInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo;
		} VkVideoDecodeH265DpbSlotInfoKHR;


		#define VK_EXT_global_priority_query 1
		#define VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION 1
		#define VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME "VK_EXT_global_priority_query"

		#define VK_MAX_GLOBAL_PRIORITY_SIZE_KHR 16
		#define VK_MAX_GLOBAL_PRIORITY_SIZE_EXT VK_MAX_GLOBAL_PRIORITY_SIZE_KHR

		typedef enum
		{
		    VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = 128,
		    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = 256,
		    VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = 512,
		    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = 1024,
		    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR,
		    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR,
		    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR,
		    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR,
		    VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkQueueGlobalPriorityKHR;


		typedef struct VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 globalPriorityQuery;
		} VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;

		typedef VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT;

		typedef struct VkQueueFamilyGlobalPriorityPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t priorityCount;
		    VkQueueGlobalPriorityKHR priorities[VK_MAX_GLOBAL_PRIORITY_SIZE_KHR];
		} VkQueueFamilyGlobalPriorityPropertiesKHR;

		typedef VkQueueFamilyGlobalPriorityPropertiesKHR VkQueueFamilyGlobalPriorityPropertiesEXT;


		#define VK_KHR_global_priority 1
		#define VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION 1
		#define VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME "VK_KHR_global_priority"

		typedef struct VkDeviceQueueGlobalPriorityCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkQueueGlobalPriorityKHR globalPriority;
		} VkDeviceQueueGlobalPriorityCreateInfoKHR;


		#define VK_EXT_global_priority 1
		#define VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION 2
		#define VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME "VK_EXT_global_priority"

		typedef VkQueueGlobalPriorityKHR VkQueueGlobalPriorityEXT;
		typedef VkDeviceQueueGlobalPriorityCreateInfoKHR VkDeviceQueueGlobalPriorityCreateInfoEXT;


		#define VK_AMD_memory_overallocation_behavior 1
		#define VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION 1
		#define VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME "VK_AMD_memory_overallocation_behavior"

		typedef enum
		{
		    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
		    VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
		    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
		    VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7FFFFFFF
		} VkMemoryOverallocationBehaviorAMD;


		typedef struct VkDeviceMemoryOverallocationCreateInfoAMD
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMemoryOverallocationBehaviorAMD overallocationBehavior;
		} VkDeviceMemoryOverallocationCreateInfoAMD;


		#define VK_EXT_pipeline_creation_feedback 1
		#define VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION 1
		#define VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME "VK_EXT_pipeline_creation_feedback"

		typedef VkPipelineCreationFeedbackFlagBits VkPipelineCreationFeedbackFlagBitsEXT;
		typedef VkPipelineCreationFeedbackFlags VkPipelineCreationFeedbackFlagsEXT;
		typedef VkPipelineCreationFeedbackCreateInfo VkPipelineCreationFeedbackCreateInfoEXT;

		typedef VkPipelineCreationFeedback VkPipelineCreationFeedbackEXT;


		#define VK_KHR_driver_properties 1
		#define VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION 1
		#define VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME "VK_KHR_driver_properties"

		#define VK_MAX_DRIVER_NAME_SIZE_KHR VK_MAX_DRIVER_NAME_SIZE
		#define VK_MAX_DRIVER_INFO_SIZE_KHR VK_MAX_DRIVER_INFO_SIZE

		typedef VkDriverId VkDriverIdKHR;
		typedef VkConformanceVersion VkConformanceVersionKHR;

		typedef VkPhysicalDeviceDriverProperties VkPhysicalDeviceDriverPropertiesKHR;


		#define VK_KHR_shader_float_controls 1
		#define VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION 4
		#define VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME "VK_KHR_shader_float_controls"

		typedef VkShaderFloatControlsIndependence VkShaderFloatControlsIndependenceKHR;
		typedef VkPhysicalDeviceFloatControlsProperties VkPhysicalDeviceFloatControlsPropertiesKHR;


		#define VK_NV_shader_subgroup_partitioned 1
		#define VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION 1
		#define VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME "VK_NV_shader_subgroup_partitioned"


		#define VK_KHR_depth_stencil_resolve 1
		#define VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION 1
		#define VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME "VK_KHR_depth_stencil_resolve"

		typedef VkResolveModeFlagBits VkResolveModeFlagBitsKHR;
		typedef VkResolveModeFlags VkResolveModeFlagsKHR;
		typedef VkSubpassDescriptionDepthStencilResolve VkSubpassDescriptionDepthStencilResolveKHR;

		typedef VkPhysicalDeviceDepthStencilResolveProperties VkPhysicalDeviceDepthStencilResolvePropertiesKHR;


		#define VK_KHR_swapchain_mutable_format 1
		#define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION 1
		#define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME "VK_KHR_swapchain_mutable_format"


		#define VK_NV_compute_shader_derivatives 1
		#define VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION 1
		#define VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME "VK_NV_compute_shader_derivatives"

		typedef struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 computeDerivativeGroupQuads;
		    VkBool32 computeDerivativeGroupLinear;
		} VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;


		#define VK_NV_mesh_shader 1
		#define VK_NV_MESH_SHADER_SPEC_VERSION 1
		#define VK_NV_MESH_SHADER_EXTENSION_NAME "VK_NV_mesh_shader"

		typedef struct VkPhysicalDeviceMeshShaderFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 taskShader;
		    VkBool32 meshShader;
		} VkPhysicalDeviceMeshShaderFeaturesNV;

		typedef struct VkPhysicalDeviceMeshShaderPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxDrawMeshTasksCount;
		    uint32_t maxTaskWorkGroupInvocations;
		    uint32_t maxTaskWorkGroupSize[3];
		    uint32_t maxTaskTotalMemorySize;
		    uint32_t maxTaskOutputCount;
		    uint32_t maxMeshWorkGroupInvocations;
		    uint32_t maxMeshWorkGroupSize[3];
		    uint32_t maxMeshTotalMemorySize;
		    uint32_t maxMeshOutputVertices;
		    uint32_t maxMeshOutputPrimitives;
		    uint32_t maxMeshMultiviewViewCount;
		    uint32_t meshOutputPerVertexGranularity;
		    uint32_t meshOutputPerPrimitiveGranularity;
		} VkPhysicalDeviceMeshShaderPropertiesNV;

		typedef struct VkDrawMeshTasksIndirectCommandNV
		{
		    uint32_t taskCount;
		    uint32_t firstTask;
		} VkDrawMeshTasksIndirectCommandNV;


		typedef void (VKAPI_PTR *PFN_vkCmdDrawMeshTasksNV)(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawMeshTasksIndirectNV)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawMeshTasksIndirectCountNV)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);


		#define VK_NV_shader_image_footprint 1
		#define VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION 2
		#define VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME "VK_NV_shader_image_footprint"

		typedef struct VkPhysicalDeviceShaderImageFootprintFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 imageFootprint;
		} VkPhysicalDeviceShaderImageFootprintFeaturesNV;


		#define VK_NV_scissor_exclusive 1
		#define VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION 2
		#define VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME "VK_NV_scissor_exclusive"

		typedef struct VkPipelineViewportExclusiveScissorStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t exclusiveScissorCount;
		    const VkRect2D* pExclusiveScissors;
		} VkPipelineViewportExclusiveScissorStateCreateInfoNV;

		typedef struct VkPhysicalDeviceExclusiveScissorFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 exclusiveScissor;
		} VkPhysicalDeviceExclusiveScissorFeaturesNV;


		typedef void (VKAPI_PTR *PFN_vkCmdSetExclusiveScissorEnableNV)(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables);
		typedef void (VKAPI_PTR *PFN_vkCmdSetExclusiveScissorNV)(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors);


		#define VK_NV_device_diagnostic_checkpoints 1
		#define VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION 2
		#define VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME "VK_NV_device_diagnostic_checkpoints"

		typedef struct VkQueueFamilyCheckpointPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPipelineStageFlags checkpointExecutionStageMask;
		} VkQueueFamilyCheckpointPropertiesNV;

		typedef struct VkCheckpointDataNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPipelineStageFlagBits stage;
		    void* pCheckpointMarker;
		} VkCheckpointDataNV;


		typedef void (VKAPI_PTR *PFN_vkCmdSetCheckpointNV)(VkCommandBuffer commandBuffer, const void* pCheckpointMarker);
		typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointDataNV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData);


		#define VK_KHR_timeline_semaphore 1
		#define VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION 2
		#define VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME "VK_KHR_timeline_semaphore"

		typedef VkSemaphoreType VkSemaphoreTypeKHR;
		typedef VkSemaphoreWaitFlagBits VkSemaphoreWaitFlagBitsKHR;
		typedef VkSemaphoreWaitFlags VkSemaphoreWaitFlagsKHR;
		typedef VkPhysicalDeviceTimelineSemaphoreFeatures VkPhysicalDeviceTimelineSemaphoreFeaturesKHR;

		typedef VkPhysicalDeviceTimelineSemaphoreProperties VkPhysicalDeviceTimelineSemaphorePropertiesKHR;

		typedef VkSemaphoreTypeCreateInfo VkSemaphoreTypeCreateInfoKHR;

		typedef VkTimelineSemaphoreSubmitInfo VkTimelineSemaphoreSubmitInfoKHR;

		typedef VkSemaphoreWaitInfo VkSemaphoreWaitInfoKHR;

		typedef VkSemaphoreSignalInfo VkSemaphoreSignalInfoKHR;

		typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValueKHR)(VkDevice device, VkSemaphore semaphore, uint64_t* pValue);
		typedef VkResult (VKAPI_PTR *PFN_vkWaitSemaphoresKHR)(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout);
		typedef VkResult (VKAPI_PTR *PFN_vkSignalSemaphoreKHR)(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo);


		#define VK_INTEL_shader_integer_functions2 1
		#define VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION 1
		#define VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME "VK_INTEL_shader_integer_functions2"

		typedef struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderIntegerFunctions2;
		} VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;


		#define VK_INTEL_performance_query 1
		#define VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION 2
		#define VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME "VK_INTEL_performance_query"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPerformanceConfigurationINTEL)

		typedef enum
		{
		    VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
		    VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF
		} VkPerformanceConfigurationTypeINTEL;

		typedef enum
		{
		    VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
		    VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7FFFFFFF
		} VkQueryPoolSamplingModeINTEL;

		typedef enum
		{
		    VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
		    VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
		    VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF
		} VkPerformanceOverrideTypeINTEL;

		typedef enum
		{
		    VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
		    VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
		    VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF
		} VkPerformanceParameterTypeINTEL;

		typedef enum
		{
		    VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
		    VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
		    VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
		    VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
		    VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
		    VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7FFFFFFF
		} VkPerformanceValueTypeINTEL;


		typedef union VkPerformanceValueDataINTEL
		{
		    uint32_t value32;
		    uint64_t value64;
		    float valueFloat;
		    VkBool32 valueBool;
		    const char* valueString;
		} VkPerformanceValueDataINTEL;

		typedef struct VkPerformanceValueINTEL
		{
		    VkPerformanceValueTypeINTEL type;
		    VkPerformanceValueDataINTEL data;
		} VkPerformanceValueINTEL;

		typedef struct VkInitializePerformanceApiInfoINTEL
		{
		    VkStructureType sType;
		    const void* pNext;
		    void* pUserData;
		} VkInitializePerformanceApiInfoINTEL;

		typedef struct VkQueryPoolPerformanceQueryCreateInfoINTEL
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkQueryPoolSamplingModeINTEL performanceCountersSampling;
		} VkQueryPoolPerformanceQueryCreateInfoINTEL;

		typedef VkQueryPoolPerformanceQueryCreateInfoINTEL VkQueryPoolCreateInfoINTEL;

		typedef struct VkPerformanceMarkerInfoINTEL
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t marker;
		} VkPerformanceMarkerInfoINTEL;

		typedef struct VkPerformanceStreamMarkerInfoINTEL
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t marker;
		} VkPerformanceStreamMarkerInfoINTEL;

		typedef struct VkPerformanceOverrideInfoINTEL
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPerformanceOverrideTypeINTEL type;
		    VkBool32 enable;
		    uint64_t parameter;
		} VkPerformanceOverrideInfoINTEL;

		typedef struct VkPerformanceConfigurationAcquireInfoINTEL
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPerformanceConfigurationTypeINTEL type;
		} VkPerformanceConfigurationAcquireInfoINTEL;


		typedef VkResult (VKAPI_PTR *PFN_vkInitializePerformanceApiINTEL)(VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo);
		typedef void (VKAPI_PTR *PFN_vkUninitializePerformanceApiINTEL)(VkDevice device);
		typedef VkResult (VKAPI_PTR *PFN_vkCmdSetPerformanceMarkerINTEL)(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCmdSetPerformanceStreamMarkerINTEL)(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCmdSetPerformanceOverrideINTEL)(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkAcquirePerformanceConfigurationINTEL)(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration);
		typedef VkResult (VKAPI_PTR *PFN_vkReleasePerformanceConfigurationINTEL)(VkDevice device, VkPerformanceConfigurationINTEL configuration);
		typedef VkResult (VKAPI_PTR *PFN_vkQueueSetPerformanceConfigurationINTEL)(VkQueue queue, VkPerformanceConfigurationINTEL configuration);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPerformanceParameterINTEL)(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue);


		#define VK_KHR_vulkan_memory_model 1
		#define VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION 3
		#define VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME "VK_KHR_vulkan_memory_model"

		typedef VkPhysicalDeviceVulkanMemoryModelFeatures VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;


		#define VK_EXT_pci_bus_info 1
		#define VK_EXT_PCI_BUS_INFO_SPEC_VERSION 2
		#define VK_EXT_PCI_BUS_INFO_EXTENSION_NAME "VK_EXT_pci_bus_info"

		typedef struct VkPhysicalDevicePCIBusInfoPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t pciDomain;
		    uint32_t pciBus;
		    uint32_t pciDevice;
		    uint32_t pciFunction;
		} VkPhysicalDevicePCIBusInfoPropertiesEXT;


		#define VK_AMD_display_native_hdr 1
		#define VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION 1
		#define VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME "VK_AMD_display_native_hdr"

		typedef struct VkDisplayNativeHdrSurfaceCapabilitiesAMD
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 localDimmingSupport;
		} VkDisplayNativeHdrSurfaceCapabilitiesAMD;

		typedef struct VkSwapchainDisplayNativeHdrCreateInfoAMD
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 localDimmingEnable;
		} VkSwapchainDisplayNativeHdrCreateInfoAMD;


		typedef void (VKAPI_PTR *PFN_vkSetLocalDimmingAMD)(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable);


		#define VK_KHR_shader_terminate_invocation 1
		#define VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION 1
		#define VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME "VK_KHR_shader_terminate_invocation"

		typedef VkPhysicalDeviceShaderTerminateInvocationFeatures VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR;


		#define VK_EXT_fragment_density_map 1
		#define VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION 2
		#define VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME "VK_EXT_fragment_density_map"

		typedef struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 fragmentDensityMap;
		    VkBool32 fragmentDensityMapDynamic;
		    VkBool32 fragmentDensityMapNonSubsampledImages;
		} VkPhysicalDeviceFragmentDensityMapFeaturesEXT;

		typedef struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent2D minFragmentDensityTexelSize;
		    VkExtent2D maxFragmentDensityTexelSize;
		    VkBool32 fragmentDensityInvocations;
		} VkPhysicalDeviceFragmentDensityMapPropertiesEXT;

		typedef struct VkRenderPassFragmentDensityMapCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAttachmentReference fragmentDensityMapAttachment;
		} VkRenderPassFragmentDensityMapCreateInfoEXT;


		#define VK_EXT_scalar_block_layout 1
		#define VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION 1
		#define VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME "VK_EXT_scalar_block_layout"

		typedef VkPhysicalDeviceScalarBlockLayoutFeatures VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;


		#define VK_GOOGLE_hlsl_functionality1 1
		#define VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION 1
		#define VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME "VK_GOOGLE_hlsl_functionality1"


		#define VK_GOOGLE_decorate_string 1
		#define VK_GOOGLE_DECORATE_STRING_SPEC_VERSION 1
		#define VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME "VK_GOOGLE_decorate_string"


		#define VK_EXT_subgroup_size_control 1
		#define VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION 2
		#define VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME "VK_EXT_subgroup_size_control"

		typedef VkPhysicalDeviceSubgroupSizeControlFeatures VkPhysicalDeviceSubgroupSizeControlFeaturesEXT;

		typedef VkPhysicalDeviceSubgroupSizeControlProperties VkPhysicalDeviceSubgroupSizeControlPropertiesEXT;

		typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;


		#define VK_KHR_fragment_shading_rate 1
		#define VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION 2
		#define VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME "VK_KHR_fragment_shading_rate"

		typedef enum
		{
		    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
		    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
		    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
		    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
		    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
		    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkFragmentShadingRateCombinerOpKHR;


		typedef struct VkFragmentShadingRateAttachmentInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const VkAttachmentReference2* pFragmentShadingRateAttachment;
		    VkExtent2D shadingRateAttachmentTexelSize;
		} VkFragmentShadingRateAttachmentInfoKHR;

		typedef struct VkPipelineFragmentShadingRateStateCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExtent2D fragmentSize;
		    VkFragmentShadingRateCombinerOpKHR combinerOps[2];
		} VkPipelineFragmentShadingRateStateCreateInfoKHR;

		typedef struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pipelineFragmentShadingRate;
		    VkBool32 primitiveFragmentShadingRate;
		    VkBool32 attachmentFragmentShadingRate;
		} VkPhysicalDeviceFragmentShadingRateFeaturesKHR;

		typedef struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent2D minFragmentShadingRateAttachmentTexelSize;
		    VkExtent2D maxFragmentShadingRateAttachmentTexelSize;
		    uint32_t maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
		    VkBool32 primitiveFragmentShadingRateWithMultipleViewports;
		    VkBool32 layeredShadingRateAttachments;
		    VkBool32 fragmentShadingRateNonTrivialCombinerOps;
		    VkExtent2D maxFragmentSize;
		    uint32_t maxFragmentSizeAspectRatio;
		    uint32_t maxFragmentShadingRateCoverageSamples;
		    VkSampleCountFlagBits maxFragmentShadingRateRasterizationSamples;
		    VkBool32 fragmentShadingRateWithShaderDepthStencilWrites;
		    VkBool32 fragmentShadingRateWithSampleMask;
		    VkBool32 fragmentShadingRateWithShaderSampleMask;
		    VkBool32 fragmentShadingRateWithConservativeRasterization;
		    VkBool32 fragmentShadingRateWithFragmentShaderInterlock;
		    VkBool32 fragmentShadingRateWithCustomSampleLocations;
		    VkBool32 fragmentShadingRateStrictMultiplyCombiner;
		} VkPhysicalDeviceFragmentShadingRatePropertiesKHR;

		typedef struct VkPhysicalDeviceFragmentShadingRateKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSampleCountFlags sampleCounts;
		    VkExtent2D fragmentSize;
		} VkPhysicalDeviceFragmentShadingRateKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates);
		typedef void (VKAPI_PTR *PFN_vkCmdSetFragmentShadingRateKHR)(VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]);


		#define VK_AMD_shader_core_properties2 1
		#define VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION 1
		#define VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME "VK_AMD_shader_core_properties2"


		typedef enum
		{
		    VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7FFFFFFF
		} VkShaderCorePropertiesFlagBitsAMD;
		typedef VkFlags VkShaderCorePropertiesFlagsAMD;

		typedef struct VkPhysicalDeviceShaderCoreProperties2AMD
		{
		    VkStructureType sType;
		    void* pNext;
		    VkShaderCorePropertiesFlagsAMD shaderCoreFeatures;
		    uint32_t activeComputeUnitCount;
		} VkPhysicalDeviceShaderCoreProperties2AMD;


		#define VK_AMD_device_coherent_memory 1
		#define VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION 1
		#define VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME "VK_AMD_device_coherent_memory"

		typedef struct VkPhysicalDeviceCoherentMemoryFeaturesAMD
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 deviceCoherentMemory;
		} VkPhysicalDeviceCoherentMemoryFeaturesAMD;


		#define VK_KHR_dynamic_rendering_local_read 1
		#define VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION 1
		#define VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME "VK_KHR_dynamic_rendering_local_read"

		typedef struct VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 dynamicRenderingLocalRead;
		} VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR;

		typedef struct VkRenderingAttachmentLocationInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t colorAttachmentCount;
		    const uint32_t* pColorAttachmentLocations;
		} VkRenderingAttachmentLocationInfoKHR;

		typedef struct VkRenderingInputAttachmentIndexInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t colorAttachmentCount;
		    const uint32_t* pColorAttachmentInputIndices;
		    const uint32_t* pDepthInputAttachmentIndex;
		    const uint32_t* pStencilInputAttachmentIndex;
		} VkRenderingInputAttachmentIndexInfoKHR;


		typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingAttachmentLocationsKHR)(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfoKHR* pLocationInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdSetRenderingInputAttachmentIndicesKHR)(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfoKHR* pLocationInfo);


		#define VK_EXT_shader_image_atomic_int64 1
		#define VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION 1
		#define VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME "VK_EXT_shader_image_atomic_int64"

		typedef struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderImageInt64Atomics;
		    VkBool32 sparseImageInt64Atomics;
		} VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT;


		#define VK_KHR_shader_quad_control 1
		#define VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION 1
		#define VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME "VK_KHR_shader_quad_control"

		typedef struct VkPhysicalDeviceShaderQuadControlFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderQuadControl;
		} VkPhysicalDeviceShaderQuadControlFeaturesKHR;


		#define VK_KHR_spirv_1_4 1
		#define VK_KHR_SPIRV_1_4_SPEC_VERSION 1
		#define VK_KHR_SPIRV_1_4_EXTENSION_NAME "VK_KHR_spirv_1_4"


		#define VK_EXT_memory_budget 1
		#define VK_EXT_MEMORY_BUDGET_SPEC_VERSION 1
		#define VK_EXT_MEMORY_BUDGET_EXTENSION_NAME "VK_EXT_memory_budget"

		typedef struct VkPhysicalDeviceMemoryBudgetPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize heapBudget[VK_MAX_MEMORY_HEAPS];
		    VkDeviceSize heapUsage[VK_MAX_MEMORY_HEAPS];
		} VkPhysicalDeviceMemoryBudgetPropertiesEXT;


		#define VK_EXT_memory_priority 1
		#define VK_EXT_MEMORY_PRIORITY_SPEC_VERSION 1
		#define VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME "VK_EXT_memory_priority"

		typedef struct VkPhysicalDeviceMemoryPriorityFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 memoryPriority;
		} VkPhysicalDeviceMemoryPriorityFeaturesEXT;

		typedef struct VkMemoryPriorityAllocateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    float priority;
		} VkMemoryPriorityAllocateInfoEXT;


		#define VK_KHR_surface_protected_capabilities 1
		#define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION 1
		#define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME "VK_KHR_surface_protected_capabilities"

		typedef struct VkSurfaceProtectedCapabilitiesKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 supportsProtected;
		} VkSurfaceProtectedCapabilitiesKHR;


		#define VK_NV_dedicated_allocation_image_aliasing 1
		#define VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION 1
		#define VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME "VK_NV_dedicated_allocation_image_aliasing"

		typedef struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 dedicatedAllocationImageAliasing;
		} VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;


		#define VK_KHR_separate_depth_stencil_layouts 1
		#define VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION 1
		#define VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME "VK_KHR_separate_depth_stencil_layouts"

		typedef VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR;

		typedef VkAttachmentReferenceStencilLayout VkAttachmentReferenceStencilLayoutKHR;

		typedef VkAttachmentDescriptionStencilLayout VkAttachmentDescriptionStencilLayoutKHR;


		#define VK_EXT_tooling_info 1
		#define VK_EXT_TOOLING_INFO_SPEC_VERSION 1
		#define VK_EXT_TOOLING_INFO_EXTENSION_NAME "VK_EXT_tooling_info"

		typedef VkToolPurposeFlagBits VkToolPurposeFlagBitsEXT;
		typedef VkToolPurposeFlags VkToolPurposeFlagsEXT;
		typedef VkPhysicalDeviceToolProperties VkPhysicalDeviceToolPropertiesEXT;

		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceToolPropertiesEXT)(VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties);


		#define VK_EXT_separate_stencil_usage 1
		#define VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION 1
		#define VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME "VK_EXT_separate_stencil_usage"

		typedef VkImageStencilUsageCreateInfo VkImageStencilUsageCreateInfoEXT;


		#define VK_EXT_validation_features 1
		#define VK_EXT_VALIDATION_FEATURES_SPEC_VERSION 6
		#define VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME "VK_EXT_validation_features"

		typedef enum
		{
		    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
		    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
		    VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
		    VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
		    VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
		    VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkValidationFeatureEnableEXT;

		typedef enum
		{
		    VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
		    VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
		    VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
		    VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
		    VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
		    VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
		    VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
		    VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
		    VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkValidationFeatureDisableEXT;


		typedef struct VkValidationFeaturesEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t enabledValidationFeatureCount;
		    const VkValidationFeatureEnableEXT* pEnabledValidationFeatures;
		    uint32_t disabledValidationFeatureCount;
		    const VkValidationFeatureDisableEXT* pDisabledValidationFeatures;
		} VkValidationFeaturesEXT;


		#define VK_KHR_present_wait 1
		#define VK_KHR_PRESENT_WAIT_SPEC_VERSION 1
		#define VK_KHR_PRESENT_WAIT_EXTENSION_NAME "VK_KHR_present_wait"

		typedef struct VkPhysicalDevicePresentWaitFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 presentWait;
		} VkPhysicalDevicePresentWaitFeaturesKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkWaitForPresentKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout);


		#define VK_NV_cooperative_matrix 1
		#define VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION 1
		#define VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME "VK_NV_cooperative_matrix"

		typedef enum
		{
		    VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
		    VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
		    VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
		    VK_COMPONENT_TYPE_SINT8_KHR = 3,
		    VK_COMPONENT_TYPE_SINT16_KHR = 4,
		    VK_COMPONENT_TYPE_SINT32_KHR = 5,
		    VK_COMPONENT_TYPE_SINT64_KHR = 6,
		    VK_COMPONENT_TYPE_UINT8_KHR = 7,
		    VK_COMPONENT_TYPE_UINT16_KHR = 8,
		    VK_COMPONENT_TYPE_UINT32_KHR = 9,
		    VK_COMPONENT_TYPE_UINT64_KHR = 10,
		    VK_COMPONENT_TYPE_FLOAT16_NV = VK_COMPONENT_TYPE_FLOAT16_KHR,
		    VK_COMPONENT_TYPE_FLOAT32_NV = VK_COMPONENT_TYPE_FLOAT32_KHR,
		    VK_COMPONENT_TYPE_FLOAT64_NV = VK_COMPONENT_TYPE_FLOAT64_KHR,
		    VK_COMPONENT_TYPE_SINT8_NV = VK_COMPONENT_TYPE_SINT8_KHR,
		    VK_COMPONENT_TYPE_SINT16_NV = VK_COMPONENT_TYPE_SINT16_KHR,
		    VK_COMPONENT_TYPE_SINT32_NV = VK_COMPONENT_TYPE_SINT32_KHR,
		    VK_COMPONENT_TYPE_SINT64_NV = VK_COMPONENT_TYPE_SINT64_KHR,
		    VK_COMPONENT_TYPE_UINT8_NV = VK_COMPONENT_TYPE_UINT8_KHR,
		    VK_COMPONENT_TYPE_UINT16_NV = VK_COMPONENT_TYPE_UINT16_KHR,
		    VK_COMPONENT_TYPE_UINT32_NV = VK_COMPONENT_TYPE_UINT32_KHR,
		    VK_COMPONENT_TYPE_UINT64_NV = VK_COMPONENT_TYPE_UINT64_KHR,
		    VK_COMPONENT_TYPE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkComponentTypeKHR;

		typedef VkComponentTypeKHR VkComponentTypeNV;
		typedef enum
		{
		    VK_SCOPE_DEVICE_KHR = 1,
		    VK_SCOPE_WORKGROUP_KHR = 2,
		    VK_SCOPE_SUBGROUP_KHR = 3,
		    VK_SCOPE_QUEUE_FAMILY_KHR = 5,
		    VK_SCOPE_DEVICE_NV = VK_SCOPE_DEVICE_KHR,
		    VK_SCOPE_WORKGROUP_NV = VK_SCOPE_WORKGROUP_KHR,
		    VK_SCOPE_SUBGROUP_NV = VK_SCOPE_SUBGROUP_KHR,
		    VK_SCOPE_QUEUE_FAMILY_NV = VK_SCOPE_QUEUE_FAMILY_KHR,
		    VK_SCOPE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkScopeKHR;

		typedef VkScopeKHR VkScopeNV;

		typedef struct VkCooperativeMatrixPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t MSize;
		    uint32_t NSize;
		    uint32_t KSize;
		    VkComponentTypeNV AType;
		    VkComponentTypeNV BType;
		    VkComponentTypeNV CType;
		    VkComponentTypeNV DType;
		    VkScopeNV scope;
		} VkCooperativeMatrixPropertiesNV;

		typedef struct VkPhysicalDeviceCooperativeMatrixFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 cooperativeMatrix;
		    VkBool32 cooperativeMatrixRobustBufferAccess;
		} VkPhysicalDeviceCooperativeMatrixFeaturesNV;

		typedef struct VkPhysicalDeviceCooperativeMatrixPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkShaderStageFlags cooperativeMatrixSupportedStages;
		} VkPhysicalDeviceCooperativeMatrixPropertiesNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties);


		#define VK_NV_coverage_reduction_mode 1
		#define VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION 1
		#define VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME "VK_NV_coverage_reduction_mode"

		typedef VkFlags VkPipelineCoverageReductionStateCreateFlagsNV;
		typedef enum
		{
		    VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
		    VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
		    VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkCoverageReductionModeNV;


		typedef struct VkPhysicalDeviceCoverageReductionModeFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 coverageReductionMode;
		} VkPhysicalDeviceCoverageReductionModeFeaturesNV;

		typedef struct VkPipelineCoverageReductionStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCoverageReductionStateCreateFlagsNV flags;
		    VkCoverageReductionModeNV coverageReductionMode;
		} VkPipelineCoverageReductionStateCreateInfoNV;

		typedef struct VkFramebufferMixedSamplesCombinationNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkCoverageReductionModeNV coverageReductionMode;
		    VkSampleCountFlagBits rasterizationSamples;
		    VkSampleCountFlags depthStencilSamples;
		    VkSampleCountFlags colorSamples;
		} VkFramebufferMixedSamplesCombinationNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)(VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations);


		#define VK_EXT_fragment_shader_interlock 1
		#define VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION 1
		#define VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME "VK_EXT_fragment_shader_interlock"

		typedef struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 fragmentShaderSampleInterlock;
		    VkBool32 fragmentShaderPixelInterlock;
		    VkBool32 fragmentShaderShadingRateInterlock;
		} VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;


		#define VK_EXT_ycbcr_image_arrays 1
		#define VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION 1
		#define VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME "VK_EXT_ycbcr_image_arrays"

		typedef struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 ycbcrImageArrays;
		} VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;


		#define VK_KHR_uniform_buffer_standard_layout 1
		#define VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION 1
		#define VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME "VK_KHR_uniform_buffer_standard_layout"

		typedef VkPhysicalDeviceUniformBufferStandardLayoutFeatures VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR;


		#define VK_EXT_provoking_vertex 1
		#define VK_EXT_PROVOKING_VERTEX_SPEC_VERSION 1
		#define VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME "VK_EXT_provoking_vertex"

		typedef enum
		{
		    VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
		    VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
		    VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkProvokingVertexModeEXT;


		typedef struct VkPhysicalDeviceProvokingVertexFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 provokingVertexLast;
		    VkBool32 transformFeedbackPreservesProvokingVertex;
		} VkPhysicalDeviceProvokingVertexFeaturesEXT;

		typedef struct VkPhysicalDeviceProvokingVertexPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 provokingVertexModePerPipeline;
		    VkBool32 transformFeedbackPreservesTriangleFanProvokingVertex;
		} VkPhysicalDeviceProvokingVertexPropertiesEXT;

		typedef struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkProvokingVertexModeEXT provokingVertexMode;
		} VkPipelineRasterizationProvokingVertexStateCreateInfoEXT;


		#define VK_EXT_headless_surface 1
		#define VK_EXT_HEADLESS_SURFACE_SPEC_VERSION 1
		#define VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME "VK_EXT_headless_surface"

		typedef VkFlags VkHeadlessSurfaceCreateFlagsEXT;
		typedef struct VkHeadlessSurfaceCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkHeadlessSurfaceCreateFlagsEXT flags;
		} VkHeadlessSurfaceCreateInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateHeadlessSurfaceEXT)(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);


		#define VK_KHR_buffer_device_address 1
		#define VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION 1
		#define VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME "VK_KHR_buffer_device_address"

		typedef VkPhysicalDeviceBufferDeviceAddressFeatures VkPhysicalDeviceBufferDeviceAddressFeaturesKHR;

		typedef VkBufferDeviceAddressInfo VkBufferDeviceAddressInfoKHR;

		typedef VkBufferOpaqueCaptureAddressCreateInfo VkBufferOpaqueCaptureAddressCreateInfoKHR;

		typedef VkMemoryOpaqueCaptureAddressAllocateInfo VkMemoryOpaqueCaptureAddressAllocateInfoKHR;

		typedef VkDeviceMemoryOpaqueCaptureAddressInfo VkDeviceMemoryOpaqueCaptureAddressInfoKHR;

		typedef VkDeviceAddress (VKAPI_PTR *PFN_vkGetBufferDeviceAddressKHR)(VkDevice device, const VkBufferDeviceAddressInfo* pInfo);
		typedef uint64_t (VKAPI_PTR *PFN_vkGetBufferOpaqueCaptureAddressKHR)(VkDevice device, const VkBufferDeviceAddressInfo* pInfo);
		typedef uint64_t (VKAPI_PTR *PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR)(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo);


		#define VK_EXT_buffer_device_address 1
		#define VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION 2
		#define VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME "VK_EXT_buffer_device_address"

		typedef struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 bufferDeviceAddress;
		    VkBool32 bufferDeviceAddressCaptureReplay;
		    VkBool32 bufferDeviceAddressMultiDevice;
		} VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

		typedef VkPhysicalDeviceBufferDeviceAddressFeaturesEXT VkPhysicalDeviceBufferAddressFeaturesEXT;

		typedef VkBufferDeviceAddressInfo VkBufferDeviceAddressInfoEXT;

		typedef struct VkBufferDeviceAddressCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceAddress deviceAddress;
		} VkBufferDeviceAddressCreateInfoEXT;


		typedef VkDeviceAddress (VKAPI_PTR *PFN_vkGetBufferDeviceAddressEXT)(VkDevice device, const VkBufferDeviceAddressInfo* pInfo);


		#define VK_EXT_shader_atomic_float 1
		#define VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION 1
		#define VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME "VK_EXT_shader_atomic_float"

		typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderBufferFloat32Atomics;
		    VkBool32 shaderBufferFloat32AtomicAdd;
		    VkBool32 shaderBufferFloat64Atomics;
		    VkBool32 shaderBufferFloat64AtomicAdd;
		    VkBool32 shaderSharedFloat32Atomics;
		    VkBool32 shaderSharedFloat32AtomicAdd;
		    VkBool32 shaderSharedFloat64Atomics;
		    VkBool32 shaderSharedFloat64AtomicAdd;
		    VkBool32 shaderImageFloat32Atomics;
		    VkBool32 shaderImageFloat32AtomicAdd;
		    VkBool32 sparseImageFloat32Atomics;
		    VkBool32 sparseImageFloat32AtomicAdd;
		} VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;


		#define VK_EXT_host_query_reset 1
		#define VK_EXT_HOST_QUERY_RESET_SPEC_VERSION 1
		#define VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME "VK_EXT_host_query_reset"

		typedef VkPhysicalDeviceHostQueryResetFeatures VkPhysicalDeviceHostQueryResetFeaturesEXT;

		typedef void (VKAPI_PTR *PFN_vkResetQueryPoolEXT)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);


		#define VK_EXT_extended_dynamic_state 1
		#define VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION 1
		#define VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME "VK_EXT_extended_dynamic_state"

		typedef struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 extendedDynamicState;
		} VkPhysicalDeviceExtendedDynamicStateFeaturesEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetCullModeEXT)(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode);
		typedef void (VKAPI_PTR *PFN_vkCmdSetFrontFaceEXT)(VkCommandBuffer commandBuffer, VkFrontFace frontFace);
		typedef void (VKAPI_PTR *PFN_vkCmdSetPrimitiveTopologyEXT)(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology);
		typedef void (VKAPI_PTR *PFN_vkCmdSetViewportWithCountEXT)(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports);
		typedef void (VKAPI_PTR *PFN_vkCmdSetScissorWithCountEXT)(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors);
		typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers2EXT)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthTestEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthWriteEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthCompareOpEXT)(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBoundsTestEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetStencilTestEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetStencilOpEXT)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp);


		#define VK_KHR_deferred_host_operations 1
		#define VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION 4
		#define VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME "VK_KHR_deferred_host_operations"

		typedef VkResult (VKAPI_PTR *PFN_vkCreateDeferredOperationKHR)(VkDevice device, const VkAllocationCallbacks* pAllocator, VkDeferredOperationKHR* pDeferredOperation);
		typedef void (VKAPI_PTR *PFN_vkDestroyDeferredOperationKHR)(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks* pAllocator);
		typedef uint32_t (VKAPI_PTR *PFN_vkGetDeferredOperationMaxConcurrencyKHR)(VkDevice device, VkDeferredOperationKHR operation);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDeferredOperationResultKHR)(VkDevice device, VkDeferredOperationKHR operation);
		typedef VkResult (VKAPI_PTR *PFN_vkDeferredOperationJoinKHR)(VkDevice device, VkDeferredOperationKHR operation);


		#define VK_KHR_pipeline_executable_properties 1
		#define VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION 1
		#define VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME "VK_KHR_pipeline_executable_properties"

		typedef enum
		{
		    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
		    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
		    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
		    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
		    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkPipelineExecutableStatisticFormatKHR;


		typedef struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pipelineExecutableInfo;
		} VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;

		typedef struct VkPipelineInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipeline pipeline;
		} VkPipelineInfoKHR;

		typedef struct VkPipelineExecutablePropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkShaderStageFlags stages;
		    char name[VK_MAX_DESCRIPTION_SIZE];
		    char description[VK_MAX_DESCRIPTION_SIZE];
		    uint32_t subgroupSize;
		} VkPipelineExecutablePropertiesKHR;

		typedef struct VkPipelineExecutableInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipeline pipeline;
		    uint32_t executableIndex;
		} VkPipelineExecutableInfoKHR;

		typedef union VkPipelineExecutableStatisticValueKHR
		{
		    VkBool32 b32;
		    int64_t i64;
		    uint64_t u64;
		    double f64;
		} VkPipelineExecutableStatisticValueKHR;

		typedef struct VkPipelineExecutableStatisticKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    char name[VK_MAX_DESCRIPTION_SIZE];
		    char description[VK_MAX_DESCRIPTION_SIZE];
		    VkPipelineExecutableStatisticFormatKHR format;
		    VkPipelineExecutableStatisticValueKHR value;
		} VkPipelineExecutableStatisticKHR;

		typedef struct VkPipelineExecutableInternalRepresentationKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    char name[VK_MAX_DESCRIPTION_SIZE];
		    char description[VK_MAX_DESCRIPTION_SIZE];
		    VkBool32 isText;
		    size_t dataSize;
		    void* pData;
		} VkPipelineExecutableInternalRepresentationKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineExecutablePropertiesKHR)(VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineExecutableStatisticsKHR)(VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineExecutableInternalRepresentationsKHR)(VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations);


		#define VK_EXT_host_image_copy 1
		#define VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION 1
		#define VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME "VK_EXT_host_image_copy"


		typedef enum
		{
		    VK_HOST_IMAGE_COPY_MEMCPY_EXT = 0x00000001,
		    VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkHostImageCopyFlagBitsEXT;
		typedef VkFlags VkHostImageCopyFlagsEXT;

		typedef struct VkPhysicalDeviceHostImageCopyFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 hostImageCopy;
		} VkPhysicalDeviceHostImageCopyFeaturesEXT;

		typedef struct VkPhysicalDeviceHostImageCopyPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t copySrcLayoutCount;
		    VkImageLayout* pCopySrcLayouts;
		    uint32_t copyDstLayoutCount;
		    VkImageLayout* pCopyDstLayouts;
		    uint8_t optimalTilingLayoutUUID[VK_UUID_SIZE];
		    VkBool32 identicalMemoryTypeRequirements;
		} VkPhysicalDeviceHostImageCopyPropertiesEXT;

		typedef struct VkMemoryToImageCopyEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    const void* pHostPointer;
		    uint32_t memoryRowLength;
		    uint32_t memoryImageHeight;
		    VkImageSubresourceLayers imageSubresource;
		    VkOffset3D imageOffset;
		    VkExtent3D imageExtent;
		} VkMemoryToImageCopyEXT;

		typedef struct VkImageToMemoryCopyEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    void* pHostPointer;
		    uint32_t memoryRowLength;
		    uint32_t memoryImageHeight;
		    VkImageSubresourceLayers imageSubresource;
		    VkOffset3D imageOffset;
		    VkExtent3D imageExtent;
		} VkImageToMemoryCopyEXT;

		typedef struct VkCopyMemoryToImageInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkHostImageCopyFlagsEXT flags;
		    VkImage dstImage;
		    VkImageLayout dstImageLayout;
		    uint32_t regionCount;
		    const VkMemoryToImageCopyEXT* pRegions;
		} VkCopyMemoryToImageInfoEXT;

		typedef struct VkCopyImageToMemoryInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkHostImageCopyFlagsEXT flags;
		    VkImage srcImage;
		    VkImageLayout srcImageLayout;
		    uint32_t regionCount;
		    const VkImageToMemoryCopyEXT* pRegions;
		} VkCopyImageToMemoryInfoEXT;

		typedef struct VkCopyImageToImageInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkHostImageCopyFlagsEXT flags;
		    VkImage srcImage;
		    VkImageLayout srcImageLayout;
		    VkImage dstImage;
		    VkImageLayout dstImageLayout;
		    uint32_t regionCount;
		    const VkImageCopy2* pRegions;
		} VkCopyImageToImageInfoEXT;

		typedef struct VkHostImageLayoutTransitionInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		    VkImageLayout oldLayout;
		    VkImageLayout newLayout;
		    VkImageSubresourceRange subresourceRange;
		} VkHostImageLayoutTransitionInfoEXT;

		typedef struct VkSubresourceHostMemcpySizeEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize size;
		} VkSubresourceHostMemcpySizeEXT;

		typedef struct VkHostImageCopyDevicePerformanceQueryEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 optimalDeviceAccess;
		    VkBool32 identicalMemoryLayout;
		} VkHostImageCopyDevicePerformanceQueryEXT;

		typedef struct VkSubresourceLayout2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSubresourceLayout subresourceLayout;
		} VkSubresourceLayout2KHR;

		typedef VkSubresourceLayout2KHR VkSubresourceLayout2EXT;

		typedef struct VkImageSubresource2KHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkImageSubresource imageSubresource;
		} VkImageSubresource2KHR;

		typedef VkImageSubresource2KHR VkImageSubresource2EXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCopyMemoryToImageEXT)(VkDevice device, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToMemoryEXT)(VkDevice device, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyImageToImageEXT)(VkDevice device, const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkTransitionImageLayoutEXT)(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT* pTransitions);
		typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2EXT)(VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout);


		#define VK_KHR_map_memory2 1
		#define VK_KHR_MAP_MEMORY_2_SPEC_VERSION 1
		#define VK_KHR_MAP_MEMORY_2_EXTENSION_NAME "VK_KHR_map_memory2"


		typedef enum
		{
		    VK_MEMORY_UNMAP_RESERVE_BIT_EXT = 0x00000001,
		    VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkMemoryUnmapFlagBitsKHR;
		typedef VkFlags VkMemoryUnmapFlagsKHR;

		typedef struct VkMemoryMapInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMemoryMapFlags flags;
		    VkDeviceMemory memory;
		    VkDeviceSize offset;
		    VkDeviceSize size;
		} VkMemoryMapInfoKHR;

		typedef struct VkMemoryUnmapInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMemoryUnmapFlagsKHR flags;
		    VkDeviceMemory memory;
		} VkMemoryUnmapInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkMapMemory2KHR)(VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData);
		typedef VkResult (VKAPI_PTR *PFN_vkUnmapMemory2KHR)(VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo);


		#define VK_EXT_map_memory_placed 1
		#define VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION 1
		#define VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME "VK_EXT_map_memory_placed"

		typedef struct VkPhysicalDeviceMapMemoryPlacedFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 memoryMapPlaced;
		    VkBool32 memoryMapRangePlaced;
		    VkBool32 memoryUnmapReserve;
		} VkPhysicalDeviceMapMemoryPlacedFeaturesEXT;

		typedef struct VkPhysicalDeviceMapMemoryPlacedPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize minPlacedMemoryMapAlignment;
		} VkPhysicalDeviceMapMemoryPlacedPropertiesEXT;

		typedef struct VkMemoryMapPlacedInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    void* pPlacedAddress;
		} VkMemoryMapPlacedInfoEXT;


		#define VK_EXT_shader_atomic_float2 1
		#define VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION 1
		#define VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME "VK_EXT_shader_atomic_float2"

		typedef struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderBufferFloat16Atomics;
		    VkBool32 shaderBufferFloat16AtomicAdd;
		    VkBool32 shaderBufferFloat16AtomicMinMax;
		    VkBool32 shaderBufferFloat32AtomicMinMax;
		    VkBool32 shaderBufferFloat64AtomicMinMax;
		    VkBool32 shaderSharedFloat16Atomics;
		    VkBool32 shaderSharedFloat16AtomicAdd;
		    VkBool32 shaderSharedFloat16AtomicMinMax;
		    VkBool32 shaderSharedFloat32AtomicMinMax;
		    VkBool32 shaderSharedFloat64AtomicMinMax;
		    VkBool32 shaderImageFloat32AtomicMinMax;
		    VkBool32 sparseImageFloat32AtomicMinMax;
		} VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT;


		#define VK_EXT_surface_maintenance1 1
		#define VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION 1
		#define VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME "VK_EXT_surface_maintenance1"


		typedef enum
		{
		    VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT = 0x00000001,
		    VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT = 0x00000002,
		    VK_PRESENT_SCALING_STRETCH_BIT_EXT = 0x00000004,
		    VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkPresentScalingFlagBitsEXT;
		typedef VkFlags VkPresentScalingFlagsEXT;

		typedef enum
		{
		    VK_PRESENT_GRAVITY_MIN_BIT_EXT = 0x00000001,
		    VK_PRESENT_GRAVITY_MAX_BIT_EXT = 0x00000002,
		    VK_PRESENT_GRAVITY_CENTERED_BIT_EXT = 0x00000004,
		    VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkPresentGravityFlagBitsEXT;
		typedef VkFlags VkPresentGravityFlagsEXT;

		typedef struct VkSurfacePresentModeEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPresentModeKHR presentMode;
		} VkSurfacePresentModeEXT;

		typedef struct VkSurfacePresentScalingCapabilitiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPresentScalingFlagsEXT supportedPresentScaling;
		    VkPresentGravityFlagsEXT supportedPresentGravityX;
		    VkPresentGravityFlagsEXT supportedPresentGravityY;
		    VkExtent2D minScaledImageExtent;
		    VkExtent2D maxScaledImageExtent;
		} VkSurfacePresentScalingCapabilitiesEXT;

		typedef struct VkSurfacePresentModeCompatibilityEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t presentModeCount;
		    VkPresentModeKHR* pPresentModes;
		} VkSurfacePresentModeCompatibilityEXT;


		#define VK_EXT_swapchain_maintenance1 1
		#define VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION 1
		#define VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME "VK_EXT_swapchain_maintenance1"

		typedef struct VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 swapchainMaintenance1;
		} VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT;

		typedef struct VkSwapchainPresentFenceInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t swapchainCount;
		    const VkFence* pFences;
		} VkSwapchainPresentFenceInfoEXT;

		typedef struct VkSwapchainPresentModesCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t presentModeCount;
		    const VkPresentModeKHR* pPresentModes;
		} VkSwapchainPresentModesCreateInfoEXT;

		typedef struct VkSwapchainPresentModeInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t swapchainCount;
		    const VkPresentModeKHR* pPresentModes;
		} VkSwapchainPresentModeInfoEXT;

		typedef struct VkSwapchainPresentScalingCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPresentScalingFlagsEXT scalingBehavior;
		    VkPresentGravityFlagsEXT presentGravityX;
		    VkPresentGravityFlagsEXT presentGravityY;
		} VkSwapchainPresentScalingCreateInfoEXT;

		typedef struct VkReleaseSwapchainImagesInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSwapchainKHR swapchain;
		    uint32_t imageIndexCount;
		    const uint32_t* pImageIndices;
		} VkReleaseSwapchainImagesInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkReleaseSwapchainImagesEXT)(VkDevice device, const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo);


		#define VK_EXT_shader_demote_to_helper_invocation 1
		#define VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION 1
		#define VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME "VK_EXT_shader_demote_to_helper_invocation"

		typedef VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;


		#define VK_NV_device_generated_commands 1
		#define VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION 3
		#define VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME "VK_NV_device_generated_commands"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkIndirectCommandsLayoutNV)


		typedef enum
		{
		    VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x00000001,
		    VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkIndirectStateFlagBitsNV;
		typedef VkFlags VkIndirectStateFlagsNV;
		typedef enum
		{
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
		    VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkIndirectCommandsTokenTypeNV;


		typedef enum
		{
		    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x00000001,
		    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x00000002,
		    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x00000004,
		    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkIndirectCommandsLayoutUsageFlagBitsNV;
		typedef VkFlags VkIndirectCommandsLayoutUsageFlagsNV;

		typedef struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxGraphicsShaderGroupCount;
		    uint32_t maxIndirectSequenceCount;
		    uint32_t maxIndirectCommandsTokenCount;
		    uint32_t maxIndirectCommandsStreamCount;
		    uint32_t maxIndirectCommandsTokenOffset;
		    uint32_t maxIndirectCommandsStreamStride;
		    uint32_t minSequencesCountBufferOffsetAlignment;
		    uint32_t minSequencesIndexBufferOffsetAlignment;
		    uint32_t minIndirectCommandsBufferOffsetAlignment;
		} VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV;

		typedef struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 deviceGeneratedCommands;
		} VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV;

		typedef struct VkGraphicsShaderGroupCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t stageCount;
		    const VkPipelineShaderStageCreateInfo* pStages;
		    const VkPipelineVertexInputStateCreateInfo* pVertexInputState;
		    const VkPipelineTessellationStateCreateInfo* pTessellationState;
		} VkGraphicsShaderGroupCreateInfoNV;

		typedef struct VkGraphicsPipelineShaderGroupsCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t groupCount;
		    const VkGraphicsShaderGroupCreateInfoNV* pGroups;
		    uint32_t pipelineCount;
		    const VkPipeline* pPipelines;
		} VkGraphicsPipelineShaderGroupsCreateInfoNV;

		typedef struct VkBindShaderGroupIndirectCommandNV
		{
		    uint32_t groupIndex;
		} VkBindShaderGroupIndirectCommandNV;

		typedef struct VkBindIndexBufferIndirectCommandNV
		{
		    VkDeviceAddress bufferAddress;
		    uint32_t size;
		    VkIndexType indexType;
		} VkBindIndexBufferIndirectCommandNV;

		typedef struct VkBindVertexBufferIndirectCommandNV
		{
		    VkDeviceAddress bufferAddress;
		    uint32_t size;
		    uint32_t stride;
		} VkBindVertexBufferIndirectCommandNV;

		typedef struct VkSetStateFlagsIndirectCommandNV
		{
		    uint32_t data;
		} VkSetStateFlagsIndirectCommandNV;

		typedef struct VkIndirectCommandsStreamNV
		{
		    VkBuffer buffer;
		    VkDeviceSize offset;
		} VkIndirectCommandsStreamNV;

		typedef struct VkIndirectCommandsLayoutTokenNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkIndirectCommandsTokenTypeNV tokenType;
		    uint32_t stream;
		    uint32_t offset;
		    uint32_t vertexBindingUnit;
		    VkBool32 vertexDynamicStride;
		    VkPipelineLayout pushconstantPipelineLayout;
		    VkShaderStageFlags pushconstantShaderStageFlags;
		    uint32_t pushconstantOffset;
		    uint32_t pushconstantSize;
		    VkIndirectStateFlagsNV indirectStateFlags;
		    uint32_t indexTypeCount;
		    const VkIndexType* pIndexTypes;
		    const uint32_t* pIndexTypeValues;
		} VkIndirectCommandsLayoutTokenNV;

		typedef struct VkIndirectCommandsLayoutCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkIndirectCommandsLayoutUsageFlagsNV flags;
		    VkPipelineBindPoint pipelineBindPoint;
		    uint32_t tokenCount;
		    const VkIndirectCommandsLayoutTokenNV* pTokens;
		    uint32_t streamCount;
		    const uint32_t* pStreamStrides;
		} VkIndirectCommandsLayoutCreateInfoNV;

		typedef struct VkGeneratedCommandsInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineBindPoint pipelineBindPoint;
		    VkPipeline pipeline;
		    VkIndirectCommandsLayoutNV indirectCommandsLayout;
		    uint32_t streamCount;
		    const VkIndirectCommandsStreamNV* pStreams;
		    uint32_t sequencesCount;
		    VkBuffer preprocessBuffer;
		    VkDeviceSize preprocessOffset;
		    VkDeviceSize preprocessSize;
		    VkBuffer sequencesCountBuffer;
		    VkDeviceSize sequencesCountOffset;
		    VkBuffer sequencesIndexBuffer;
		    VkDeviceSize sequencesIndexOffset;
		} VkGeneratedCommandsInfoNV;

		typedef struct VkGeneratedCommandsMemoryRequirementsInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineBindPoint pipelineBindPoint;
		    VkPipeline pipeline;
		    VkIndirectCommandsLayoutNV indirectCommandsLayout;
		    uint32_t maxSequencesCount;
		} VkGeneratedCommandsMemoryRequirementsInfoNV;


		typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkCmdPreprocessGeneratedCommandsNV)(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdExecuteGeneratedCommandsNV)(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdBindPipelineShaderGroupNV)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateIndirectCommandsLayoutNV)(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNV* pIndirectCommandsLayout);
		typedef void (VKAPI_PTR *PFN_vkDestroyIndirectCommandsLayoutNV)(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks* pAllocator);


		#define VK_NV_inherited_viewport_scissor 1
		#define VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION 1
		#define VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME "VK_NV_inherited_viewport_scissor"

		typedef struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 inheritedViewportScissor2D;
		} VkPhysicalDeviceInheritedViewportScissorFeaturesNV;

		typedef struct VkCommandBufferInheritanceViewportScissorInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 viewportScissor2D;
		    uint32_t viewportDepthCount;
		    const VkViewport* pViewportDepths;
		} VkCommandBufferInheritanceViewportScissorInfoNV;


		#define VK_KHR_shader_integer_dot_product 1
		#define VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION 1
		#define VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME "VK_KHR_shader_integer_dot_product"

		typedef VkPhysicalDeviceShaderIntegerDotProductFeatures VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR;

		typedef VkPhysicalDeviceShaderIntegerDotProductProperties VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR;


		#define VK_EXT_texel_buffer_alignment 1
		#define VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION 1
		#define VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME "VK_EXT_texel_buffer_alignment"

		typedef struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 texelBufferAlignment;
		} VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;

		typedef VkPhysicalDeviceTexelBufferAlignmentProperties VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;


		#define VK_QCOM_render_pass_transform 1
		#define VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION 4
		#define VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME "VK_QCOM_render_pass_transform"

		typedef struct VkRenderPassTransformBeginInfoQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSurfaceTransformFlagBitsKHR transform;
		} VkRenderPassTransformBeginInfoQCOM;

		typedef struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSurfaceTransformFlagBitsKHR transform;
		    VkRect2D renderArea;
		} VkCommandBufferInheritanceRenderPassTransformInfoQCOM;


		#define VK_EXT_depth_bias_control 1
		#define VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION 1
		#define VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME "VK_EXT_depth_bias_control"

		typedef enum
		{
		    VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
		    VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
		    VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
		    VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDepthBiasRepresentationEXT;


		typedef struct VkPhysicalDeviceDepthBiasControlFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 depthBiasControl;
		    VkBool32 leastRepresentableValueForceUnormRepresentation;
		    VkBool32 floatRepresentation;
		    VkBool32 depthBiasExact;
		} VkPhysicalDeviceDepthBiasControlFeaturesEXT;

		typedef struct VkDepthBiasInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    float depthBiasConstantFactor;
		    float depthBiasClamp;
		    float depthBiasSlopeFactor;
		} VkDepthBiasInfoEXT;

		typedef struct VkDepthBiasRepresentationInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDepthBiasRepresentationEXT depthBiasRepresentation;
		    VkBool32 depthBiasExact;
		} VkDepthBiasRepresentationInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias2EXT)(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT* pDepthBiasInfo);


		#define VK_EXT_device_memory_report 1
		#define VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION 2
		#define VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME "VK_EXT_device_memory_report"

		typedef VkFlags VkDeviceMemoryReportFlagsEXT;
		typedef enum
		{
		    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
		    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
		    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
		    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
		    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
		    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDeviceMemoryReportEventTypeEXT;


		typedef struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 deviceMemoryReport;
		} VkPhysicalDeviceDeviceMemoryReportFeaturesEXT;

		typedef struct VkDeviceMemoryReportCallbackDataEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceMemoryReportFlagsEXT flags;
		    VkDeviceMemoryReportEventTypeEXT type;
		    uint64_t memoryObjectId;
		    VkDeviceSize size;
		    VkObjectType objectType;
		    uint64_t objectHandle;
		    uint32_t heapIndex;
		} VkDeviceMemoryReportCallbackDataEXT;

		typedef void (VKAPI_PTR *PFN_vkDeviceMemoryReportCallbackEXT)(const VkDeviceMemoryReportCallbackDataEXT* pCallbackData, void* pUserData);

		typedef struct VkDeviceDeviceMemoryReportCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemoryReportFlagsEXT flags;
		    PFN_vkDeviceMemoryReportCallbackEXT pfnUserCallback;
		    void* pUserData;
		} VkDeviceDeviceMemoryReportCreateInfoEXT;


		#define VK_EXT_acquire_drm_display 1
		#define VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION 1
		#define VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME "VK_EXT_acquire_drm_display"

		typedef VkResult (VKAPI_PTR *PFN_vkAcquireDrmDisplayEXT)(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDrmDisplayEXT)(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR* display);


		#define VK_EXT_robustness2 1
		#define VK_EXT_ROBUSTNESS_2_SPEC_VERSION 1
		#define VK_EXT_ROBUSTNESS_2_EXTENSION_NAME "VK_EXT_robustness2"

		typedef struct VkPhysicalDeviceRobustness2FeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 robustBufferAccess2;
		    VkBool32 robustImageAccess2;
		    VkBool32 nullDescriptor;
		} VkPhysicalDeviceRobustness2FeaturesEXT;

		typedef struct VkPhysicalDeviceRobustness2PropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize robustStorageBufferAccessSizeAlignment;
		    VkDeviceSize robustUniformBufferAccessSizeAlignment;
		} VkPhysicalDeviceRobustness2PropertiesEXT;


		#define VK_EXT_custom_border_color 1
		#define VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION 12
		#define VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME "VK_EXT_custom_border_color"

		typedef struct VkSamplerCustomBorderColorCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkClearColorValue customBorderColor;
		    VkFormat format;
		} VkSamplerCustomBorderColorCreateInfoEXT;

		typedef struct VkPhysicalDeviceCustomBorderColorPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxCustomBorderColorSamplers;
		} VkPhysicalDeviceCustomBorderColorPropertiesEXT;

		typedef struct VkPhysicalDeviceCustomBorderColorFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 customBorderColors;
		    VkBool32 customBorderColorWithoutFormat;
		} VkPhysicalDeviceCustomBorderColorFeaturesEXT;


		#define VK_GOOGLE_user_type 1
		#define VK_GOOGLE_USER_TYPE_SPEC_VERSION 1
		#define VK_GOOGLE_USER_TYPE_EXTENSION_NAME "VK_GOOGLE_user_type"


		#define VK_KHR_pipeline_library 1
		#define VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION 1
		#define VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME "VK_KHR_pipeline_library"


		#define VK_NV_present_barrier 1
		#define VK_NV_PRESENT_BARRIER_SPEC_VERSION 1
		#define VK_NV_PRESENT_BARRIER_EXTENSION_NAME "VK_NV_present_barrier"

		typedef struct VkPhysicalDevicePresentBarrierFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 presentBarrier;
		} VkPhysicalDevicePresentBarrierFeaturesNV;

		typedef struct VkSurfaceCapabilitiesPresentBarrierNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 presentBarrierSupported;
		} VkSurfaceCapabilitiesPresentBarrierNV;

		typedef struct VkSwapchainPresentBarrierCreateInfoNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 presentBarrierEnable;
		} VkSwapchainPresentBarrierCreateInfoNV;


		#define VK_KHR_shader_non_semantic_info 1
		#define VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION 1
		#define VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME "VK_KHR_shader_non_semantic_info"


		#define VK_KHR_present_id 1
		#define VK_KHR_PRESENT_ID_SPEC_VERSION 1
		#define VK_KHR_PRESENT_ID_EXTENSION_NAME "VK_KHR_present_id"

		typedef struct VkPresentIdKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t swapchainCount;
		    const uint64_t* pPresentIds;
		} VkPresentIdKHR;

		typedef struct VkPhysicalDevicePresentIdFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 presentId;
		} VkPhysicalDevicePresentIdFeaturesKHR;


		#define VK_EXT_private_data 1
		#define VK_EXT_PRIVATE_DATA_SPEC_VERSION 1
		#define VK_EXT_PRIVATE_DATA_EXTENSION_NAME "VK_EXT_private_data"

		typedef VkPrivateDataSlot VkPrivateDataSlotEXT;
		typedef VkPrivateDataSlotCreateFlags VkPrivateDataSlotCreateFlagsEXT;
		typedef VkPhysicalDevicePrivateDataFeatures VkPhysicalDevicePrivateDataFeaturesEXT;

		typedef VkDevicePrivateDataCreateInfo VkDevicePrivateDataCreateInfoEXT;

		typedef VkPrivateDataSlotCreateInfo VkPrivateDataSlotCreateInfoEXT;

		typedef VkResult (VKAPI_PTR *PFN_vkCreatePrivateDataSlotEXT)(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot);
		typedef void (VKAPI_PTR *PFN_vkDestroyPrivateDataSlotEXT)(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkSetPrivateDataEXT)(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data);
		typedef void (VKAPI_PTR *PFN_vkGetPrivateDataEXT)(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData);


		#define VK_EXT_pipeline_creation_cache_control 1
		#define VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION 3
		#define VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME "VK_EXT_pipeline_creation_cache_control"

		typedef VkPhysicalDevicePipelineCreationCacheControlFeatures VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT;


		#define VK_KHR_video_encode_queue 1
		#define VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION 12
		#define VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME "VK_KHR_video_encode_queue"


		typedef enum
		{
		    VK_VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeFlagBitsKHR;
		typedef VkFlags VkVideoEncodeFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeCapabilityFlagBitsKHR;
		typedef VkFlags VkVideoEncodeCapabilityFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = 0,
		    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeRateControlModeFlagBitsKHR;
		typedef VkFlags VkVideoEncodeRateControlModeFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeFeedbackFlagBitsKHR;
		typedef VkFlags VkVideoEncodeFeedbackFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
		    VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 0x00000008,
		    VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeUsageFlagBitsKHR;
		typedef VkFlags VkVideoEncodeUsageFlagsKHR;

		typedef enum
		{
		    VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
		    VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 0x00000001,
		    VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 0x00000002,
		    VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 0x00000004,
		    VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeContentFlagBitsKHR;
		typedef VkFlags VkVideoEncodeContentFlagsKHR;
		typedef enum
		{
		    VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
		    VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
		    VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
		    VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
		    VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
		    VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkVideoEncodeTuningModeKHR;

		typedef VkFlags VkVideoEncodeRateControlFlagsKHR;

		typedef struct VkVideoEncodeInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoEncodeFlagsKHR flags;
		    VkBuffer dstBuffer;
		    VkDeviceSize dstBufferOffset;
		    VkDeviceSize dstBufferRange;
		    VkVideoPictureResourceInfoKHR srcPictureResource;
		    const VkVideoReferenceSlotInfoKHR* pSetupReferenceSlot;
		    uint32_t referenceSlotCount;
		    const VkVideoReferenceSlotInfoKHR* pReferenceSlots;
		    uint32_t precedingExternallyEncodedBytes;
		} VkVideoEncodeInfoKHR;

		typedef struct VkVideoEncodeCapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoEncodeCapabilityFlagsKHR flags;
		    VkVideoEncodeRateControlModeFlagsKHR rateControlModes;
		    uint32_t maxRateControlLayers;
		    uint64_t maxBitrate;
		    uint32_t maxQualityLevels;
		    VkExtent2D encodeInputPictureGranularity;
		    VkVideoEncodeFeedbackFlagsKHR supportedEncodeFeedbackFlags;
		} VkVideoEncodeCapabilitiesKHR;

		typedef struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoEncodeFeedbackFlagsKHR encodeFeedbackFlags;
		} VkQueryPoolVideoEncodeFeedbackCreateInfoKHR;

		typedef struct VkVideoEncodeUsageInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoEncodeUsageFlagsKHR videoUsageHints;
		    VkVideoEncodeContentFlagsKHR videoContentHints;
		    VkVideoEncodeTuningModeKHR tuningMode;
		} VkVideoEncodeUsageInfoKHR;

		typedef struct VkVideoEncodeRateControlLayerInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t averageBitrate;
		    uint64_t maxBitrate;
		    uint32_t frameRateNumerator;
		    uint32_t frameRateDenominator;
		} VkVideoEncodeRateControlLayerInfoKHR;

		typedef struct VkVideoEncodeRateControlInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoEncodeRateControlFlagsKHR flags;
		    VkVideoEncodeRateControlModeFlagBitsKHR rateControlMode;
		    uint32_t layerCount;
		    const VkVideoEncodeRateControlLayerInfoKHR* pLayers;
		    uint32_t virtualBufferSizeInMs;
		    uint32_t initialVirtualBufferSizeInMs;
		} VkVideoEncodeRateControlInfoKHR;

		typedef struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const VkVideoProfileInfoKHR* pVideoProfile;
		    uint32_t qualityLevel;
		} VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR;

		typedef struct VkVideoEncodeQualityLevelPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkVideoEncodeRateControlModeFlagBitsKHR preferredRateControlMode;
		    uint32_t preferredRateControlLayerCount;
		} VkVideoEncodeQualityLevelPropertiesKHR;

		typedef struct VkVideoEncodeQualityLevelInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t qualityLevel;
		} VkVideoEncodeQualityLevelInfoKHR;

		typedef struct VkVideoEncodeSessionParametersGetInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkVideoSessionParametersKHR videoSessionParameters;
		} VkVideoEncodeSessionParametersGetInfoKHR;

		typedef struct VkVideoEncodeSessionParametersFeedbackInfoKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 hasOverrides;
		} VkVideoEncodeSessionParametersFeedbackInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetEncodedVideoSessionParametersKHR)(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, size_t* pDataSize, void* pData);
		typedef void (VKAPI_PTR *PFN_vkCmdEncodeVideoKHR)(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR* pEncodeInfo);


		#define VK_NV_device_diagnostics_config 1
		#define VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION 2
		#define VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME "VK_NV_device_diagnostics_config"


		typedef enum
		{
		    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x00000001,
		    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x00000002,
		    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x00000004,
		    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x00000008,
		    VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkDeviceDiagnosticsConfigFlagBitsNV;
		typedef VkFlags VkDeviceDiagnosticsConfigFlagsNV;

		typedef struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 diagnosticsConfig;
		} VkPhysicalDeviceDiagnosticsConfigFeaturesNV;

		typedef struct VkDeviceDiagnosticsConfigCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceDiagnosticsConfigFlagsNV flags;
		} VkDeviceDiagnosticsConfigCreateInfoNV;


		#define VK_QCOM_render_pass_store_ops 1
		#define VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION 2
		#define VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME "VK_QCOM_render_pass_store_ops"


		#define VK_NV_cuda_kernel_launch 1
		#define VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION 2
		#define VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME "VK_NV_cuda_kernel_launch"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCudaModuleNV)
		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCudaFunctionNV)

		typedef struct VkCudaModuleCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    size_t dataSize;
		    const void* pData;
		} VkCudaModuleCreateInfoNV;

		typedef struct VkCudaFunctionCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCudaModuleNV module;
		    const char* pName;
		} VkCudaFunctionCreateInfoNV;

		typedef struct VkCudaLaunchInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCudaFunctionNV function;
		    uint32_t gridDimX;
		    uint32_t gridDimY;
		    uint32_t gridDimZ;
		    uint32_t blockDimX;
		    uint32_t blockDimY;
		    uint32_t blockDimZ;
		    uint32_t sharedMemBytes;
		    size_t paramCount;
		    const void* const * pParams;
		    size_t extraCount;
		    const void* const * pExtras;
		} VkCudaLaunchInfoNV;

		typedef struct VkPhysicalDeviceCudaKernelLaunchFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 cudaKernelLaunchFeatures;
		} VkPhysicalDeviceCudaKernelLaunchFeaturesNV;

		typedef struct VkPhysicalDeviceCudaKernelLaunchPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t computeCapabilityMinor;
		    uint32_t computeCapabilityMajor;
		} VkPhysicalDeviceCudaKernelLaunchPropertiesNV;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateCudaModuleNV)(VkDevice device, const VkCudaModuleCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCudaModuleNV* pModule);
		typedef VkResult (VKAPI_PTR *PFN_vkGetCudaModuleCacheNV)(VkDevice device, VkCudaModuleNV module, size_t* pCacheSize, void* pCacheData);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateCudaFunctionNV)(VkDevice device, const VkCudaFunctionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCudaFunctionNV* pFunction);
		typedef void (VKAPI_PTR *PFN_vkDestroyCudaModuleNV)(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkDestroyCudaFunctionNV)(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkCmdCudaLaunchKernelNV)(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV* pLaunchInfo);


		#define VK_KHR_object_refresh 1
		#define VK_KHR_OBJECT_REFRESH_SPEC_VERSION 1
		#define VK_KHR_OBJECT_REFRESH_EXTENSION_NAME "VK_KHR_object_refresh"


		typedef enum
		{
		    VK_REFRESH_OBJECT_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkRefreshObjectFlagBitsKHR;
		typedef VkFlags VkRefreshObjectFlagsKHR;

		typedef struct VkRefreshObjectKHR
		{
		    VkObjectType objectType;
		    uint64_t objectHandle;
		    VkRefreshObjectFlagsKHR flags;
		} VkRefreshObjectKHR;

		typedef struct VkRefreshObjectListKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t objectCount;
		    const VkRefreshObjectKHR* pObjects;
		} VkRefreshObjectListKHR;


		typedef void (VKAPI_PTR *PFN_vkCmdRefreshObjectsKHR)(VkCommandBuffer commandBuffer, const VkRefreshObjectListKHR* pRefreshObjects);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pRefreshableObjectTypeCount, VkObjectType* pRefreshableObjectTypes);


		#define VK_NV_low_latency 1
		#define VK_NV_LOW_LATENCY_SPEC_VERSION 1
		#define VK_NV_LOW_LATENCY_EXTENSION_NAME "VK_NV_low_latency"

		typedef struct VkQueryLowLatencySupportNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    void* pQueriedLowLatencyData;
		} VkQueryLowLatencySupportNV;


		#define VK_KHR_synchronization2 1
		#define VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION 1
		#define VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME "VK_KHR_synchronization2"

		typedef VkPipelineStageFlags2 VkPipelineStageFlags2KHR;
		typedef VkPipelineStageFlagBits2 VkPipelineStageFlagBits2KHR;
		typedef VkAccessFlags2 VkAccessFlags2KHR;
		typedef VkAccessFlagBits2 VkAccessFlagBits2KHR;
		typedef VkSubmitFlagBits VkSubmitFlagBitsKHR;
		typedef VkSubmitFlags VkSubmitFlagsKHR;
		typedef VkMemoryBarrier2 VkMemoryBarrier2KHR;

		typedef VkBufferMemoryBarrier2 VkBufferMemoryBarrier2KHR;

		typedef VkImageMemoryBarrier2 VkImageMemoryBarrier2KHR;

		typedef VkDependencyInfo VkDependencyInfoKHR;

		typedef VkSubmitInfo2 VkSubmitInfo2KHR;

		typedef VkSemaphoreSubmitInfo VkSemaphoreSubmitInfoKHR;

		typedef VkCommandBufferSubmitInfo VkCommandBufferSubmitInfoKHR;

		typedef VkPhysicalDeviceSynchronization2Features VkPhysicalDeviceSynchronization2FeaturesKHR;

		typedef struct VkQueueFamilyCheckpointProperties2NV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPipelineStageFlags2 checkpointExecutionStageMask;
		} VkQueueFamilyCheckpointProperties2NV;

		typedef struct VkCheckpointData2NV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPipelineStageFlags2 stage;
		    void* pCheckpointMarker;
		} VkCheckpointData2NV;


		typedef void (VKAPI_PTR *PFN_vkCmdSetEvent2KHR)(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdResetEvent2KHR)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask);
		typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents2KHR)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos);
		typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier2KHR)(VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp2KHR)(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query);
		typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit2KHR)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence);
		typedef void (VKAPI_PTR *PFN_vkCmdWriteBufferMarker2AMD)(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker);
		typedef void (VKAPI_PTR *PFN_vkGetQueueCheckpointData2NV)(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData);


		#define VK_EXT_descriptor_buffer 1
		#define VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION 1
		#define VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME "VK_EXT_descriptor_buffer"

		typedef struct VkPhysicalDeviceDescriptorBufferPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 combinedImageSamplerDescriptorSingleArray;
		    VkBool32 bufferlessPushDescriptors;
		    VkBool32 allowSamplerImageViewPostSubmitCreation;
		    VkDeviceSize descriptorBufferOffsetAlignment;
		    uint32_t maxDescriptorBufferBindings;
		    uint32_t maxResourceDescriptorBufferBindings;
		    uint32_t maxSamplerDescriptorBufferBindings;
		    uint32_t maxEmbeddedImmutableSamplerBindings;
		    uint32_t maxEmbeddedImmutableSamplers;
		    size_t bufferCaptureReplayDescriptorDataSize;
		    size_t imageCaptureReplayDescriptorDataSize;
		    size_t imageViewCaptureReplayDescriptorDataSize;
		    size_t samplerCaptureReplayDescriptorDataSize;
		    size_t accelerationStructureCaptureReplayDescriptorDataSize;
		    size_t samplerDescriptorSize;
		    size_t combinedImageSamplerDescriptorSize;
		    size_t sampledImageDescriptorSize;
		    size_t storageImageDescriptorSize;
		    size_t uniformTexelBufferDescriptorSize;
		    size_t robustUniformTexelBufferDescriptorSize;
		    size_t storageTexelBufferDescriptorSize;
		    size_t robustStorageTexelBufferDescriptorSize;
		    size_t uniformBufferDescriptorSize;
		    size_t robustUniformBufferDescriptorSize;
		    size_t storageBufferDescriptorSize;
		    size_t robustStorageBufferDescriptorSize;
		    size_t inputAttachmentDescriptorSize;
		    size_t accelerationStructureDescriptorSize;
		    VkDeviceSize maxSamplerDescriptorBufferRange;
		    VkDeviceSize maxResourceDescriptorBufferRange;
		    VkDeviceSize samplerDescriptorBufferAddressSpaceSize;
		    VkDeviceSize resourceDescriptorBufferAddressSpaceSize;
		    VkDeviceSize descriptorBufferAddressSpaceSize;
		} VkPhysicalDeviceDescriptorBufferPropertiesEXT;

		typedef struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    size_t combinedImageSamplerDensityMapDescriptorSize;
		} VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT;

		typedef struct VkPhysicalDeviceDescriptorBufferFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 descriptorBuffer;
		    VkBool32 descriptorBufferCaptureReplay;
		    VkBool32 descriptorBufferImageLayoutIgnored;
		    VkBool32 descriptorBufferPushDescriptors;
		} VkPhysicalDeviceDescriptorBufferFeaturesEXT;

		typedef struct VkDescriptorAddressInfoEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceAddress address;
		    VkDeviceSize range;
		    VkFormat format;
		} VkDescriptorAddressInfoEXT;

		typedef struct VkDescriptorBufferBindingInfoEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceAddress address;
		    VkBufferUsageFlags usage;
		} VkDescriptorBufferBindingInfoEXT;

		typedef struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBuffer buffer;
		} VkDescriptorBufferBindingPushDescriptorBufferHandleEXT;

		typedef union VkDescriptorDataEXT
		{
		    const VkSampler* pSampler;
		    const VkDescriptorImageInfo* pCombinedImageSampler;
		    const VkDescriptorImageInfo* pInputAttachmentImage;
		    const VkDescriptorImageInfo* pSampledImage;
		    const VkDescriptorImageInfo* pStorageImage;
		    const VkDescriptorAddressInfoEXT* pUniformTexelBuffer;
		    const VkDescriptorAddressInfoEXT* pStorageTexelBuffer;
		    const VkDescriptorAddressInfoEXT* pUniformBuffer;
		    const VkDescriptorAddressInfoEXT* pStorageBuffer;
		    VkDeviceAddress accelerationStructure;
		} VkDescriptorDataEXT;

		typedef struct VkDescriptorGetInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorType type;
		    VkDescriptorDataEXT data;
		} VkDescriptorGetInfoEXT;

		typedef struct VkBufferCaptureDescriptorDataInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBuffer buffer;
		} VkBufferCaptureDescriptorDataInfoEXT;

		typedef struct VkImageCaptureDescriptorDataInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		} VkImageCaptureDescriptorDataInfoEXT;

		typedef struct VkImageViewCaptureDescriptorDataInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageView imageView;
		} VkImageViewCaptureDescriptorDataInfoEXT;

		typedef struct VkSamplerCaptureDescriptorDataInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSampler sampler;
		} VkSamplerCaptureDescriptorDataInfoEXT;

		typedef struct VkOpaqueCaptureDescriptorDataCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    const void* opaqueCaptureDescriptorData;
		} VkOpaqueCaptureDescriptorDataCreateInfoEXT;

		typedef struct VkAccelerationStructureCaptureDescriptorDataInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAccelerationStructureKHR accelerationStructure;
		    VkAccelerationStructureNV accelerationStructureNV;
		} VkAccelerationStructureCaptureDescriptorDataInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutSizeEXT)(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize* pLayoutSizeInBytes);
		typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize* pOffset);
		typedef void (VKAPI_PTR *PFN_vkGetDescriptorEXT)(VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize, void* pDescriptor);
		typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorBuffersEXT)(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDescriptorBufferOffsetsEXT)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets);
		typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set);
		typedef VkResult (VKAPI_PTR *PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData);
		typedef VkResult (VKAPI_PTR *PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData);
		typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData);
		typedef VkResult (VKAPI_PTR *PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData);
		typedef VkResult (VKAPI_PTR *PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData);


		#define VK_EXT_graphics_pipeline_library 1
		#define VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION 1
		#define VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME "VK_EXT_graphics_pipeline_library"


		typedef enum
		{
		    VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x00000001,
		    VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x00000002,
		    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x00000004,
		    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x00000008,
		    VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkGraphicsPipelineLibraryFlagBitsEXT;
		typedef VkFlags VkGraphicsPipelineLibraryFlagsEXT;

		typedef struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 graphicsPipelineLibrary;
		} VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;

		typedef struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 graphicsPipelineLibraryFastLinking;
		    VkBool32 graphicsPipelineLibraryIndependentInterpolationDecoration;
		} VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT;

		typedef struct VkGraphicsPipelineLibraryCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkGraphicsPipelineLibraryFlagsEXT flags;
		} VkGraphicsPipelineLibraryCreateInfoEXT;


		#define VK_AMD_shader_early_and_late_fragment_tests 1
		#define VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION 1
		#define VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME "VK_AMD_shader_early_and_late_fragment_tests"

		typedef struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderEarlyAndLateFragmentTests;
		} VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;


		#define VK_KHR_fragment_shader_barycentric 1
		#define VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION 1
		#define VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME "VK_KHR_fragment_shader_barycentric"

		typedef struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 fragmentShaderBarycentric;
		} VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;

		typedef struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 triStripVertexOrderIndependentOfProvokingVertex;
		} VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR;


		#define VK_NV_fragment_shader_barycentric 1
		#define VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION 1
		#define VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME "VK_NV_fragment_shader_barycentric"

		typedef VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV;


		#define VK_KHR_shader_subgroup_uniform_control_flow 1
		#define VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION 1
		#define VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME "VK_KHR_shader_subgroup_uniform_control_flow"

		typedef struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderSubgroupUniformControlFlow;
		} VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;


		#define VK_KHR_zero_initialize_workgroup_memory 1
		#define VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION 1
		#define VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME "VK_KHR_zero_initialize_workgroup_memory"

		typedef VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR;


		#define VK_NV_fragment_shading_rate_enums 1
		#define VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION 1
		#define VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME "VK_NV_fragment_shading_rate_enums"

		typedef enum
		{
		    VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
		    VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
		    VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkFragmentShadingRateTypeNV;

		typedef enum
		{
		    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
		    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
		    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
		    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
		    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
		    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
		    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
		    VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
		    VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
		    VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
		    VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
		    VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
		    VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkFragmentShadingRateNV;


		typedef struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 fragmentShadingRateEnums;
		    VkBool32 supersampleFragmentShadingRates;
		    VkBool32 noInvocationFragmentShadingRates;
		} VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV;

		typedef struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkSampleCountFlagBits maxFragmentShadingRateInvocationCount;
		} VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV;

		typedef struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFragmentShadingRateTypeNV shadingRateType;
		    VkFragmentShadingRateNV shadingRate;
		    VkFragmentShadingRateCombinerOpKHR combinerOps[2];
		} VkPipelineFragmentShadingRateEnumStateCreateInfoNV;


		typedef void (VKAPI_PTR *PFN_vkCmdSetFragmentShadingRateEnumNV)(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]);


		#define VK_NV_ray_tracing_motion_blur 1
		#define VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION 1
		#define VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME "VK_NV_ray_tracing_motion_blur"

		typedef VkFlags VkAccelerationStructureMotionInfoFlagsNV;
		typedef enum
		{
		    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
		    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
		    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
		    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkAccelerationStructureMotionInstanceTypeNV;

		typedef VkFlags VkAccelerationStructureMotionInstanceFlagsNV;

		typedef struct VkAccelerationStructureGeometryMotionTrianglesDataNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceOrHostAddressConstKHR vertexData;
		} VkAccelerationStructureGeometryMotionTrianglesDataNV;

		typedef struct VkAccelerationStructureMotionInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t maxInstances;
		    VkAccelerationStructureMotionInfoFlagsNV flags;
		} VkAccelerationStructureMotionInfoNV;

		typedef struct VkAccelerationStructureMatrixMotionInstanceNV
		{
		    VkTransformMatrixKHR transformT0;
		    VkTransformMatrixKHR transformT1;
		    uint32_t instanceCustomIndex:24;
		    uint32_t mask:8;
		    uint32_t instanceShaderBindingTableRecordOffset:24;
		    VkGeometryInstanceFlagsKHR flags:8;
		    uint64_t accelerationStructureReference;
		} VkAccelerationStructureMatrixMotionInstanceNV;

		typedef struct VkSRTDataNV
		{
		    float sx;
		    float a;
		    float b;
		    float pvx;
		    float sy;
		    float c;
		    float pvy;
		    float sz;
		    float pvz;
		    float qx;
		    float qy;
		    float qz;
		    float qw;
		    float tx;
		    float ty;
		    float tz;
		} VkSRTDataNV;

		typedef struct VkAccelerationStructureSRTMotionInstanceNV
		{
		    VkSRTDataNV transformT0;
		    VkSRTDataNV transformT1;
		    uint32_t instanceCustomIndex:24;
		    uint32_t mask:8;
		    uint32_t instanceShaderBindingTableRecordOffset:24;
		    VkGeometryInstanceFlagsKHR flags:8;
		    uint64_t accelerationStructureReference;
		} VkAccelerationStructureSRTMotionInstanceNV;

		typedef union VkAccelerationStructureMotionInstanceDataNV
		{
		    VkAccelerationStructureInstanceKHR staticInstance;
		    VkAccelerationStructureMatrixMotionInstanceNV matrixMotionInstance;
		    VkAccelerationStructureSRTMotionInstanceNV srtMotionInstance;
		} VkAccelerationStructureMotionInstanceDataNV;

		typedef struct VkAccelerationStructureMotionInstanceNV
		{
		    VkAccelerationStructureMotionInstanceTypeNV type;
		    VkAccelerationStructureMotionInstanceFlagsNV flags;
		    VkAccelerationStructureMotionInstanceDataNV data;
		} VkAccelerationStructureMotionInstanceNV;

		typedef struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rayTracingMotionBlur;
		    VkBool32 rayTracingMotionBlurPipelineTraceRaysIndirect;
		} VkPhysicalDeviceRayTracingMotionBlurFeaturesNV;


		#define VK_EXT_mesh_shader 1
		#define VK_EXT_MESH_SHADER_SPEC_VERSION 1
		#define VK_EXT_MESH_SHADER_EXTENSION_NAME "VK_EXT_mesh_shader"

		typedef struct VkPhysicalDeviceMeshShaderFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 taskShader;
		    VkBool32 meshShader;
		    VkBool32 multiviewMeshShader;
		    VkBool32 primitiveFragmentShadingRateMeshShader;
		    VkBool32 meshShaderQueries;
		} VkPhysicalDeviceMeshShaderFeaturesEXT;

		typedef struct VkPhysicalDeviceMeshShaderPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxTaskWorkGroupTotalCount;
		    uint32_t maxTaskWorkGroupCount[3];
		    uint32_t maxTaskWorkGroupInvocations;
		    uint32_t maxTaskWorkGroupSize[3];
		    uint32_t maxTaskPayloadSize;
		    uint32_t maxTaskSharedMemorySize;
		    uint32_t maxTaskPayloadAndSharedMemorySize;
		    uint32_t maxMeshWorkGroupTotalCount;
		    uint32_t maxMeshWorkGroupCount[3];
		    uint32_t maxMeshWorkGroupInvocations;
		    uint32_t maxMeshWorkGroupSize[3];
		    uint32_t maxMeshSharedMemorySize;
		    uint32_t maxMeshPayloadAndSharedMemorySize;
		    uint32_t maxMeshOutputMemorySize;
		    uint32_t maxMeshPayloadAndOutputMemorySize;
		    uint32_t maxMeshOutputComponents;
		    uint32_t maxMeshOutputVertices;
		    uint32_t maxMeshOutputPrimitives;
		    uint32_t maxMeshOutputLayers;
		    uint32_t maxMeshMultiviewViewCount;
		    uint32_t meshOutputPerVertexGranularity;
		    uint32_t meshOutputPerPrimitiveGranularity;
		    uint32_t maxPreferredTaskWorkGroupInvocations;
		    uint32_t maxPreferredMeshWorkGroupInvocations;
		    VkBool32 prefersLocalInvocationVertexOutput;
		    VkBool32 prefersLocalInvocationPrimitiveOutput;
		    VkBool32 prefersCompactVertexOutput;
		    VkBool32 prefersCompactPrimitiveOutput;
		} VkPhysicalDeviceMeshShaderPropertiesEXT;

		typedef struct VkDrawMeshTasksIndirectCommandEXT
		{
		    uint32_t groupCountX;
		    uint32_t groupCountY;
		    uint32_t groupCountZ;
		} VkDrawMeshTasksIndirectCommandEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdDrawMeshTasksEXT)(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawMeshTasksIndirectEXT)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawMeshTasksIndirectCountEXT)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);


		#define VK_EXT_ycbcr_2plane_444_formats 1
		#define VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION 1
		#define VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME "VK_EXT_ycbcr_2plane_444_formats"

		typedef struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 ycbcr2plane444Formats;
		} VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;


		#define VK_EXT_fragment_density_map2 1
		#define VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION 1
		#define VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME "VK_EXT_fragment_density_map2"

		typedef struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 fragmentDensityMapDeferred;
		} VkPhysicalDeviceFragmentDensityMap2FeaturesEXT;

		typedef struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 subsampledLoads;
		    VkBool32 subsampledCoarseReconstructionEarlyAccess;
		    uint32_t maxSubsampledArrayLayers;
		    uint32_t maxDescriptorSetSubsampledSamplers;
		} VkPhysicalDeviceFragmentDensityMap2PropertiesEXT;


		#define VK_QCOM_rotated_copy_commands 1
		#define VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION 2
		#define VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME "VK_QCOM_rotated_copy_commands"

		typedef struct VkCopyCommandTransformInfoQCOM
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSurfaceTransformFlagBitsKHR transform;
		} VkCopyCommandTransformInfoQCOM;


		#define VK_EXT_image_robustness 1
		#define VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION 1
		#define VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME "VK_EXT_image_robustness"

		typedef VkPhysicalDeviceImageRobustnessFeatures VkPhysicalDeviceImageRobustnessFeaturesEXT;


		#define VK_KHR_workgroup_memory_explicit_layout 1
		#define VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION 1
		#define VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME "VK_KHR_workgroup_memory_explicit_layout"

		typedef struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 workgroupMemoryExplicitLayout;
		    VkBool32 workgroupMemoryExplicitLayoutScalarBlockLayout;
		    VkBool32 workgroupMemoryExplicitLayout8BitAccess;
		    VkBool32 workgroupMemoryExplicitLayout16BitAccess;
		} VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;


		#define VK_KHR_copy_commands2 1
		#define VK_KHR_COPY_COMMANDS_2_SPEC_VERSION 1
		#define VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME "VK_KHR_copy_commands2"

		typedef VkCopyBufferInfo2 VkCopyBufferInfo2KHR;

		typedef VkCopyImageInfo2 VkCopyImageInfo2KHR;

		typedef VkCopyBufferToImageInfo2 VkCopyBufferToImageInfo2KHR;

		typedef VkCopyImageToBufferInfo2 VkCopyImageToBufferInfo2KHR;

		typedef VkBlitImageInfo2 VkBlitImageInfo2KHR;

		typedef VkResolveImageInfo2 VkResolveImageInfo2KHR;

		typedef VkBufferCopy2 VkBufferCopy2KHR;

		typedef VkImageCopy2 VkImageCopy2KHR;

		typedef VkImageBlit2 VkImageBlit2KHR;

		typedef VkBufferImageCopy2 VkBufferImageCopy2KHR;

		typedef VkImageResolve2 VkImageResolve2KHR;

		typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer2KHR)(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyImage2KHR)(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage2KHR)(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer2KHR)(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdBlitImage2KHR)(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdResolveImage2KHR)(VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo);


		#define VK_EXT_image_compression_control 1
		#define VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION 1
		#define VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME "VK_EXT_image_compression_control"


		typedef enum
		{
		    VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x00000001,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x00000002,
		    VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x00000004,
		    VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkImageCompressionFlagBitsEXT;
		typedef VkFlags VkImageCompressionFlagsEXT;

		typedef enum
		{
		    VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x00000001,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x00000002,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x00000004,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x00000008,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x00000010,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x00000020,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x00000040,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x00000080,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x00000100,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x00000200,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x00000400,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x00000800,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x00001000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x00002000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x00004000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x00008000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x00010000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x00020000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x00040000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x00080000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x00100000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x00200000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x00400000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x00800000,
		    VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkImageCompressionFixedRateFlagBitsEXT;
		typedef VkFlags VkImageCompressionFixedRateFlagsEXT;

		typedef struct VkPhysicalDeviceImageCompressionControlFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 imageCompressionControl;
		} VkPhysicalDeviceImageCompressionControlFeaturesEXT;

		typedef struct VkImageCompressionControlEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageCompressionFlagsEXT flags;
		    uint32_t compressionControlPlaneCount;
		    VkImageCompressionFixedRateFlagsEXT* pFixedRateFlags;
		} VkImageCompressionControlEXT;

		typedef struct VkImageCompressionPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkImageCompressionFlagsEXT imageCompressionFlags;
		    VkImageCompressionFixedRateFlagsEXT imageCompressionFixedRateFlags;
		} VkImageCompressionPropertiesEXT;


		#define VK_EXT_attachment_feedback_loop_layout 1
		#define VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION 2
		#define VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME "VK_EXT_attachment_feedback_loop_layout"

		typedef struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 attachmentFeedbackLoopLayout;
		} VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;


		#define VK_EXT_4444_formats 1
		#define VK_EXT_4444_FORMATS_SPEC_VERSION 1
		#define VK_EXT_4444_FORMATS_EXTENSION_NAME "VK_EXT_4444_formats"

		typedef struct VkPhysicalDevice4444FormatsFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 formatA4R4G4B4;
		    VkBool32 formatA4B4G4R4;
		} VkPhysicalDevice4444FormatsFeaturesEXT;


		#define VK_EXT_device_fault 1
		#define VK_EXT_DEVICE_FAULT_SPEC_VERSION 2
		#define VK_EXT_DEVICE_FAULT_EXTENSION_NAME "VK_EXT_device_fault"

		typedef enum
		{
		    VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
		    VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
		    VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
		    VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
		    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
		    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
		    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
		    VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDeviceFaultAddressTypeEXT;

		typedef enum
		{
		    VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
		    VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDeviceFaultVendorBinaryHeaderVersionEXT;


		typedef struct VkPhysicalDeviceFaultFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 deviceFault;
		    VkBool32 deviceFaultVendorBinary;
		} VkPhysicalDeviceFaultFeaturesEXT;

		typedef struct VkDeviceFaultCountsEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t addressInfoCount;
		    uint32_t vendorInfoCount;
		    VkDeviceSize vendorBinarySize;
		} VkDeviceFaultCountsEXT;

		typedef struct VkDeviceFaultAddressInfoEXT
		{
		    VkDeviceFaultAddressTypeEXT addressType;
		    VkDeviceAddress reportedAddress;
		    VkDeviceSize addressPrecision;
		} VkDeviceFaultAddressInfoEXT;

		typedef struct VkDeviceFaultVendorInfoEXT
		{
		    char description[VK_MAX_DESCRIPTION_SIZE];
		    uint64_t vendorFaultCode;
		    uint64_t vendorFaultData;
		} VkDeviceFaultVendorInfoEXT;

		typedef struct VkDeviceFaultInfoEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    char description[VK_MAX_DESCRIPTION_SIZE];
		    VkDeviceFaultAddressInfoEXT* pAddressInfos;
		    VkDeviceFaultVendorInfoEXT* pVendorInfos;
		    void* pVendorBinaryData;
		} VkDeviceFaultInfoEXT;

		typedef struct VkDeviceFaultVendorBinaryHeaderVersionOneEXT
		{
		    uint32_t headerSize;
		    VkDeviceFaultVendorBinaryHeaderVersionEXT headerVersion;
		    uint32_t vendorID;
		    uint32_t deviceID;
		    uint32_t driverVersion;
		    uint8_t pipelineCacheUUID[VK_UUID_SIZE];
		    uint32_t applicationNameOffset;
		    uint32_t applicationVersion;
		    uint32_t engineNameOffset;
		    uint32_t engineVersion;
		    uint32_t apiVersion;
		} VkDeviceFaultVendorBinaryHeaderVersionOneEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceFaultInfoEXT)(VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo);


		#define VK_EXT_rgba10x6_formats 1
		#define VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION 1
		#define VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME "VK_EXT_rgba10x6_formats"

		typedef struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 formatRgba10x6WithoutYCbCrSampler;
		} VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT;


		#define VK_EXT_vertex_input_dynamic_state 1
		#define VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION 2
		#define VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME "VK_EXT_vertex_input_dynamic_state"

		typedef struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 vertexInputDynamicState;
		} VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT;

		typedef struct VkVertexInputBindingDescription2EXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t binding;
		    uint32_t stride;
		    VkVertexInputRate inputRate;
		    uint32_t divisor;
		} VkVertexInputBindingDescription2EXT;

		typedef struct VkVertexInputAttributeDescription2EXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t location;
		    uint32_t binding;
		    VkFormat format;
		    uint32_t offset;
		} VkVertexInputAttributeDescription2EXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetVertexInputEXT)(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions);


		#define VK_EXT_physical_device_drm 1
		#define VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION 1
		#define VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME "VK_EXT_physical_device_drm"

		typedef struct VkPhysicalDeviceDrmPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 hasPrimary;
		    VkBool32 hasRender;
		    int64_t primaryMajor;
		    int64_t primaryMinor;
		    int64_t renderMajor;
		    int64_t renderMinor;
		} VkPhysicalDeviceDrmPropertiesEXT;


		#define VK_EXT_device_address_binding_report 1
		#define VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION 1
		#define VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME "VK_EXT_device_address_binding_report"


		typedef enum
		{
		    VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x00000001,
		    VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDeviceAddressBindingFlagBitsEXT;
		typedef VkFlags VkDeviceAddressBindingFlagsEXT;
		typedef enum
		{
		    VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
		    VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
		    VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkDeviceAddressBindingTypeEXT;


		typedef struct VkPhysicalDeviceAddressBindingReportFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 reportAddressBinding;
		} VkPhysicalDeviceAddressBindingReportFeaturesEXT;

		typedef struct VkDeviceAddressBindingCallbackDataEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceAddressBindingFlagsEXT flags;
		    VkDeviceAddress baseAddress;
		    VkDeviceSize size;
		    VkDeviceAddressBindingTypeEXT bindingType;
		} VkDeviceAddressBindingCallbackDataEXT;


		#define VK_EXT_depth_clip_control 1
		#define VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION 1
		#define VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME "VK_EXT_depth_clip_control"

		typedef struct VkPhysicalDeviceDepthClipControlFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 depthClipControl;
		} VkPhysicalDeviceDepthClipControlFeaturesEXT;

		typedef struct VkPipelineViewportDepthClipControlCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 negativeOneToOne;
		} VkPipelineViewportDepthClipControlCreateInfoEXT;


		#define VK_EXT_primitive_topology_list_restart 1
		#define VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION 1
		#define VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME "VK_EXT_primitive_topology_list_restart"

		typedef struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 primitiveTopologyListRestart;
		    VkBool32 primitiveTopologyPatchListRestart;
		} VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;


		#define VK_KHR_format_feature_flags2 1
		#define VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION 2
		#define VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME "VK_KHR_format_feature_flags2"

		typedef VkFormatFeatureFlags2 VkFormatFeatureFlags2KHR;
		typedef VkFormatFeatureFlagBits2 VkFormatFeatureFlagBits2KHR;
		typedef VkFormatProperties3 VkFormatProperties3KHR;


		#define VK_HUAWEI_subpass_shading 1
		#define VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION 3
		#define VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME "VK_HUAWEI_subpass_shading"

		typedef struct VkSubpassShadingPipelineCreateInfoHUAWEI
		{
		    VkStructureType sType;
		    void* pNext;
		    VkRenderPass renderPass;
		    uint32_t subpass;
		} VkSubpassShadingPipelineCreateInfoHUAWEI;

		typedef struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 subpassShading;
		} VkPhysicalDeviceSubpassShadingFeaturesHUAWEI;

		typedef struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxSubpassShadingWorkgroupSizeAspectRatio;
		} VkPhysicalDeviceSubpassShadingPropertiesHUAWEI;


		typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)(VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize);
		typedef void (VKAPI_PTR *PFN_vkCmdSubpassShadingHUAWEI)(VkCommandBuffer commandBuffer);


		#define VK_HUAWEI_invocation_mask 1
		#define VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION 1
		#define VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME "VK_HUAWEI_invocation_mask"

		typedef struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 invocationMask;
		} VkPhysicalDeviceInvocationMaskFeaturesHUAWEI;


		typedef void (VKAPI_PTR *PFN_vkCmdBindInvocationMaskHUAWEI)(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout);


		#define VK_NV_external_memory_rdma 1
		#define VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION 1
		#define VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME "VK_NV_external_memory_rdma"

		typedef void* VkRemoteAddressNV;

		typedef struct VkMemoryGetRemoteAddressInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		} VkMemoryGetRemoteAddressInfoNV;

		typedef struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 externalMemoryRDMA;
		} VkPhysicalDeviceExternalMemoryRDMAFeaturesNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryRemoteAddressNV)(VkDevice device, const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, VkRemoteAddressNV* pAddress);


		#define VK_EXT_pipeline_properties 1
		#define VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION 1
		#define VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME "VK_EXT_pipeline_properties"

		typedef VkPipelineInfoKHR VkPipelineInfoEXT;

		typedef struct VkPipelinePropertiesIdentifierEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint8_t pipelineIdentifier[VK_UUID_SIZE];
		} VkPipelinePropertiesIdentifierEXT;

		typedef struct VkPhysicalDevicePipelinePropertiesFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pipelinePropertiesIdentifier;
		} VkPhysicalDevicePipelinePropertiesFeaturesEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPipelinePropertiesEXT)(VkDevice device, const VkPipelineInfoEXT* pPipelineInfo, VkBaseOutStructure* pPipelineProperties);


		#define VK_EXT_frame_boundary 1
		#define VK_EXT_FRAME_BOUNDARY_SPEC_VERSION 1
		#define VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME "VK_EXT_frame_boundary"


		typedef enum
		{
		    VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = 0x00000001,
		    VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkFrameBoundaryFlagBitsEXT;
		typedef VkFlags VkFrameBoundaryFlagsEXT;

		typedef struct VkPhysicalDeviceFrameBoundaryFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 frameBoundary;
		} VkPhysicalDeviceFrameBoundaryFeaturesEXT;

		typedef struct VkFrameBoundaryEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFrameBoundaryFlagsEXT flags;
		    uint64_t frameID;
		    uint32_t imageCount;
		    const VkImage* pImages;
		    uint32_t bufferCount;
		    const VkBuffer* pBuffers;
		    uint64_t tagName;
		    size_t tagSize;
		    const void* pTag;
		} VkFrameBoundaryEXT;


		#define VK_EXT_multisampled_render_to_single_sampled 1
		#define VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION 1
		#define VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME "VK_EXT_multisampled_render_to_single_sampled"

		typedef struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 multisampledRenderToSingleSampled;
		} VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;

		typedef struct VkSubpassResolvePerformanceQueryEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 optimal;
		} VkSubpassResolvePerformanceQueryEXT;

		typedef struct VkMultisampledRenderToSingleSampledInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 multisampledRenderToSingleSampledEnable;
		    VkSampleCountFlagBits rasterizationSamples;
		} VkMultisampledRenderToSingleSampledInfoEXT;


		#define VK_EXT_extended_dynamic_state2 1
		#define VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION 1
		#define VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME "VK_EXT_extended_dynamic_state2"

		typedef struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 extendedDynamicState2;
		    VkBool32 extendedDynamicState2LogicOp;
		    VkBool32 extendedDynamicState2PatchControlPoints;
		} VkPhysicalDeviceExtendedDynamicState2FeaturesEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetPatchControlPointsEXT)(VkCommandBuffer commandBuffer, uint32_t patchControlPoints);
		typedef void (VKAPI_PTR *PFN_vkCmdSetRasterizerDiscardEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBiasEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetLogicOpEXT)(VkCommandBuffer commandBuffer, VkLogicOp logicOp);
		typedef void (VKAPI_PTR *PFN_vkCmdSetPrimitiveRestartEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable);


		#define VK_EXT_color_write_enable 1
		#define VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION 1
		#define VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME "VK_EXT_color_write_enable"

		typedef struct VkPhysicalDeviceColorWriteEnableFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 colorWriteEnable;
		} VkPhysicalDeviceColorWriteEnableFeaturesEXT;

		typedef struct VkPipelineColorWriteCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t attachmentCount;
		    const VkBool32* pColorWriteEnables;
		} VkPipelineColorWriteCreateInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetColorWriteEnableEXT)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32* pColorWriteEnables);


		#define VK_EXT_primitives_generated_query 1
		#define VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION 1
		#define VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME "VK_EXT_primitives_generated_query"

		typedef struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 primitivesGeneratedQuery;
		    VkBool32 primitivesGeneratedQueryWithRasterizerDiscard;
		    VkBool32 primitivesGeneratedQueryWithNonZeroStreams;
		} VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;


		#define VK_KHR_ray_tracing_maintenance1 1
		#define VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION 1
		#define VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME "VK_KHR_ray_tracing_maintenance1"

		typedef struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rayTracingMaintenance1;
		    VkBool32 rayTracingPipelineTraceRaysIndirect2;
		} VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR;

		typedef struct VkTraceRaysIndirectCommand2KHR
		{
		    VkDeviceAddress raygenShaderRecordAddress;
		    VkDeviceSize raygenShaderRecordSize;
		    VkDeviceAddress missShaderBindingTableAddress;
		    VkDeviceSize missShaderBindingTableSize;
		    VkDeviceSize missShaderBindingTableStride;
		    VkDeviceAddress hitShaderBindingTableAddress;
		    VkDeviceSize hitShaderBindingTableSize;
		    VkDeviceSize hitShaderBindingTableStride;
		    VkDeviceAddress callableShaderBindingTableAddress;
		    VkDeviceSize callableShaderBindingTableSize;
		    VkDeviceSize callableShaderBindingTableStride;
		    uint32_t width;
		    uint32_t height;
		    uint32_t depth;
		} VkTraceRaysIndirectCommand2KHR;


		typedef void (VKAPI_PTR *PFN_vkCmdTraceRaysIndirect2KHR)(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress);


		#define VK_EXT_image_view_min_lod 1
		#define VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION 1
		#define VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME "VK_EXT_image_view_min_lod"

		typedef struct VkPhysicalDeviceImageViewMinLodFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 minLod;
		} VkPhysicalDeviceImageViewMinLodFeaturesEXT;

		typedef struct VkImageViewMinLodCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    float minLod;
		} VkImageViewMinLodCreateInfoEXT;


		#define VK_EXT_multi_draw 1
		#define VK_EXT_MULTI_DRAW_SPEC_VERSION 1
		#define VK_EXT_MULTI_DRAW_EXTENSION_NAME "VK_EXT_multi_draw"

		typedef struct VkPhysicalDeviceMultiDrawFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 multiDraw;
		} VkPhysicalDeviceMultiDrawFeaturesEXT;

		typedef struct VkPhysicalDeviceMultiDrawPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxMultiDrawCount;
		} VkPhysicalDeviceMultiDrawPropertiesEXT;

		typedef struct VkMultiDrawInfoEXT
		{
		    uint32_t firstVertex;
		    uint32_t vertexCount;
		} VkMultiDrawInfoEXT;

		typedef struct VkMultiDrawIndexedInfoEXT
		{
		    uint32_t firstIndex;
		    uint32_t indexCount;
		    int32_t vertexOffset;
		} VkMultiDrawIndexedInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdDrawMultiEXT)(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawMultiIndexedEXT)(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset);


		#define VK_EXT_image_2d_view_of_3d 1
		#define VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION 1
		#define VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME "VK_EXT_image_2d_view_of_3d"

		typedef struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 image2DViewOf3D;
		    VkBool32 sampler2DViewOf3D;
		} VkPhysicalDeviceImage2DViewOf3DFeaturesEXT;


		#define VK_KHR_portability_enumeration 1
		#define VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION 1
		#define VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME "VK_KHR_portability_enumeration"


		#define VK_EXT_shader_tile_image 1
		#define VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION 1
		#define VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME "VK_EXT_shader_tile_image"

		typedef struct VkPhysicalDeviceShaderTileImageFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderTileImageColorReadAccess;
		    VkBool32 shaderTileImageDepthReadAccess;
		    VkBool32 shaderTileImageStencilReadAccess;
		} VkPhysicalDeviceShaderTileImageFeaturesEXT;

		typedef struct VkPhysicalDeviceShaderTileImagePropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderTileImageCoherentReadAccelerated;
		    VkBool32 shaderTileImageReadSampleFromPixelRateInvocation;
		    VkBool32 shaderTileImageReadFromHelperInvocation;
		} VkPhysicalDeviceShaderTileImagePropertiesEXT;


		#define VK_EXT_opacity_micromap 1
		#define VK_EXT_OPACITY_MICROMAP_SPEC_VERSION 2
		#define VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME "VK_EXT_opacity_micromap"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkMicromapEXT)

		typedef enum
		{
		    VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
		    VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV = 1000397000,
		    VK_MICROMAP_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkMicromapTypeEXT;


		typedef enum
		{
		    VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x00000001,
		    VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x00000002,
		    VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x00000004,
		    VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkBuildMicromapFlagBitsEXT;
		typedef VkFlags VkBuildMicromapFlagsEXT;
		typedef enum
		{
		    VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
		    VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkBuildMicromapModeEXT;


		typedef enum
		{
		    VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000001,
		    VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkMicromapCreateFlagBitsEXT;
		typedef VkFlags VkMicromapCreateFlagsEXT;
		typedef enum
		{
		    VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
		    VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
		    VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
		    VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
		    VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkCopyMicromapModeEXT;

		typedef enum
		{
		    VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
		    VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
		    VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkOpacityMicromapFormatEXT;

		typedef enum
		{
		    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
		    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
		    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
		    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
		    VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkOpacityMicromapSpecialIndexEXT;


		typedef struct VkMicromapUsageEXT
		{
		    uint32_t count;
		    uint32_t subdivisionLevel;
		    uint32_t format;
		} VkMicromapUsageEXT;

		typedef struct VkMicromapBuildInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMicromapTypeEXT type;
		    VkBuildMicromapFlagsEXT flags;
		    VkBuildMicromapModeEXT mode;
		    VkMicromapEXT dstMicromap;
		    uint32_t usageCountsCount;
		    const VkMicromapUsageEXT* pUsageCounts;
		    const VkMicromapUsageEXT* const* ppUsageCounts;
		    VkDeviceOrHostAddressConstKHR data;
		    VkDeviceOrHostAddressKHR scratchData;
		    VkDeviceOrHostAddressConstKHR triangleArray;
		    VkDeviceSize triangleArrayStride;
		} VkMicromapBuildInfoEXT;

		typedef struct VkMicromapCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMicromapCreateFlagsEXT createFlags;
		    VkBuffer buffer;
		    VkDeviceSize offset;
		    VkDeviceSize size;
		    VkMicromapTypeEXT type;
		    VkDeviceAddress deviceAddress;
		} VkMicromapCreateInfoEXT;

		typedef struct VkPhysicalDeviceOpacityMicromapFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 micromap;
		    VkBool32 micromapCaptureReplay;
		    VkBool32 micromapHostCommands;
		} VkPhysicalDeviceOpacityMicromapFeaturesEXT;

		typedef struct VkPhysicalDeviceOpacityMicromapPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxOpacity2StateSubdivisionLevel;
		    uint32_t maxOpacity4StateSubdivisionLevel;
		} VkPhysicalDeviceOpacityMicromapPropertiesEXT;

		typedef struct VkMicromapVersionInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    const uint8_t* pVersionData;
		} VkMicromapVersionInfoEXT;

		typedef struct VkCopyMicromapToMemoryInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMicromapEXT src;
		    VkDeviceOrHostAddressKHR dst;
		    VkCopyMicromapModeEXT mode;
		} VkCopyMicromapToMemoryInfoEXT;

		typedef struct VkCopyMemoryToMicromapInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceOrHostAddressConstKHR src;
		    VkMicromapEXT dst;
		    VkCopyMicromapModeEXT mode;
		} VkCopyMemoryToMicromapInfoEXT;

		typedef struct VkCopyMicromapInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMicromapEXT src;
		    VkMicromapEXT dst;
		    VkCopyMicromapModeEXT mode;
		} VkCopyMicromapInfoEXT;

		typedef struct VkMicromapBuildSizesInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceSize micromapSize;
		    VkDeviceSize buildScratchSize;
		    VkBool32 discardable;
		} VkMicromapBuildSizesInfoEXT;

		typedef struct VkAccelerationStructureTrianglesOpacityMicromapEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkIndexType indexType;
		    VkDeviceOrHostAddressConstKHR indexBuffer;
		    VkDeviceSize indexStride;
		    uint32_t baseTriangle;
		    uint32_t usageCountsCount;
		    const VkMicromapUsageEXT* pUsageCounts;
		    const VkMicromapUsageEXT* const* ppUsageCounts;
		    VkMicromapEXT micromap;
		} VkAccelerationStructureTrianglesOpacityMicromapEXT;

		typedef struct VkMicromapTriangleEXT
		{
		    uint32_t dataOffset;
		    uint16_t subdivisionLevel;
		    uint16_t format;
		} VkMicromapTriangleEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateMicromapEXT)(VkDevice device, const VkMicromapCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap);
		typedef void (VKAPI_PTR *PFN_vkDestroyMicromapEXT)(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator);
		typedef void (VKAPI_PTR *PFN_vkCmdBuildMicromapsEXT)(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos);
		typedef VkResult (VKAPI_PTR *PFN_vkBuildMicromapsEXT)(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyMicromapEXT)(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT* pInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyMicromapToMemoryEXT)(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT* pInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkCopyMemoryToMicromapEXT)(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT* pInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkWriteMicromapsPropertiesEXT)(VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, size_t dataSize, void* pData, size_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyMicromapEXT)(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyMicromapToMemoryEXT)(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyMemoryToMicromapEXT)(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdWriteMicromapsPropertiesEXT)(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceMicromapCompatibilityEXT)(VkDevice device, const VkMicromapVersionInfoEXT* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility);
		typedef void (VKAPI_PTR *PFN_vkGetMicromapBuildSizesEXT)(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT* pBuildInfo, VkMicromapBuildSizesInfoEXT* pSizeInfo);


		#define VK_HUAWEI_cluster_culling_shader 1
		#define VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION 3
		#define VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME "VK_HUAWEI_cluster_culling_shader"

		typedef struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 clustercullingShader;
		    VkBool32 multiviewClusterCullingShader;
		} VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI;

		typedef struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxWorkGroupCount[3];
		    uint32_t maxWorkGroupSize[3];
		    uint32_t maxOutputClusterCount;
		    VkDeviceSize indirectBufferOffsetAlignment;
		} VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI;

		typedef struct VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 clusterShadingRate;
		} VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI;


		typedef void (VKAPI_PTR *PFN_vkCmdDrawClusterHUAWEI)(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
		typedef void (VKAPI_PTR *PFN_vkCmdDrawClusterIndirectHUAWEI)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);


		#define VK_EXT_border_color_swizzle 1
		#define VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION 1
		#define VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME "VK_EXT_border_color_swizzle"

		typedef struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 borderColorSwizzle;
		    VkBool32 borderColorSwizzleFromImage;
		} VkPhysicalDeviceBorderColorSwizzleFeaturesEXT;

		typedef struct VkSamplerBorderColorComponentMappingCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkComponentMapping components;
		    VkBool32 srgb;
		} VkSamplerBorderColorComponentMappingCreateInfoEXT;


		#define VK_EXT_pageable_device_local_memory 1
		#define VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION 1
		#define VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME "VK_EXT_pageable_device_local_memory"

		typedef struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pageableDeviceLocalMemory;
		} VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;


		typedef void (VKAPI_PTR *PFN_vkSetDeviceMemoryPriorityEXT)(VkDevice device, VkDeviceMemory memory, float priority);


		#define VK_KHR_maintenance4 1
		#define VK_KHR_MAINTENANCE_4_SPEC_VERSION 2
		#define VK_KHR_MAINTENANCE_4_EXTENSION_NAME "VK_KHR_maintenance4"

		typedef VkPhysicalDeviceMaintenance4Features VkPhysicalDeviceMaintenance4FeaturesKHR;

		typedef VkPhysicalDeviceMaintenance4Properties VkPhysicalDeviceMaintenance4PropertiesKHR;

		typedef VkDeviceBufferMemoryRequirements VkDeviceBufferMemoryRequirementsKHR;

		typedef VkDeviceImageMemoryRequirements VkDeviceImageMemoryRequirementsKHR;

		typedef void (VKAPI_PTR *PFN_vkGetDeviceBufferMemoryRequirementsKHR)(VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceImageMemoryRequirementsKHR)(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceImageSparseMemoryRequirementsKHR)(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements);


		#define VK_ARM_shader_core_properties 1
		#define VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION 1
		#define VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME "VK_ARM_shader_core_properties"

		typedef struct VkPhysicalDeviceShaderCorePropertiesARM
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t pixelRate;
		    uint32_t texelRate;
		    uint32_t fmaRate;
		} VkPhysicalDeviceShaderCorePropertiesARM;


		#define VK_KHR_shader_subgroup_rotate 1
		#define VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION 2
		#define VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME "VK_KHR_shader_subgroup_rotate"

		typedef struct VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderSubgroupRotate;
		    VkBool32 shaderSubgroupRotateClustered;
		} VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR;


		#define VK_ARM_scheduling_controls 1
		#define VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION 1
		#define VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME "VK_ARM_scheduling_controls"


		typedef VkFlags64 VkPhysicalDeviceSchedulingControlsFlagBitsARM;
		static const VkPhysicalDeviceSchedulingControlsFlagBitsARM VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM = 0x00000001;
		typedef VkFlags64 VkPhysicalDeviceSchedulingControlsFlagsARM;

		typedef struct VkDeviceQueueShaderCoreControlCreateInfoARM
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t shaderCoreCount;
		} VkDeviceQueueShaderCoreControlCreateInfoARM;

		typedef struct VkPhysicalDeviceSchedulingControlsFeaturesARM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 schedulingControls;
		} VkPhysicalDeviceSchedulingControlsFeaturesARM;

		typedef struct VkPhysicalDeviceSchedulingControlsPropertiesARM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkPhysicalDeviceSchedulingControlsFlagsARM schedulingControlsFlags;
		} VkPhysicalDeviceSchedulingControlsPropertiesARM;


		#define VK_EXT_image_sliced_view_of_3d 1
		#define VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION 1
		#define VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME "VK_EXT_image_sliced_view_of_3d"

		#define VK_REMAINING_3D_SLICES_EXT (~0U)

		typedef struct VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 imageSlicedViewOf3D;
		} VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT;

		typedef struct VkImageViewSlicedCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t sliceOffset;
		    uint32_t sliceCount;
		} VkImageViewSlicedCreateInfoEXT;


		#define VK_VALVE_descriptor_set_host_mapping 1
		#define VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION 1
		#define VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME "VK_VALVE_descriptor_set_host_mapping"

		typedef struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 descriptorSetHostMapping;
		} VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;

		typedef struct VkDescriptorSetBindingReferenceVALVE
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorSetLayout descriptorSetLayout;
		    uint32_t binding;
		} VkDescriptorSetBindingReferenceVALVE;

		typedef struct VkDescriptorSetLayoutHostMappingInfoVALVE
		{
		    VkStructureType sType;
		    void* pNext;
		    size_t descriptorOffset;
		    uint32_t descriptorSize;
		} VkDescriptorSetLayoutHostMappingInfoVALVE;


		typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)(VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping);
		typedef void (VKAPI_PTR *PFN_vkGetDescriptorSetHostMappingVALVE)(VkDevice device, VkDescriptorSet descriptorSet, void** ppData);


		#define VK_EXT_depth_clamp_zero_one 1
		#define VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION 1
		#define VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME "VK_EXT_depth_clamp_zero_one"

		typedef struct VkPhysicalDeviceDepthClampZeroOneFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 depthClampZeroOne;
		} VkPhysicalDeviceDepthClampZeroOneFeaturesEXT;


		#define VK_EXT_non_seamless_cube_map 1
		#define VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION 1
		#define VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME "VK_EXT_non_seamless_cube_map"

		typedef struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 nonSeamlessCubeMap;
		} VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT;


		#define VK_ARM_render_pass_striped 1
		#define VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION 1
		#define VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME "VK_ARM_render_pass_striped"

		typedef struct VkPhysicalDeviceRenderPassStripedFeaturesARM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 renderPassStriped;
		} VkPhysicalDeviceRenderPassStripedFeaturesARM;

		typedef struct VkPhysicalDeviceRenderPassStripedPropertiesARM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent2D renderPassStripeGranularity;
		    uint32_t maxRenderPassStripes;
		} VkPhysicalDeviceRenderPassStripedPropertiesARM;

		typedef struct VkRenderPassStripeInfoARM
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRect2D stripeArea;
		} VkRenderPassStripeInfoARM;

		typedef struct VkRenderPassStripeBeginInfoARM
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t stripeInfoCount;
		    const VkRenderPassStripeInfoARM* pStripeInfos;
		} VkRenderPassStripeBeginInfoARM;

		typedef struct VkRenderPassStripeSubmitInfoARM
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t stripeSemaphoreInfoCount;
		    const VkSemaphoreSubmitInfo* pStripeSemaphoreInfos;
		} VkRenderPassStripeSubmitInfoARM;


		#define VK_QCOM_fragment_density_map_offset 1
		#define VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION 1
		#define VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME "VK_QCOM_fragment_density_map_offset"

		typedef struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 fragmentDensityMapOffset;
		} VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM;

		typedef struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent2D fragmentDensityOffsetGranularity;
		} VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM;

		typedef struct VkSubpassFragmentDensityMapOffsetEndInfoQCOM
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t fragmentDensityOffsetCount;
		    const VkOffset2D* pFragmentDensityOffsets;
		} VkSubpassFragmentDensityMapOffsetEndInfoQCOM;


		#define VK_NV_copy_memory_indirect 1
		#define VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION 1
		#define VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME "VK_NV_copy_memory_indirect"

		typedef struct VkCopyMemoryIndirectCommandNV
		{
		    VkDeviceAddress srcAddress;
		    VkDeviceAddress dstAddress;
		    VkDeviceSize size;
		} VkCopyMemoryIndirectCommandNV;

		typedef struct VkCopyMemoryToImageIndirectCommandNV
		{
		    VkDeviceAddress srcAddress;
		    uint32_t bufferRowLength;
		    uint32_t bufferImageHeight;
		    VkImageSubresourceLayers imageSubresource;
		    VkOffset3D imageOffset;
		    VkExtent3D imageExtent;
		} VkCopyMemoryToImageIndirectCommandNV;

		typedef struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 indirectCopy;
		} VkPhysicalDeviceCopyMemoryIndirectFeaturesNV;

		typedef struct VkPhysicalDeviceCopyMemoryIndirectPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkQueueFlags supportedQueues;
		} VkPhysicalDeviceCopyMemoryIndirectPropertiesNV;


		typedef void (VKAPI_PTR *PFN_vkCmdCopyMemoryIndirectNV)(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride);
		typedef void (VKAPI_PTR *PFN_vkCmdCopyMemoryToImageIndirectNV)(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources);


		#define VK_NV_memory_decompression 1
		#define VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION 1
		#define VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME "VK_NV_memory_decompression"


		typedef VkFlags64 VkMemoryDecompressionMethodFlagBitsNV;
		static const VkMemoryDecompressionMethodFlagBitsNV VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV = 0x00000001;
		typedef VkFlags64 VkMemoryDecompressionMethodFlagsNV;

		typedef struct VkDecompressMemoryRegionNV
		{
		    VkDeviceAddress srcAddress;
		    VkDeviceAddress dstAddress;
		    VkDeviceSize compressedSize;
		    VkDeviceSize decompressedSize;
		    VkMemoryDecompressionMethodFlagsNV decompressionMethod;
		} VkDecompressMemoryRegionNV;

		typedef struct VkPhysicalDeviceMemoryDecompressionFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 memoryDecompression;
		} VkPhysicalDeviceMemoryDecompressionFeaturesNV;

		typedef struct VkPhysicalDeviceMemoryDecompressionPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkMemoryDecompressionMethodFlagsNV decompressionMethods;
		    uint64_t maxDecompressionIndirectCount;
		} VkPhysicalDeviceMemoryDecompressionPropertiesNV;


		typedef void (VKAPI_PTR *PFN_vkCmdDecompressMemoryNV)(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV* pDecompressMemoryRegions);
		typedef void (VKAPI_PTR *PFN_vkCmdDecompressMemoryIndirectCountNV)(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride);


		#define VK_NV_device_generated_commands_compute 1
		#define VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION 2
		#define VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME "VK_NV_device_generated_commands_compute"

		typedef struct VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 deviceGeneratedCompute;
		    VkBool32 deviceGeneratedComputePipelines;
		    VkBool32 deviceGeneratedComputeCaptureReplay;
		} VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV;

		typedef struct VkComputePipelineIndirectBufferInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceAddress deviceAddress;
		    VkDeviceSize size;
		    VkDeviceAddress pipelineDeviceAddressCaptureReplay;
		} VkComputePipelineIndirectBufferInfoNV;

		typedef struct VkPipelineIndirectDeviceAddressInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineBindPoint pipelineBindPoint;
		    VkPipeline pipeline;
		} VkPipelineIndirectDeviceAddressInfoNV;

		typedef struct VkBindPipelineIndirectCommandNV
		{
		    VkDeviceAddress pipelineAddress;
		} VkBindPipelineIndirectCommandNV;


		typedef void (VKAPI_PTR *PFN_vkGetPipelineIndirectMemoryRequirementsNV)(VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements);
		typedef void (VKAPI_PTR *PFN_vkCmdUpdatePipelineIndirectBufferNV)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
		typedef VkDeviceAddress (VKAPI_PTR *PFN_vkGetPipelineIndirectDeviceAddressNV)(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo);


		#define VK_NV_linear_color_attachment 1
		#define VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION 1
		#define VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME "VK_NV_linear_color_attachment"

		typedef struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 linearColorAttachment;
		} VkPhysicalDeviceLinearColorAttachmentFeaturesNV;


		#define VK_GOOGLE_surfaceless_query 1
		#define VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION 2
		#define VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME "VK_GOOGLE_surfaceless_query"


		#define VK_KHR_shader_maximal_reconvergence 1
		#define VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION 1
		#define VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME "VK_KHR_shader_maximal_reconvergence"

		typedef struct VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderMaximalReconvergence;
		} VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR;


		#define VK_EXT_application_parameters 1
		#define VK_EXT_APPLICATION_PARAMETERS_SPEC_VERSION 1
		#define VK_EXT_APPLICATION_PARAMETERS_EXTENSION_NAME "VK_EXT_application_parameters"

		typedef struct VkApplicationParametersEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t vendorID;
		    uint32_t deviceID;
		    uint32_t key;
		    uint64_t value;
		} VkApplicationParametersEXT;


		#define VK_EXT_image_compression_control_swapchain 1
		#define VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION 1
		#define VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME "VK_EXT_image_compression_control_swapchain"

		typedef struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 imageCompressionControlSwapchain;
		} VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;


		#define VK_QCOM_image_processing 1
		#define VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION 1
		#define VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME "VK_QCOM_image_processing"

		typedef struct VkImageViewSampleWeightCreateInfoQCOM
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkOffset2D filterCenter;
		    VkExtent2D filterSize;
		    uint32_t numPhases;
		} VkImageViewSampleWeightCreateInfoQCOM;

		typedef struct VkPhysicalDeviceImageProcessingFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 textureSampleWeighted;
		    VkBool32 textureBoxFilter;
		    VkBool32 textureBlockMatch;
		} VkPhysicalDeviceImageProcessingFeaturesQCOM;

		typedef struct VkPhysicalDeviceImageProcessingPropertiesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxWeightFilterPhases;
		    VkExtent2D maxWeightFilterDimension;
		    VkExtent2D maxBlockMatchRegion;
		    VkExtent2D maxBoxFilterBlockSize;
		} VkPhysicalDeviceImageProcessingPropertiesQCOM;


		#define VK_EXT_nested_command_buffer 1
		#define VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION 1
		#define VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME "VK_EXT_nested_command_buffer"

		typedef struct VkPhysicalDeviceNestedCommandBufferFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 nestedCommandBuffer;
		    VkBool32 nestedCommandBufferRendering;
		    VkBool32 nestedCommandBufferSimultaneousUse;
		} VkPhysicalDeviceNestedCommandBufferFeaturesEXT;

		typedef struct VkPhysicalDeviceNestedCommandBufferPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxCommandBufferNestingLevel;
		} VkPhysicalDeviceNestedCommandBufferPropertiesEXT;


		#define VK_EXT_external_memory_acquire_unmodified 1
		#define VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION 1
		#define VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME "VK_EXT_external_memory_acquire_unmodified"

		typedef struct VkExternalMemoryAcquireUnmodifiedEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 acquireUnmodifiedMemory;
		} VkExternalMemoryAcquireUnmodifiedEXT;


		#define VK_EXT_extended_dynamic_state3 1
		#define VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION 2
		#define VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME "VK_EXT_extended_dynamic_state3"

		typedef enum
		{
		    VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR = 0,
		    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR,
		    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR = 1,
		    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR,
		    VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR = 2,
		    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR,
		    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR = 3,
		    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR,
		    VK_LINE_RASTERIZATION_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkLineRasterizationModeKHR;

		typedef VkLineRasterizationModeKHR VkLineRasterizationModeEXT;

		typedef struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 extendedDynamicState3TessellationDomainOrigin;
		    VkBool32 extendedDynamicState3DepthClampEnable;
		    VkBool32 extendedDynamicState3PolygonMode;
		    VkBool32 extendedDynamicState3RasterizationSamples;
		    VkBool32 extendedDynamicState3SampleMask;
		    VkBool32 extendedDynamicState3AlphaToCoverageEnable;
		    VkBool32 extendedDynamicState3AlphaToOneEnable;
		    VkBool32 extendedDynamicState3LogicOpEnable;
		    VkBool32 extendedDynamicState3ColorBlendEnable;
		    VkBool32 extendedDynamicState3ColorBlendEquation;
		    VkBool32 extendedDynamicState3ColorWriteMask;
		    VkBool32 extendedDynamicState3RasterizationStream;
		    VkBool32 extendedDynamicState3ConservativeRasterizationMode;
		    VkBool32 extendedDynamicState3ExtraPrimitiveOverestimationSize;
		    VkBool32 extendedDynamicState3DepthClipEnable;
		    VkBool32 extendedDynamicState3SampleLocationsEnable;
		    VkBool32 extendedDynamicState3ColorBlendAdvanced;
		    VkBool32 extendedDynamicState3ProvokingVertexMode;
		    VkBool32 extendedDynamicState3LineRasterizationMode;
		    VkBool32 extendedDynamicState3LineStippleEnable;
		    VkBool32 extendedDynamicState3DepthClipNegativeOneToOne;
		    VkBool32 extendedDynamicState3ViewportWScalingEnable;
		    VkBool32 extendedDynamicState3ViewportSwizzle;
		    VkBool32 extendedDynamicState3CoverageToColorEnable;
		    VkBool32 extendedDynamicState3CoverageToColorLocation;
		    VkBool32 extendedDynamicState3CoverageModulationMode;
		    VkBool32 extendedDynamicState3CoverageModulationTableEnable;
		    VkBool32 extendedDynamicState3CoverageModulationTable;
		    VkBool32 extendedDynamicState3CoverageReductionMode;
		    VkBool32 extendedDynamicState3RepresentativeFragmentTestEnable;
		    VkBool32 extendedDynamicState3ShadingRateImageEnable;
		} VkPhysicalDeviceExtendedDynamicState3FeaturesEXT;

		typedef struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 dynamicPrimitiveTopologyUnrestricted;
		} VkPhysicalDeviceExtendedDynamicState3PropertiesEXT;

		typedef struct VkColorBlendEquationEXT
		{
		    VkBlendFactor srcColorBlendFactor;
		    VkBlendFactor dstColorBlendFactor;
		    VkBlendOp colorBlendOp;
		    VkBlendFactor srcAlphaBlendFactor;
		    VkBlendFactor dstAlphaBlendFactor;
		    VkBlendOp alphaBlendOp;
		} VkColorBlendEquationEXT;

		typedef struct VkColorBlendAdvancedEXT
		{
		    VkBlendOp advancedBlendOp;
		    VkBool32 srcPremultiplied;
		    VkBool32 dstPremultiplied;
		    VkBlendOverlapEXT blendOverlap;
		    VkBool32 clampResults;
		} VkColorBlendAdvancedEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthClampEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetPolygonModeEXT)(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode);
		typedef void (VKAPI_PTR *PFN_vkCmdSetRasterizationSamplesEXT)(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples);
		typedef void (VKAPI_PTR *PFN_vkCmdSetSampleMaskEXT)(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask* pSampleMask);
		typedef void (VKAPI_PTR *PFN_vkCmdSetAlphaToCoverageEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetAlphaToOneEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetLogicOpEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetColorBlendEnableEXT)(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32* pColorBlendEnables);
		typedef void (VKAPI_PTR *PFN_vkCmdSetColorBlendEquationEXT)(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations);
		typedef void (VKAPI_PTR *PFN_vkCmdSetColorWriteMaskEXT)(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks);
		typedef void (VKAPI_PTR *PFN_vkCmdSetTessellationDomainOriginEXT)(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin);
		typedef void (VKAPI_PTR *PFN_vkCmdSetRasterizationStreamEXT)(VkCommandBuffer commandBuffer, uint32_t rasterizationStream);
		typedef void (VKAPI_PTR *PFN_vkCmdSetConservativeRasterizationModeEXT)(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode);
		typedef void (VKAPI_PTR *PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthClipEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetSampleLocationsEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetColorBlendAdvancedEXT)(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT* pColorBlendAdvanced);
		typedef void (VKAPI_PTR *PFN_vkCmdSetProvokingVertexModeEXT)(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode);
		typedef void (VKAPI_PTR *PFN_vkCmdSetLineRasterizationModeEXT)(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode);
		typedef void (VKAPI_PTR *PFN_vkCmdSetLineStippleEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDepthClipNegativeOneToOneEXT)(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne);
		typedef void (VKAPI_PTR *PFN_vkCmdSetViewportWScalingEnableNV)(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetViewportSwizzleNV)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV* pViewportSwizzles);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCoverageToColorEnableNV)(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCoverageToColorLocationNV)(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCoverageModulationModeNV)(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCoverageModulationTableEnableNV)(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCoverageModulationTableNV)(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetShadingRateImageEnableNV)(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetRepresentativeFragmentTestEnableNV)(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable);
		typedef void (VKAPI_PTR *PFN_vkCmdSetCoverageReductionModeNV)(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode);


		#define VK_EXT_subpass_merge_feedback 1
		#define VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION 2
		#define VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME "VK_EXT_subpass_merge_feedback"

		typedef enum
		{
		    VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
		    VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
		    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
		    VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkSubpassMergeStatusEXT;


		typedef struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 subpassMergeFeedback;
		} VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT;

		typedef struct VkRenderPassCreationControlEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 disallowMerging;
		} VkRenderPassCreationControlEXT;

		typedef struct VkRenderPassCreationFeedbackInfoEXT
		{
		    uint32_t postMergeSubpassCount;
		} VkRenderPassCreationFeedbackInfoEXT;

		typedef struct VkRenderPassCreationFeedbackCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderPassCreationFeedbackInfoEXT* pRenderPassFeedback;
		} VkRenderPassCreationFeedbackCreateInfoEXT;

		typedef struct VkRenderPassSubpassFeedbackInfoEXT
		{
		    VkSubpassMergeStatusEXT subpassMergeStatus;
		    char description[VK_MAX_DESCRIPTION_SIZE];
		    uint32_t postMergeIndex;
		} VkRenderPassSubpassFeedbackInfoEXT;

		typedef struct VkRenderPassSubpassFeedbackCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkRenderPassSubpassFeedbackInfoEXT* pSubpassFeedback;
		} VkRenderPassSubpassFeedbackCreateInfoEXT;


		#define VK_LUNARG_direct_driver_loading 1
		#define VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION 1
		#define VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME "VK_LUNARG_direct_driver_loading"

		typedef VkFlags VkDirectDriverLoadingFlagsLUNARG;
		typedef enum
		{
		    VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
		    VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
		    VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG = 0x7FFFFFFF
		} VkDirectDriverLoadingModeLUNARG;


		typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddrLUNARG)(VkInstance instance, const char* pName);

		typedef struct VkDirectDriverLoadingInfoLUNARG
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDirectDriverLoadingFlagsLUNARG flags;
		    PFN_vkGetInstanceProcAddrLUNARG pfnGetInstanceProcAddr;
		} VkDirectDriverLoadingInfoLUNARG;

		typedef struct VkDirectDriverLoadingListLUNARG
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDirectDriverLoadingModeLUNARG mode;
		    uint32_t driverCount;
		    const VkDirectDriverLoadingInfoLUNARG* pDrivers;
		} VkDirectDriverLoadingListLUNARG;


		#define VK_EXT_shader_module_identifier 1
		#define VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION 1
		#define VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME "VK_EXT_shader_module_identifier"

		#define VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT 32

		typedef struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderModuleIdentifier;
		} VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT;

		typedef struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint8_t shaderModuleIdentifierAlgorithmUUID[VK_UUID_SIZE];
		} VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT;

		typedef struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t identifierSize;
		    const uint8_t* pIdentifier;
		} VkPipelineShaderStageModuleIdentifierCreateInfoEXT;

		typedef struct VkShaderModuleIdentifierEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t identifierSize;
		    uint8_t identifier[VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT];
		} VkShaderModuleIdentifierEXT;


		typedef void (VKAPI_PTR *PFN_vkGetShaderModuleIdentifierEXT)(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT* pIdentifier);
		typedef void (VKAPI_PTR *PFN_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, VkShaderModuleIdentifierEXT* pIdentifier);


		#define VK_EXT_rasterization_order_attachment_access 1
		#define VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION 1
		#define VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME "VK_EXT_rasterization_order_attachment_access"

		typedef struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rasterizationOrderColorAttachmentAccess;
		    VkBool32 rasterizationOrderDepthAttachmentAccess;
		    VkBool32 rasterizationOrderStencilAttachmentAccess;
		} VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;


		#define VK_ARM_rasterization_order_attachment_access 1
		#define VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION 1
		#define VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME "VK_ARM_rasterization_order_attachment_access"

		typedef VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM;


		#define VK_NV_optical_flow 1
		#define VK_NV_OPTICAL_FLOW_SPEC_VERSION 1
		#define VK_NV_OPTICAL_FLOW_EXTENSION_NAME "VK_NV_optical_flow"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkOpticalFlowSessionNV)


		typedef enum
		{
		    VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
		    VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x00000001,
		    VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x00000002,
		    VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x00000004,
		    VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x00000008,
		    VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkOpticalFlowGridSizeFlagBitsNV;
		typedef VkFlags VkOpticalFlowGridSizeFlagsNV;

		typedef enum
		{
		    VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
		    VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x00000001,
		    VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x00000002,
		    VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x00000004,
		    VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x00000008,
		    VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x00000010,
		    VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkOpticalFlowUsageFlagBitsNV;
		typedef VkFlags VkOpticalFlowUsageFlagsNV;
		typedef enum
		{
		    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
		    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
		    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
		    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
		    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = 0x7FFFFFFF
		} VkOpticalFlowPerformanceLevelNV;

		typedef enum
		{
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
		    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = 0x7FFFFFFF
		} VkOpticalFlowSessionBindingPointNV;


		typedef enum
		{
		    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x00000001,
		    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x00000002,
		    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x00000004,
		    VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x00000008,
		    VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x00000010,
		    VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkOpticalFlowSessionCreateFlagBitsNV;
		typedef VkFlags VkOpticalFlowSessionCreateFlagsNV;

		typedef enum
		{
		    VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x00000001,
		    VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
		} VkOpticalFlowExecuteFlagBitsNV;
		typedef VkFlags VkOpticalFlowExecuteFlagsNV;

		typedef struct VkPhysicalDeviceOpticalFlowFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 opticalFlow;
		} VkPhysicalDeviceOpticalFlowFeaturesNV;

		typedef struct VkPhysicalDeviceOpticalFlowPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkOpticalFlowGridSizeFlagsNV supportedOutputGridSizes;
		    VkOpticalFlowGridSizeFlagsNV supportedHintGridSizes;
		    VkBool32 hintSupported;
		    VkBool32 costSupported;
		    VkBool32 bidirectionalFlowSupported;
		    VkBool32 globalFlowSupported;
		    uint32_t minWidth;
		    uint32_t minHeight;
		    uint32_t maxWidth;
		    uint32_t maxHeight;
		    uint32_t maxNumRegionsOfInterest;
		} VkPhysicalDeviceOpticalFlowPropertiesNV;

		typedef struct VkOpticalFlowImageFormatInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkOpticalFlowUsageFlagsNV usage;
		} VkOpticalFlowImageFormatInfoNV;

		typedef struct VkOpticalFlowImageFormatPropertiesNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFormat format;
		} VkOpticalFlowImageFormatPropertiesNV;

		typedef struct VkOpticalFlowSessionCreateInfoNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t width;
		    uint32_t height;
		    VkFormat imageFormat;
		    VkFormat flowVectorFormat;
		    VkFormat costFormat;
		    VkOpticalFlowGridSizeFlagsNV outputGridSize;
		    VkOpticalFlowGridSizeFlagsNV hintGridSize;
		    VkOpticalFlowPerformanceLevelNV performanceLevel;
		    VkOpticalFlowSessionCreateFlagsNV flags;
		} VkOpticalFlowSessionCreateInfoNV;

		typedef struct VkOpticalFlowSessionCreatePrivateDataInfoNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t id;
		    uint32_t size;
		    const void* pPrivateData;
		} VkOpticalFlowSessionCreatePrivateDataInfoNV;

		typedef struct VkOpticalFlowExecuteInfoNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkOpticalFlowExecuteFlagsNV flags;
		    uint32_t regionCount;
		    const VkRect2D* pRegions;
		} VkOpticalFlowExecuteInfoNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkCreateOpticalFlowSessionNV)(VkDevice device, const VkOpticalFlowSessionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession);
		typedef void (VKAPI_PTR *PFN_vkDestroyOpticalFlowSessionNV)(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkBindOpticalFlowSessionImageNV)(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout);
		typedef void (VKAPI_PTR *PFN_vkCmdOpticalFlowExecuteNV)(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV* pExecuteInfo);


		#define VK_EXT_legacy_dithering 1
		#define VK_EXT_LEGACY_DITHERING_SPEC_VERSION 2
		#define VK_EXT_LEGACY_DITHERING_EXTENSION_NAME "VK_EXT_legacy_dithering"

		typedef struct VkPhysicalDeviceLegacyDitheringFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 legacyDithering;
		} VkPhysicalDeviceLegacyDitheringFeaturesEXT;


		#define VK_EXT_pipeline_protected_access 1
		#define VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION 1
		#define VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME "VK_EXT_pipeline_protected_access"

		typedef struct VkPhysicalDevicePipelineProtectedAccessFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pipelineProtectedAccess;
		} VkPhysicalDevicePipelineProtectedAccessFeaturesEXT;


		#define VK_KHR_maintenance5 1
		#define VK_KHR_MAINTENANCE_5_SPEC_VERSION 1
		#define VK_KHR_MAINTENANCE_5_EXTENSION_NAME "VK_KHR_maintenance5"


		typedef VkFlags64 VkPipelineCreateFlagBits2KHR;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR = 0x00000001;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR = 0x00000002;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR = 0x00000004;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = (VkPipelineCreateFlagBits2KHR)(((VkPipelineCreateFlagBits2KHR)0x00000004 << 32) | (0x00000000));
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x00000008;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR = 0x00000010;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV = 0x00000020;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR = 0x00000040;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x00000080;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR = 0x00000100;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR = 0x00000200;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x00000400;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x00800000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR = 0x00000800;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x00001000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x00002000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x00004000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x00008000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x00010000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x00020000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x00080000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV = 0x00040000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x00100000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x00200000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00400000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x01000000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x02000000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x04000000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT = 0x08000000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x10000000;
		static const VkPipelineCreateFlagBits2KHR VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000;
		typedef VkFlags64 VkPipelineCreateFlags2KHR;

		typedef VkFlags64 VkBufferUsageFlagBits2KHR;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR = 0x00000001;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR = 0x00000002;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 0x00000004;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 0x00000008;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR = 0x00000010;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR = 0x00000020;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR = 0x00000040;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR = 0x00000080;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR = 0x00000100;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x02000000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = 0x00000400;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR = 0x00002000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR = 0x00004000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR = 0x00008000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR = 0x00010000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR = 0x00020000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x00080000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x00100000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x00200000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x00400000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x04000000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x00800000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT = 0x01000000;
		static const VkBufferUsageFlagBits2KHR VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV = 0x00000400;
		typedef VkFlags64 VkBufferUsageFlags2KHR;

		typedef struct VkPhysicalDeviceMaintenance5FeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 maintenance5;
		} VkPhysicalDeviceMaintenance5FeaturesKHR;

		typedef struct VkPhysicalDeviceMaintenance5PropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 earlyFragmentMultisampleCoverageAfterSampleCounting;
		    VkBool32 earlyFragmentSampleMaskTestBeforeSampleCounting;
		    VkBool32 depthStencilSwizzleOneSupport;
		    VkBool32 polygonModePointSize;
		    VkBool32 nonStrictSinglePixelWideLinesUseParallelogram;
		    VkBool32 nonStrictWideLinesUseParallelogram;
		} VkPhysicalDeviceMaintenance5PropertiesKHR;

		typedef struct VkRenderingAreaInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t viewMask;
		    uint32_t colorAttachmentCount;
		    const VkFormat* pColorAttachmentFormats;
		    VkFormat depthAttachmentFormat;
		    VkFormat stencilAttachmentFormat;
		} VkRenderingAreaInfoKHR;

		typedef struct VkDeviceImageSubresourceInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const VkImageCreateInfo* pCreateInfo;
		    const VkImageSubresource2KHR* pSubresource;
		} VkDeviceImageSubresourceInfoKHR;

		typedef struct VkPipelineCreateFlags2CreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCreateFlags2KHR flags;
		} VkPipelineCreateFlags2CreateInfoKHR;

		typedef struct VkBufferUsageFlags2CreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferUsageFlags2KHR usage;
		} VkBufferUsageFlags2CreateInfoKHR;


		typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer2KHR)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType);
		typedef void (VKAPI_PTR *PFN_vkGetRenderingAreaGranularityKHR)(VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity);
		typedef void (VKAPI_PTR *PFN_vkGetDeviceImageSubresourceLayoutKHR)(VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo, VkSubresourceLayout2KHR* pLayout);
		typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2KHR)(VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout);


		#define VK_KHR_ray_tracing_position_fetch 1
		#define VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION 1
		#define VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME "VK_KHR_ray_tracing_position_fetch"

		typedef struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rayTracingPositionFetch;
		} VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR;


		#define VK_EXT_shader_object 1
		#define VK_EXT_SHADER_OBJECT_SPEC_VERSION 1
		#define VK_EXT_SHADER_OBJECT_EXTENSION_NAME "VK_EXT_shader_object"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderEXT)


		typedef enum
		{
		    VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 0x00000001,
		    VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x00000002,
		    VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x00000004,
		    VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 0x00000008,
		    VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 0x00000010,
		    VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x00000020,
		    VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x00000040,
		    VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkShaderCreateFlagBitsEXT;
		typedef VkFlags VkShaderCreateFlagsEXT;
		typedef enum
		{
		    VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
		    VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
		    VK_SHADER_CODE_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkShaderCodeTypeEXT;


		typedef struct VkPhysicalDeviceShaderObjectFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderObject;
		} VkPhysicalDeviceShaderObjectFeaturesEXT;

		typedef struct VkPhysicalDeviceShaderObjectPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint8_t shaderBinaryUUID[VK_UUID_SIZE];
		    uint32_t shaderBinaryVersion;
		} VkPhysicalDeviceShaderObjectPropertiesEXT;

		typedef struct VkShaderCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkShaderCreateFlagsEXT flags;
		    VkShaderStageFlagBits stage;
		    VkShaderStageFlags nextStage;
		    VkShaderCodeTypeEXT codeType;
		    size_t codeSize;
		    const void* pCode;
		    const char* pName;
		    uint32_t setLayoutCount;
		    const VkDescriptorSetLayout* pSetLayouts;
		    uint32_t pushConstantRangeCount;
		    const VkPushConstantRange* pPushConstantRanges;
		    const VkSpecializationInfo* pSpecializationInfo;
		} VkShaderCreateInfoEXT;

		typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo VkShaderRequiredSubgroupSizeCreateInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateShadersEXT)(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders);
		typedef void (VKAPI_PTR *PFN_vkDestroyShaderEXT)(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetShaderBinaryDataEXT)(VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData);
		typedef void (VKAPI_PTR *PFN_vkCmdBindShadersEXT)(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders);


		#define VK_QCOM_tile_properties 1
		#define VK_QCOM_TILE_PROPERTIES_SPEC_VERSION 1
		#define VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME "VK_QCOM_tile_properties"

		typedef struct VkPhysicalDeviceTilePropertiesFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 tileProperties;
		} VkPhysicalDeviceTilePropertiesFeaturesQCOM;

		typedef struct VkTilePropertiesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent3D tileSize;
		    VkExtent2D apronSize;
		    VkOffset2D origin;
		} VkTilePropertiesQCOM;


		typedef VkResult (VKAPI_PTR *PFN_vkGetFramebufferTilePropertiesQCOM)(VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount, VkTilePropertiesQCOM* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDynamicRenderingTilePropertiesQCOM)(VkDevice device, const VkRenderingInfo* pRenderingInfo, VkTilePropertiesQCOM* pProperties);


		#define VK_SEC_amigo_profiling 1
		#define VK_SEC_AMIGO_PROFILING_SPEC_VERSION 1
		#define VK_SEC_AMIGO_PROFILING_EXTENSION_NAME "VK_SEC_amigo_profiling"

		typedef struct VkPhysicalDeviceAmigoProfilingFeaturesSEC
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 amigoProfiling;
		} VkPhysicalDeviceAmigoProfilingFeaturesSEC;

		typedef struct VkAmigoProfilingSubmitInfoSEC
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t firstDrawTimestamp;
		    uint64_t swapBufferTimestamp;
		} VkAmigoProfilingSubmitInfoSEC;


		#define VK_QCOM_multiview_per_view_viewports 1
		#define VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION 1
		#define VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME "VK_QCOM_multiview_per_view_viewports"

		typedef struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 multiviewPerViewViewports;
		} VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;


		#define VK_NV_ray_tracing_invocation_reorder 1
		#define VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION 1
		#define VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME "VK_NV_ray_tracing_invocation_reorder"

		typedef enum
		{
		    VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
		    VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
		    VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkRayTracingInvocationReorderModeNV;


		typedef struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkRayTracingInvocationReorderModeNV rayTracingInvocationReorderReorderingHint;
		} VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV;

		typedef struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rayTracingInvocationReorder;
		} VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV;


		#define VK_NV_extended_sparse_address_space 1
		#define VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION 1
		#define VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME "VK_NV_extended_sparse_address_space"

		typedef struct VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 extendedSparseAddressSpace;
		} VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV;

		typedef struct VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize extendedSparseAddressSpaceSize;
		    VkImageUsageFlags extendedSparseImageUsageFlags;
		    VkBufferUsageFlags extendedSparseBufferUsageFlags;
		} VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV;


		#define VK_EXT_mutable_descriptor_type 1
		#define VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION 1
		#define VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME "VK_EXT_mutable_descriptor_type"

		typedef struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 mutableDescriptorType;
		} VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;

		typedef struct VkMutableDescriptorTypeListEXT
		{
		    uint32_t descriptorTypeCount;
		    const VkDescriptorType* pDescriptorTypes;
		} VkMutableDescriptorTypeListEXT;

		typedef struct VkMutableDescriptorTypeCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t mutableDescriptorTypeListCount;
		    const VkMutableDescriptorTypeListEXT* pMutableDescriptorTypeLists;
		} VkMutableDescriptorTypeCreateInfoEXT;


		#define VK_VALVE_mutable_descriptor_type 1
		#define VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION 1
		#define VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME "VK_VALVE_mutable_descriptor_type"

		typedef VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE;

		typedef VkMutableDescriptorTypeListEXT VkMutableDescriptorTypeListVALVE;

		typedef VkMutableDescriptorTypeCreateInfoEXT VkMutableDescriptorTypeCreateInfoVALVE;


		#define VK_EXT_layer_settings 1
		#define VK_EXT_LAYER_SETTINGS_SPEC_VERSION 2
		#define VK_EXT_LAYER_SETTINGS_EXTENSION_NAME "VK_EXT_layer_settings"

		typedef enum
		{
		    VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0,
		    VK_LAYER_SETTING_TYPE_INT32_EXT = 1,
		    VK_LAYER_SETTING_TYPE_INT64_EXT = 2,
		    VK_LAYER_SETTING_TYPE_UINT32_EXT = 3,
		    VK_LAYER_SETTING_TYPE_UINT64_EXT = 4,
		    VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5,
		    VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6,
		    VK_LAYER_SETTING_TYPE_STRING_EXT = 7,
		    VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkLayerSettingTypeEXT;


		typedef struct VkLayerSettingEXT
		{
		    const char* pLayerName;
		    const char* pSettingName;
		    VkLayerSettingTypeEXT type;
		    uint32_t valueCount;
		    const void* pValues;
		} VkLayerSettingEXT;

		typedef struct VkLayerSettingsCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t settingCount;
		    const VkLayerSettingEXT* pSettings;
		} VkLayerSettingsCreateInfoEXT;


		#define VK_EXT_validation_flags 1
		#define VK_EXT_VALIDATION_FLAGS_SPEC_VERSION 3
		#define VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME "VK_EXT_validation_flags"

		typedef enum
		{
		    VK_VALIDATION_CHECK_ALL_EXT = 0,
		    VK_VALIDATION_CHECK_SHADERS_EXT = 1,
		    VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkValidationCheckEXT;


		typedef struct VkValidationFlagsEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t disabledValidationCheckCount;
		    const VkValidationCheckEXT* pDisabledValidationChecks;
		} VkValidationFlagsEXT;


		#define VK_ARM_shader_core_builtins 1
		#define VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION 2
		#define VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME "VK_ARM_shader_core_builtins"

		typedef struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderCoreBuiltins;
		} VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM;

		typedef struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM
		{
		    VkStructureType sType;
		    void* pNext;
		    uint64_t shaderCoreMask;
		    uint32_t shaderCoreCount;
		    uint32_t shaderWarpsPerCore;
		} VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM;


		#define VK_EXT_pipeline_library_group_handles 1
		#define VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION 1
		#define VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME "VK_EXT_pipeline_library_group_handles"

		typedef struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 pipelineLibraryGroupHandles;
		} VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;


		#define VK_EXT_dynamic_rendering_unused_attachments 1
		#define VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION 1
		#define VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME "VK_EXT_dynamic_rendering_unused_attachments"

		typedef struct VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 dynamicRenderingUnusedAttachments;
		} VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;


		#define VK_NV_low_latency2 1
		#define VK_NV_LOW_LATENCY_2_SPEC_VERSION 2
		#define VK_NV_LOW_LATENCY_2_EXTENSION_NAME "VK_NV_low_latency2"

		typedef enum
		{
		    VK_LATENCY_MARKER_SIMULATION_START_NV = 0,
		    VK_LATENCY_MARKER_SIMULATION_END_NV = 1,
		    VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2,
		    VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3,
		    VK_LATENCY_MARKER_PRESENT_START_NV = 4,
		    VK_LATENCY_MARKER_PRESENT_END_NV = 5,
		    VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6,
		    VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7,
		    VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8,
		    VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9,
		    VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10,
		    VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11,
		    VK_LATENCY_MARKER_MAX_ENUM_NV = 0x7FFFFFFF
		} VkLatencyMarkerNV;

		typedef enum
		{
		    VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0,
		    VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1,
		    VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkOutOfBandQueueTypeNV;


		typedef struct VkLatencySleepModeInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 lowLatencyMode;
		    VkBool32 lowLatencyBoost;
		    uint32_t minimumIntervalUs;
		} VkLatencySleepModeInfoNV;

		typedef struct VkLatencySleepInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore signalSemaphore;
		    uint64_t value;
		} VkLatencySleepInfoNV;

		typedef struct VkSetLatencyMarkerInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t presentID;
		    VkLatencyMarkerNV marker;
		} VkSetLatencyMarkerInfoNV;

		typedef struct VkLatencyTimingsFrameReportNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t presentID;
		    uint64_t inputSampleTimeUs;
		    uint64_t simStartTimeUs;
		    uint64_t simEndTimeUs;
		    uint64_t renderSubmitStartTimeUs;
		    uint64_t renderSubmitEndTimeUs;
		    uint64_t presentStartTimeUs;
		    uint64_t presentEndTimeUs;
		    uint64_t driverStartTimeUs;
		    uint64_t driverEndTimeUs;
		    uint64_t osRenderQueueStartTimeUs;
		    uint64_t osRenderQueueEndTimeUs;
		    uint64_t gpuRenderStartTimeUs;
		    uint64_t gpuRenderEndTimeUs;
		} VkLatencyTimingsFrameReportNV;

		typedef struct VkGetLatencyMarkerInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t timingCount;
		    VkLatencyTimingsFrameReportNV* pTimings;
		} VkGetLatencyMarkerInfoNV;

		typedef struct VkLatencySubmissionPresentIdNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint64_t presentID;
		} VkLatencySubmissionPresentIdNV;

		typedef struct VkSwapchainLatencyCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBool32 latencyModeEnable;
		} VkSwapchainLatencyCreateInfoNV;

		typedef struct VkOutOfBandQueueTypeInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkOutOfBandQueueTypeNV queueType;
		} VkOutOfBandQueueTypeInfoNV;

		typedef struct VkLatencySurfaceCapabilitiesNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t presentModeCount;
		    VkPresentModeKHR* pPresentModes;
		} VkLatencySurfaceCapabilitiesNV;


		typedef VkResult (VKAPI_PTR *PFN_vkSetLatencySleepModeNV)(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV* pSleepModeInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkLatencySleepNV)(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV* pSleepInfo);
		typedef void (VKAPI_PTR *PFN_vkSetLatencyMarkerNV)(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo);
		typedef void (VKAPI_PTR *PFN_vkGetLatencyTimingsNV)(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV* pLatencyMarkerInfo);
		typedef void (VKAPI_PTR *PFN_vkQueueNotifyOutOfBandNV)(VkQueue queue, const VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo);


		#define VK_KHR_cooperative_matrix 1
		#define VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION 2
		#define VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME "VK_KHR_cooperative_matrix"

		typedef struct VkCooperativeMatrixPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t MSize;
		    uint32_t NSize;
		    uint32_t KSize;
		    VkComponentTypeKHR AType;
		    VkComponentTypeKHR BType;
		    VkComponentTypeKHR CType;
		    VkComponentTypeKHR ResultType;
		    VkBool32 saturatingAccumulation;
		    VkScopeKHR scope;
		} VkCooperativeMatrixPropertiesKHR;

		typedef struct VkPhysicalDeviceCooperativeMatrixFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 cooperativeMatrix;
		    VkBool32 cooperativeMatrixRobustBufferAccess;
		} VkPhysicalDeviceCooperativeMatrixFeaturesKHR;

		typedef struct VkPhysicalDeviceCooperativeMatrixPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkShaderStageFlags cooperativeMatrixSupportedStages;
		} VkPhysicalDeviceCooperativeMatrixPropertiesKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties);


		#define VK_QCOM_multiview_per_view_render_areas 1
		#define VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION 1
		#define VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME "VK_QCOM_multiview_per_view_render_areas"

		typedef struct VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 multiviewPerViewRenderAreas;
		} VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;

		typedef struct VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t perViewRenderAreaCount;
		    const VkRect2D* pPerViewRenderAreas;
		} VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM;


		#define VK_KHR_video_decode_av1 1
		#define VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION 1
		#define VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME "VK_KHR_video_decode_av1"

		#define VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR 7

		typedef struct VkVideoDecodeAV1ProfileInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    StdVideoAV1Profile stdProfile;
		    VkBool32 filmGrainSupport;
		} VkVideoDecodeAV1ProfileInfoKHR;

		typedef struct VkVideoDecodeAV1CapabilitiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    StdVideoAV1Level maxLevel;
		} VkVideoDecodeAV1CapabilitiesKHR;

		typedef struct VkVideoDecodeAV1SessionParametersCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoAV1SequenceHeader* pStdSequenceHeader;
		} VkVideoDecodeAV1SessionParametersCreateInfoKHR;

		typedef struct VkVideoDecodeAV1PictureInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoDecodeAV1PictureInfo* pStdPictureInfo;
		    int32_t referenceNameSlotIndices[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR];
		    uint32_t frameHeaderOffset;
		    uint32_t tileCount;
		    const uint32_t* pTileOffsets;
		    const uint32_t* pTileSizes;
		} VkVideoDecodeAV1PictureInfoKHR;

		typedef struct VkVideoDecodeAV1DpbSlotInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const StdVideoDecodeAV1ReferenceInfo* pStdReferenceInfo;
		} VkVideoDecodeAV1DpbSlotInfoKHR;


		#define VK_KHR_video_maintenance1 1
		#define VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION 1
		#define VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME "VK_KHR_video_maintenance1"

		typedef struct VkPhysicalDeviceVideoMaintenance1FeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 videoMaintenance1;
		} VkPhysicalDeviceVideoMaintenance1FeaturesKHR;

		typedef struct VkVideoInlineQueryInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkQueryPool queryPool;
		    uint32_t firstQuery;
		    uint32_t queryCount;
		} VkVideoInlineQueryInfoKHR;


		#define VK_NV_per_stage_descriptor_set 1
		#define VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION 1
		#define VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME "VK_NV_per_stage_descriptor_set"

		typedef struct VkPhysicalDevicePerStageDescriptorSetFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 perStageDescriptorSet;
		    VkBool32 dynamicPipelineLayout;
		} VkPhysicalDevicePerStageDescriptorSetFeaturesNV;


		#define VK_QCOM_image_processing2 1
		#define VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION 1
		#define VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME "VK_QCOM_image_processing2"

		typedef enum
		{
		    VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0,
		    VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1,
		    VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM = 0x7FFFFFFF
		} VkBlockMatchWindowCompareModeQCOM;


		typedef struct VkPhysicalDeviceImageProcessing2FeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 textureBlockMatch2;
		} VkPhysicalDeviceImageProcessing2FeaturesQCOM;

		typedef struct VkPhysicalDeviceImageProcessing2PropertiesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkExtent2D maxBlockMatchWindow;
		} VkPhysicalDeviceImageProcessing2PropertiesQCOM;

		typedef struct VkSamplerBlockMatchWindowCreateInfoQCOM
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExtent2D windowExtent;
		    VkBlockMatchWindowCompareModeQCOM windowCompareMode;
		} VkSamplerBlockMatchWindowCreateInfoQCOM;


		#define VK_QCOM_filter_cubic_weights 1
		#define VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION 1
		#define VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME "VK_QCOM_filter_cubic_weights"

		typedef enum
		{
		    VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0,
		    VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1,
		    VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2,
		    VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3,
		    VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM = 0x7FFFFFFF
		} VkCubicFilterWeightsQCOM;


		typedef struct VkPhysicalDeviceCubicWeightsFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 selectableCubicWeights;
		} VkPhysicalDeviceCubicWeightsFeaturesQCOM;

		typedef struct VkSamplerCubicWeightsCreateInfoQCOM
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCubicFilterWeightsQCOM cubicWeights;
		} VkSamplerCubicWeightsCreateInfoQCOM;

		typedef struct VkBlitImageCubicWeightsInfoQCOM
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkCubicFilterWeightsQCOM cubicWeights;
		} VkBlitImageCubicWeightsInfoQCOM;


		#define VK_QCOM_ycbcr_degamma 1
		#define VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION 1
		#define VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME "VK_QCOM_ycbcr_degamma"

		typedef struct VkPhysicalDeviceYcbcrDegammaFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 ycbcrDegamma;
		} VkPhysicalDeviceYcbcrDegammaFeaturesQCOM;

		typedef struct VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 enableYDegamma;
		    VkBool32 enableCbCrDegamma;
		} VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM;


		#define VK_QCOM_filter_cubic_clamp 1
		#define VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION 1
		#define VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME "VK_QCOM_filter_cubic_clamp"

		typedef struct VkPhysicalDeviceCubicClampFeaturesQCOM
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 cubicRangeClamp;
		} VkPhysicalDeviceCubicClampFeaturesQCOM;


		#define VK_EXT_attachment_feedback_loop_dynamic_state 1
		#define VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION 1
		#define VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME "VK_EXT_attachment_feedback_loop_dynamic_state"

		typedef struct VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 attachmentFeedbackLoopDynamicState;
		} VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask);


		#define VK_KHR_vertex_attribute_divisor 1
		#define VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION 1
		#define VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME "VK_KHR_vertex_attribute_divisor"

		typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxVertexAttribDivisor;
		    VkBool32 supportsNonZeroFirstInstance;
		} VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR;

		typedef struct VkVertexInputBindingDivisorDescriptionKHR
		{
		    uint32_t binding;
		    uint32_t divisor;
		} VkVertexInputBindingDivisorDescriptionKHR;

		typedef struct VkPipelineVertexInputDivisorStateCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t vertexBindingDivisorCount;
		    const VkVertexInputBindingDivisorDescriptionKHR* pVertexBindingDivisors;
		} VkPipelineVertexInputDivisorStateCreateInfoKHR;

		typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 vertexAttributeInstanceRateDivisor;
		    VkBool32 vertexAttributeInstanceRateZeroDivisor;
		} VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR;


		#define VK_EXT_vertex_attribute_divisor 1
		#define VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION 3
		#define VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME "VK_EXT_vertex_attribute_divisor"

		typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxVertexAttribDivisor;
		} VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;

		typedef VkVertexInputBindingDivisorDescriptionKHR VkVertexInputBindingDivisorDescriptionEXT;

		typedef VkPipelineVertexInputDivisorStateCreateInfoKHR VkPipelineVertexInputDivisorStateCreateInfoEXT;

		typedef VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;


		#define VK_KHR_load_store_op_none 1
		#define VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION 1
		#define VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME "VK_KHR_load_store_op_none"


		#define VK_EXT_load_store_op_none 1
		#define VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION 1
		#define VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME "VK_EXT_load_store_op_none"


		#define VK_KHR_shader_float_controls2 1
		#define VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION 1
		#define VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME "VK_KHR_shader_float_controls2"

		typedef struct VkPhysicalDeviceShaderFloatControls2FeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderFloatControls2;
		} VkPhysicalDeviceShaderFloatControls2FeaturesKHR;


		#define VK_MSFT_layered_driver 1
		#define VK_MSFT_LAYERED_DRIVER_SPEC_VERSION 1
		#define VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME "VK_MSFT_layered_driver"

		typedef enum
		{
		    VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0,
		    VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1,
		    VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT = 0x7FFFFFFF
		} VkLayeredDriverUnderlyingApiMSFT;


		typedef struct VkPhysicalDeviceLayeredDriverPropertiesMSFT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkLayeredDriverUnderlyingApiMSFT underlyingAPI;
		} VkPhysicalDeviceLayeredDriverPropertiesMSFT;


		#define VK_KHR_index_type_uint8 1
		#define VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION 1
		#define VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME "VK_KHR_index_type_uint8"

		typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 indexTypeUint8;
		} VkPhysicalDeviceIndexTypeUint8FeaturesKHR;


		#define VK_EXT_index_type_uint8 1
		#define VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION 1
		#define VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME "VK_EXT_index_type_uint8"

		typedef VkPhysicalDeviceIndexTypeUint8FeaturesKHR VkPhysicalDeviceIndexTypeUint8FeaturesEXT;


		#define VK_KHR_line_rasterization 1
		#define VK_KHR_LINE_RASTERIZATION_SPEC_VERSION 1
		#define VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME "VK_KHR_line_rasterization"

		typedef struct VkPhysicalDeviceLineRasterizationFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rectangularLines;
		    VkBool32 bresenhamLines;
		    VkBool32 smoothLines;
		    VkBool32 stippledRectangularLines;
		    VkBool32 stippledBresenhamLines;
		    VkBool32 stippledSmoothLines;
		} VkPhysicalDeviceLineRasterizationFeaturesKHR;

		typedef struct VkPhysicalDeviceLineRasterizationPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t lineSubPixelPrecisionBits;
		} VkPhysicalDeviceLineRasterizationPropertiesKHR;

		typedef struct VkPipelineRasterizationLineStateCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkLineRasterizationModeKHR lineRasterizationMode;
		    VkBool32 stippledLineEnable;
		    uint32_t lineStippleFactor;
		    uint16_t lineStipplePattern;
		} VkPipelineRasterizationLineStateCreateInfoKHR;


		typedef void (VKAPI_PTR *PFN_vkCmdSetLineStippleKHR)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);


		#define VK_EXT_line_rasterization 1
		#define VK_EXT_LINE_RASTERIZATION_SPEC_VERSION 1
		#define VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME "VK_EXT_line_rasterization"

		typedef VkPhysicalDeviceLineRasterizationFeaturesKHR VkPhysicalDeviceLineRasterizationFeaturesEXT;

		typedef VkPhysicalDeviceLineRasterizationPropertiesKHR VkPhysicalDeviceLineRasterizationPropertiesEXT;

		typedef VkPipelineRasterizationLineStateCreateInfoKHR VkPipelineRasterizationLineStateCreateInfoEXT;

		typedef void (VKAPI_PTR *PFN_vkCmdSetLineStippleEXT)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);


		#define VK_KHR_calibrated_timestamps 1
		#define VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION 1
		#define VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME "VK_KHR_calibrated_timestamps"

		typedef enum
		{
		    VK_TIME_DOMAIN_DEVICE_KHR = 0,
		    VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR = 1,
		    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR = 2,
		    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR = 3,
		    VK_TIME_DOMAIN_DEVICE_EXT = VK_TIME_DOMAIN_DEVICE_KHR,
		    VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
		    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
		    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
		    VK_TIME_DOMAIN_MAX_ENUM_KHR = 0x7FFFFFFF
		} VkTimeDomainKHR;


		typedef struct VkCalibratedTimestampInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkTimeDomainKHR timeDomain;
		} VkCalibratedTimestampInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR)(VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains);
		typedef VkResult (VKAPI_PTR *PFN_vkGetCalibratedTimestampsKHR)(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation);


		#define VK_EXT_calibrated_timestamps 1
		#define VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION 2
		#define VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME "VK_EXT_calibrated_timestamps"

		typedef VkTimeDomainKHR VkTimeDomainEXT;
		typedef VkCalibratedTimestampInfoKHR VkCalibratedTimestampInfoEXT;

		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)(VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains);
		typedef VkResult (VKAPI_PTR *PFN_vkGetCalibratedTimestampsEXT)(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation);


		#define VK_KHR_shader_expect_assume 1
		#define VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION 1
		#define VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME "VK_KHR_shader_expect_assume"

		typedef struct VkPhysicalDeviceShaderExpectAssumeFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderExpectAssume;
		} VkPhysicalDeviceShaderExpectAssumeFeaturesKHR;


		#define VK_KHR_maintenance6 1
		#define VK_KHR_MAINTENANCE_6_SPEC_VERSION 1
		#define VK_KHR_MAINTENANCE_6_EXTENSION_NAME "VK_KHR_maintenance6"

		typedef struct VkPhysicalDeviceMaintenance6FeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 maintenance6;
		} VkPhysicalDeviceMaintenance6FeaturesKHR;

		typedef struct VkPhysicalDeviceMaintenance6PropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 blockTexelViewCompatibleMultipleLayers;
		    uint32_t maxCombinedImageSamplerDescriptorCount;
		    VkBool32 fragmentShadingRateClampCombinerInputs;
		} VkPhysicalDeviceMaintenance6PropertiesKHR;

		typedef struct VkBindMemoryStatusKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkResult* pResult;
		} VkBindMemoryStatusKHR;

		typedef struct VkBindDescriptorSetsInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkShaderStageFlags stageFlags;
		    VkPipelineLayout layout;
		    uint32_t firstSet;
		    uint32_t descriptorSetCount;
		    const VkDescriptorSet* pDescriptorSets;
		    uint32_t dynamicOffsetCount;
		    const uint32_t* pDynamicOffsets;
		} VkBindDescriptorSetsInfoKHR;

		typedef struct VkPushConstantsInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineLayout layout;
		    VkShaderStageFlags stageFlags;
		    uint32_t offset;
		    uint32_t size;
		    const void* pValues;
		} VkPushConstantsInfoKHR;

		typedef struct VkPushDescriptorSetInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkShaderStageFlags stageFlags;
		    VkPipelineLayout layout;
		    uint32_t set;
		    uint32_t descriptorWriteCount;
		    const VkWriteDescriptorSet* pDescriptorWrites;
		} VkPushDescriptorSetInfoKHR;

		typedef struct VkPushDescriptorSetWithTemplateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDescriptorUpdateTemplate descriptorUpdateTemplate;
		    VkPipelineLayout layout;
		    uint32_t set;
		    const void* pData;
		} VkPushDescriptorSetWithTemplateInfoKHR;

		typedef struct VkSetDescriptorBufferOffsetsInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkShaderStageFlags stageFlags;
		    VkPipelineLayout layout;
		    uint32_t firstSet;
		    uint32_t setCount;
		    const uint32_t* pBufferIndices;
		    const VkDeviceSize* pOffsets;
		} VkSetDescriptorBufferOffsetsInfoEXT;

		typedef struct VkBindDescriptorBufferEmbeddedSamplersInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkShaderStageFlags stageFlags;
		    VkPipelineLayout layout;
		    uint32_t set;
		} VkBindDescriptorBufferEmbeddedSamplersInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets2KHR)(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfoKHR* pBindDescriptorSetsInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdPushConstants2KHR)(VkCommandBuffer commandBuffer, const VkPushConstantsInfoKHR* pPushConstantsInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSet2KHR)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfoKHR* pPushDescriptorSetInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdPushDescriptorSetWithTemplate2KHR)(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfoKHR* pPushDescriptorSetWithTemplateInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdSetDescriptorBufferOffsets2EXT)(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo);


		#define VK_NV_descriptor_pool_overallocation 1
		#define VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION 1
		#define VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME "VK_NV_descriptor_pool_overallocation"

		typedef struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 descriptorPoolOverallocation;
		} VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV;


		#define VK_NV_raw_access_chains 1
		#define VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION 1
		#define VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME "VK_NV_raw_access_chains"

		typedef struct VkPhysicalDeviceRawAccessChainsFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderRawAccessChains;
		} VkPhysicalDeviceRawAccessChainsFeaturesNV;


		#define VK_NV_shader_atomic_float16_vector 1
		#define VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION 1
		#define VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME "VK_NV_shader_atomic_float16_vector"

		typedef struct VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderFloat16VectorAtomics;
		} VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV;


		#define VK_NV_ray_tracing_validation 1
		#define VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION 1
		#define VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME "VK_NV_ray_tracing_validation"

		typedef struct VkPhysicalDeviceRayTracingValidationFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 rayTracingValidation;
		} VkPhysicalDeviceRayTracingValidationFeaturesNV;

		#ifdef VK_USE_PLATFORM_XLIB_KHR

		#define VK_KHR_xlib_surface 1
		#define VK_KHR_XLIB_SURFACE_SPEC_VERSION 6
		#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

		typedef VkFlags VkXlibSurfaceCreateFlagsKHR;
		typedef struct VkXlibSurfaceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkXlibSurfaceCreateFlagsKHR flags;
		    vkbind_Display* dpy;
		    vkbind_Window window;
		} VkXlibSurfaceCreateInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
		typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, vkbind_Display* dpy, vkbind_VisualID visualID);

		#endif /*VK_USE_PLATFORM_XLIB_KHR*/

		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT

		#define VK_EXT_acquire_xlib_display 1
		#define VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION 1
		#define VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME "VK_EXT_acquire_xlib_display"

		typedef VkResult (VKAPI_PTR *PFN_vkAcquireXlibDisplayEXT)(VkPhysicalDevice physicalDevice, vkbind_Display* dpy, VkDisplayKHR display);
		typedef VkResult (VKAPI_PTR *PFN_vkGetRandROutputDisplayEXT)(VkPhysicalDevice physicalDevice, vkbind_Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay);

		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/

		#ifdef VK_USE_PLATFORM_XCB_KHR
		#include <xcb/xcb.h>

		#define VK_KHR_xcb_surface 1
		#define VK_KHR_XCB_SURFACE_SPEC_VERSION 6
		#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

		typedef VkFlags VkXcbSurfaceCreateFlagsKHR;
		typedef struct VkXcbSurfaceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkXcbSurfaceCreateFlagsKHR flags;
		    xcb_connection_t* connection;
		    xcb_window_t window;
		} VkXcbSurfaceCreateInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
		typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);

		#endif /*VK_USE_PLATFORM_XCB_KHR*/

		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		#include <wayland-client.h>

		#define VK_KHR_wayland_surface 1
		#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 6
		#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"

		typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;
		typedef struct VkWaylandSurfaceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkWaylandSurfaceCreateFlagsKHR flags;
		    struct wl_display* display;
		    struct wl_surface* surface;
		} VkWaylandSurfaceCreateInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
		typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);

		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		#include <directfb.h>

		#define VK_EXT_directfb_surface 1
		#define VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION 1
		#define VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME "VK_EXT_directfb_surface"

		typedef VkFlags VkDirectFBSurfaceCreateFlagsEXT;
		typedef struct VkDirectFBSurfaceCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDirectFBSurfaceCreateFlagsEXT flags;
		    IDirectFB* dfb;
		    IDirectFBSurface* surface;
		} VkDirectFBSurfaceCreateInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateDirectFBSurfaceEXT)(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
		typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB* dfb);

		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/

		#ifdef VK_USE_PLATFORM_ANDROID_KHR

		#define VK_KHR_android_surface 1
		#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
		#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"

		struct ANativeWindow;

		typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;
		typedef struct VkAndroidSurfaceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkAndroidSurfaceCreateFlagsKHR flags;
		    struct ANativeWindow* window;
		} VkAndroidSurfaceCreateInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);


		#define VK_ANDROID_external_memory_android_hardware_buffer 1
		#define VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION 5
		#define VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME "VK_ANDROID_external_memory_android_hardware_buffer"

		struct AHardwareBuffer;

		typedef struct VkAndroidHardwareBufferUsageANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    uint64_t androidHardwareBufferUsage;
		} VkAndroidHardwareBufferUsageANDROID;

		typedef struct VkAndroidHardwareBufferPropertiesANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize allocationSize;
		    uint32_t memoryTypeBits;
		} VkAndroidHardwareBufferPropertiesANDROID;

		typedef struct VkAndroidHardwareBufferFormatPropertiesANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormat format;
		    uint64_t externalFormat;
		    VkFormatFeatureFlags formatFeatures;
		    VkComponentMapping samplerYcbcrConversionComponents;
		    VkSamplerYcbcrModelConversion suggestedYcbcrModel;
		    VkSamplerYcbcrRange suggestedYcbcrRange;
		    VkChromaLocation suggestedXChromaOffset;
		    VkChromaLocation suggestedYChromaOffset;
		} VkAndroidHardwareBufferFormatPropertiesANDROID;

		typedef struct VkImportAndroidHardwareBufferInfoANDROID
		{
		    VkStructureType sType;
		    const void* pNext;
		    struct AHardwareBuffer* buffer;
		} VkImportAndroidHardwareBufferInfoANDROID;

		typedef struct VkMemoryGetAndroidHardwareBufferInfoANDROID
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		} VkMemoryGetAndroidHardwareBufferInfoANDROID;

		typedef struct VkExternalFormatANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    uint64_t externalFormat;
		} VkExternalFormatANDROID;

		typedef struct VkAndroidHardwareBufferFormatProperties2ANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormat format;
		    uint64_t externalFormat;
		    VkFormatFeatureFlags2 formatFeatures;
		    VkComponentMapping samplerYcbcrConversionComponents;
		    VkSamplerYcbcrModelConversion suggestedYcbcrModel;
		    VkSamplerYcbcrRange suggestedYcbcrRange;
		    VkChromaLocation suggestedXChromaOffset;
		    VkChromaLocation suggestedYChromaOffset;
		} VkAndroidHardwareBufferFormatProperties2ANDROID;


		typedef VkResult (VKAPI_PTR *PFN_vkGetAndroidHardwareBufferPropertiesANDROID)(VkDevice device, const struct AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryAndroidHardwareBufferANDROID)(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer);


		#define VK_ANDROID_external_format_resolve 1
		#define VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION 1
		#define VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME "VK_ANDROID_external_format_resolve"

		typedef struct VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 externalFormatResolve;
		} VkPhysicalDeviceExternalFormatResolveFeaturesANDROID;

		typedef struct VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 nullColorAttachmentWithExternalFormatResolve;
		    VkChromaLocation externalFormatResolveChromaOffsetX;
		    VkChromaLocation externalFormatResolveChromaOffsetY;
		} VkPhysicalDeviceExternalFormatResolvePropertiesANDROID;

		typedef struct VkAndroidHardwareBufferFormatResolvePropertiesANDROID
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormat colorAttachmentFormat;
		} VkAndroidHardwareBufferFormatResolvePropertiesANDROID;

		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

		#ifdef VK_USE_PLATFORM_WIN32_KHR

		#define VK_KHR_win32_surface 1
		#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 6
		#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"

		typedef VkFlags VkWin32SurfaceCreateFlagsKHR;
		typedef struct VkWin32SurfaceCreateInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkWin32SurfaceCreateFlagsKHR flags;
		    HINSTANCE hinstance;
		    HWND hwnd;
		} VkWin32SurfaceCreateInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
		typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);


		#define VK_KHR_external_memory_win32 1
		#define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"

		typedef struct VkImportMemoryWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		    HANDLE handle;
		    LPCWSTR name;
		} VkImportMemoryWin32HandleInfoKHR;

		typedef struct VkExportMemoryWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const SECURITY_ATTRIBUTES* pAttributes;
		    DWORD dwAccess;
		    LPCWSTR name;
		} VkExportMemoryWin32HandleInfoKHR;

		typedef struct VkMemoryWin32HandlePropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t memoryTypeBits;
		} VkMemoryWin32HandlePropertiesKHR;

		typedef struct VkMemoryGetWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		} VkMemoryGetWin32HandleInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);
		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties);


		#define VK_NV_external_memory_win32 1
		#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
		#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

		typedef struct VkImportMemoryWin32HandleInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagsNV handleType;
		    HANDLE handle;
		} VkImportMemoryWin32HandleInfoNV;

		typedef struct VkExportMemoryWin32HandleInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    const SECURITY_ATTRIBUTES* pAttributes;
		    DWORD dwAccess;
		} VkExportMemoryWin32HandleInfoNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);


		#define VK_KHR_win32_keyed_mutex 1
		#define VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION 1
		#define VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_KHR_win32_keyed_mutex"

		typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t acquireCount;
		    const VkDeviceMemory* pAcquireSyncs;
		    const uint64_t* pAcquireKeys;
		    const uint32_t* pAcquireTimeouts;
		    uint32_t releaseCount;
		    const VkDeviceMemory* pReleaseSyncs;
		    const uint64_t* pReleaseKeys;
		} VkWin32KeyedMutexAcquireReleaseInfoKHR;


		#define VK_NV_win32_keyed_mutex 1
		#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 2
		#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

		typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t acquireCount;
		    const VkDeviceMemory* pAcquireSyncs;
		    const uint64_t* pAcquireKeys;
		    const uint32_t* pAcquireTimeoutMilliseconds;
		    uint32_t releaseCount;
		    const VkDeviceMemory* pReleaseSyncs;
		    const uint64_t* pReleaseKeys;
		} VkWin32KeyedMutexAcquireReleaseInfoNV;


		#define VK_KHR_external_semaphore_win32 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME "VK_KHR_external_semaphore_win32"

		typedef struct VkImportSemaphoreWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkSemaphoreImportFlags flags;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		    HANDLE handle;
		    LPCWSTR name;
		} VkImportSemaphoreWin32HandleInfoKHR;

		typedef struct VkExportSemaphoreWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const SECURITY_ATTRIBUTES* pAttributes;
		    DWORD dwAccess;
		    LPCWSTR name;
		} VkExportSemaphoreWin32HandleInfoKHR;

		typedef struct VkD3D12FenceSubmitInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t waitSemaphoreValuesCount;
		    const uint64_t* pWaitSemaphoreValues;
		    uint32_t signalSemaphoreValuesCount;
		    const uint64_t* pSignalSemaphoreValues;
		} VkD3D12FenceSubmitInfoKHR;

		typedef struct VkSemaphoreGetWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		} VkSemaphoreGetWin32HandleInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreWin32HandleKHR)(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreWin32HandleKHR)(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);


		#define VK_KHR_external_fence_win32 1
		#define VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION 1
		#define VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME "VK_KHR_external_fence_win32"

		typedef struct VkImportFenceWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFence fence;
		    VkFenceImportFlags flags;
		    VkExternalFenceHandleTypeFlagBits handleType;
		    HANDLE handle;
		    LPCWSTR name;
		} VkImportFenceWin32HandleInfoKHR;

		typedef struct VkExportFenceWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    const SECURITY_ATTRIBUTES* pAttributes;
		    DWORD dwAccess;
		    LPCWSTR name;
		} VkExportFenceWin32HandleInfoKHR;

		typedef struct VkFenceGetWin32HandleInfoKHR
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFence fence;
		    VkExternalFenceHandleTypeFlagBits handleType;
		} VkFenceGetWin32HandleInfoKHR;


		typedef VkResult (VKAPI_PTR *PFN_vkImportFenceWin32HandleKHR)(VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetFenceWin32HandleKHR)(VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle);


		#define VK_EXT_full_screen_exclusive 1
		#define VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION 4
		#define VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME "VK_EXT_full_screen_exclusive"

		typedef enum
		{
		    VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
		    VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
		    VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
		    VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
		    VK_FULL_SCREEN_EXCLUSIVE_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkFullScreenExclusiveEXT;


		typedef struct VkSurfaceFullScreenExclusiveInfoEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFullScreenExclusiveEXT fullScreenExclusive;
		} VkSurfaceFullScreenExclusiveInfoEXT;

		typedef struct VkSurfaceCapabilitiesFullScreenExclusiveEXT
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 fullScreenExclusiveSupported;
		} VkSurfaceCapabilitiesFullScreenExclusiveEXT;

		typedef struct VkSurfaceFullScreenExclusiveWin32InfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    HMONITOR hmonitor;
		} VkSurfaceFullScreenExclusiveWin32InfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);
		typedef VkResult (VKAPI_PTR *PFN_vkAcquireFullScreenExclusiveModeEXT)(VkDevice device, VkSwapchainKHR swapchain);
		typedef VkResult (VKAPI_PTR *PFN_vkReleaseFullScreenExclusiveModeEXT)(VkDevice device, VkSwapchainKHR swapchain);
		typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceGroupSurfacePresentModes2EXT)(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR* pModes);


		#define VK_NV_acquire_winrt_display 1
		#define VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION 1
		#define VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME "VK_NV_acquire_winrt_display"

		typedef VkResult (VKAPI_PTR *PFN_vkAcquireWinrtDisplayNV)(VkPhysicalDevice physicalDevice, VkDisplayKHR display);
		typedef VkResult (VKAPI_PTR *PFN_vkGetWinrtDisplayNV)(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR* pDisplay);

		#endif /*VK_USE_PLATFORM_WIN32_KHR*/

		#ifdef VK_USE_PLATFORM_VI_NN

		#define VK_NN_vi_surface 1
		#define VK_NN_VI_SURFACE_SPEC_VERSION 1
		#define VK_NN_VI_SURFACE_EXTENSION_NAME "VK_NN_vi_surface"

		typedef VkFlags VkViSurfaceCreateFlagsNN;
		typedef struct VkViSurfaceCreateInfoNN
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkViSurfaceCreateFlagsNN flags;
		    void* window;
		} VkViSurfaceCreateInfoNN;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateViSurfaceNN)(VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

		#endif /*VK_USE_PLATFORM_VI_NN*/

		#ifdef VK_USE_PLATFORM_IOS_MVK

		#define VK_MVK_ios_surface 1
		#define VK_MVK_IOS_SURFACE_SPEC_VERSION 3
		#define VK_MVK_IOS_SURFACE_EXTENSION_NAME "VK_MVK_ios_surface"

		typedef VkFlags VkIOSSurfaceCreateFlagsMVK;
		typedef struct VkIOSSurfaceCreateInfoMVK
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkIOSSurfaceCreateFlagsMVK flags;
		    const void* pView;
		} VkIOSSurfaceCreateInfoMVK;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateIOSSurfaceMVK)(VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

		#endif /*VK_USE_PLATFORM_IOS_MVK*/

		#ifdef VK_USE_PLATFORM_MACOS_MVK

		#define VK_MVK_macos_surface 1
		#define VK_MVK_MACOS_SURFACE_SPEC_VERSION 3
		#define VK_MVK_MACOS_SURFACE_EXTENSION_NAME "VK_MVK_macos_surface"

		typedef VkFlags VkMacOSSurfaceCreateFlagsMVK;
		typedef struct VkMacOSSurfaceCreateInfoMVK
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMacOSSurfaceCreateFlagsMVK flags;
		    const void* pView;
		} VkMacOSSurfaceCreateInfoMVK;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateMacOSSurfaceMVK)(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

		#endif /*VK_USE_PLATFORM_MACOS_MVK*/

		#ifdef VK_USE_PLATFORM_METAL_EXT

		#define VK_EXT_metal_surface 1
		#define VK_EXT_METAL_SURFACE_SPEC_VERSION 1
		#define VK_EXT_METAL_SURFACE_EXTENSION_NAME "VK_EXT_metal_surface"

		#ifdef __OBJC__
		@class CAMetalLayer;
		#else
		typedef void CAMetalLayer;
		#endif

		typedef VkFlags VkMetalSurfaceCreateFlagsEXT;
		typedef struct VkMetalSurfaceCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkMetalSurfaceCreateFlagsEXT flags;
		    const CAMetalLayer* pLayer;
		} VkMetalSurfaceCreateInfoEXT;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateMetalSurfaceEXT)(VkInstance instance, const VkMetalSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);


		#define VK_EXT_metal_objects 1
		#define VK_EXT_METAL_OBJECTS_SPEC_VERSION 2
		#define VK_EXT_METAL_OBJECTS_EXTENSION_NAME "VK_EXT_metal_objects"

		#ifdef __OBJC__
		@protocol MTLDevice;
		typedef __unsafe_unretained id<MTLDevice> MTLDevice_id;
		#else
		typedef void* MTLDevice_id;
		#endif
		#ifdef __OBJC__
		@protocol MTLCommandQueue;
		typedef __unsafe_unretained id<MTLCommandQueue> MTLCommandQueue_id;
		#else
		typedef void* MTLCommandQueue_id;
		#endif
		#ifdef __OBJC__
		@protocol MTLBuffer;
		typedef __unsafe_unretained id<MTLBuffer> MTLBuffer_id;
		#else
		typedef void* MTLBuffer_id;
		#endif
		#ifdef __OBJC__
		@protocol MTLTexture;
		typedef __unsafe_unretained id<MTLTexture> MTLTexture_id;
		#else
		typedef void* MTLTexture_id;
		#endif
		typedef struct __IOSurface* IOSurfaceRef;
		#ifdef __OBJC__
		@protocol MTLSharedEvent;
		typedef __unsafe_unretained id<MTLSharedEvent> MTLSharedEvent_id;
		#else
		typedef void* MTLSharedEvent_id;
		#endif


		typedef enum
		{
		    VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 0x00000001,
		    VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 0x00000002,
		    VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 0x00000004,
		    VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 0x00000008,
		    VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 0x00000010,
		    VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 0x00000020,
		    VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
		} VkExportMetalObjectTypeFlagBitsEXT;
		typedef VkFlags VkExportMetalObjectTypeFlagsEXT;

		typedef struct VkExportMetalObjectCreateInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExportMetalObjectTypeFlagBitsEXT exportObjectType;
		} VkExportMetalObjectCreateInfoEXT;

		typedef struct VkExportMetalObjectsInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		} VkExportMetalObjectsInfoEXT;

		typedef struct VkExportMetalDeviceInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    MTLDevice_id mtlDevice;
		} VkExportMetalDeviceInfoEXT;

		typedef struct VkExportMetalCommandQueueInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkQueue queue;
		    MTLCommandQueue_id mtlCommandQueue;
		} VkExportMetalCommandQueueInfoEXT;

		typedef struct VkExportMetalBufferInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		    MTLBuffer_id mtlBuffer;
		} VkExportMetalBufferInfoEXT;

		typedef struct VkImportMetalBufferInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    MTLBuffer_id mtlBuffer;
		} VkImportMetalBufferInfoEXT;

		typedef struct VkExportMetalTextureInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		    VkImageView imageView;
		    VkBufferView bufferView;
		    VkImageAspectFlagBits plane;
		    MTLTexture_id mtlTexture;
		} VkExportMetalTextureInfoEXT;

		typedef struct VkImportMetalTextureInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageAspectFlagBits plane;
		    MTLTexture_id mtlTexture;
		} VkImportMetalTextureInfoEXT;

		typedef struct VkExportMetalIOSurfaceInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImage image;
		    IOSurfaceRef ioSurface;
		} VkExportMetalIOSurfaceInfoEXT;

		typedef struct VkImportMetalIOSurfaceInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    IOSurfaceRef ioSurface;
		} VkImportMetalIOSurfaceInfoEXT;

		typedef struct VkExportMetalSharedEventInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkEvent event;
		    MTLSharedEvent_id mtlSharedEvent;
		} VkExportMetalSharedEventInfoEXT;

		typedef struct VkImportMetalSharedEventInfoEXT
		{
		    VkStructureType sType;
		    const void* pNext;
		    MTLSharedEvent_id mtlSharedEvent;
		} VkImportMetalSharedEventInfoEXT;


		typedef void (VKAPI_PTR *PFN_vkExportMetalObjectsEXT)(VkDevice device, VkExportMetalObjectsInfoEXT* pMetalObjectsInfo);

		#endif /*VK_USE_PLATFORM_METAL_EXT*/

		#ifdef VK_USE_PLATFORM_FUCHSIA
		#include <zircon/types.h>

		#define VK_FUCHSIA_imagepipe_surface 1
		#define VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION 1
		#define VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME "VK_FUCHSIA_imagepipe_surface"

		typedef VkFlags VkImagePipeSurfaceCreateFlagsFUCHSIA;
		typedef struct VkImagePipeSurfaceCreateInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImagePipeSurfaceCreateFlagsFUCHSIA flags;
		    zx_handle_t imagePipeHandle;
		} VkImagePipeSurfaceCreateInfoFUCHSIA;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateImagePipeSurfaceFUCHSIA)(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);


		#define VK_FUCHSIA_external_memory 1
		#define VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION 1
		#define VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME "VK_FUCHSIA_external_memory"

		typedef struct VkImportMemoryZirconHandleInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		    zx_handle_t handle;
		} VkImportMemoryZirconHandleInfoFUCHSIA;

		typedef struct VkMemoryZirconHandlePropertiesFUCHSIA
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t memoryTypeBits;
		} VkMemoryZirconHandlePropertiesFUCHSIA;

		typedef struct VkMemoryGetZirconHandleInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		} VkMemoryGetZirconHandleInfoFUCHSIA;


		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryZirconHandleFUCHSIA)(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle);
		typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties);


		#define VK_FUCHSIA_external_semaphore 1
		#define VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
		#define VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_FUCHSIA_external_semaphore"

		typedef struct VkImportSemaphoreZirconHandleInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkSemaphoreImportFlags flags;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		    zx_handle_t zirconHandle;
		} VkImportSemaphoreZirconHandleInfoFUCHSIA;

		typedef struct VkSemaphoreGetZirconHandleInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		} VkSemaphoreGetZirconHandleInfoFUCHSIA;


		typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreZirconHandleFUCHSIA)(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreZirconHandleFUCHSIA)(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle);


		#define VK_FUCHSIA_buffer_collection 1
		#define VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION 2
		#define VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME "VK_FUCHSIA_buffer_collection"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferCollectionFUCHSIA)

		typedef VkFlags VkImageFormatConstraintsFlagsFUCHSIA;

		typedef enum
		{
		    VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = 0x00000001,
		    VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = 0x00000002,
		    VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = 0x00000004,
		    VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = 0x00000008,
		    VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = 0x00000010,
		    VK_IMAGE_CONSTRAINTS_INFO_FLAG_BITS_MAX_ENUM_FUCHSIA = 0x7FFFFFFF
		} VkImageConstraintsInfoFlagBitsFUCHSIA;
		typedef VkFlags VkImageConstraintsInfoFlagsFUCHSIA;

		typedef struct VkBufferCollectionCreateInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    zx_handle_t collectionToken;
		} VkBufferCollectionCreateInfoFUCHSIA;

		typedef struct VkImportMemoryBufferCollectionFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferCollectionFUCHSIA collection;
		    uint32_t index;
		} VkImportMemoryBufferCollectionFUCHSIA;

		typedef struct VkBufferCollectionImageCreateInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferCollectionFUCHSIA collection;
		    uint32_t index;
		} VkBufferCollectionImageCreateInfoFUCHSIA;

		typedef struct VkBufferCollectionConstraintsInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t minBufferCount;
		    uint32_t maxBufferCount;
		    uint32_t minBufferCountForCamping;
		    uint32_t minBufferCountForDedicatedSlack;
		    uint32_t minBufferCountForSharedSlack;
		} VkBufferCollectionConstraintsInfoFUCHSIA;

		typedef struct VkBufferConstraintsInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferCreateInfo createInfo;
		    VkFormatFeatureFlags requiredFormatFeatures;
		    VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;
		} VkBufferConstraintsInfoFUCHSIA;

		typedef struct VkBufferCollectionBufferCreateInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkBufferCollectionFUCHSIA collection;
		    uint32_t index;
		} VkBufferCollectionBufferCreateInfoFUCHSIA;

		typedef struct VkSysmemColorSpaceFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t colorSpace;
		} VkSysmemColorSpaceFUCHSIA;

		typedef struct VkBufferCollectionPropertiesFUCHSIA
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t memoryTypeBits;
		    uint32_t bufferCount;
		    uint32_t createInfoIndex;
		    uint64_t sysmemPixelFormat;
		    VkFormatFeatureFlags formatFeatures;
		    VkSysmemColorSpaceFUCHSIA sysmemColorSpaceIndex;
		    VkComponentMapping samplerYcbcrConversionComponents;
		    VkSamplerYcbcrModelConversion suggestedYcbcrModel;
		    VkSamplerYcbcrRange suggestedYcbcrRange;
		    VkChromaLocation suggestedXChromaOffset;
		    VkChromaLocation suggestedYChromaOffset;
		} VkBufferCollectionPropertiesFUCHSIA;

		typedef struct VkImageFormatConstraintsInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkImageCreateInfo imageCreateInfo;
		    VkFormatFeatureFlags requiredFormatFeatures;
		    VkImageFormatConstraintsFlagsFUCHSIA flags;
		    uint64_t sysmemPixelFormat;
		    uint32_t colorSpaceCount;
		    const VkSysmemColorSpaceFUCHSIA* pColorSpaces;
		} VkImageFormatConstraintsInfoFUCHSIA;

		typedef struct VkImageConstraintsInfoFUCHSIA
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t formatConstraintsCount;
		    const VkImageFormatConstraintsInfoFUCHSIA* pFormatConstraints;
		    VkBufferCollectionConstraintsInfoFUCHSIA bufferCollectionConstraints;
		    VkImageConstraintsInfoFlagsFUCHSIA flags;
		} VkImageConstraintsInfoFUCHSIA;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferCollectionFUCHSIA)(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferCollectionFUCHSIA* pCollection);
		typedef VkResult (VKAPI_PTR *PFN_vkSetBufferCollectionImageConstraintsFUCHSIA)(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA)(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo);
		typedef void (VKAPI_PTR *PFN_vkDestroyBufferCollectionFUCHSIA)(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetBufferCollectionPropertiesFUCHSIA)(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA* pProperties);

		#endif /*VK_USE_PLATFORM_FUCHSIA*/

		#ifdef VK_USE_PLATFORM_GGP
		#include <ggp_c/vulkan_types.h>

		#define VK_GGP_stream_descriptor_surface 1
		#define VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION 1
		#define VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME "VK_GGP_stream_descriptor_surface"

		typedef VkFlags VkStreamDescriptorSurfaceCreateFlagsGGP;
		typedef struct VkStreamDescriptorSurfaceCreateInfoGGP
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkStreamDescriptorSurfaceCreateFlagsGGP flags;
		    GgpStreamDescriptor streamDescriptor;
		} VkStreamDescriptorSurfaceCreateInfoGGP;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateStreamDescriptorSurfaceGGP)(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);


		#define VK_GGP_frame_token 1
		#define VK_GGP_FRAME_TOKEN_SPEC_VERSION 1
		#define VK_GGP_FRAME_TOKEN_EXTENSION_NAME "VK_GGP_frame_token"

		typedef struct VkPresentFrameTokenGGP
		{
		    VkStructureType sType;
		    const void* pNext;
		    GgpFrameToken frameToken;
		} VkPresentFrameTokenGGP;

		#endif /*VK_USE_PLATFORM_GGP*/

		#ifdef VK_USE_PLATFORM_SCI
		#include <nvscibuf.h>
		#include <nvscisync.h>

		#define VK_NV_external_memory_sci_buf 1
		#define VK_NV_EXTERNAL_MEMORY_SCI_BUF_SPEC_VERSION 2
		#define VK_NV_EXTERNAL_MEMORY_SCI_BUF_EXTENSION_NAME "VK_NV_external_memory_sci_buf"

		typedef struct VkExportMemorySciBufInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    NvSciBufAttrList pAttributes;
		} VkExportMemorySciBufInfoNV;

		typedef struct VkImportMemorySciBufInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		    NvSciBufObj handle;
		} VkImportMemorySciBufInfoNV;

		typedef struct VkMemoryGetSciBufInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkDeviceMemory memory;
		    VkExternalMemoryHandleTypeFlagBits handleType;
		} VkMemoryGetSciBufInfoNV;

		typedef struct VkMemorySciBufPropertiesNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t memoryTypeBits;
		} VkMemorySciBufPropertiesNV;

		typedef struct VkPhysicalDeviceExternalMemorySciBufFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 sciBufImport;
		    VkBool32 sciBufExport;
		} VkPhysicalDeviceExternalMemorySciBufFeaturesNV;

		typedef VkPhysicalDeviceExternalMemorySciBufFeaturesNV VkPhysicalDeviceExternalSciBufFeaturesNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetMemorySciBufNV)(VkDevice device, const VkMemoryGetSciBufInfoNV* pGetSciBufInfo, NvSciBufObj* pHandle);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV)(VkPhysicalDevice physicalDevice, VkExternalMemoryHandleTypeFlagBits handleType, NvSciBufObj handle, VkMemorySciBufPropertiesNV* pMemorySciBufProperties);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSciBufAttributesNV)(VkPhysicalDevice physicalDevice, NvSciBufAttrList pAttributes);


		#define VK_NV_external_sci_sync2 1
		#define VK_NV_EXTERNAL_SCI_SYNC_2_SPEC_VERSION 1
		#define VK_NV_EXTERNAL_SCI_SYNC_2_EXTENSION_NAME "VK_NV_external_sci_sync2"

		VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphoreSciSyncPoolNV)

		typedef enum
		{
		    VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV = 0,
		    VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV = 1,
		    VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV = 2,
		    VK_SCI_SYNC_CLIENT_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkSciSyncClientTypeNV;

		typedef enum
		{
		    VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV = 0,
		    VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV = 1,
		    VK_SCI_SYNC_PRIMITIVE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
		} VkSciSyncPrimitiveTypeNV;


		typedef struct VkPhysicalDeviceExternalSciSync2FeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 sciSyncFence;
		    VkBool32 sciSyncSemaphore2;
		    VkBool32 sciSyncImport;
		    VkBool32 sciSyncExport;
		} VkPhysicalDeviceExternalSciSync2FeaturesNV;

		typedef struct VkSemaphoreSciSyncPoolCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    NvSciSyncObj handle;
		} VkSemaphoreSciSyncPoolCreateInfoNV;

		typedef struct VkSemaphoreSciSyncCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphoreSciSyncPoolNV semaphorePool;
		    const NvSciSyncFence* pFence;
		} VkSemaphoreSciSyncCreateInfoNV;

		typedef struct VkExportFenceSciSyncInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    NvSciSyncAttrList pAttributes;
		} VkExportFenceSciSyncInfoNV;

		typedef struct VkImportFenceSciSyncInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFence fence;
		    VkExternalFenceHandleTypeFlagBits handleType;
		    void* handle;
		} VkImportFenceSciSyncInfoNV;

		typedef struct VkFenceGetSciSyncInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkFence fence;
		    VkExternalFenceHandleTypeFlagBits handleType;
		} VkFenceGetSciSyncInfoNV;

		typedef struct VkSciSyncAttributesInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSciSyncClientTypeNV clientType;
		    VkSciSyncPrimitiveTypeNV primitiveType;
		} VkSciSyncAttributesInfoNV;

		typedef struct VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    uint32_t semaphoreSciSyncPoolRequestCount;
		} VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphoreSciSyncPoolNV)(VkDevice device, const VkSemaphoreSciSyncPoolCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphoreSciSyncPoolNV* pSemaphorePool);
		typedef void (VKAPI_PTR *PFN_vkDestroySemaphoreSciSyncPoolNV)(VkDevice device, VkSemaphoreSciSyncPoolNV semaphorePool, const VkAllocationCallbacks* pAllocator);
		typedef VkResult (VKAPI_PTR *PFN_vkGetFenceSciSyncFenceNV)(VkDevice device, const VkFenceGetSciSyncInfoNV* pGetSciSyncHandleInfo, void* pHandle);
		typedef VkResult (VKAPI_PTR *PFN_vkGetFenceSciSyncObjNV)(VkDevice device, const VkFenceGetSciSyncInfoNV* pGetSciSyncHandleInfo, void* pHandle);
		typedef VkResult (VKAPI_PTR *PFN_vkImportFenceSciSyncFenceNV)(VkDevice device, const VkImportFenceSciSyncInfoNV* pImportFenceSciSyncInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkImportFenceSciSyncObjNV)(VkDevice device, const VkImportFenceSciSyncInfoNV* pImportFenceSciSyncInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSciSyncAttributesNV)(VkPhysicalDevice physicalDevice, const VkSciSyncAttributesInfoNV* pSciSyncAttributesInfo, NvSciSyncAttrList pAttributes);


		#define VK_NV_external_sci_sync 1
		#define VK_NV_EXTERNAL_SCI_SYNC_SPEC_VERSION 2
		#define VK_NV_EXTERNAL_SCI_SYNC_EXTENSION_NAME "VK_NV_external_sci_sync"

		typedef struct VkExportSemaphoreSciSyncInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    NvSciSyncAttrList pAttributes;
		} VkExportSemaphoreSciSyncInfoNV;

		typedef struct VkImportSemaphoreSciSyncInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		    void* handle;
		} VkImportSemaphoreSciSyncInfoNV;

		typedef struct VkSemaphoreGetSciSyncInfoNV
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkSemaphore semaphore;
		    VkExternalSemaphoreHandleTypeFlagBits handleType;
		} VkSemaphoreGetSciSyncInfoNV;

		typedef struct VkPhysicalDeviceExternalSciSyncFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 sciSyncFence;
		    VkBool32 sciSyncSemaphore;
		    VkBool32 sciSyncImport;
		    VkBool32 sciSyncExport;
		} VkPhysicalDeviceExternalSciSyncFeaturesNV;


		typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreSciSyncObjNV)(VkDevice device, const VkSemaphoreGetSciSyncInfoNV* pGetSciSyncInfo, void* pHandle);
		typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreSciSyncObjNV)(VkDevice device, const VkImportSemaphoreSciSyncInfoNV* pImportSemaphoreSciSyncInfo);

		#endif /*VK_USE_PLATFORM_SCI*/

		#ifdef VK_ENABLE_BETA_EXTENSIONS

		#define VK_AMDX_shader_enqueue 1
		#define VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION 1
		#define VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME "VK_AMDX_shader_enqueue"

		#define VK_SHADER_INDEX_UNUSED_AMDX (~0U)

		typedef struct VkPhysicalDeviceShaderEnqueueFeaturesAMDX
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 shaderEnqueue;
		} VkPhysicalDeviceShaderEnqueueFeaturesAMDX;

		typedef struct VkPhysicalDeviceShaderEnqueuePropertiesAMDX
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxExecutionGraphDepth;
		    uint32_t maxExecutionGraphShaderOutputNodes;
		    uint32_t maxExecutionGraphShaderPayloadSize;
		    uint32_t maxExecutionGraphShaderPayloadCount;
		    uint32_t executionGraphDispatchAddressAlignment;
		} VkPhysicalDeviceShaderEnqueuePropertiesAMDX;

		typedef struct VkExecutionGraphPipelineScratchSizeAMDX
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize size;
		} VkExecutionGraphPipelineScratchSizeAMDX;

		typedef struct VkExecutionGraphPipelineCreateInfoAMDX
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkPipelineCreateFlags flags;
		    uint32_t stageCount;
		    const VkPipelineShaderStageCreateInfo* pStages;
		    const VkPipelineLibraryCreateInfoKHR* pLibraryInfo;
		    VkPipelineLayout layout;
		    VkPipeline basePipelineHandle;
		    int32_t basePipelineIndex;
		} VkExecutionGraphPipelineCreateInfoAMDX;

		typedef union VkDeviceOrHostAddressConstAMDX
		{
		    VkDeviceAddress deviceAddress;
		    const void* hostAddress;
		} VkDeviceOrHostAddressConstAMDX;

		typedef struct VkDispatchGraphInfoAMDX
		{
		    uint32_t nodeIndex;
		    uint32_t payloadCount;
		    VkDeviceOrHostAddressConstAMDX payloads;
		    uint64_t payloadStride;
		} VkDispatchGraphInfoAMDX;

		typedef struct VkDispatchGraphCountInfoAMDX
		{
		    uint32_t count;
		    VkDeviceOrHostAddressConstAMDX infos;
		    uint64_t stride;
		} VkDispatchGraphCountInfoAMDX;

		typedef struct VkPipelineShaderStageNodeCreateInfoAMDX
		{
		    VkStructureType sType;
		    const void* pNext;
		    const char* pName;
		    uint32_t index;
		} VkPipelineShaderStageNodeCreateInfoAMDX;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateExecutionGraphPipelinesAMDX)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
		typedef VkResult (VKAPI_PTR *PFN_vkGetExecutionGraphPipelineScratchSizeAMDX)(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo);
		typedef VkResult (VKAPI_PTR *PFN_vkGetExecutionGraphPipelineNodeIndexAMDX)(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, uint32_t* pNodeIndex);
		typedef void (VKAPI_PTR *PFN_vkCmdInitializeGraphScratchMemoryAMDX)(VkCommandBuffer commandBuffer, VkDeviceAddress scratch);
		typedef void (VKAPI_PTR *PFN_vkCmdDispatchGraphAMDX)(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, const VkDispatchGraphCountInfoAMDX* pCountInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdDispatchGraphIndirectAMDX)(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, const VkDispatchGraphCountInfoAMDX* pCountInfo);
		typedef void (VKAPI_PTR *PFN_vkCmdDispatchGraphIndirectCountAMDX)(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceAddress countInfo);


		#define VK_KHR_portability_subset 1
		#define VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION 1
		#define VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME "VK_KHR_portability_subset"

		typedef struct VkPhysicalDevicePortabilitySubsetFeaturesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 constantAlphaColorBlendFactors;
		    VkBool32 events;
		    VkBool32 imageViewFormatReinterpretation;
		    VkBool32 imageViewFormatSwizzle;
		    VkBool32 imageView2DOn3DImage;
		    VkBool32 multisampleArrayImage;
		    VkBool32 mutableComparisonSamplers;
		    VkBool32 pointPolygons;
		    VkBool32 samplerMipLodBias;
		    VkBool32 separateStencilMaskRef;
		    VkBool32 shaderSampleRateInterpolationFunctions;
		    VkBool32 tessellationIsolines;
		    VkBool32 tessellationPointMode;
		    VkBool32 triangleFans;
		    VkBool32 vertexAttributeAccessBeyondStride;
		} VkPhysicalDevicePortabilitySubsetFeaturesKHR;

		typedef struct VkPhysicalDevicePortabilitySubsetPropertiesKHR
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t minVertexInputBindingStrideAlignment;
		} VkPhysicalDevicePortabilitySubsetPropertiesKHR;


		#define VK_NV_displacement_micromap 1
		#define VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION 2
		#define VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME "VK_NV_displacement_micromap"

		typedef enum
		{
		    VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = 1,
		    VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = 2,
		    VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = 3,
		    VK_DISPLACEMENT_MICROMAP_FORMAT_MAX_ENUM_NV = 0x7FFFFFFF
		} VkDisplacementMicromapFormatNV;


		typedef struct VkPhysicalDeviceDisplacementMicromapFeaturesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 displacementMicromap;
		} VkPhysicalDeviceDisplacementMicromapFeaturesNV;

		typedef struct VkPhysicalDeviceDisplacementMicromapPropertiesNV
		{
		    VkStructureType sType;
		    void* pNext;
		    uint32_t maxDisplacementMicromapSubdivisionLevel;
		} VkPhysicalDeviceDisplacementMicromapPropertiesNV;

		typedef struct VkAccelerationStructureTrianglesDisplacementMicromapNV
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormat displacementBiasAndScaleFormat;
		    VkFormat displacementVectorFormat;
		    VkDeviceOrHostAddressConstKHR displacementBiasAndScaleBuffer;
		    VkDeviceSize displacementBiasAndScaleStride;
		    VkDeviceOrHostAddressConstKHR displacementVectorBuffer;
		    VkDeviceSize displacementVectorStride;
		    VkDeviceOrHostAddressConstKHR displacedMicromapPrimitiveFlags;
		    VkDeviceSize displacedMicromapPrimitiveFlagsStride;
		    VkIndexType indexType;
		    VkDeviceOrHostAddressConstKHR indexBuffer;
		    VkDeviceSize indexStride;
		    uint32_t baseTriangle;
		    uint32_t usageCountsCount;
		    const VkMicromapUsageEXT* pUsageCounts;
		    const VkMicromapUsageEXT* const* ppUsageCounts;
		    VkMicromapEXT micromap;
		} VkAccelerationStructureTrianglesDisplacementMicromapNV;

		#endif /*VK_ENABLE_BETA_EXTENSIONS*/

		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		#include <screen/screen.h>

		#define VK_QNX_screen_surface 1
		#define VK_QNX_SCREEN_SURFACE_SPEC_VERSION 1
		#define VK_QNX_SCREEN_SURFACE_EXTENSION_NAME "VK_QNX_screen_surface"

		typedef VkFlags VkScreenSurfaceCreateFlagsQNX;
		typedef struct VkScreenSurfaceCreateInfoQNX
		{
		    VkStructureType sType;
		    const void* pNext;
		    VkScreenSurfaceCreateFlagsQNX flags;
		    struct _screen_context* context;
		    struct _screen_window* window;
		} VkScreenSurfaceCreateInfoQNX;


		typedef VkResult (VKAPI_PTR *PFN_vkCreateScreenSurfaceQNX)(VkInstance instance, const VkScreenSurfaceCreateInfoQNX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
		typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window* window);


		#define VK_QNX_external_memory_screen_buffer 1
		#define VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION 1
		#define VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME "VK_QNX_external_memory_screen_buffer"

		typedef struct VkScreenBufferPropertiesQNX
		{
		    VkStructureType sType;
		    void* pNext;
		    VkDeviceSize allocationSize;
		    uint32_t memoryTypeBits;
		} VkScreenBufferPropertiesQNX;

		typedef struct VkScreenBufferFormatPropertiesQNX
		{
		    VkStructureType sType;
		    void* pNext;
		    VkFormat format;
		    uint64_t externalFormat;
		    uint64_t screenUsage;
		    VkFormatFeatureFlags formatFeatures;
		    VkComponentMapping samplerYcbcrConversionComponents;
		    VkSamplerYcbcrModelConversion suggestedYcbcrModel;
		    VkSamplerYcbcrRange suggestedYcbcrRange;
		    VkChromaLocation suggestedXChromaOffset;
		    VkChromaLocation suggestedYChromaOffset;
		} VkScreenBufferFormatPropertiesQNX;

		typedef struct VkImportScreenBufferInfoQNX
		{
		    VkStructureType sType;
		    const void* pNext;
		    struct _screen_buffer* buffer;
		} VkImportScreenBufferInfoQNX;

		typedef struct VkExternalFormatQNX
		{
		    VkStructureType sType;
		    void* pNext;
		    uint64_t externalFormat;
		} VkExternalFormatQNX;

		typedef struct VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX
		{
		    VkStructureType sType;
		    void* pNext;
		    VkBool32 screenBufferImport;
		} VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX;


		typedef VkResult (VKAPI_PTR *PFN_vkGetScreenBufferPropertiesQNX)(VkDevice device, const struct _screen_buffer* buffer, VkScreenBufferPropertiesQNX* pProperties);

		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/



		#ifndef VKBIND_NO_GLOBAL_API
		extern PFN_vkCreateInstance vkCreateInstance;
		extern PFN_vkDestroyInstance vkDestroyInstance;
		extern PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices;
		extern PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures;
		extern PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties;
		extern PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties;
		extern PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
		extern PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties;
		extern PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
		extern PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
		extern PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;
		extern PFN_vkCreateDevice vkCreateDevice;
		extern PFN_vkDestroyDevice vkDestroyDevice;
		extern PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties;
		extern PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties;
		extern PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties;
		extern PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties;
		extern PFN_vkGetDeviceQueue vkGetDeviceQueue;
		extern PFN_vkQueueSubmit vkQueueSubmit;
		extern PFN_vkQueueWaitIdle vkQueueWaitIdle;
		extern PFN_vkDeviceWaitIdle vkDeviceWaitIdle;
		extern PFN_vkAllocateMemory vkAllocateMemory;
		extern PFN_vkFreeMemory vkFreeMemory;
		extern PFN_vkMapMemory vkMapMemory;
		extern PFN_vkUnmapMemory vkUnmapMemory;
		extern PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
		extern PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
		extern PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment;
		extern PFN_vkBindBufferMemory vkBindBufferMemory;
		extern PFN_vkBindImageMemory vkBindImageMemory;
		extern PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
		extern PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
		extern PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements;
		extern PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties;
		extern PFN_vkQueueBindSparse vkQueueBindSparse;
		extern PFN_vkCreateFence vkCreateFence;
		extern PFN_vkDestroyFence vkDestroyFence;
		extern PFN_vkResetFences vkResetFences;
		extern PFN_vkGetFenceStatus vkGetFenceStatus;
		extern PFN_vkWaitForFences vkWaitForFences;
		extern PFN_vkCreateSemaphore vkCreateSemaphore;
		extern PFN_vkDestroySemaphore vkDestroySemaphore;
		extern PFN_vkCreateEvent vkCreateEvent;
		extern PFN_vkDestroyEvent vkDestroyEvent;
		extern PFN_vkGetEventStatus vkGetEventStatus;
		extern PFN_vkSetEvent vkSetEvent;
		extern PFN_vkResetEvent vkResetEvent;
		extern PFN_vkCreateQueryPool vkCreateQueryPool;
		extern PFN_vkDestroyQueryPool vkDestroyQueryPool;
		extern PFN_vkGetQueryPoolResults vkGetQueryPoolResults;
		extern PFN_vkCreateBuffer vkCreateBuffer;
		extern PFN_vkDestroyBuffer vkDestroyBuffer;
		extern PFN_vkCreateBufferView vkCreateBufferView;
		extern PFN_vkDestroyBufferView vkDestroyBufferView;
		extern PFN_vkCreateImage vkCreateImage;
		extern PFN_vkDestroyImage vkDestroyImage;
		extern PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout;
		extern PFN_vkCreateImageView vkCreateImageView;
		extern PFN_vkDestroyImageView vkDestroyImageView;
		extern PFN_vkCreateShaderModule vkCreateShaderModule;
		extern PFN_vkDestroyShaderModule vkDestroyShaderModule;
		extern PFN_vkCreatePipelineCache vkCreatePipelineCache;
		extern PFN_vkDestroyPipelineCache vkDestroyPipelineCache;
		extern PFN_vkGetPipelineCacheData vkGetPipelineCacheData;
		extern PFN_vkMergePipelineCaches vkMergePipelineCaches;
		extern PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines;
		extern PFN_vkCreateComputePipelines vkCreateComputePipelines;
		extern PFN_vkDestroyPipeline vkDestroyPipeline;
		extern PFN_vkCreatePipelineLayout vkCreatePipelineLayout;
		extern PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout;
		extern PFN_vkCreateSampler vkCreateSampler;
		extern PFN_vkDestroySampler vkDestroySampler;
		extern PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout;
		extern PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout;
		extern PFN_vkCreateDescriptorPool vkCreateDescriptorPool;
		extern PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool;
		extern PFN_vkResetDescriptorPool vkResetDescriptorPool;
		extern PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets;
		extern PFN_vkFreeDescriptorSets vkFreeDescriptorSets;
		extern PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets;
		extern PFN_vkCreateFramebuffer vkCreateFramebuffer;
		extern PFN_vkDestroyFramebuffer vkDestroyFramebuffer;
		extern PFN_vkCreateRenderPass vkCreateRenderPass;
		extern PFN_vkDestroyRenderPass vkDestroyRenderPass;
		extern PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity;
		extern PFN_vkCreateCommandPool vkCreateCommandPool;
		extern PFN_vkDestroyCommandPool vkDestroyCommandPool;
		extern PFN_vkResetCommandPool vkResetCommandPool;
		extern PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers;
		extern PFN_vkFreeCommandBuffers vkFreeCommandBuffers;
		extern PFN_vkBeginCommandBuffer vkBeginCommandBuffer;
		extern PFN_vkEndCommandBuffer vkEndCommandBuffer;
		extern PFN_vkResetCommandBuffer vkResetCommandBuffer;
		extern PFN_vkCmdBindPipeline vkCmdBindPipeline;
		extern PFN_vkCmdSetViewport vkCmdSetViewport;
		extern PFN_vkCmdSetScissor vkCmdSetScissor;
		extern PFN_vkCmdSetLineWidth vkCmdSetLineWidth;
		extern PFN_vkCmdSetDepthBias vkCmdSetDepthBias;
		extern PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants;
		extern PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds;
		extern PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask;
		extern PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask;
		extern PFN_vkCmdSetStencilReference vkCmdSetStencilReference;
		extern PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets;
		extern PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer;
		extern PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers;
		extern PFN_vkCmdDraw vkCmdDraw;
		extern PFN_vkCmdDrawIndexed vkCmdDrawIndexed;
		extern PFN_vkCmdDrawIndirect vkCmdDrawIndirect;
		extern PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect;
		extern PFN_vkCmdDispatch vkCmdDispatch;
		extern PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect;
		extern PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
		extern PFN_vkCmdCopyImage vkCmdCopyImage;
		extern PFN_vkCmdBlitImage vkCmdBlitImage;
		extern PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage;
		extern PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer;
		extern PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer;
		extern PFN_vkCmdFillBuffer vkCmdFillBuffer;
		extern PFN_vkCmdClearColorImage vkCmdClearColorImage;
		extern PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage;
		extern PFN_vkCmdClearAttachments vkCmdClearAttachments;
		extern PFN_vkCmdResolveImage vkCmdResolveImage;
		extern PFN_vkCmdSetEvent vkCmdSetEvent;
		extern PFN_vkCmdResetEvent vkCmdResetEvent;
		extern PFN_vkCmdWaitEvents vkCmdWaitEvents;
		extern PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier;
		extern PFN_vkCmdBeginQuery vkCmdBeginQuery;
		extern PFN_vkCmdEndQuery vkCmdEndQuery;
		extern PFN_vkCmdResetQueryPool vkCmdResetQueryPool;
		extern PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp;
		extern PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults;
		extern PFN_vkCmdPushConstants vkCmdPushConstants;
		extern PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass;
		extern PFN_vkCmdNextSubpass vkCmdNextSubpass;
		extern PFN_vkCmdEndRenderPass vkCmdEndRenderPass;
		extern PFN_vkCmdExecuteCommands vkCmdExecuteCommands;
		extern PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersion;
		extern PFN_vkBindBufferMemory2 vkBindBufferMemory2;
		extern PFN_vkBindImageMemory2 vkBindImageMemory2;
		extern PFN_vkGetDeviceGroupPeerMemoryFeatures vkGetDeviceGroupPeerMemoryFeatures;
		extern PFN_vkCmdSetDeviceMask vkCmdSetDeviceMask;
		extern PFN_vkCmdDispatchBase vkCmdDispatchBase;
		extern PFN_vkEnumeratePhysicalDeviceGroups vkEnumeratePhysicalDeviceGroups;
		extern PFN_vkGetImageMemoryRequirements2 vkGetImageMemoryRequirements2;
		extern PFN_vkGetBufferMemoryRequirements2 vkGetBufferMemoryRequirements2;
		extern PFN_vkGetImageSparseMemoryRequirements2 vkGetImageSparseMemoryRequirements2;
		extern PFN_vkGetPhysicalDeviceFeatures2 vkGetPhysicalDeviceFeatures2;
		extern PFN_vkGetPhysicalDeviceProperties2 vkGetPhysicalDeviceProperties2;
		extern PFN_vkGetPhysicalDeviceFormatProperties2 vkGetPhysicalDeviceFormatProperties2;
		extern PFN_vkGetPhysicalDeviceImageFormatProperties2 vkGetPhysicalDeviceImageFormatProperties2;
		extern PFN_vkGetPhysicalDeviceQueueFamilyProperties2 vkGetPhysicalDeviceQueueFamilyProperties2;
		extern PFN_vkGetPhysicalDeviceMemoryProperties2 vkGetPhysicalDeviceMemoryProperties2;
		extern PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 vkGetPhysicalDeviceSparseImageFormatProperties2;
		extern PFN_vkTrimCommandPool vkTrimCommandPool;
		extern PFN_vkGetDeviceQueue2 vkGetDeviceQueue2;
		extern PFN_vkCreateSamplerYcbcrConversion vkCreateSamplerYcbcrConversion;
		extern PFN_vkDestroySamplerYcbcrConversion vkDestroySamplerYcbcrConversion;
		extern PFN_vkCreateDescriptorUpdateTemplate vkCreateDescriptorUpdateTemplate;
		extern PFN_vkDestroyDescriptorUpdateTemplate vkDestroyDescriptorUpdateTemplate;
		extern PFN_vkUpdateDescriptorSetWithTemplate vkUpdateDescriptorSetWithTemplate;
		extern PFN_vkGetPhysicalDeviceExternalBufferProperties vkGetPhysicalDeviceExternalBufferProperties;
		extern PFN_vkGetPhysicalDeviceExternalFenceProperties vkGetPhysicalDeviceExternalFenceProperties;
		extern PFN_vkGetPhysicalDeviceExternalSemaphoreProperties vkGetPhysicalDeviceExternalSemaphoreProperties;
		extern PFN_vkGetDescriptorSetLayoutSupport vkGetDescriptorSetLayoutSupport;
		extern PFN_vkCmdDrawIndirectCount vkCmdDrawIndirectCount;
		extern PFN_vkCmdDrawIndexedIndirectCount vkCmdDrawIndexedIndirectCount;
		extern PFN_vkCreateRenderPass2 vkCreateRenderPass2;
		extern PFN_vkCmdBeginRenderPass2 vkCmdBeginRenderPass2;
		extern PFN_vkCmdNextSubpass2 vkCmdNextSubpass2;
		extern PFN_vkCmdEndRenderPass2 vkCmdEndRenderPass2;
		extern PFN_vkResetQueryPool vkResetQueryPool;
		extern PFN_vkGetSemaphoreCounterValue vkGetSemaphoreCounterValue;
		extern PFN_vkWaitSemaphores vkWaitSemaphores;
		extern PFN_vkSignalSemaphore vkSignalSemaphore;
		extern PFN_vkGetBufferDeviceAddress vkGetBufferDeviceAddress;
		extern PFN_vkGetBufferOpaqueCaptureAddress vkGetBufferOpaqueCaptureAddress;
		extern PFN_vkGetDeviceMemoryOpaqueCaptureAddress vkGetDeviceMemoryOpaqueCaptureAddress;
		extern PFN_vkGetPhysicalDeviceToolProperties vkGetPhysicalDeviceToolProperties;
		extern PFN_vkCreatePrivateDataSlot vkCreatePrivateDataSlot;
		extern PFN_vkDestroyPrivateDataSlot vkDestroyPrivateDataSlot;
		extern PFN_vkSetPrivateData vkSetPrivateData;
		extern PFN_vkGetPrivateData vkGetPrivateData;
		extern PFN_vkCmdSetEvent2 vkCmdSetEvent2;
		extern PFN_vkCmdResetEvent2 vkCmdResetEvent2;
		extern PFN_vkCmdWaitEvents2 vkCmdWaitEvents2;
		extern PFN_vkCmdPipelineBarrier2 vkCmdPipelineBarrier2;
		extern PFN_vkCmdWriteTimestamp2 vkCmdWriteTimestamp2;
		extern PFN_vkQueueSubmit2 vkQueueSubmit2;
		extern PFN_vkCmdCopyBuffer2 vkCmdCopyBuffer2;
		extern PFN_vkCmdCopyImage2 vkCmdCopyImage2;
		extern PFN_vkCmdCopyBufferToImage2 vkCmdCopyBufferToImage2;
		extern PFN_vkCmdCopyImageToBuffer2 vkCmdCopyImageToBuffer2;
		extern PFN_vkCmdBlitImage2 vkCmdBlitImage2;
		extern PFN_vkCmdResolveImage2 vkCmdResolveImage2;
		extern PFN_vkCmdBeginRendering vkCmdBeginRendering;
		extern PFN_vkCmdEndRendering vkCmdEndRendering;
		extern PFN_vkCmdSetCullMode vkCmdSetCullMode;
		extern PFN_vkCmdSetFrontFace vkCmdSetFrontFace;
		extern PFN_vkCmdSetPrimitiveTopology vkCmdSetPrimitiveTopology;
		extern PFN_vkCmdSetViewportWithCount vkCmdSetViewportWithCount;
		extern PFN_vkCmdSetScissorWithCount vkCmdSetScissorWithCount;
		extern PFN_vkCmdBindVertexBuffers2 vkCmdBindVertexBuffers2;
		extern PFN_vkCmdSetDepthTestEnable vkCmdSetDepthTestEnable;
		extern PFN_vkCmdSetDepthWriteEnable vkCmdSetDepthWriteEnable;
		extern PFN_vkCmdSetDepthCompareOp vkCmdSetDepthCompareOp;
		extern PFN_vkCmdSetDepthBoundsTestEnable vkCmdSetDepthBoundsTestEnable;
		extern PFN_vkCmdSetStencilTestEnable vkCmdSetStencilTestEnable;
		extern PFN_vkCmdSetStencilOp vkCmdSetStencilOp;
		extern PFN_vkCmdSetRasterizerDiscardEnable vkCmdSetRasterizerDiscardEnable;
		extern PFN_vkCmdSetDepthBiasEnable vkCmdSetDepthBiasEnable;
		extern PFN_vkCmdSetPrimitiveRestartEnable vkCmdSetPrimitiveRestartEnable;
		extern PFN_vkGetDeviceBufferMemoryRequirements vkGetDeviceBufferMemoryRequirements;
		extern PFN_vkGetDeviceImageMemoryRequirements vkGetDeviceImageMemoryRequirements;
		extern PFN_vkGetDeviceImageSparseMemoryRequirements vkGetDeviceImageSparseMemoryRequirements;
		extern PFN_vkGetCommandPoolMemoryConsumption vkGetCommandPoolMemoryConsumption;
		extern PFN_vkGetFaultData vkGetFaultData;
		extern PFN_vkDestroySurfaceKHR vkDestroySurfaceKHR;
		extern PFN_vkGetPhysicalDeviceSurfaceSupportKHR vkGetPhysicalDeviceSurfaceSupportKHR;
		extern PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
		extern PFN_vkGetPhysicalDeviceSurfaceFormatsKHR vkGetPhysicalDeviceSurfaceFormatsKHR;
		extern PFN_vkGetPhysicalDeviceSurfacePresentModesKHR vkGetPhysicalDeviceSurfacePresentModesKHR;
		extern PFN_vkCreateSwapchainKHR vkCreateSwapchainKHR;
		extern PFN_vkDestroySwapchainKHR vkDestroySwapchainKHR;
		extern PFN_vkGetSwapchainImagesKHR vkGetSwapchainImagesKHR;
		extern PFN_vkAcquireNextImageKHR vkAcquireNextImageKHR;
		extern PFN_vkQueuePresentKHR vkQueuePresentKHR;
		extern PFN_vkGetDeviceGroupPresentCapabilitiesKHR vkGetDeviceGroupPresentCapabilitiesKHR;
		extern PFN_vkGetDeviceGroupSurfacePresentModesKHR vkGetDeviceGroupSurfacePresentModesKHR;
		extern PFN_vkGetPhysicalDevicePresentRectanglesKHR vkGetPhysicalDevicePresentRectanglesKHR;
		extern PFN_vkAcquireNextImage2KHR vkAcquireNextImage2KHR;
		extern PFN_vkGetPhysicalDeviceDisplayPropertiesKHR vkGetPhysicalDeviceDisplayPropertiesKHR;
		extern PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
		extern PFN_vkGetDisplayPlaneSupportedDisplaysKHR vkGetDisplayPlaneSupportedDisplaysKHR;
		extern PFN_vkGetDisplayModePropertiesKHR vkGetDisplayModePropertiesKHR;
		extern PFN_vkCreateDisplayModeKHR vkCreateDisplayModeKHR;
		extern PFN_vkGetDisplayPlaneCapabilitiesKHR vkGetDisplayPlaneCapabilitiesKHR;
		extern PFN_vkCreateDisplayPlaneSurfaceKHR vkCreateDisplayPlaneSurfaceKHR;
		extern PFN_vkCreateSharedSwapchainsKHR vkCreateSharedSwapchainsKHR;
		extern PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR vkGetPhysicalDeviceVideoCapabilitiesKHR;
		extern PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR vkGetPhysicalDeviceVideoFormatPropertiesKHR;
		extern PFN_vkCreateVideoSessionKHR vkCreateVideoSessionKHR;
		extern PFN_vkDestroyVideoSessionKHR vkDestroyVideoSessionKHR;
		extern PFN_vkGetVideoSessionMemoryRequirementsKHR vkGetVideoSessionMemoryRequirementsKHR;
		extern PFN_vkBindVideoSessionMemoryKHR vkBindVideoSessionMemoryKHR;
		extern PFN_vkCreateVideoSessionParametersKHR vkCreateVideoSessionParametersKHR;
		extern PFN_vkUpdateVideoSessionParametersKHR vkUpdateVideoSessionParametersKHR;
		extern PFN_vkDestroyVideoSessionParametersKHR vkDestroyVideoSessionParametersKHR;
		extern PFN_vkCmdBeginVideoCodingKHR vkCmdBeginVideoCodingKHR;
		extern PFN_vkCmdEndVideoCodingKHR vkCmdEndVideoCodingKHR;
		extern PFN_vkCmdControlVideoCodingKHR vkCmdControlVideoCodingKHR;
		extern PFN_vkCmdDecodeVideoKHR vkCmdDecodeVideoKHR;
		extern PFN_vkCmdBindTransformFeedbackBuffersEXT vkCmdBindTransformFeedbackBuffersEXT;
		extern PFN_vkCmdBeginTransformFeedbackEXT vkCmdBeginTransformFeedbackEXT;
		extern PFN_vkCmdEndTransformFeedbackEXT vkCmdEndTransformFeedbackEXT;
		extern PFN_vkCmdBeginQueryIndexedEXT vkCmdBeginQueryIndexedEXT;
		extern PFN_vkCmdEndQueryIndexedEXT vkCmdEndQueryIndexedEXT;
		extern PFN_vkCmdDrawIndirectByteCountEXT vkCmdDrawIndirectByteCountEXT;
		extern PFN_vkCreateCuModuleNVX vkCreateCuModuleNVX;
		extern PFN_vkCreateCuFunctionNVX vkCreateCuFunctionNVX;
		extern PFN_vkDestroyCuModuleNVX vkDestroyCuModuleNVX;
		extern PFN_vkDestroyCuFunctionNVX vkDestroyCuFunctionNVX;
		extern PFN_vkCmdCuLaunchKernelNVX vkCmdCuLaunchKernelNVX;
		extern PFN_vkGetImageViewHandleNVX vkGetImageViewHandleNVX;
		extern PFN_vkGetImageViewAddressNVX vkGetImageViewAddressNVX;
		extern PFN_vkGetShaderInfoAMD vkGetShaderInfoAMD;
		extern PFN_vkCmdBeginRenderingKHR vkCmdBeginRenderingKHR;
		extern PFN_vkCmdEndRenderingKHR vkCmdEndRenderingKHR;
		extern PFN_vkGetPhysicalDeviceFeatures2KHR vkGetPhysicalDeviceFeatures2KHR;
		extern PFN_vkGetPhysicalDeviceProperties2KHR vkGetPhysicalDeviceProperties2KHR;
		extern PFN_vkGetPhysicalDeviceFormatProperties2KHR vkGetPhysicalDeviceFormatProperties2KHR;
		extern PFN_vkGetPhysicalDeviceImageFormatProperties2KHR vkGetPhysicalDeviceImageFormatProperties2KHR;
		extern PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR vkGetPhysicalDeviceQueueFamilyProperties2KHR;
		extern PFN_vkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR;
		extern PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
		extern PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR vkGetDeviceGroupPeerMemoryFeaturesKHR;
		extern PFN_vkCmdSetDeviceMaskKHR vkCmdSetDeviceMaskKHR;
		extern PFN_vkCmdDispatchBaseKHR vkCmdDispatchBaseKHR;
		extern PFN_vkTrimCommandPoolKHR vkTrimCommandPoolKHR;
		extern PFN_vkEnumeratePhysicalDeviceGroupsKHR vkEnumeratePhysicalDeviceGroupsKHR;
		extern PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR vkGetPhysicalDeviceExternalBufferPropertiesKHR;
		extern PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
		extern PFN_vkGetMemoryFdKHR vkGetMemoryFdKHR;
		extern PFN_vkGetMemoryFdPropertiesKHR vkGetMemoryFdPropertiesKHR;
		extern PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
		extern PFN_vkImportSemaphoreFdKHR vkImportSemaphoreFdKHR;
		extern PFN_vkGetSemaphoreFdKHR vkGetSemaphoreFdKHR;
		extern PFN_vkCmdPushDescriptorSetKHR vkCmdPushDescriptorSetKHR;
		extern PFN_vkCmdPushDescriptorSetWithTemplateKHR vkCmdPushDescriptorSetWithTemplateKHR;
		extern PFN_vkCmdBeginConditionalRenderingEXT vkCmdBeginConditionalRenderingEXT;
		extern PFN_vkCmdEndConditionalRenderingEXT vkCmdEndConditionalRenderingEXT;
		extern PFN_vkCreateDescriptorUpdateTemplateKHR vkCreateDescriptorUpdateTemplateKHR;
		extern PFN_vkDestroyDescriptorUpdateTemplateKHR vkDestroyDescriptorUpdateTemplateKHR;
		extern PFN_vkUpdateDescriptorSetWithTemplateKHR vkUpdateDescriptorSetWithTemplateKHR;
		extern PFN_vkCmdSetViewportWScalingNV vkCmdSetViewportWScalingNV;
		extern PFN_vkReleaseDisplayEXT vkReleaseDisplayEXT;
		extern PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT vkGetPhysicalDeviceSurfaceCapabilities2EXT;
		extern PFN_vkDisplayPowerControlEXT vkDisplayPowerControlEXT;
		extern PFN_vkRegisterDeviceEventEXT vkRegisterDeviceEventEXT;
		extern PFN_vkRegisterDisplayEventEXT vkRegisterDisplayEventEXT;
		extern PFN_vkGetSwapchainCounterEXT vkGetSwapchainCounterEXT;
		extern PFN_vkGetRefreshCycleDurationGOOGLE vkGetRefreshCycleDurationGOOGLE;
		extern PFN_vkGetPastPresentationTimingGOOGLE vkGetPastPresentationTimingGOOGLE;
		extern PFN_vkCmdSetDiscardRectangleEXT vkCmdSetDiscardRectangleEXT;
		extern PFN_vkCmdSetDiscardRectangleEnableEXT vkCmdSetDiscardRectangleEnableEXT;
		extern PFN_vkCmdSetDiscardRectangleModeEXT vkCmdSetDiscardRectangleModeEXT;
		extern PFN_vkSetHdrMetadataEXT vkSetHdrMetadataEXT;
		extern PFN_vkCreateRenderPass2KHR vkCreateRenderPass2KHR;
		extern PFN_vkCmdBeginRenderPass2KHR vkCmdBeginRenderPass2KHR;
		extern PFN_vkCmdNextSubpass2KHR vkCmdNextSubpass2KHR;
		extern PFN_vkCmdEndRenderPass2KHR vkCmdEndRenderPass2KHR;
		extern PFN_vkGetSwapchainStatusKHR vkGetSwapchainStatusKHR;
		extern PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR vkGetPhysicalDeviceExternalFencePropertiesKHR;
		extern PFN_vkImportFenceFdKHR vkImportFenceFdKHR;
		extern PFN_vkGetFenceFdKHR vkGetFenceFdKHR;
		extern PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
		extern PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
		extern PFN_vkAcquireProfilingLockKHR vkAcquireProfilingLockKHR;
		extern PFN_vkReleaseProfilingLockKHR vkReleaseProfilingLockKHR;
		extern PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR vkGetPhysicalDeviceSurfaceCapabilities2KHR;
		extern PFN_vkGetPhysicalDeviceSurfaceFormats2KHR vkGetPhysicalDeviceSurfaceFormats2KHR;
		extern PFN_vkGetPhysicalDeviceDisplayProperties2KHR vkGetPhysicalDeviceDisplayProperties2KHR;
		extern PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
		extern PFN_vkGetDisplayModeProperties2KHR vkGetDisplayModeProperties2KHR;
		extern PFN_vkGetDisplayPlaneCapabilities2KHR vkGetDisplayPlaneCapabilities2KHR;
		extern PFN_vkSetDebugUtilsObjectNameEXT vkSetDebugUtilsObjectNameEXT;
		extern PFN_vkSetDebugUtilsObjectTagEXT vkSetDebugUtilsObjectTagEXT;
		extern PFN_vkQueueBeginDebugUtilsLabelEXT vkQueueBeginDebugUtilsLabelEXT;
		extern PFN_vkQueueEndDebugUtilsLabelEXT vkQueueEndDebugUtilsLabelEXT;
		extern PFN_vkQueueInsertDebugUtilsLabelEXT vkQueueInsertDebugUtilsLabelEXT;
		extern PFN_vkCmdBeginDebugUtilsLabelEXT vkCmdBeginDebugUtilsLabelEXT;
		extern PFN_vkCmdEndDebugUtilsLabelEXT vkCmdEndDebugUtilsLabelEXT;
		extern PFN_vkCmdInsertDebugUtilsLabelEXT vkCmdInsertDebugUtilsLabelEXT;
		extern PFN_vkCreateDebugUtilsMessengerEXT vkCreateDebugUtilsMessengerEXT;
		extern PFN_vkDestroyDebugUtilsMessengerEXT vkDestroyDebugUtilsMessengerEXT;
		extern PFN_vkSubmitDebugUtilsMessageEXT vkSubmitDebugUtilsMessageEXT;
		extern PFN_vkDebugMarkerSetObjectTagEXT vkDebugMarkerSetObjectTagEXT;
		extern PFN_vkDebugMarkerSetObjectNameEXT vkDebugMarkerSetObjectNameEXT;
		extern PFN_vkCmdDebugMarkerBeginEXT vkCmdDebugMarkerBeginEXT;
		extern PFN_vkCmdDebugMarkerEndEXT vkCmdDebugMarkerEndEXT;
		extern PFN_vkCmdDebugMarkerInsertEXT vkCmdDebugMarkerInsertEXT;
		extern PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT;
		extern PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT;
		extern PFN_vkDebugReportMessageEXT vkDebugReportMessageEXT;
		extern PFN_vkCmdSetSampleLocationsEXT vkCmdSetSampleLocationsEXT;
		extern PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT vkGetPhysicalDeviceMultisamplePropertiesEXT;
		extern PFN_vkGetImageMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR;
		extern PFN_vkGetBufferMemoryRequirements2KHR vkGetBufferMemoryRequirements2KHR;
		extern PFN_vkGetImageSparseMemoryRequirements2KHR vkGetImageSparseMemoryRequirements2KHR;
		extern PFN_vkCreateAccelerationStructureKHR vkCreateAccelerationStructureKHR;
		extern PFN_vkDestroyAccelerationStructureKHR vkDestroyAccelerationStructureKHR;
		extern PFN_vkCmdBuildAccelerationStructuresKHR vkCmdBuildAccelerationStructuresKHR;
		extern PFN_vkCmdBuildAccelerationStructuresIndirectKHR vkCmdBuildAccelerationStructuresIndirectKHR;
		extern PFN_vkBuildAccelerationStructuresKHR vkBuildAccelerationStructuresKHR;
		extern PFN_vkCopyAccelerationStructureKHR vkCopyAccelerationStructureKHR;
		extern PFN_vkCopyAccelerationStructureToMemoryKHR vkCopyAccelerationStructureToMemoryKHR;
		extern PFN_vkCopyMemoryToAccelerationStructureKHR vkCopyMemoryToAccelerationStructureKHR;
		extern PFN_vkWriteAccelerationStructuresPropertiesKHR vkWriteAccelerationStructuresPropertiesKHR;
		extern PFN_vkCmdCopyAccelerationStructureKHR vkCmdCopyAccelerationStructureKHR;
		extern PFN_vkCmdCopyAccelerationStructureToMemoryKHR vkCmdCopyAccelerationStructureToMemoryKHR;
		extern PFN_vkCmdCopyMemoryToAccelerationStructureKHR vkCmdCopyMemoryToAccelerationStructureKHR;
		extern PFN_vkGetAccelerationStructureDeviceAddressKHR vkGetAccelerationStructureDeviceAddressKHR;
		extern PFN_vkCmdWriteAccelerationStructuresPropertiesKHR vkCmdWriteAccelerationStructuresPropertiesKHR;
		extern PFN_vkGetDeviceAccelerationStructureCompatibilityKHR vkGetDeviceAccelerationStructureCompatibilityKHR;
		extern PFN_vkGetAccelerationStructureBuildSizesKHR vkGetAccelerationStructureBuildSizesKHR;
		extern PFN_vkCmdTraceRaysKHR vkCmdTraceRaysKHR;
		extern PFN_vkCreateRayTracingPipelinesKHR vkCreateRayTracingPipelinesKHR;
		extern PFN_vkGetRayTracingShaderGroupHandlesKHR vkGetRayTracingShaderGroupHandlesKHR;
		extern PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
		extern PFN_vkCmdTraceRaysIndirectKHR vkCmdTraceRaysIndirectKHR;
		extern PFN_vkGetRayTracingShaderGroupStackSizeKHR vkGetRayTracingShaderGroupStackSizeKHR;
		extern PFN_vkCmdSetRayTracingPipelineStackSizeKHR vkCmdSetRayTracingPipelineStackSizeKHR;
		extern PFN_vkCreateSamplerYcbcrConversionKHR vkCreateSamplerYcbcrConversionKHR;
		extern PFN_vkDestroySamplerYcbcrConversionKHR vkDestroySamplerYcbcrConversionKHR;
		extern PFN_vkBindBufferMemory2KHR vkBindBufferMemory2KHR;
		extern PFN_vkBindImageMemory2KHR vkBindImageMemory2KHR;
		extern PFN_vkGetImageDrmFormatModifierPropertiesEXT vkGetImageDrmFormatModifierPropertiesEXT;
		extern PFN_vkCreateValidationCacheEXT vkCreateValidationCacheEXT;
		extern PFN_vkDestroyValidationCacheEXT vkDestroyValidationCacheEXT;
		extern PFN_vkMergeValidationCachesEXT vkMergeValidationCachesEXT;
		extern PFN_vkGetValidationCacheDataEXT vkGetValidationCacheDataEXT;
		extern PFN_vkCmdBindShadingRateImageNV vkCmdBindShadingRateImageNV;
		extern PFN_vkCmdSetViewportShadingRatePaletteNV vkCmdSetViewportShadingRatePaletteNV;
		extern PFN_vkCmdSetCoarseSampleOrderNV vkCmdSetCoarseSampleOrderNV;
		extern PFN_vkCreateAccelerationStructureNV vkCreateAccelerationStructureNV;
		extern PFN_vkDestroyAccelerationStructureNV vkDestroyAccelerationStructureNV;
		extern PFN_vkGetAccelerationStructureMemoryRequirementsNV vkGetAccelerationStructureMemoryRequirementsNV;
		extern PFN_vkBindAccelerationStructureMemoryNV vkBindAccelerationStructureMemoryNV;
		extern PFN_vkCmdBuildAccelerationStructureNV vkCmdBuildAccelerationStructureNV;
		extern PFN_vkCmdCopyAccelerationStructureNV vkCmdCopyAccelerationStructureNV;
		extern PFN_vkCmdTraceRaysNV vkCmdTraceRaysNV;
		extern PFN_vkCreateRayTracingPipelinesNV vkCreateRayTracingPipelinesNV;
		extern PFN_vkGetRayTracingShaderGroupHandlesNV vkGetRayTracingShaderGroupHandlesNV;
		extern PFN_vkGetAccelerationStructureHandleNV vkGetAccelerationStructureHandleNV;
		extern PFN_vkCmdWriteAccelerationStructuresPropertiesNV vkCmdWriteAccelerationStructuresPropertiesNV;
		extern PFN_vkCompileDeferredNV vkCompileDeferredNV;
		extern PFN_vkGetDescriptorSetLayoutSupportKHR vkGetDescriptorSetLayoutSupportKHR;
		extern PFN_vkCmdDrawIndirectCountKHR vkCmdDrawIndirectCountKHR;
		extern PFN_vkCmdDrawIndexedIndirectCountKHR vkCmdDrawIndexedIndirectCountKHR;
		extern PFN_vkCmdDrawIndirectCountAMD vkCmdDrawIndirectCountAMD;
		extern PFN_vkCmdDrawIndexedIndirectCountAMD vkCmdDrawIndexedIndirectCountAMD;
		extern PFN_vkGetMemoryHostPointerPropertiesEXT vkGetMemoryHostPointerPropertiesEXT;
		extern PFN_vkCmdWriteBufferMarkerAMD vkCmdWriteBufferMarkerAMD;
		extern PFN_vkCmdDrawMeshTasksNV vkCmdDrawMeshTasksNV;
		extern PFN_vkCmdDrawMeshTasksIndirectNV vkCmdDrawMeshTasksIndirectNV;
		extern PFN_vkCmdDrawMeshTasksIndirectCountNV vkCmdDrawMeshTasksIndirectCountNV;
		extern PFN_vkCmdSetExclusiveScissorEnableNV vkCmdSetExclusiveScissorEnableNV;
		extern PFN_vkCmdSetExclusiveScissorNV vkCmdSetExclusiveScissorNV;
		extern PFN_vkCmdSetCheckpointNV vkCmdSetCheckpointNV;
		extern PFN_vkGetQueueCheckpointDataNV vkGetQueueCheckpointDataNV;
		extern PFN_vkGetSemaphoreCounterValueKHR vkGetSemaphoreCounterValueKHR;
		extern PFN_vkWaitSemaphoresKHR vkWaitSemaphoresKHR;
		extern PFN_vkSignalSemaphoreKHR vkSignalSemaphoreKHR;
		extern PFN_vkInitializePerformanceApiINTEL vkInitializePerformanceApiINTEL;
		extern PFN_vkUninitializePerformanceApiINTEL vkUninitializePerformanceApiINTEL;
		extern PFN_vkCmdSetPerformanceMarkerINTEL vkCmdSetPerformanceMarkerINTEL;
		extern PFN_vkCmdSetPerformanceStreamMarkerINTEL vkCmdSetPerformanceStreamMarkerINTEL;
		extern PFN_vkCmdSetPerformanceOverrideINTEL vkCmdSetPerformanceOverrideINTEL;
		extern PFN_vkAcquirePerformanceConfigurationINTEL vkAcquirePerformanceConfigurationINTEL;
		extern PFN_vkReleasePerformanceConfigurationINTEL vkReleasePerformanceConfigurationINTEL;
		extern PFN_vkQueueSetPerformanceConfigurationINTEL vkQueueSetPerformanceConfigurationINTEL;
		extern PFN_vkGetPerformanceParameterINTEL vkGetPerformanceParameterINTEL;
		extern PFN_vkSetLocalDimmingAMD vkSetLocalDimmingAMD;
		extern PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR vkGetPhysicalDeviceFragmentShadingRatesKHR;
		extern PFN_vkCmdSetFragmentShadingRateKHR vkCmdSetFragmentShadingRateKHR;
		extern PFN_vkCmdSetRenderingAttachmentLocationsKHR vkCmdSetRenderingAttachmentLocationsKHR;
		extern PFN_vkCmdSetRenderingInputAttachmentIndicesKHR vkCmdSetRenderingInputAttachmentIndicesKHR;
		extern PFN_vkGetPhysicalDeviceToolPropertiesEXT vkGetPhysicalDeviceToolPropertiesEXT;
		extern PFN_vkWaitForPresentKHR vkWaitForPresentKHR;
		extern PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV vkGetPhysicalDeviceCooperativeMatrixPropertiesNV;
		extern PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
		extern PFN_vkCreateHeadlessSurfaceEXT vkCreateHeadlessSurfaceEXT;
		extern PFN_vkGetBufferDeviceAddressKHR vkGetBufferDeviceAddressKHR;
		extern PFN_vkGetBufferOpaqueCaptureAddressKHR vkGetBufferOpaqueCaptureAddressKHR;
		extern PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR vkGetDeviceMemoryOpaqueCaptureAddressKHR;
		extern PFN_vkGetBufferDeviceAddressEXT vkGetBufferDeviceAddressEXT;
		extern PFN_vkResetQueryPoolEXT vkResetQueryPoolEXT;
		extern PFN_vkCmdSetCullModeEXT vkCmdSetCullModeEXT;
		extern PFN_vkCmdSetFrontFaceEXT vkCmdSetFrontFaceEXT;
		extern PFN_vkCmdSetPrimitiveTopologyEXT vkCmdSetPrimitiveTopologyEXT;
		extern PFN_vkCmdSetViewportWithCountEXT vkCmdSetViewportWithCountEXT;
		extern PFN_vkCmdSetScissorWithCountEXT vkCmdSetScissorWithCountEXT;
		extern PFN_vkCmdBindVertexBuffers2EXT vkCmdBindVertexBuffers2EXT;
		extern PFN_vkCmdSetDepthTestEnableEXT vkCmdSetDepthTestEnableEXT;
		extern PFN_vkCmdSetDepthWriteEnableEXT vkCmdSetDepthWriteEnableEXT;
		extern PFN_vkCmdSetDepthCompareOpEXT vkCmdSetDepthCompareOpEXT;
		extern PFN_vkCmdSetDepthBoundsTestEnableEXT vkCmdSetDepthBoundsTestEnableEXT;
		extern PFN_vkCmdSetStencilTestEnableEXT vkCmdSetStencilTestEnableEXT;
		extern PFN_vkCmdSetStencilOpEXT vkCmdSetStencilOpEXT;
		extern PFN_vkCreateDeferredOperationKHR vkCreateDeferredOperationKHR;
		extern PFN_vkDestroyDeferredOperationKHR vkDestroyDeferredOperationKHR;
		extern PFN_vkGetDeferredOperationMaxConcurrencyKHR vkGetDeferredOperationMaxConcurrencyKHR;
		extern PFN_vkGetDeferredOperationResultKHR vkGetDeferredOperationResultKHR;
		extern PFN_vkDeferredOperationJoinKHR vkDeferredOperationJoinKHR;
		extern PFN_vkGetPipelineExecutablePropertiesKHR vkGetPipelineExecutablePropertiesKHR;
		extern PFN_vkGetPipelineExecutableStatisticsKHR vkGetPipelineExecutableStatisticsKHR;
		extern PFN_vkGetPipelineExecutableInternalRepresentationsKHR vkGetPipelineExecutableInternalRepresentationsKHR;
		extern PFN_vkCopyMemoryToImageEXT vkCopyMemoryToImageEXT;
		extern PFN_vkCopyImageToMemoryEXT vkCopyImageToMemoryEXT;
		extern PFN_vkCopyImageToImageEXT vkCopyImageToImageEXT;
		extern PFN_vkTransitionImageLayoutEXT vkTransitionImageLayoutEXT;
		extern PFN_vkGetImageSubresourceLayout2EXT vkGetImageSubresourceLayout2EXT;
		extern PFN_vkMapMemory2KHR vkMapMemory2KHR;
		extern PFN_vkUnmapMemory2KHR vkUnmapMemory2KHR;
		extern PFN_vkReleaseSwapchainImagesEXT vkReleaseSwapchainImagesEXT;
		extern PFN_vkGetGeneratedCommandsMemoryRequirementsNV vkGetGeneratedCommandsMemoryRequirementsNV;
		extern PFN_vkCmdPreprocessGeneratedCommandsNV vkCmdPreprocessGeneratedCommandsNV;
		extern PFN_vkCmdExecuteGeneratedCommandsNV vkCmdExecuteGeneratedCommandsNV;
		extern PFN_vkCmdBindPipelineShaderGroupNV vkCmdBindPipelineShaderGroupNV;
		extern PFN_vkCreateIndirectCommandsLayoutNV vkCreateIndirectCommandsLayoutNV;
		extern PFN_vkDestroyIndirectCommandsLayoutNV vkDestroyIndirectCommandsLayoutNV;
		extern PFN_vkCmdSetDepthBias2EXT vkCmdSetDepthBias2EXT;
		extern PFN_vkAcquireDrmDisplayEXT vkAcquireDrmDisplayEXT;
		extern PFN_vkGetDrmDisplayEXT vkGetDrmDisplayEXT;
		extern PFN_vkCreatePrivateDataSlotEXT vkCreatePrivateDataSlotEXT;
		extern PFN_vkDestroyPrivateDataSlotEXT vkDestroyPrivateDataSlotEXT;
		extern PFN_vkSetPrivateDataEXT vkSetPrivateDataEXT;
		extern PFN_vkGetPrivateDataEXT vkGetPrivateDataEXT;
		extern PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
		extern PFN_vkGetEncodedVideoSessionParametersKHR vkGetEncodedVideoSessionParametersKHR;
		extern PFN_vkCmdEncodeVideoKHR vkCmdEncodeVideoKHR;
		extern PFN_vkCreateCudaModuleNV vkCreateCudaModuleNV;
		extern PFN_vkGetCudaModuleCacheNV vkGetCudaModuleCacheNV;
		extern PFN_vkCreateCudaFunctionNV vkCreateCudaFunctionNV;
		extern PFN_vkDestroyCudaModuleNV vkDestroyCudaModuleNV;
		extern PFN_vkDestroyCudaFunctionNV vkDestroyCudaFunctionNV;
		extern PFN_vkCmdCudaLaunchKernelNV vkCmdCudaLaunchKernelNV;
		extern PFN_vkCmdRefreshObjectsKHR vkCmdRefreshObjectsKHR;
		extern PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR vkGetPhysicalDeviceRefreshableObjectTypesKHR;
		extern PFN_vkCmdSetEvent2KHR vkCmdSetEvent2KHR;
		extern PFN_vkCmdResetEvent2KHR vkCmdResetEvent2KHR;
		extern PFN_vkCmdWaitEvents2KHR vkCmdWaitEvents2KHR;
		extern PFN_vkCmdPipelineBarrier2KHR vkCmdPipelineBarrier2KHR;
		extern PFN_vkCmdWriteTimestamp2KHR vkCmdWriteTimestamp2KHR;
		extern PFN_vkQueueSubmit2KHR vkQueueSubmit2KHR;
		extern PFN_vkCmdWriteBufferMarker2AMD vkCmdWriteBufferMarker2AMD;
		extern PFN_vkGetQueueCheckpointData2NV vkGetQueueCheckpointData2NV;
		extern PFN_vkGetDescriptorSetLayoutSizeEXT vkGetDescriptorSetLayoutSizeEXT;
		extern PFN_vkGetDescriptorSetLayoutBindingOffsetEXT vkGetDescriptorSetLayoutBindingOffsetEXT;
		extern PFN_vkGetDescriptorEXT vkGetDescriptorEXT;
		extern PFN_vkCmdBindDescriptorBuffersEXT vkCmdBindDescriptorBuffersEXT;
		extern PFN_vkCmdSetDescriptorBufferOffsetsEXT vkCmdSetDescriptorBufferOffsetsEXT;
		extern PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT vkCmdBindDescriptorBufferEmbeddedSamplersEXT;
		extern PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT vkGetBufferOpaqueCaptureDescriptorDataEXT;
		extern PFN_vkGetImageOpaqueCaptureDescriptorDataEXT vkGetImageOpaqueCaptureDescriptorDataEXT;
		extern PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT vkGetImageViewOpaqueCaptureDescriptorDataEXT;
		extern PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT vkGetSamplerOpaqueCaptureDescriptorDataEXT;
		extern PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
		extern PFN_vkCmdSetFragmentShadingRateEnumNV vkCmdSetFragmentShadingRateEnumNV;
		extern PFN_vkCmdDrawMeshTasksEXT vkCmdDrawMeshTasksEXT;
		extern PFN_vkCmdDrawMeshTasksIndirectEXT vkCmdDrawMeshTasksIndirectEXT;
		extern PFN_vkCmdDrawMeshTasksIndirectCountEXT vkCmdDrawMeshTasksIndirectCountEXT;
		extern PFN_vkCmdCopyBuffer2KHR vkCmdCopyBuffer2KHR;
		extern PFN_vkCmdCopyImage2KHR vkCmdCopyImage2KHR;
		extern PFN_vkCmdCopyBufferToImage2KHR vkCmdCopyBufferToImage2KHR;
		extern PFN_vkCmdCopyImageToBuffer2KHR vkCmdCopyImageToBuffer2KHR;
		extern PFN_vkCmdBlitImage2KHR vkCmdBlitImage2KHR;
		extern PFN_vkCmdResolveImage2KHR vkCmdResolveImage2KHR;
		extern PFN_vkGetDeviceFaultInfoEXT vkGetDeviceFaultInfoEXT;
		extern PFN_vkCmdSetVertexInputEXT vkCmdSetVertexInputEXT;
		extern PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
		extern PFN_vkCmdSubpassShadingHUAWEI vkCmdSubpassShadingHUAWEI;
		extern PFN_vkCmdBindInvocationMaskHUAWEI vkCmdBindInvocationMaskHUAWEI;
		extern PFN_vkGetMemoryRemoteAddressNV vkGetMemoryRemoteAddressNV;
		extern PFN_vkGetPipelinePropertiesEXT vkGetPipelinePropertiesEXT;
		extern PFN_vkCmdSetPatchControlPointsEXT vkCmdSetPatchControlPointsEXT;
		extern PFN_vkCmdSetRasterizerDiscardEnableEXT vkCmdSetRasterizerDiscardEnableEXT;
		extern PFN_vkCmdSetDepthBiasEnableEXT vkCmdSetDepthBiasEnableEXT;
		extern PFN_vkCmdSetLogicOpEXT vkCmdSetLogicOpEXT;
		extern PFN_vkCmdSetPrimitiveRestartEnableEXT vkCmdSetPrimitiveRestartEnableEXT;
		extern PFN_vkCmdSetColorWriteEnableEXT vkCmdSetColorWriteEnableEXT;
		extern PFN_vkCmdTraceRaysIndirect2KHR vkCmdTraceRaysIndirect2KHR;
		extern PFN_vkCmdDrawMultiEXT vkCmdDrawMultiEXT;
		extern PFN_vkCmdDrawMultiIndexedEXT vkCmdDrawMultiIndexedEXT;
		extern PFN_vkCreateMicromapEXT vkCreateMicromapEXT;
		extern PFN_vkDestroyMicromapEXT vkDestroyMicromapEXT;
		extern PFN_vkCmdBuildMicromapsEXT vkCmdBuildMicromapsEXT;
		extern PFN_vkBuildMicromapsEXT vkBuildMicromapsEXT;
		extern PFN_vkCopyMicromapEXT vkCopyMicromapEXT;
		extern PFN_vkCopyMicromapToMemoryEXT vkCopyMicromapToMemoryEXT;
		extern PFN_vkCopyMemoryToMicromapEXT vkCopyMemoryToMicromapEXT;
		extern PFN_vkWriteMicromapsPropertiesEXT vkWriteMicromapsPropertiesEXT;
		extern PFN_vkCmdCopyMicromapEXT vkCmdCopyMicromapEXT;
		extern PFN_vkCmdCopyMicromapToMemoryEXT vkCmdCopyMicromapToMemoryEXT;
		extern PFN_vkCmdCopyMemoryToMicromapEXT vkCmdCopyMemoryToMicromapEXT;
		extern PFN_vkCmdWriteMicromapsPropertiesEXT vkCmdWriteMicromapsPropertiesEXT;
		extern PFN_vkGetDeviceMicromapCompatibilityEXT vkGetDeviceMicromapCompatibilityEXT;
		extern PFN_vkGetMicromapBuildSizesEXT vkGetMicromapBuildSizesEXT;
		extern PFN_vkCmdDrawClusterHUAWEI vkCmdDrawClusterHUAWEI;
		extern PFN_vkCmdDrawClusterIndirectHUAWEI vkCmdDrawClusterIndirectHUAWEI;
		extern PFN_vkSetDeviceMemoryPriorityEXT vkSetDeviceMemoryPriorityEXT;
		extern PFN_vkGetDeviceBufferMemoryRequirementsKHR vkGetDeviceBufferMemoryRequirementsKHR;
		extern PFN_vkGetDeviceImageMemoryRequirementsKHR vkGetDeviceImageMemoryRequirementsKHR;
		extern PFN_vkGetDeviceImageSparseMemoryRequirementsKHR vkGetDeviceImageSparseMemoryRequirementsKHR;
		extern PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE vkGetDescriptorSetLayoutHostMappingInfoVALVE;
		extern PFN_vkGetDescriptorSetHostMappingVALVE vkGetDescriptorSetHostMappingVALVE;
		extern PFN_vkCmdCopyMemoryIndirectNV vkCmdCopyMemoryIndirectNV;
		extern PFN_vkCmdCopyMemoryToImageIndirectNV vkCmdCopyMemoryToImageIndirectNV;
		extern PFN_vkCmdDecompressMemoryNV vkCmdDecompressMemoryNV;
		extern PFN_vkCmdDecompressMemoryIndirectCountNV vkCmdDecompressMemoryIndirectCountNV;
		extern PFN_vkGetPipelineIndirectMemoryRequirementsNV vkGetPipelineIndirectMemoryRequirementsNV;
		extern PFN_vkCmdUpdatePipelineIndirectBufferNV vkCmdUpdatePipelineIndirectBufferNV;
		extern PFN_vkGetPipelineIndirectDeviceAddressNV vkGetPipelineIndirectDeviceAddressNV;
		extern PFN_vkCmdSetDepthClampEnableEXT vkCmdSetDepthClampEnableEXT;
		extern PFN_vkCmdSetPolygonModeEXT vkCmdSetPolygonModeEXT;
		extern PFN_vkCmdSetRasterizationSamplesEXT vkCmdSetRasterizationSamplesEXT;
		extern PFN_vkCmdSetSampleMaskEXT vkCmdSetSampleMaskEXT;
		extern PFN_vkCmdSetAlphaToCoverageEnableEXT vkCmdSetAlphaToCoverageEnableEXT;
		extern PFN_vkCmdSetAlphaToOneEnableEXT vkCmdSetAlphaToOneEnableEXT;
		extern PFN_vkCmdSetLogicOpEnableEXT vkCmdSetLogicOpEnableEXT;
		extern PFN_vkCmdSetColorBlendEnableEXT vkCmdSetColorBlendEnableEXT;
		extern PFN_vkCmdSetColorBlendEquationEXT vkCmdSetColorBlendEquationEXT;
		extern PFN_vkCmdSetColorWriteMaskEXT vkCmdSetColorWriteMaskEXT;
		extern PFN_vkCmdSetTessellationDomainOriginEXT vkCmdSetTessellationDomainOriginEXT;
		extern PFN_vkCmdSetRasterizationStreamEXT vkCmdSetRasterizationStreamEXT;
		extern PFN_vkCmdSetConservativeRasterizationModeEXT vkCmdSetConservativeRasterizationModeEXT;
		extern PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT vkCmdSetExtraPrimitiveOverestimationSizeEXT;
		extern PFN_vkCmdSetDepthClipEnableEXT vkCmdSetDepthClipEnableEXT;
		extern PFN_vkCmdSetSampleLocationsEnableEXT vkCmdSetSampleLocationsEnableEXT;
		extern PFN_vkCmdSetColorBlendAdvancedEXT vkCmdSetColorBlendAdvancedEXT;
		extern PFN_vkCmdSetProvokingVertexModeEXT vkCmdSetProvokingVertexModeEXT;
		extern PFN_vkCmdSetLineRasterizationModeEXT vkCmdSetLineRasterizationModeEXT;
		extern PFN_vkCmdSetLineStippleEnableEXT vkCmdSetLineStippleEnableEXT;
		extern PFN_vkCmdSetDepthClipNegativeOneToOneEXT vkCmdSetDepthClipNegativeOneToOneEXT;
		extern PFN_vkCmdSetViewportWScalingEnableNV vkCmdSetViewportWScalingEnableNV;
		extern PFN_vkCmdSetViewportSwizzleNV vkCmdSetViewportSwizzleNV;
		extern PFN_vkCmdSetCoverageToColorEnableNV vkCmdSetCoverageToColorEnableNV;
		extern PFN_vkCmdSetCoverageToColorLocationNV vkCmdSetCoverageToColorLocationNV;
		extern PFN_vkCmdSetCoverageModulationModeNV vkCmdSetCoverageModulationModeNV;
		extern PFN_vkCmdSetCoverageModulationTableEnableNV vkCmdSetCoverageModulationTableEnableNV;
		extern PFN_vkCmdSetCoverageModulationTableNV vkCmdSetCoverageModulationTableNV;
		extern PFN_vkCmdSetShadingRateImageEnableNV vkCmdSetShadingRateImageEnableNV;
		extern PFN_vkCmdSetRepresentativeFragmentTestEnableNV vkCmdSetRepresentativeFragmentTestEnableNV;
		extern PFN_vkCmdSetCoverageReductionModeNV vkCmdSetCoverageReductionModeNV;
		extern PFN_vkGetShaderModuleIdentifierEXT vkGetShaderModuleIdentifierEXT;
		extern PFN_vkGetShaderModuleCreateInfoIdentifierEXT vkGetShaderModuleCreateInfoIdentifierEXT;
		extern PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV vkGetPhysicalDeviceOpticalFlowImageFormatsNV;
		extern PFN_vkCreateOpticalFlowSessionNV vkCreateOpticalFlowSessionNV;
		extern PFN_vkDestroyOpticalFlowSessionNV vkDestroyOpticalFlowSessionNV;
		extern PFN_vkBindOpticalFlowSessionImageNV vkBindOpticalFlowSessionImageNV;
		extern PFN_vkCmdOpticalFlowExecuteNV vkCmdOpticalFlowExecuteNV;
		extern PFN_vkCmdBindIndexBuffer2KHR vkCmdBindIndexBuffer2KHR;
		extern PFN_vkGetRenderingAreaGranularityKHR vkGetRenderingAreaGranularityKHR;
		extern PFN_vkGetDeviceImageSubresourceLayoutKHR vkGetDeviceImageSubresourceLayoutKHR;
		extern PFN_vkGetImageSubresourceLayout2KHR vkGetImageSubresourceLayout2KHR;
		extern PFN_vkCreateShadersEXT vkCreateShadersEXT;
		extern PFN_vkDestroyShaderEXT vkDestroyShaderEXT;
		extern PFN_vkGetShaderBinaryDataEXT vkGetShaderBinaryDataEXT;
		extern PFN_vkCmdBindShadersEXT vkCmdBindShadersEXT;
		extern PFN_vkGetFramebufferTilePropertiesQCOM vkGetFramebufferTilePropertiesQCOM;
		extern PFN_vkGetDynamicRenderingTilePropertiesQCOM vkGetDynamicRenderingTilePropertiesQCOM;
		extern PFN_vkSetLatencySleepModeNV vkSetLatencySleepModeNV;
		extern PFN_vkLatencySleepNV vkLatencySleepNV;
		extern PFN_vkSetLatencyMarkerNV vkSetLatencyMarkerNV;
		extern PFN_vkGetLatencyTimingsNV vkGetLatencyTimingsNV;
		extern PFN_vkQueueNotifyOutOfBandNV vkQueueNotifyOutOfBandNV;
		extern PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR;
		extern PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT vkCmdSetAttachmentFeedbackLoopEnableEXT;
		extern PFN_vkCmdSetLineStippleKHR vkCmdSetLineStippleKHR;
		extern PFN_vkCmdSetLineStippleEXT vkCmdSetLineStippleEXT;
		extern PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
		extern PFN_vkGetCalibratedTimestampsKHR vkGetCalibratedTimestampsKHR;
		extern PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT vkGetPhysicalDeviceCalibrateableTimeDomainsEXT;
		extern PFN_vkGetCalibratedTimestampsEXT vkGetCalibratedTimestampsEXT;
		extern PFN_vkCmdBindDescriptorSets2KHR vkCmdBindDescriptorSets2KHR;
		extern PFN_vkCmdPushConstants2KHR vkCmdPushConstants2KHR;
		extern PFN_vkCmdPushDescriptorSet2KHR vkCmdPushDescriptorSet2KHR;
		extern PFN_vkCmdPushDescriptorSetWithTemplate2KHR vkCmdPushDescriptorSetWithTemplate2KHR;
		extern PFN_vkCmdSetDescriptorBufferOffsets2EXT vkCmdSetDescriptorBufferOffsets2EXT;
		extern PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT vkCmdBindDescriptorBufferEmbeddedSamplers2EXT;
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		extern PFN_vkCreateXlibSurfaceKHR vkCreateXlibSurfaceKHR;
		extern PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR vkGetPhysicalDeviceXlibPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		extern PFN_vkAcquireXlibDisplayEXT vkAcquireXlibDisplayEXT;
		extern PFN_vkGetRandROutputDisplayEXT vkGetRandROutputDisplayEXT;
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		extern PFN_vkCreateXcbSurfaceKHR vkCreateXcbSurfaceKHR;
		extern PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR vkGetPhysicalDeviceXcbPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		extern PFN_vkCreateWaylandSurfaceKHR vkCreateWaylandSurfaceKHR;
		extern PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR vkGetPhysicalDeviceWaylandPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		extern PFN_vkCreateDirectFBSurfaceEXT vkCreateDirectFBSurfaceEXT;
		extern PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		extern PFN_vkCreateAndroidSurfaceKHR vkCreateAndroidSurfaceKHR;
		extern PFN_vkGetAndroidHardwareBufferPropertiesANDROID vkGetAndroidHardwareBufferPropertiesANDROID;
		extern PFN_vkGetMemoryAndroidHardwareBufferANDROID vkGetMemoryAndroidHardwareBufferANDROID;
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		extern PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR;
		extern PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR vkGetPhysicalDeviceWin32PresentationSupportKHR;
		extern PFN_vkGetMemoryWin32HandleKHR vkGetMemoryWin32HandleKHR;
		extern PFN_vkGetMemoryWin32HandlePropertiesKHR vkGetMemoryWin32HandlePropertiesKHR;
		extern PFN_vkGetMemoryWin32HandleNV vkGetMemoryWin32HandleNV;
		extern PFN_vkImportSemaphoreWin32HandleKHR vkImportSemaphoreWin32HandleKHR;
		extern PFN_vkGetSemaphoreWin32HandleKHR vkGetSemaphoreWin32HandleKHR;
		extern PFN_vkImportFenceWin32HandleKHR vkImportFenceWin32HandleKHR;
		extern PFN_vkGetFenceWin32HandleKHR vkGetFenceWin32HandleKHR;
		extern PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT vkGetPhysicalDeviceSurfacePresentModes2EXT;
		extern PFN_vkAcquireFullScreenExclusiveModeEXT vkAcquireFullScreenExclusiveModeEXT;
		extern PFN_vkReleaseFullScreenExclusiveModeEXT vkReleaseFullScreenExclusiveModeEXT;
		extern PFN_vkGetDeviceGroupSurfacePresentModes2EXT vkGetDeviceGroupSurfacePresentModes2EXT;
		extern PFN_vkAcquireWinrtDisplayNV vkAcquireWinrtDisplayNV;
		extern PFN_vkGetWinrtDisplayNV vkGetWinrtDisplayNV;
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		extern PFN_vkCreateViSurfaceNN vkCreateViSurfaceNN;
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		extern PFN_vkCreateIOSSurfaceMVK vkCreateIOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		extern PFN_vkCreateMacOSSurfaceMVK vkCreateMacOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		extern PFN_vkCreateMetalSurfaceEXT vkCreateMetalSurfaceEXT;
		extern PFN_vkExportMetalObjectsEXT vkExportMetalObjectsEXT;
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		extern PFN_vkCreateImagePipeSurfaceFUCHSIA vkCreateImagePipeSurfaceFUCHSIA;
		extern PFN_vkGetMemoryZirconHandleFUCHSIA vkGetMemoryZirconHandleFUCHSIA;
		extern PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA vkGetMemoryZirconHandlePropertiesFUCHSIA;
		extern PFN_vkImportSemaphoreZirconHandleFUCHSIA vkImportSemaphoreZirconHandleFUCHSIA;
		extern PFN_vkGetSemaphoreZirconHandleFUCHSIA vkGetSemaphoreZirconHandleFUCHSIA;
		extern PFN_vkCreateBufferCollectionFUCHSIA vkCreateBufferCollectionFUCHSIA;
		extern PFN_vkSetBufferCollectionImageConstraintsFUCHSIA vkSetBufferCollectionImageConstraintsFUCHSIA;
		extern PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA vkSetBufferCollectionBufferConstraintsFUCHSIA;
		extern PFN_vkDestroyBufferCollectionFUCHSIA vkDestroyBufferCollectionFUCHSIA;
		extern PFN_vkGetBufferCollectionPropertiesFUCHSIA vkGetBufferCollectionPropertiesFUCHSIA;
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		extern PFN_vkCreateStreamDescriptorSurfaceGGP vkCreateStreamDescriptorSurfaceGGP;
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		extern PFN_vkGetMemorySciBufNV vkGetMemorySciBufNV;
		extern PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV;
		extern PFN_vkGetPhysicalDeviceSciBufAttributesNV vkGetPhysicalDeviceSciBufAttributesNV;
		extern PFN_vkCreateSemaphoreSciSyncPoolNV vkCreateSemaphoreSciSyncPoolNV;
		extern PFN_vkDestroySemaphoreSciSyncPoolNV vkDestroySemaphoreSciSyncPoolNV;
		extern PFN_vkGetFenceSciSyncFenceNV vkGetFenceSciSyncFenceNV;
		extern PFN_vkGetFenceSciSyncObjNV vkGetFenceSciSyncObjNV;
		extern PFN_vkImportFenceSciSyncFenceNV vkImportFenceSciSyncFenceNV;
		extern PFN_vkImportFenceSciSyncObjNV vkImportFenceSciSyncObjNV;
		extern PFN_vkGetPhysicalDeviceSciSyncAttributesNV vkGetPhysicalDeviceSciSyncAttributesNV;
		extern PFN_vkGetSemaphoreSciSyncObjNV vkGetSemaphoreSciSyncObjNV;
		extern PFN_vkImportSemaphoreSciSyncObjNV vkImportSemaphoreSciSyncObjNV;
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		extern PFN_vkCreateExecutionGraphPipelinesAMDX vkCreateExecutionGraphPipelinesAMDX;
		extern PFN_vkGetExecutionGraphPipelineScratchSizeAMDX vkGetExecutionGraphPipelineScratchSizeAMDX;
		extern PFN_vkGetExecutionGraphPipelineNodeIndexAMDX vkGetExecutionGraphPipelineNodeIndexAMDX;
		extern PFN_vkCmdInitializeGraphScratchMemoryAMDX vkCmdInitializeGraphScratchMemoryAMDX;
		extern PFN_vkCmdDispatchGraphAMDX vkCmdDispatchGraphAMDX;
		extern PFN_vkCmdDispatchGraphIndirectAMDX vkCmdDispatchGraphIndirectAMDX;
		extern PFN_vkCmdDispatchGraphIndirectCountAMDX vkCmdDispatchGraphIndirectCountAMDX;
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		extern PFN_vkCreateScreenSurfaceQNX vkCreateScreenSurfaceQNX;
		extern PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX vkGetPhysicalDeviceScreenPresentationSupportQNX;
		extern PFN_vkGetScreenBufferPropertiesQNX vkGetScreenBufferPropertiesQNX;
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/
		#endif /*VKBIND_NO_GLOBAL_API*/

		typedef struct
		{
		    PFN_vkCreateInstance vkCreateInstance;
		    PFN_vkDestroyInstance vkDestroyInstance;
		    PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices;
		    PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures;
		    PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties;
		    PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties;
		    PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
		    PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties;
		    PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
		    PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
		    PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;
		    PFN_vkCreateDevice vkCreateDevice;
		    PFN_vkDestroyDevice vkDestroyDevice;
		    PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties;
		    PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties;
		    PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties;
		    PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties;
		    PFN_vkGetDeviceQueue vkGetDeviceQueue;
		    PFN_vkQueueSubmit vkQueueSubmit;
		    PFN_vkQueueWaitIdle vkQueueWaitIdle;
		    PFN_vkDeviceWaitIdle vkDeviceWaitIdle;
		    PFN_vkAllocateMemory vkAllocateMemory;
		    PFN_vkFreeMemory vkFreeMemory;
		    PFN_vkMapMemory vkMapMemory;
		    PFN_vkUnmapMemory vkUnmapMemory;
		    PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
		    PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
		    PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment;
		    PFN_vkBindBufferMemory vkBindBufferMemory;
		    PFN_vkBindImageMemory vkBindImageMemory;
		    PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
		    PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
		    PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements;
		    PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties;
		    PFN_vkQueueBindSparse vkQueueBindSparse;
		    PFN_vkCreateFence vkCreateFence;
		    PFN_vkDestroyFence vkDestroyFence;
		    PFN_vkResetFences vkResetFences;
		    PFN_vkGetFenceStatus vkGetFenceStatus;
		    PFN_vkWaitForFences vkWaitForFences;
		    PFN_vkCreateSemaphore vkCreateSemaphore;
		    PFN_vkDestroySemaphore vkDestroySemaphore;
		    PFN_vkCreateEvent vkCreateEvent;
		    PFN_vkDestroyEvent vkDestroyEvent;
		    PFN_vkGetEventStatus vkGetEventStatus;
		    PFN_vkSetEvent vkSetEvent;
		    PFN_vkResetEvent vkResetEvent;
		    PFN_vkCreateQueryPool vkCreateQueryPool;
		    PFN_vkDestroyQueryPool vkDestroyQueryPool;
		    PFN_vkGetQueryPoolResults vkGetQueryPoolResults;
		    PFN_vkCreateBuffer vkCreateBuffer;
		    PFN_vkDestroyBuffer vkDestroyBuffer;
		    PFN_vkCreateBufferView vkCreateBufferView;
		    PFN_vkDestroyBufferView vkDestroyBufferView;
		    PFN_vkCreateImage vkCreateImage;
		    PFN_vkDestroyImage vkDestroyImage;
		    PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout;
		    PFN_vkCreateImageView vkCreateImageView;
		    PFN_vkDestroyImageView vkDestroyImageView;
		    PFN_vkCreateShaderModule vkCreateShaderModule;
		    PFN_vkDestroyShaderModule vkDestroyShaderModule;
		    PFN_vkCreatePipelineCache vkCreatePipelineCache;
		    PFN_vkDestroyPipelineCache vkDestroyPipelineCache;
		    PFN_vkGetPipelineCacheData vkGetPipelineCacheData;
		    PFN_vkMergePipelineCaches vkMergePipelineCaches;
		    PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines;
		    PFN_vkCreateComputePipelines vkCreateComputePipelines;
		    PFN_vkDestroyPipeline vkDestroyPipeline;
		    PFN_vkCreatePipelineLayout vkCreatePipelineLayout;
		    PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout;
		    PFN_vkCreateSampler vkCreateSampler;
		    PFN_vkDestroySampler vkDestroySampler;
		    PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout;
		    PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout;
		    PFN_vkCreateDescriptorPool vkCreateDescriptorPool;
		    PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool;
		    PFN_vkResetDescriptorPool vkResetDescriptorPool;
		    PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets;
		    PFN_vkFreeDescriptorSets vkFreeDescriptorSets;
		    PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets;
		    PFN_vkCreateFramebuffer vkCreateFramebuffer;
		    PFN_vkDestroyFramebuffer vkDestroyFramebuffer;
		    PFN_vkCreateRenderPass vkCreateRenderPass;
		    PFN_vkDestroyRenderPass vkDestroyRenderPass;
		    PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity;
		    PFN_vkCreateCommandPool vkCreateCommandPool;
		    PFN_vkDestroyCommandPool vkDestroyCommandPool;
		    PFN_vkResetCommandPool vkResetCommandPool;
		    PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers;
		    PFN_vkFreeCommandBuffers vkFreeCommandBuffers;
		    PFN_vkBeginCommandBuffer vkBeginCommandBuffer;
		    PFN_vkEndCommandBuffer vkEndCommandBuffer;
		    PFN_vkResetCommandBuffer vkResetCommandBuffer;
		    PFN_vkCmdBindPipeline vkCmdBindPipeline;
		    PFN_vkCmdSetViewport vkCmdSetViewport;
		    PFN_vkCmdSetScissor vkCmdSetScissor;
		    PFN_vkCmdSetLineWidth vkCmdSetLineWidth;
		    PFN_vkCmdSetDepthBias vkCmdSetDepthBias;
		    PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants;
		    PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds;
		    PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask;
		    PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask;
		    PFN_vkCmdSetStencilReference vkCmdSetStencilReference;
		    PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets;
		    PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer;
		    PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers;
		    PFN_vkCmdDraw vkCmdDraw;
		    PFN_vkCmdDrawIndexed vkCmdDrawIndexed;
		    PFN_vkCmdDrawIndirect vkCmdDrawIndirect;
		    PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect;
		    PFN_vkCmdDispatch vkCmdDispatch;
		    PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect;
		    PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
		    PFN_vkCmdCopyImage vkCmdCopyImage;
		    PFN_vkCmdBlitImage vkCmdBlitImage;
		    PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage;
		    PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer;
		    PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer;
		    PFN_vkCmdFillBuffer vkCmdFillBuffer;
		    PFN_vkCmdClearColorImage vkCmdClearColorImage;
		    PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage;
		    PFN_vkCmdClearAttachments vkCmdClearAttachments;
		    PFN_vkCmdResolveImage vkCmdResolveImage;
		    PFN_vkCmdSetEvent vkCmdSetEvent;
		    PFN_vkCmdResetEvent vkCmdResetEvent;
		    PFN_vkCmdWaitEvents vkCmdWaitEvents;
		    PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier;
		    PFN_vkCmdBeginQuery vkCmdBeginQuery;
		    PFN_vkCmdEndQuery vkCmdEndQuery;
		    PFN_vkCmdResetQueryPool vkCmdResetQueryPool;
		    PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp;
		    PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults;
		    PFN_vkCmdPushConstants vkCmdPushConstants;
		    PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass;
		    PFN_vkCmdNextSubpass vkCmdNextSubpass;
		    PFN_vkCmdEndRenderPass vkCmdEndRenderPass;
		    PFN_vkCmdExecuteCommands vkCmdExecuteCommands;
		    PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersion;
		    PFN_vkBindBufferMemory2 vkBindBufferMemory2;
		    PFN_vkBindImageMemory2 vkBindImageMemory2;
		    PFN_vkGetDeviceGroupPeerMemoryFeatures vkGetDeviceGroupPeerMemoryFeatures;
		    PFN_vkCmdSetDeviceMask vkCmdSetDeviceMask;
		    PFN_vkCmdDispatchBase vkCmdDispatchBase;
		    PFN_vkEnumeratePhysicalDeviceGroups vkEnumeratePhysicalDeviceGroups;
		    PFN_vkGetImageMemoryRequirements2 vkGetImageMemoryRequirements2;
		    PFN_vkGetBufferMemoryRequirements2 vkGetBufferMemoryRequirements2;
		    PFN_vkGetImageSparseMemoryRequirements2 vkGetImageSparseMemoryRequirements2;
		    PFN_vkGetPhysicalDeviceFeatures2 vkGetPhysicalDeviceFeatures2;
		    PFN_vkGetPhysicalDeviceProperties2 vkGetPhysicalDeviceProperties2;
		    PFN_vkGetPhysicalDeviceFormatProperties2 vkGetPhysicalDeviceFormatProperties2;
		    PFN_vkGetPhysicalDeviceImageFormatProperties2 vkGetPhysicalDeviceImageFormatProperties2;
		    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 vkGetPhysicalDeviceQueueFamilyProperties2;
		    PFN_vkGetPhysicalDeviceMemoryProperties2 vkGetPhysicalDeviceMemoryProperties2;
		    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 vkGetPhysicalDeviceSparseImageFormatProperties2;
		    PFN_vkTrimCommandPool vkTrimCommandPool;
		    PFN_vkGetDeviceQueue2 vkGetDeviceQueue2;
		    PFN_vkCreateSamplerYcbcrConversion vkCreateSamplerYcbcrConversion;
		    PFN_vkDestroySamplerYcbcrConversion vkDestroySamplerYcbcrConversion;
		    PFN_vkCreateDescriptorUpdateTemplate vkCreateDescriptorUpdateTemplate;
		    PFN_vkDestroyDescriptorUpdateTemplate vkDestroyDescriptorUpdateTemplate;
		    PFN_vkUpdateDescriptorSetWithTemplate vkUpdateDescriptorSetWithTemplate;
		    PFN_vkGetPhysicalDeviceExternalBufferProperties vkGetPhysicalDeviceExternalBufferProperties;
		    PFN_vkGetPhysicalDeviceExternalFenceProperties vkGetPhysicalDeviceExternalFenceProperties;
		    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties vkGetPhysicalDeviceExternalSemaphoreProperties;
		    PFN_vkGetDescriptorSetLayoutSupport vkGetDescriptorSetLayoutSupport;
		    PFN_vkCmdDrawIndirectCount vkCmdDrawIndirectCount;
		    PFN_vkCmdDrawIndexedIndirectCount vkCmdDrawIndexedIndirectCount;
		    PFN_vkCreateRenderPass2 vkCreateRenderPass2;
		    PFN_vkCmdBeginRenderPass2 vkCmdBeginRenderPass2;
		    PFN_vkCmdNextSubpass2 vkCmdNextSubpass2;
		    PFN_vkCmdEndRenderPass2 vkCmdEndRenderPass2;
		    PFN_vkResetQueryPool vkResetQueryPool;
		    PFN_vkGetSemaphoreCounterValue vkGetSemaphoreCounterValue;
		    PFN_vkWaitSemaphores vkWaitSemaphores;
		    PFN_vkSignalSemaphore vkSignalSemaphore;
		    PFN_vkGetBufferDeviceAddress vkGetBufferDeviceAddress;
		    PFN_vkGetBufferOpaqueCaptureAddress vkGetBufferOpaqueCaptureAddress;
		    PFN_vkGetDeviceMemoryOpaqueCaptureAddress vkGetDeviceMemoryOpaqueCaptureAddress;
		    PFN_vkGetPhysicalDeviceToolProperties vkGetPhysicalDeviceToolProperties;
		    PFN_vkCreatePrivateDataSlot vkCreatePrivateDataSlot;
		    PFN_vkDestroyPrivateDataSlot vkDestroyPrivateDataSlot;
		    PFN_vkSetPrivateData vkSetPrivateData;
		    PFN_vkGetPrivateData vkGetPrivateData;
		    PFN_vkCmdSetEvent2 vkCmdSetEvent2;
		    PFN_vkCmdResetEvent2 vkCmdResetEvent2;
		    PFN_vkCmdWaitEvents2 vkCmdWaitEvents2;
		    PFN_vkCmdPipelineBarrier2 vkCmdPipelineBarrier2;
		    PFN_vkCmdWriteTimestamp2 vkCmdWriteTimestamp2;
		    PFN_vkQueueSubmit2 vkQueueSubmit2;
		    PFN_vkCmdCopyBuffer2 vkCmdCopyBuffer2;
		    PFN_vkCmdCopyImage2 vkCmdCopyImage2;
		    PFN_vkCmdCopyBufferToImage2 vkCmdCopyBufferToImage2;
		    PFN_vkCmdCopyImageToBuffer2 vkCmdCopyImageToBuffer2;
		    PFN_vkCmdBlitImage2 vkCmdBlitImage2;
		    PFN_vkCmdResolveImage2 vkCmdResolveImage2;
		    PFN_vkCmdBeginRendering vkCmdBeginRendering;
		    PFN_vkCmdEndRendering vkCmdEndRendering;
		    PFN_vkCmdSetCullMode vkCmdSetCullMode;
		    PFN_vkCmdSetFrontFace vkCmdSetFrontFace;
		    PFN_vkCmdSetPrimitiveTopology vkCmdSetPrimitiveTopology;
		    PFN_vkCmdSetViewportWithCount vkCmdSetViewportWithCount;
		    PFN_vkCmdSetScissorWithCount vkCmdSetScissorWithCount;
		    PFN_vkCmdBindVertexBuffers2 vkCmdBindVertexBuffers2;
		    PFN_vkCmdSetDepthTestEnable vkCmdSetDepthTestEnable;
		    PFN_vkCmdSetDepthWriteEnable vkCmdSetDepthWriteEnable;
		    PFN_vkCmdSetDepthCompareOp vkCmdSetDepthCompareOp;
		    PFN_vkCmdSetDepthBoundsTestEnable vkCmdSetDepthBoundsTestEnable;
		    PFN_vkCmdSetStencilTestEnable vkCmdSetStencilTestEnable;
		    PFN_vkCmdSetStencilOp vkCmdSetStencilOp;
		    PFN_vkCmdSetRasterizerDiscardEnable vkCmdSetRasterizerDiscardEnable;
		    PFN_vkCmdSetDepthBiasEnable vkCmdSetDepthBiasEnable;
		    PFN_vkCmdSetPrimitiveRestartEnable vkCmdSetPrimitiveRestartEnable;
		    PFN_vkGetDeviceBufferMemoryRequirements vkGetDeviceBufferMemoryRequirements;
		    PFN_vkGetDeviceImageMemoryRequirements vkGetDeviceImageMemoryRequirements;
		    PFN_vkGetDeviceImageSparseMemoryRequirements vkGetDeviceImageSparseMemoryRequirements;
		    PFN_vkGetCommandPoolMemoryConsumption vkGetCommandPoolMemoryConsumption;
		    PFN_vkGetFaultData vkGetFaultData;
		    PFN_vkDestroySurfaceKHR vkDestroySurfaceKHR;
		    PFN_vkGetPhysicalDeviceSurfaceSupportKHR vkGetPhysicalDeviceSurfaceSupportKHR;
		    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
		    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR vkGetPhysicalDeviceSurfaceFormatsKHR;
		    PFN_vkGetPhysicalDeviceSurfacePresentModesKHR vkGetPhysicalDeviceSurfacePresentModesKHR;
		    PFN_vkCreateSwapchainKHR vkCreateSwapchainKHR;
		    PFN_vkDestroySwapchainKHR vkDestroySwapchainKHR;
		    PFN_vkGetSwapchainImagesKHR vkGetSwapchainImagesKHR;
		    PFN_vkAcquireNextImageKHR vkAcquireNextImageKHR;
		    PFN_vkQueuePresentKHR vkQueuePresentKHR;
		    PFN_vkGetDeviceGroupPresentCapabilitiesKHR vkGetDeviceGroupPresentCapabilitiesKHR;
		    PFN_vkGetDeviceGroupSurfacePresentModesKHR vkGetDeviceGroupSurfacePresentModesKHR;
		    PFN_vkGetPhysicalDevicePresentRectanglesKHR vkGetPhysicalDevicePresentRectanglesKHR;
		    PFN_vkAcquireNextImage2KHR vkAcquireNextImage2KHR;
		    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR vkGetPhysicalDeviceDisplayPropertiesKHR;
		    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
		    PFN_vkGetDisplayPlaneSupportedDisplaysKHR vkGetDisplayPlaneSupportedDisplaysKHR;
		    PFN_vkGetDisplayModePropertiesKHR vkGetDisplayModePropertiesKHR;
		    PFN_vkCreateDisplayModeKHR vkCreateDisplayModeKHR;
		    PFN_vkGetDisplayPlaneCapabilitiesKHR vkGetDisplayPlaneCapabilitiesKHR;
		    PFN_vkCreateDisplayPlaneSurfaceKHR vkCreateDisplayPlaneSurfaceKHR;
		    PFN_vkCreateSharedSwapchainsKHR vkCreateSharedSwapchainsKHR;
		    PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR vkGetPhysicalDeviceVideoCapabilitiesKHR;
		    PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR vkGetPhysicalDeviceVideoFormatPropertiesKHR;
		    PFN_vkCreateVideoSessionKHR vkCreateVideoSessionKHR;
		    PFN_vkDestroyVideoSessionKHR vkDestroyVideoSessionKHR;
		    PFN_vkGetVideoSessionMemoryRequirementsKHR vkGetVideoSessionMemoryRequirementsKHR;
		    PFN_vkBindVideoSessionMemoryKHR vkBindVideoSessionMemoryKHR;
		    PFN_vkCreateVideoSessionParametersKHR vkCreateVideoSessionParametersKHR;
		    PFN_vkUpdateVideoSessionParametersKHR vkUpdateVideoSessionParametersKHR;
		    PFN_vkDestroyVideoSessionParametersKHR vkDestroyVideoSessionParametersKHR;
		    PFN_vkCmdBeginVideoCodingKHR vkCmdBeginVideoCodingKHR;
		    PFN_vkCmdEndVideoCodingKHR vkCmdEndVideoCodingKHR;
		    PFN_vkCmdControlVideoCodingKHR vkCmdControlVideoCodingKHR;
		    PFN_vkCmdDecodeVideoKHR vkCmdDecodeVideoKHR;
		    PFN_vkCmdBindTransformFeedbackBuffersEXT vkCmdBindTransformFeedbackBuffersEXT;
		    PFN_vkCmdBeginTransformFeedbackEXT vkCmdBeginTransformFeedbackEXT;
		    PFN_vkCmdEndTransformFeedbackEXT vkCmdEndTransformFeedbackEXT;
		    PFN_vkCmdBeginQueryIndexedEXT vkCmdBeginQueryIndexedEXT;
		    PFN_vkCmdEndQueryIndexedEXT vkCmdEndQueryIndexedEXT;
		    PFN_vkCmdDrawIndirectByteCountEXT vkCmdDrawIndirectByteCountEXT;
		    PFN_vkCreateCuModuleNVX vkCreateCuModuleNVX;
		    PFN_vkCreateCuFunctionNVX vkCreateCuFunctionNVX;
		    PFN_vkDestroyCuModuleNVX vkDestroyCuModuleNVX;
		    PFN_vkDestroyCuFunctionNVX vkDestroyCuFunctionNVX;
		    PFN_vkCmdCuLaunchKernelNVX vkCmdCuLaunchKernelNVX;
		    PFN_vkGetImageViewHandleNVX vkGetImageViewHandleNVX;
		    PFN_vkGetImageViewAddressNVX vkGetImageViewAddressNVX;
		    PFN_vkGetShaderInfoAMD vkGetShaderInfoAMD;
		    PFN_vkCmdBeginRenderingKHR vkCmdBeginRenderingKHR;
		    PFN_vkCmdEndRenderingKHR vkCmdEndRenderingKHR;
		    PFN_vkGetPhysicalDeviceFeatures2KHR vkGetPhysicalDeviceFeatures2KHR;
		    PFN_vkGetPhysicalDeviceProperties2KHR vkGetPhysicalDeviceProperties2KHR;
		    PFN_vkGetPhysicalDeviceFormatProperties2KHR vkGetPhysicalDeviceFormatProperties2KHR;
		    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR vkGetPhysicalDeviceImageFormatProperties2KHR;
		    PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR vkGetPhysicalDeviceQueueFamilyProperties2KHR;
		    PFN_vkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR;
		    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
		    PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR vkGetDeviceGroupPeerMemoryFeaturesKHR;
		    PFN_vkCmdSetDeviceMaskKHR vkCmdSetDeviceMaskKHR;
		    PFN_vkCmdDispatchBaseKHR vkCmdDispatchBaseKHR;
		    PFN_vkTrimCommandPoolKHR vkTrimCommandPoolKHR;
		    PFN_vkEnumeratePhysicalDeviceGroupsKHR vkEnumeratePhysicalDeviceGroupsKHR;
		    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR vkGetPhysicalDeviceExternalBufferPropertiesKHR;
		    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
		    PFN_vkGetMemoryFdKHR vkGetMemoryFdKHR;
		    PFN_vkGetMemoryFdPropertiesKHR vkGetMemoryFdPropertiesKHR;
		    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
		    PFN_vkImportSemaphoreFdKHR vkImportSemaphoreFdKHR;
		    PFN_vkGetSemaphoreFdKHR vkGetSemaphoreFdKHR;
		    PFN_vkCmdPushDescriptorSetKHR vkCmdPushDescriptorSetKHR;
		    PFN_vkCmdPushDescriptorSetWithTemplateKHR vkCmdPushDescriptorSetWithTemplateKHR;
		    PFN_vkCmdBeginConditionalRenderingEXT vkCmdBeginConditionalRenderingEXT;
		    PFN_vkCmdEndConditionalRenderingEXT vkCmdEndConditionalRenderingEXT;
		    PFN_vkCreateDescriptorUpdateTemplateKHR vkCreateDescriptorUpdateTemplateKHR;
		    PFN_vkDestroyDescriptorUpdateTemplateKHR vkDestroyDescriptorUpdateTemplateKHR;
		    PFN_vkUpdateDescriptorSetWithTemplateKHR vkUpdateDescriptorSetWithTemplateKHR;
		    PFN_vkCmdSetViewportWScalingNV vkCmdSetViewportWScalingNV;
		    PFN_vkReleaseDisplayEXT vkReleaseDisplayEXT;
		    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT vkGetPhysicalDeviceSurfaceCapabilities2EXT;
		    PFN_vkDisplayPowerControlEXT vkDisplayPowerControlEXT;
		    PFN_vkRegisterDeviceEventEXT vkRegisterDeviceEventEXT;
		    PFN_vkRegisterDisplayEventEXT vkRegisterDisplayEventEXT;
		    PFN_vkGetSwapchainCounterEXT vkGetSwapchainCounterEXT;
		    PFN_vkGetRefreshCycleDurationGOOGLE vkGetRefreshCycleDurationGOOGLE;
		    PFN_vkGetPastPresentationTimingGOOGLE vkGetPastPresentationTimingGOOGLE;
		    PFN_vkCmdSetDiscardRectangleEXT vkCmdSetDiscardRectangleEXT;
		    PFN_vkCmdSetDiscardRectangleEnableEXT vkCmdSetDiscardRectangleEnableEXT;
		    PFN_vkCmdSetDiscardRectangleModeEXT vkCmdSetDiscardRectangleModeEXT;
		    PFN_vkSetHdrMetadataEXT vkSetHdrMetadataEXT;
		    PFN_vkCreateRenderPass2KHR vkCreateRenderPass2KHR;
		    PFN_vkCmdBeginRenderPass2KHR vkCmdBeginRenderPass2KHR;
		    PFN_vkCmdNextSubpass2KHR vkCmdNextSubpass2KHR;
		    PFN_vkCmdEndRenderPass2KHR vkCmdEndRenderPass2KHR;
		    PFN_vkGetSwapchainStatusKHR vkGetSwapchainStatusKHR;
		    PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR vkGetPhysicalDeviceExternalFencePropertiesKHR;
		    PFN_vkImportFenceFdKHR vkImportFenceFdKHR;
		    PFN_vkGetFenceFdKHR vkGetFenceFdKHR;
		    PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
		    PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
		    PFN_vkAcquireProfilingLockKHR vkAcquireProfilingLockKHR;
		    PFN_vkReleaseProfilingLockKHR vkReleaseProfilingLockKHR;
		    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR vkGetPhysicalDeviceSurfaceCapabilities2KHR;
		    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR vkGetPhysicalDeviceSurfaceFormats2KHR;
		    PFN_vkGetPhysicalDeviceDisplayProperties2KHR vkGetPhysicalDeviceDisplayProperties2KHR;
		    PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
		    PFN_vkGetDisplayModeProperties2KHR vkGetDisplayModeProperties2KHR;
		    PFN_vkGetDisplayPlaneCapabilities2KHR vkGetDisplayPlaneCapabilities2KHR;
		    PFN_vkSetDebugUtilsObjectNameEXT vkSetDebugUtilsObjectNameEXT;
		    PFN_vkSetDebugUtilsObjectTagEXT vkSetDebugUtilsObjectTagEXT;
		    PFN_vkQueueBeginDebugUtilsLabelEXT vkQueueBeginDebugUtilsLabelEXT;
		    PFN_vkQueueEndDebugUtilsLabelEXT vkQueueEndDebugUtilsLabelEXT;
		    PFN_vkQueueInsertDebugUtilsLabelEXT vkQueueInsertDebugUtilsLabelEXT;
		    PFN_vkCmdBeginDebugUtilsLabelEXT vkCmdBeginDebugUtilsLabelEXT;
		    PFN_vkCmdEndDebugUtilsLabelEXT vkCmdEndDebugUtilsLabelEXT;
		    PFN_vkCmdInsertDebugUtilsLabelEXT vkCmdInsertDebugUtilsLabelEXT;
		    PFN_vkCreateDebugUtilsMessengerEXT vkCreateDebugUtilsMessengerEXT;
		    PFN_vkDestroyDebugUtilsMessengerEXT vkDestroyDebugUtilsMessengerEXT;
		    PFN_vkSubmitDebugUtilsMessageEXT vkSubmitDebugUtilsMessageEXT;
		    PFN_vkDebugMarkerSetObjectTagEXT vkDebugMarkerSetObjectTagEXT;
		    PFN_vkDebugMarkerSetObjectNameEXT vkDebugMarkerSetObjectNameEXT;
		    PFN_vkCmdDebugMarkerBeginEXT vkCmdDebugMarkerBeginEXT;
		    PFN_vkCmdDebugMarkerEndEXT vkCmdDebugMarkerEndEXT;
		    PFN_vkCmdDebugMarkerInsertEXT vkCmdDebugMarkerInsertEXT;
		    PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT;
		    PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT;
		    PFN_vkDebugReportMessageEXT vkDebugReportMessageEXT;
		    PFN_vkCmdSetSampleLocationsEXT vkCmdSetSampleLocationsEXT;
		    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT vkGetPhysicalDeviceMultisamplePropertiesEXT;
		    PFN_vkGetImageMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR;
		    PFN_vkGetBufferMemoryRequirements2KHR vkGetBufferMemoryRequirements2KHR;
		    PFN_vkGetImageSparseMemoryRequirements2KHR vkGetImageSparseMemoryRequirements2KHR;
		    PFN_vkCreateAccelerationStructureKHR vkCreateAccelerationStructureKHR;
		    PFN_vkDestroyAccelerationStructureKHR vkDestroyAccelerationStructureKHR;
		    PFN_vkCmdBuildAccelerationStructuresKHR vkCmdBuildAccelerationStructuresKHR;
		    PFN_vkCmdBuildAccelerationStructuresIndirectKHR vkCmdBuildAccelerationStructuresIndirectKHR;
		    PFN_vkBuildAccelerationStructuresKHR vkBuildAccelerationStructuresKHR;
		    PFN_vkCopyAccelerationStructureKHR vkCopyAccelerationStructureKHR;
		    PFN_vkCopyAccelerationStructureToMemoryKHR vkCopyAccelerationStructureToMemoryKHR;
		    PFN_vkCopyMemoryToAccelerationStructureKHR vkCopyMemoryToAccelerationStructureKHR;
		    PFN_vkWriteAccelerationStructuresPropertiesKHR vkWriteAccelerationStructuresPropertiesKHR;
		    PFN_vkCmdCopyAccelerationStructureKHR vkCmdCopyAccelerationStructureKHR;
		    PFN_vkCmdCopyAccelerationStructureToMemoryKHR vkCmdCopyAccelerationStructureToMemoryKHR;
		    PFN_vkCmdCopyMemoryToAccelerationStructureKHR vkCmdCopyMemoryToAccelerationStructureKHR;
		    PFN_vkGetAccelerationStructureDeviceAddressKHR vkGetAccelerationStructureDeviceAddressKHR;
		    PFN_vkCmdWriteAccelerationStructuresPropertiesKHR vkCmdWriteAccelerationStructuresPropertiesKHR;
		    PFN_vkGetDeviceAccelerationStructureCompatibilityKHR vkGetDeviceAccelerationStructureCompatibilityKHR;
		    PFN_vkGetAccelerationStructureBuildSizesKHR vkGetAccelerationStructureBuildSizesKHR;
		    PFN_vkCmdTraceRaysKHR vkCmdTraceRaysKHR;
		    PFN_vkCreateRayTracingPipelinesKHR vkCreateRayTracingPipelinesKHR;
		    PFN_vkGetRayTracingShaderGroupHandlesKHR vkGetRayTracingShaderGroupHandlesKHR;
		    PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
		    PFN_vkCmdTraceRaysIndirectKHR vkCmdTraceRaysIndirectKHR;
		    PFN_vkGetRayTracingShaderGroupStackSizeKHR vkGetRayTracingShaderGroupStackSizeKHR;
		    PFN_vkCmdSetRayTracingPipelineStackSizeKHR vkCmdSetRayTracingPipelineStackSizeKHR;
		    PFN_vkCreateSamplerYcbcrConversionKHR vkCreateSamplerYcbcrConversionKHR;
		    PFN_vkDestroySamplerYcbcrConversionKHR vkDestroySamplerYcbcrConversionKHR;
		    PFN_vkBindBufferMemory2KHR vkBindBufferMemory2KHR;
		    PFN_vkBindImageMemory2KHR vkBindImageMemory2KHR;
		    PFN_vkGetImageDrmFormatModifierPropertiesEXT vkGetImageDrmFormatModifierPropertiesEXT;
		    PFN_vkCreateValidationCacheEXT vkCreateValidationCacheEXT;
		    PFN_vkDestroyValidationCacheEXT vkDestroyValidationCacheEXT;
		    PFN_vkMergeValidationCachesEXT vkMergeValidationCachesEXT;
		    PFN_vkGetValidationCacheDataEXT vkGetValidationCacheDataEXT;
		    PFN_vkCmdBindShadingRateImageNV vkCmdBindShadingRateImageNV;
		    PFN_vkCmdSetViewportShadingRatePaletteNV vkCmdSetViewportShadingRatePaletteNV;
		    PFN_vkCmdSetCoarseSampleOrderNV vkCmdSetCoarseSampleOrderNV;
		    PFN_vkCreateAccelerationStructureNV vkCreateAccelerationStructureNV;
		    PFN_vkDestroyAccelerationStructureNV vkDestroyAccelerationStructureNV;
		    PFN_vkGetAccelerationStructureMemoryRequirementsNV vkGetAccelerationStructureMemoryRequirementsNV;
		    PFN_vkBindAccelerationStructureMemoryNV vkBindAccelerationStructureMemoryNV;
		    PFN_vkCmdBuildAccelerationStructureNV vkCmdBuildAccelerationStructureNV;
		    PFN_vkCmdCopyAccelerationStructureNV vkCmdCopyAccelerationStructureNV;
		    PFN_vkCmdTraceRaysNV vkCmdTraceRaysNV;
		    PFN_vkCreateRayTracingPipelinesNV vkCreateRayTracingPipelinesNV;
		    PFN_vkGetRayTracingShaderGroupHandlesNV vkGetRayTracingShaderGroupHandlesNV;
		    PFN_vkGetAccelerationStructureHandleNV vkGetAccelerationStructureHandleNV;
		    PFN_vkCmdWriteAccelerationStructuresPropertiesNV vkCmdWriteAccelerationStructuresPropertiesNV;
		    PFN_vkCompileDeferredNV vkCompileDeferredNV;
		    PFN_vkGetDescriptorSetLayoutSupportKHR vkGetDescriptorSetLayoutSupportKHR;
		    PFN_vkCmdDrawIndirectCountKHR vkCmdDrawIndirectCountKHR;
		    PFN_vkCmdDrawIndexedIndirectCountKHR vkCmdDrawIndexedIndirectCountKHR;
		    PFN_vkCmdDrawIndirectCountAMD vkCmdDrawIndirectCountAMD;
		    PFN_vkCmdDrawIndexedIndirectCountAMD vkCmdDrawIndexedIndirectCountAMD;
		    PFN_vkGetMemoryHostPointerPropertiesEXT vkGetMemoryHostPointerPropertiesEXT;
		    PFN_vkCmdWriteBufferMarkerAMD vkCmdWriteBufferMarkerAMD;
		    PFN_vkCmdDrawMeshTasksNV vkCmdDrawMeshTasksNV;
		    PFN_vkCmdDrawMeshTasksIndirectNV vkCmdDrawMeshTasksIndirectNV;
		    PFN_vkCmdDrawMeshTasksIndirectCountNV vkCmdDrawMeshTasksIndirectCountNV;
		    PFN_vkCmdSetExclusiveScissorEnableNV vkCmdSetExclusiveScissorEnableNV;
		    PFN_vkCmdSetExclusiveScissorNV vkCmdSetExclusiveScissorNV;
		    PFN_vkCmdSetCheckpointNV vkCmdSetCheckpointNV;
		    PFN_vkGetQueueCheckpointDataNV vkGetQueueCheckpointDataNV;
		    PFN_vkGetSemaphoreCounterValueKHR vkGetSemaphoreCounterValueKHR;
		    PFN_vkWaitSemaphoresKHR vkWaitSemaphoresKHR;
		    PFN_vkSignalSemaphoreKHR vkSignalSemaphoreKHR;
		    PFN_vkInitializePerformanceApiINTEL vkInitializePerformanceApiINTEL;
		    PFN_vkUninitializePerformanceApiINTEL vkUninitializePerformanceApiINTEL;
		    PFN_vkCmdSetPerformanceMarkerINTEL vkCmdSetPerformanceMarkerINTEL;
		    PFN_vkCmdSetPerformanceStreamMarkerINTEL vkCmdSetPerformanceStreamMarkerINTEL;
		    PFN_vkCmdSetPerformanceOverrideINTEL vkCmdSetPerformanceOverrideINTEL;
		    PFN_vkAcquirePerformanceConfigurationINTEL vkAcquirePerformanceConfigurationINTEL;
		    PFN_vkReleasePerformanceConfigurationINTEL vkReleasePerformanceConfigurationINTEL;
		    PFN_vkQueueSetPerformanceConfigurationINTEL vkQueueSetPerformanceConfigurationINTEL;
		    PFN_vkGetPerformanceParameterINTEL vkGetPerformanceParameterINTEL;
		    PFN_vkSetLocalDimmingAMD vkSetLocalDimmingAMD;
		    PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR vkGetPhysicalDeviceFragmentShadingRatesKHR;
		    PFN_vkCmdSetFragmentShadingRateKHR vkCmdSetFragmentShadingRateKHR;
		    PFN_vkCmdSetRenderingAttachmentLocationsKHR vkCmdSetRenderingAttachmentLocationsKHR;
		    PFN_vkCmdSetRenderingInputAttachmentIndicesKHR vkCmdSetRenderingInputAttachmentIndicesKHR;
		    PFN_vkGetPhysicalDeviceToolPropertiesEXT vkGetPhysicalDeviceToolPropertiesEXT;
		    PFN_vkWaitForPresentKHR vkWaitForPresentKHR;
		    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV vkGetPhysicalDeviceCooperativeMatrixPropertiesNV;
		    PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
		    PFN_vkCreateHeadlessSurfaceEXT vkCreateHeadlessSurfaceEXT;
		    PFN_vkGetBufferDeviceAddressKHR vkGetBufferDeviceAddressKHR;
		    PFN_vkGetBufferOpaqueCaptureAddressKHR vkGetBufferOpaqueCaptureAddressKHR;
		    PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR vkGetDeviceMemoryOpaqueCaptureAddressKHR;
		    PFN_vkGetBufferDeviceAddressEXT vkGetBufferDeviceAddressEXT;
		    PFN_vkResetQueryPoolEXT vkResetQueryPoolEXT;
		    PFN_vkCmdSetCullModeEXT vkCmdSetCullModeEXT;
		    PFN_vkCmdSetFrontFaceEXT vkCmdSetFrontFaceEXT;
		    PFN_vkCmdSetPrimitiveTopologyEXT vkCmdSetPrimitiveTopologyEXT;
		    PFN_vkCmdSetViewportWithCountEXT vkCmdSetViewportWithCountEXT;
		    PFN_vkCmdSetScissorWithCountEXT vkCmdSetScissorWithCountEXT;
		    PFN_vkCmdBindVertexBuffers2EXT vkCmdBindVertexBuffers2EXT;
		    PFN_vkCmdSetDepthTestEnableEXT vkCmdSetDepthTestEnableEXT;
		    PFN_vkCmdSetDepthWriteEnableEXT vkCmdSetDepthWriteEnableEXT;
		    PFN_vkCmdSetDepthCompareOpEXT vkCmdSetDepthCompareOpEXT;
		    PFN_vkCmdSetDepthBoundsTestEnableEXT vkCmdSetDepthBoundsTestEnableEXT;
		    PFN_vkCmdSetStencilTestEnableEXT vkCmdSetStencilTestEnableEXT;
		    PFN_vkCmdSetStencilOpEXT vkCmdSetStencilOpEXT;
		    PFN_vkCreateDeferredOperationKHR vkCreateDeferredOperationKHR;
		    PFN_vkDestroyDeferredOperationKHR vkDestroyDeferredOperationKHR;
		    PFN_vkGetDeferredOperationMaxConcurrencyKHR vkGetDeferredOperationMaxConcurrencyKHR;
		    PFN_vkGetDeferredOperationResultKHR vkGetDeferredOperationResultKHR;
		    PFN_vkDeferredOperationJoinKHR vkDeferredOperationJoinKHR;
		    PFN_vkGetPipelineExecutablePropertiesKHR vkGetPipelineExecutablePropertiesKHR;
		    PFN_vkGetPipelineExecutableStatisticsKHR vkGetPipelineExecutableStatisticsKHR;
		    PFN_vkGetPipelineExecutableInternalRepresentationsKHR vkGetPipelineExecutableInternalRepresentationsKHR;
		    PFN_vkCopyMemoryToImageEXT vkCopyMemoryToImageEXT;
		    PFN_vkCopyImageToMemoryEXT vkCopyImageToMemoryEXT;
		    PFN_vkCopyImageToImageEXT vkCopyImageToImageEXT;
		    PFN_vkTransitionImageLayoutEXT vkTransitionImageLayoutEXT;
		    PFN_vkGetImageSubresourceLayout2EXT vkGetImageSubresourceLayout2EXT;
		    PFN_vkMapMemory2KHR vkMapMemory2KHR;
		    PFN_vkUnmapMemory2KHR vkUnmapMemory2KHR;
		    PFN_vkReleaseSwapchainImagesEXT vkReleaseSwapchainImagesEXT;
		    PFN_vkGetGeneratedCommandsMemoryRequirementsNV vkGetGeneratedCommandsMemoryRequirementsNV;
		    PFN_vkCmdPreprocessGeneratedCommandsNV vkCmdPreprocessGeneratedCommandsNV;
		    PFN_vkCmdExecuteGeneratedCommandsNV vkCmdExecuteGeneratedCommandsNV;
		    PFN_vkCmdBindPipelineShaderGroupNV vkCmdBindPipelineShaderGroupNV;
		    PFN_vkCreateIndirectCommandsLayoutNV vkCreateIndirectCommandsLayoutNV;
		    PFN_vkDestroyIndirectCommandsLayoutNV vkDestroyIndirectCommandsLayoutNV;
		    PFN_vkCmdSetDepthBias2EXT vkCmdSetDepthBias2EXT;
		    PFN_vkAcquireDrmDisplayEXT vkAcquireDrmDisplayEXT;
		    PFN_vkGetDrmDisplayEXT vkGetDrmDisplayEXT;
		    PFN_vkCreatePrivateDataSlotEXT vkCreatePrivateDataSlotEXT;
		    PFN_vkDestroyPrivateDataSlotEXT vkDestroyPrivateDataSlotEXT;
		    PFN_vkSetPrivateDataEXT vkSetPrivateDataEXT;
		    PFN_vkGetPrivateDataEXT vkGetPrivateDataEXT;
		    PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
		    PFN_vkGetEncodedVideoSessionParametersKHR vkGetEncodedVideoSessionParametersKHR;
		    PFN_vkCmdEncodeVideoKHR vkCmdEncodeVideoKHR;
		    PFN_vkCreateCudaModuleNV vkCreateCudaModuleNV;
		    PFN_vkGetCudaModuleCacheNV vkGetCudaModuleCacheNV;
		    PFN_vkCreateCudaFunctionNV vkCreateCudaFunctionNV;
		    PFN_vkDestroyCudaModuleNV vkDestroyCudaModuleNV;
		    PFN_vkDestroyCudaFunctionNV vkDestroyCudaFunctionNV;
		    PFN_vkCmdCudaLaunchKernelNV vkCmdCudaLaunchKernelNV;
		    PFN_vkCmdRefreshObjectsKHR vkCmdRefreshObjectsKHR;
		    PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR vkGetPhysicalDeviceRefreshableObjectTypesKHR;
		    PFN_vkCmdSetEvent2KHR vkCmdSetEvent2KHR;
		    PFN_vkCmdResetEvent2KHR vkCmdResetEvent2KHR;
		    PFN_vkCmdWaitEvents2KHR vkCmdWaitEvents2KHR;
		    PFN_vkCmdPipelineBarrier2KHR vkCmdPipelineBarrier2KHR;
		    PFN_vkCmdWriteTimestamp2KHR vkCmdWriteTimestamp2KHR;
		    PFN_vkQueueSubmit2KHR vkQueueSubmit2KHR;
		    PFN_vkCmdWriteBufferMarker2AMD vkCmdWriteBufferMarker2AMD;
		    PFN_vkGetQueueCheckpointData2NV vkGetQueueCheckpointData2NV;
		    PFN_vkGetDescriptorSetLayoutSizeEXT vkGetDescriptorSetLayoutSizeEXT;
		    PFN_vkGetDescriptorSetLayoutBindingOffsetEXT vkGetDescriptorSetLayoutBindingOffsetEXT;
		    PFN_vkGetDescriptorEXT vkGetDescriptorEXT;
		    PFN_vkCmdBindDescriptorBuffersEXT vkCmdBindDescriptorBuffersEXT;
		    PFN_vkCmdSetDescriptorBufferOffsetsEXT vkCmdSetDescriptorBufferOffsetsEXT;
		    PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT vkCmdBindDescriptorBufferEmbeddedSamplersEXT;
		    PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT vkGetBufferOpaqueCaptureDescriptorDataEXT;
		    PFN_vkGetImageOpaqueCaptureDescriptorDataEXT vkGetImageOpaqueCaptureDescriptorDataEXT;
		    PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT vkGetImageViewOpaqueCaptureDescriptorDataEXT;
		    PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT vkGetSamplerOpaqueCaptureDescriptorDataEXT;
		    PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
		    PFN_vkCmdSetFragmentShadingRateEnumNV vkCmdSetFragmentShadingRateEnumNV;
		    PFN_vkCmdDrawMeshTasksEXT vkCmdDrawMeshTasksEXT;
		    PFN_vkCmdDrawMeshTasksIndirectEXT vkCmdDrawMeshTasksIndirectEXT;
		    PFN_vkCmdDrawMeshTasksIndirectCountEXT vkCmdDrawMeshTasksIndirectCountEXT;
		    PFN_vkCmdCopyBuffer2KHR vkCmdCopyBuffer2KHR;
		    PFN_vkCmdCopyImage2KHR vkCmdCopyImage2KHR;
		    PFN_vkCmdCopyBufferToImage2KHR vkCmdCopyBufferToImage2KHR;
		    PFN_vkCmdCopyImageToBuffer2KHR vkCmdCopyImageToBuffer2KHR;
		    PFN_vkCmdBlitImage2KHR vkCmdBlitImage2KHR;
		    PFN_vkCmdResolveImage2KHR vkCmdResolveImage2KHR;
		    PFN_vkGetDeviceFaultInfoEXT vkGetDeviceFaultInfoEXT;
		    PFN_vkCmdSetVertexInputEXT vkCmdSetVertexInputEXT;
		    PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
		    PFN_vkCmdSubpassShadingHUAWEI vkCmdSubpassShadingHUAWEI;
		    PFN_vkCmdBindInvocationMaskHUAWEI vkCmdBindInvocationMaskHUAWEI;
		    PFN_vkGetMemoryRemoteAddressNV vkGetMemoryRemoteAddressNV;
		    PFN_vkGetPipelinePropertiesEXT vkGetPipelinePropertiesEXT;
		    PFN_vkCmdSetPatchControlPointsEXT vkCmdSetPatchControlPointsEXT;
		    PFN_vkCmdSetRasterizerDiscardEnableEXT vkCmdSetRasterizerDiscardEnableEXT;
		    PFN_vkCmdSetDepthBiasEnableEXT vkCmdSetDepthBiasEnableEXT;
		    PFN_vkCmdSetLogicOpEXT vkCmdSetLogicOpEXT;
		    PFN_vkCmdSetPrimitiveRestartEnableEXT vkCmdSetPrimitiveRestartEnableEXT;
		    PFN_vkCmdSetColorWriteEnableEXT vkCmdSetColorWriteEnableEXT;
		    PFN_vkCmdTraceRaysIndirect2KHR vkCmdTraceRaysIndirect2KHR;
		    PFN_vkCmdDrawMultiEXT vkCmdDrawMultiEXT;
		    PFN_vkCmdDrawMultiIndexedEXT vkCmdDrawMultiIndexedEXT;
		    PFN_vkCreateMicromapEXT vkCreateMicromapEXT;
		    PFN_vkDestroyMicromapEXT vkDestroyMicromapEXT;
		    PFN_vkCmdBuildMicromapsEXT vkCmdBuildMicromapsEXT;
		    PFN_vkBuildMicromapsEXT vkBuildMicromapsEXT;
		    PFN_vkCopyMicromapEXT vkCopyMicromapEXT;
		    PFN_vkCopyMicromapToMemoryEXT vkCopyMicromapToMemoryEXT;
		    PFN_vkCopyMemoryToMicromapEXT vkCopyMemoryToMicromapEXT;
		    PFN_vkWriteMicromapsPropertiesEXT vkWriteMicromapsPropertiesEXT;
		    PFN_vkCmdCopyMicromapEXT vkCmdCopyMicromapEXT;
		    PFN_vkCmdCopyMicromapToMemoryEXT vkCmdCopyMicromapToMemoryEXT;
		    PFN_vkCmdCopyMemoryToMicromapEXT vkCmdCopyMemoryToMicromapEXT;
		    PFN_vkCmdWriteMicromapsPropertiesEXT vkCmdWriteMicromapsPropertiesEXT;
		    PFN_vkGetDeviceMicromapCompatibilityEXT vkGetDeviceMicromapCompatibilityEXT;
		    PFN_vkGetMicromapBuildSizesEXT vkGetMicromapBuildSizesEXT;
		    PFN_vkCmdDrawClusterHUAWEI vkCmdDrawClusterHUAWEI;
		    PFN_vkCmdDrawClusterIndirectHUAWEI vkCmdDrawClusterIndirectHUAWEI;
		    PFN_vkSetDeviceMemoryPriorityEXT vkSetDeviceMemoryPriorityEXT;
		    PFN_vkGetDeviceBufferMemoryRequirementsKHR vkGetDeviceBufferMemoryRequirementsKHR;
		    PFN_vkGetDeviceImageMemoryRequirementsKHR vkGetDeviceImageMemoryRequirementsKHR;
		    PFN_vkGetDeviceImageSparseMemoryRequirementsKHR vkGetDeviceImageSparseMemoryRequirementsKHR;
		    PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE vkGetDescriptorSetLayoutHostMappingInfoVALVE;
		    PFN_vkGetDescriptorSetHostMappingVALVE vkGetDescriptorSetHostMappingVALVE;
		    PFN_vkCmdCopyMemoryIndirectNV vkCmdCopyMemoryIndirectNV;
		    PFN_vkCmdCopyMemoryToImageIndirectNV vkCmdCopyMemoryToImageIndirectNV;
		    PFN_vkCmdDecompressMemoryNV vkCmdDecompressMemoryNV;
		    PFN_vkCmdDecompressMemoryIndirectCountNV vkCmdDecompressMemoryIndirectCountNV;
		    PFN_vkGetPipelineIndirectMemoryRequirementsNV vkGetPipelineIndirectMemoryRequirementsNV;
		    PFN_vkCmdUpdatePipelineIndirectBufferNV vkCmdUpdatePipelineIndirectBufferNV;
		    PFN_vkGetPipelineIndirectDeviceAddressNV vkGetPipelineIndirectDeviceAddressNV;
		    PFN_vkCmdSetDepthClampEnableEXT vkCmdSetDepthClampEnableEXT;
		    PFN_vkCmdSetPolygonModeEXT vkCmdSetPolygonModeEXT;
		    PFN_vkCmdSetRasterizationSamplesEXT vkCmdSetRasterizationSamplesEXT;
		    PFN_vkCmdSetSampleMaskEXT vkCmdSetSampleMaskEXT;
		    PFN_vkCmdSetAlphaToCoverageEnableEXT vkCmdSetAlphaToCoverageEnableEXT;
		    PFN_vkCmdSetAlphaToOneEnableEXT vkCmdSetAlphaToOneEnableEXT;
		    PFN_vkCmdSetLogicOpEnableEXT vkCmdSetLogicOpEnableEXT;
		    PFN_vkCmdSetColorBlendEnableEXT vkCmdSetColorBlendEnableEXT;
		    PFN_vkCmdSetColorBlendEquationEXT vkCmdSetColorBlendEquationEXT;
		    PFN_vkCmdSetColorWriteMaskEXT vkCmdSetColorWriteMaskEXT;
		    PFN_vkCmdSetTessellationDomainOriginEXT vkCmdSetTessellationDomainOriginEXT;
		    PFN_vkCmdSetRasterizationStreamEXT vkCmdSetRasterizationStreamEXT;
		    PFN_vkCmdSetConservativeRasterizationModeEXT vkCmdSetConservativeRasterizationModeEXT;
		    PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT vkCmdSetExtraPrimitiveOverestimationSizeEXT;
		    PFN_vkCmdSetDepthClipEnableEXT vkCmdSetDepthClipEnableEXT;
		    PFN_vkCmdSetSampleLocationsEnableEXT vkCmdSetSampleLocationsEnableEXT;
		    PFN_vkCmdSetColorBlendAdvancedEXT vkCmdSetColorBlendAdvancedEXT;
		    PFN_vkCmdSetProvokingVertexModeEXT vkCmdSetProvokingVertexModeEXT;
		    PFN_vkCmdSetLineRasterizationModeEXT vkCmdSetLineRasterizationModeEXT;
		    PFN_vkCmdSetLineStippleEnableEXT vkCmdSetLineStippleEnableEXT;
		    PFN_vkCmdSetDepthClipNegativeOneToOneEXT vkCmdSetDepthClipNegativeOneToOneEXT;
		    PFN_vkCmdSetViewportWScalingEnableNV vkCmdSetViewportWScalingEnableNV;
		    PFN_vkCmdSetViewportSwizzleNV vkCmdSetViewportSwizzleNV;
		    PFN_vkCmdSetCoverageToColorEnableNV vkCmdSetCoverageToColorEnableNV;
		    PFN_vkCmdSetCoverageToColorLocationNV vkCmdSetCoverageToColorLocationNV;
		    PFN_vkCmdSetCoverageModulationModeNV vkCmdSetCoverageModulationModeNV;
		    PFN_vkCmdSetCoverageModulationTableEnableNV vkCmdSetCoverageModulationTableEnableNV;
		    PFN_vkCmdSetCoverageModulationTableNV vkCmdSetCoverageModulationTableNV;
		    PFN_vkCmdSetShadingRateImageEnableNV vkCmdSetShadingRateImageEnableNV;
		    PFN_vkCmdSetRepresentativeFragmentTestEnableNV vkCmdSetRepresentativeFragmentTestEnableNV;
		    PFN_vkCmdSetCoverageReductionModeNV vkCmdSetCoverageReductionModeNV;
		    PFN_vkGetShaderModuleIdentifierEXT vkGetShaderModuleIdentifierEXT;
		    PFN_vkGetShaderModuleCreateInfoIdentifierEXT vkGetShaderModuleCreateInfoIdentifierEXT;
		    PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV vkGetPhysicalDeviceOpticalFlowImageFormatsNV;
		    PFN_vkCreateOpticalFlowSessionNV vkCreateOpticalFlowSessionNV;
		    PFN_vkDestroyOpticalFlowSessionNV vkDestroyOpticalFlowSessionNV;
		    PFN_vkBindOpticalFlowSessionImageNV vkBindOpticalFlowSessionImageNV;
		    PFN_vkCmdOpticalFlowExecuteNV vkCmdOpticalFlowExecuteNV;
		    PFN_vkCmdBindIndexBuffer2KHR vkCmdBindIndexBuffer2KHR;
		    PFN_vkGetRenderingAreaGranularityKHR vkGetRenderingAreaGranularityKHR;
		    PFN_vkGetDeviceImageSubresourceLayoutKHR vkGetDeviceImageSubresourceLayoutKHR;
		    PFN_vkGetImageSubresourceLayout2KHR vkGetImageSubresourceLayout2KHR;
		    PFN_vkCreateShadersEXT vkCreateShadersEXT;
		    PFN_vkDestroyShaderEXT vkDestroyShaderEXT;
		    PFN_vkGetShaderBinaryDataEXT vkGetShaderBinaryDataEXT;
		    PFN_vkCmdBindShadersEXT vkCmdBindShadersEXT;
		    PFN_vkGetFramebufferTilePropertiesQCOM vkGetFramebufferTilePropertiesQCOM;
		    PFN_vkGetDynamicRenderingTilePropertiesQCOM vkGetDynamicRenderingTilePropertiesQCOM;
		    PFN_vkSetLatencySleepModeNV vkSetLatencySleepModeNV;
		    PFN_vkLatencySleepNV vkLatencySleepNV;
		    PFN_vkSetLatencyMarkerNV vkSetLatencyMarkerNV;
		    PFN_vkGetLatencyTimingsNV vkGetLatencyTimingsNV;
		    PFN_vkQueueNotifyOutOfBandNV vkQueueNotifyOutOfBandNV;
		    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR;
		    PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT vkCmdSetAttachmentFeedbackLoopEnableEXT;
		    PFN_vkCmdSetLineStippleKHR vkCmdSetLineStippleKHR;
		    PFN_vkCmdSetLineStippleEXT vkCmdSetLineStippleEXT;
		    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
		    PFN_vkGetCalibratedTimestampsKHR vkGetCalibratedTimestampsKHR;
		    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT vkGetPhysicalDeviceCalibrateableTimeDomainsEXT;
		    PFN_vkGetCalibratedTimestampsEXT vkGetCalibratedTimestampsEXT;
		    PFN_vkCmdBindDescriptorSets2KHR vkCmdBindDescriptorSets2KHR;
		    PFN_vkCmdPushConstants2KHR vkCmdPushConstants2KHR;
		    PFN_vkCmdPushDescriptorSet2KHR vkCmdPushDescriptorSet2KHR;
		    PFN_vkCmdPushDescriptorSetWithTemplate2KHR vkCmdPushDescriptorSetWithTemplate2KHR;
		    PFN_vkCmdSetDescriptorBufferOffsets2EXT vkCmdSetDescriptorBufferOffsets2EXT;
		    PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT vkCmdBindDescriptorBufferEmbeddedSamplers2EXT;
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		    PFN_vkCreateXlibSurfaceKHR vkCreateXlibSurfaceKHR;
		    PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR vkGetPhysicalDeviceXlibPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		    PFN_vkAcquireXlibDisplayEXT vkAcquireXlibDisplayEXT;
		    PFN_vkGetRandROutputDisplayEXT vkGetRandROutputDisplayEXT;
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		    PFN_vkCreateXcbSurfaceKHR vkCreateXcbSurfaceKHR;
		    PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR vkGetPhysicalDeviceXcbPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		    PFN_vkCreateWaylandSurfaceKHR vkCreateWaylandSurfaceKHR;
		    PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR vkGetPhysicalDeviceWaylandPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		    PFN_vkCreateDirectFBSurfaceEXT vkCreateDirectFBSurfaceEXT;
		    PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		    PFN_vkCreateAndroidSurfaceKHR vkCreateAndroidSurfaceKHR;
		    PFN_vkGetAndroidHardwareBufferPropertiesANDROID vkGetAndroidHardwareBufferPropertiesANDROID;
		    PFN_vkGetMemoryAndroidHardwareBufferANDROID vkGetMemoryAndroidHardwareBufferANDROID;
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		    PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR;
		    PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR vkGetPhysicalDeviceWin32PresentationSupportKHR;
		    PFN_vkGetMemoryWin32HandleKHR vkGetMemoryWin32HandleKHR;
		    PFN_vkGetMemoryWin32HandlePropertiesKHR vkGetMemoryWin32HandlePropertiesKHR;
		    PFN_vkGetMemoryWin32HandleNV vkGetMemoryWin32HandleNV;
		    PFN_vkImportSemaphoreWin32HandleKHR vkImportSemaphoreWin32HandleKHR;
		    PFN_vkGetSemaphoreWin32HandleKHR vkGetSemaphoreWin32HandleKHR;
		    PFN_vkImportFenceWin32HandleKHR vkImportFenceWin32HandleKHR;
		    PFN_vkGetFenceWin32HandleKHR vkGetFenceWin32HandleKHR;
		    PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT vkGetPhysicalDeviceSurfacePresentModes2EXT;
		    PFN_vkAcquireFullScreenExclusiveModeEXT vkAcquireFullScreenExclusiveModeEXT;
		    PFN_vkReleaseFullScreenExclusiveModeEXT vkReleaseFullScreenExclusiveModeEXT;
		    PFN_vkGetDeviceGroupSurfacePresentModes2EXT vkGetDeviceGroupSurfacePresentModes2EXT;
		    PFN_vkAcquireWinrtDisplayNV vkAcquireWinrtDisplayNV;
		    PFN_vkGetWinrtDisplayNV vkGetWinrtDisplayNV;
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		    PFN_vkCreateViSurfaceNN vkCreateViSurfaceNN;
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		    PFN_vkCreateIOSSurfaceMVK vkCreateIOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		    PFN_vkCreateMacOSSurfaceMVK vkCreateMacOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		    PFN_vkCreateMetalSurfaceEXT vkCreateMetalSurfaceEXT;
		    PFN_vkExportMetalObjectsEXT vkExportMetalObjectsEXT;
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		    PFN_vkCreateImagePipeSurfaceFUCHSIA vkCreateImagePipeSurfaceFUCHSIA;
		    PFN_vkGetMemoryZirconHandleFUCHSIA vkGetMemoryZirconHandleFUCHSIA;
		    PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA vkGetMemoryZirconHandlePropertiesFUCHSIA;
		    PFN_vkImportSemaphoreZirconHandleFUCHSIA vkImportSemaphoreZirconHandleFUCHSIA;
		    PFN_vkGetSemaphoreZirconHandleFUCHSIA vkGetSemaphoreZirconHandleFUCHSIA;
		    PFN_vkCreateBufferCollectionFUCHSIA vkCreateBufferCollectionFUCHSIA;
		    PFN_vkSetBufferCollectionImageConstraintsFUCHSIA vkSetBufferCollectionImageConstraintsFUCHSIA;
		    PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA vkSetBufferCollectionBufferConstraintsFUCHSIA;
		    PFN_vkDestroyBufferCollectionFUCHSIA vkDestroyBufferCollectionFUCHSIA;
		    PFN_vkGetBufferCollectionPropertiesFUCHSIA vkGetBufferCollectionPropertiesFUCHSIA;
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		    PFN_vkCreateStreamDescriptorSurfaceGGP vkCreateStreamDescriptorSurfaceGGP;
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		    PFN_vkGetMemorySciBufNV vkGetMemorySciBufNV;
		    PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV;
		    PFN_vkGetPhysicalDeviceSciBufAttributesNV vkGetPhysicalDeviceSciBufAttributesNV;
		    PFN_vkCreateSemaphoreSciSyncPoolNV vkCreateSemaphoreSciSyncPoolNV;
		    PFN_vkDestroySemaphoreSciSyncPoolNV vkDestroySemaphoreSciSyncPoolNV;
		    PFN_vkGetFenceSciSyncFenceNV vkGetFenceSciSyncFenceNV;
		    PFN_vkGetFenceSciSyncObjNV vkGetFenceSciSyncObjNV;
		    PFN_vkImportFenceSciSyncFenceNV vkImportFenceSciSyncFenceNV;
		    PFN_vkImportFenceSciSyncObjNV vkImportFenceSciSyncObjNV;
		    PFN_vkGetPhysicalDeviceSciSyncAttributesNV vkGetPhysicalDeviceSciSyncAttributesNV;
		    PFN_vkGetSemaphoreSciSyncObjNV vkGetSemaphoreSciSyncObjNV;
		    PFN_vkImportSemaphoreSciSyncObjNV vkImportSemaphoreSciSyncObjNV;
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		    PFN_vkCreateExecutionGraphPipelinesAMDX vkCreateExecutionGraphPipelinesAMDX;
		    PFN_vkGetExecutionGraphPipelineScratchSizeAMDX vkGetExecutionGraphPipelineScratchSizeAMDX;
		    PFN_vkGetExecutionGraphPipelineNodeIndexAMDX vkGetExecutionGraphPipelineNodeIndexAMDX;
		    PFN_vkCmdInitializeGraphScratchMemoryAMDX vkCmdInitializeGraphScratchMemoryAMDX;
		    PFN_vkCmdDispatchGraphAMDX vkCmdDispatchGraphAMDX;
		    PFN_vkCmdDispatchGraphIndirectAMDX vkCmdDispatchGraphIndirectAMDX;
		    PFN_vkCmdDispatchGraphIndirectCountAMDX vkCmdDispatchGraphIndirectCountAMDX;
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		    PFN_vkCreateScreenSurfaceQNX vkCreateScreenSurfaceQNX;
		    PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX vkGetPhysicalDeviceScreenPresentationSupportQNX;
		    PFN_vkGetScreenBufferPropertiesQNX vkGetScreenBufferPropertiesQNX;
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/
		} VkbAPI;


		/*
		Initializes vkbind and attempts to load APIs statically.

		Note that it should be expected that APIs are not necessarilly statically implemented on every platform. This function
		will reliably load the following APIs (assuming platform support for the relevant version of Vulkan):

		Vulkan 1.0
		    vkGetInstanceProcAddr
		    vkCreateInstance
		    vkEnumerateInstanceExtensionProperties
		    vkEnumerateInstanceLayerProperties
		Vulkan 1.1
		    vkEnumerateInstanceVersion
		Vulkan 1.2

		Vulkan 1.3

		Vulkan 1.0
		    vkGetInstanceProcAddr

		vkbInit() will attempt to load every API statically, but for robustness you should not assume this will be successful.
		You should instead use vkCreateInstance() to create a Vulkan instance, then parse that to vkbInitInstanceAPI() and use
		vkbBindInstanceAPI() if you want to bind the instance API to global scope.

		pAPI is optional. On output it will contain pointers to all Vulkan APIs found by the loader.
		*/
		VkResult vkbInit(VkbAPI* pAPI);

		/*
		Uninitializes vkbind.

		Each call to vkbInit() must be matched up with a call to vkbUninit().
		*/
		void vkbUninit();

		/*
		Loads per-instance function pointers into the specified API object.

		This does not bind the function pointers to global scope. Use vkbBindAPI() for this.
		*/
		VkResult vkbInitInstanceAPI(VkInstance instance, VkbAPI* pAPI);

		/*
		Loads per-device function pointers into the specified API object.

		This does not bind the function pointers to global scope. Use vkbBindAPI() for this.

		This function only sets device-specific function pointers. The proper way to use this function is to first call
		vkbInitInstanceAPI() first, then call vkbInitDeviceAPI() using the same VkbAPI object, like the following.

		    VkbAPI api;
		    vkbInitInstanceAPI(instance, &api);
		    vkbInitDeviceAPI(device, &api);
		    vkbBindAPI(&api);   // <-- Optional. Can also call function pointers directly from the "api" object.
		    
		Use of this function is optional. It is provided only for optimization purposes to avoid the cost of internal dispatching.
		*/
		VkResult vkbInitDeviceAPI(VkDevice device, VkbAPI* pAPI);

		/*
		Binds the function pointers in pAPI to global scope.
		*/
		VkResult vkbBindAPI(const VkbAPI* pAPI);

		#ifdef __cplusplus
		}
		#endif
		#endif  /* VKBIND_H */

	/* vkbind v1.3.283.0 implementation */

		#define VKBIND_IMPLEMENTATION
		#ifdef VKBIND_IMPLEMENTATION
		#ifdef _WIN32
		#include <windows.h>
		#else
		#include <unistd.h>
		#include <dlfcn.h>
		#endif

		#ifndef VKBIND_NO_GLOBAL_API
		PFN_vkCreateInstance vkCreateInstance;
		PFN_vkDestroyInstance vkDestroyInstance;
		PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices;
		PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures;
		PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties;
		PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties;
		PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
		PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties;
		PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
		PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
		PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;
		PFN_vkCreateDevice vkCreateDevice;
		PFN_vkDestroyDevice vkDestroyDevice;
		PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties;
		PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties;
		PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties;
		PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties;
		PFN_vkGetDeviceQueue vkGetDeviceQueue;
		PFN_vkQueueSubmit vkQueueSubmit;
		PFN_vkQueueWaitIdle vkQueueWaitIdle;
		PFN_vkDeviceWaitIdle vkDeviceWaitIdle;
		PFN_vkAllocateMemory vkAllocateMemory;
		PFN_vkFreeMemory vkFreeMemory;
		PFN_vkMapMemory vkMapMemory;
		PFN_vkUnmapMemory vkUnmapMemory;
		PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
		PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
		PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment;
		PFN_vkBindBufferMemory vkBindBufferMemory;
		PFN_vkBindImageMemory vkBindImageMemory;
		PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
		PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
		PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements;
		PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties;
		PFN_vkQueueBindSparse vkQueueBindSparse;
		PFN_vkCreateFence vkCreateFence;
		PFN_vkDestroyFence vkDestroyFence;
		PFN_vkResetFences vkResetFences;
		PFN_vkGetFenceStatus vkGetFenceStatus;
		PFN_vkWaitForFences vkWaitForFences;
		PFN_vkCreateSemaphore vkCreateSemaphore;
		PFN_vkDestroySemaphore vkDestroySemaphore;
		PFN_vkCreateEvent vkCreateEvent;
		PFN_vkDestroyEvent vkDestroyEvent;
		PFN_vkGetEventStatus vkGetEventStatus;
		PFN_vkSetEvent vkSetEvent;
		PFN_vkResetEvent vkResetEvent;
		PFN_vkCreateQueryPool vkCreateQueryPool;
		PFN_vkDestroyQueryPool vkDestroyQueryPool;
		PFN_vkGetQueryPoolResults vkGetQueryPoolResults;
		PFN_vkCreateBuffer vkCreateBuffer;
		PFN_vkDestroyBuffer vkDestroyBuffer;
		PFN_vkCreateBufferView vkCreateBufferView;
		PFN_vkDestroyBufferView vkDestroyBufferView;
		PFN_vkCreateImage vkCreateImage;
		PFN_vkDestroyImage vkDestroyImage;
		PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout;
		PFN_vkCreateImageView vkCreateImageView;
		PFN_vkDestroyImageView vkDestroyImageView;
		PFN_vkCreateShaderModule vkCreateShaderModule;
		PFN_vkDestroyShaderModule vkDestroyShaderModule;
		PFN_vkCreatePipelineCache vkCreatePipelineCache;
		PFN_vkDestroyPipelineCache vkDestroyPipelineCache;
		PFN_vkGetPipelineCacheData vkGetPipelineCacheData;
		PFN_vkMergePipelineCaches vkMergePipelineCaches;
		PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines;
		PFN_vkCreateComputePipelines vkCreateComputePipelines;
		PFN_vkDestroyPipeline vkDestroyPipeline;
		PFN_vkCreatePipelineLayout vkCreatePipelineLayout;
		PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout;
		PFN_vkCreateSampler vkCreateSampler;
		PFN_vkDestroySampler vkDestroySampler;
		PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout;
		PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout;
		PFN_vkCreateDescriptorPool vkCreateDescriptorPool;
		PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool;
		PFN_vkResetDescriptorPool vkResetDescriptorPool;
		PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets;
		PFN_vkFreeDescriptorSets vkFreeDescriptorSets;
		PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets;
		PFN_vkCreateFramebuffer vkCreateFramebuffer;
		PFN_vkDestroyFramebuffer vkDestroyFramebuffer;
		PFN_vkCreateRenderPass vkCreateRenderPass;
		PFN_vkDestroyRenderPass vkDestroyRenderPass;
		PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity;
		PFN_vkCreateCommandPool vkCreateCommandPool;
		PFN_vkDestroyCommandPool vkDestroyCommandPool;
		PFN_vkResetCommandPool vkResetCommandPool;
		PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers;
		PFN_vkFreeCommandBuffers vkFreeCommandBuffers;
		PFN_vkBeginCommandBuffer vkBeginCommandBuffer;
		PFN_vkEndCommandBuffer vkEndCommandBuffer;
		PFN_vkResetCommandBuffer vkResetCommandBuffer;
		PFN_vkCmdBindPipeline vkCmdBindPipeline;
		PFN_vkCmdSetViewport vkCmdSetViewport;
		PFN_vkCmdSetScissor vkCmdSetScissor;
		PFN_vkCmdSetLineWidth vkCmdSetLineWidth;
		PFN_vkCmdSetDepthBias vkCmdSetDepthBias;
		PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants;
		PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds;
		PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask;
		PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask;
		PFN_vkCmdSetStencilReference vkCmdSetStencilReference;
		PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets;
		PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer;
		PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers;
		PFN_vkCmdDraw vkCmdDraw;
		PFN_vkCmdDrawIndexed vkCmdDrawIndexed;
		PFN_vkCmdDrawIndirect vkCmdDrawIndirect;
		PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect;
		PFN_vkCmdDispatch vkCmdDispatch;
		PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect;
		PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
		PFN_vkCmdCopyImage vkCmdCopyImage;
		PFN_vkCmdBlitImage vkCmdBlitImage;
		PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage;
		PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer;
		PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer;
		PFN_vkCmdFillBuffer vkCmdFillBuffer;
		PFN_vkCmdClearColorImage vkCmdClearColorImage;
		PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage;
		PFN_vkCmdClearAttachments vkCmdClearAttachments;
		PFN_vkCmdResolveImage vkCmdResolveImage;
		PFN_vkCmdSetEvent vkCmdSetEvent;
		PFN_vkCmdResetEvent vkCmdResetEvent;
		PFN_vkCmdWaitEvents vkCmdWaitEvents;
		PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier;
		PFN_vkCmdBeginQuery vkCmdBeginQuery;
		PFN_vkCmdEndQuery vkCmdEndQuery;
		PFN_vkCmdResetQueryPool vkCmdResetQueryPool;
		PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp;
		PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults;
		PFN_vkCmdPushConstants vkCmdPushConstants;
		PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass;
		PFN_vkCmdNextSubpass vkCmdNextSubpass;
		PFN_vkCmdEndRenderPass vkCmdEndRenderPass;
		PFN_vkCmdExecuteCommands vkCmdExecuteCommands;
		PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersion;
		PFN_vkBindBufferMemory2 vkBindBufferMemory2;
		PFN_vkBindImageMemory2 vkBindImageMemory2;
		PFN_vkGetDeviceGroupPeerMemoryFeatures vkGetDeviceGroupPeerMemoryFeatures;
		PFN_vkCmdSetDeviceMask vkCmdSetDeviceMask;
		PFN_vkCmdDispatchBase vkCmdDispatchBase;
		PFN_vkEnumeratePhysicalDeviceGroups vkEnumeratePhysicalDeviceGroups;
		PFN_vkGetImageMemoryRequirements2 vkGetImageMemoryRequirements2;
		PFN_vkGetBufferMemoryRequirements2 vkGetBufferMemoryRequirements2;
		PFN_vkGetImageSparseMemoryRequirements2 vkGetImageSparseMemoryRequirements2;
		PFN_vkGetPhysicalDeviceFeatures2 vkGetPhysicalDeviceFeatures2;
		PFN_vkGetPhysicalDeviceProperties2 vkGetPhysicalDeviceProperties2;
		PFN_vkGetPhysicalDeviceFormatProperties2 vkGetPhysicalDeviceFormatProperties2;
		PFN_vkGetPhysicalDeviceImageFormatProperties2 vkGetPhysicalDeviceImageFormatProperties2;
		PFN_vkGetPhysicalDeviceQueueFamilyProperties2 vkGetPhysicalDeviceQueueFamilyProperties2;
		PFN_vkGetPhysicalDeviceMemoryProperties2 vkGetPhysicalDeviceMemoryProperties2;
		PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 vkGetPhysicalDeviceSparseImageFormatProperties2;
		PFN_vkTrimCommandPool vkTrimCommandPool;
		PFN_vkGetDeviceQueue2 vkGetDeviceQueue2;
		PFN_vkCreateSamplerYcbcrConversion vkCreateSamplerYcbcrConversion;
		PFN_vkDestroySamplerYcbcrConversion vkDestroySamplerYcbcrConversion;
		PFN_vkCreateDescriptorUpdateTemplate vkCreateDescriptorUpdateTemplate;
		PFN_vkDestroyDescriptorUpdateTemplate vkDestroyDescriptorUpdateTemplate;
		PFN_vkUpdateDescriptorSetWithTemplate vkUpdateDescriptorSetWithTemplate;
		PFN_vkGetPhysicalDeviceExternalBufferProperties vkGetPhysicalDeviceExternalBufferProperties;
		PFN_vkGetPhysicalDeviceExternalFenceProperties vkGetPhysicalDeviceExternalFenceProperties;
		PFN_vkGetPhysicalDeviceExternalSemaphoreProperties vkGetPhysicalDeviceExternalSemaphoreProperties;
		PFN_vkGetDescriptorSetLayoutSupport vkGetDescriptorSetLayoutSupport;
		PFN_vkCmdDrawIndirectCount vkCmdDrawIndirectCount;
		PFN_vkCmdDrawIndexedIndirectCount vkCmdDrawIndexedIndirectCount;
		PFN_vkCreateRenderPass2 vkCreateRenderPass2;
		PFN_vkCmdBeginRenderPass2 vkCmdBeginRenderPass2;
		PFN_vkCmdNextSubpass2 vkCmdNextSubpass2;
		PFN_vkCmdEndRenderPass2 vkCmdEndRenderPass2;
		PFN_vkResetQueryPool vkResetQueryPool;
		PFN_vkGetSemaphoreCounterValue vkGetSemaphoreCounterValue;
		PFN_vkWaitSemaphores vkWaitSemaphores;
		PFN_vkSignalSemaphore vkSignalSemaphore;
		PFN_vkGetBufferDeviceAddress vkGetBufferDeviceAddress;
		PFN_vkGetBufferOpaqueCaptureAddress vkGetBufferOpaqueCaptureAddress;
		PFN_vkGetDeviceMemoryOpaqueCaptureAddress vkGetDeviceMemoryOpaqueCaptureAddress;
		PFN_vkGetPhysicalDeviceToolProperties vkGetPhysicalDeviceToolProperties;
		PFN_vkCreatePrivateDataSlot vkCreatePrivateDataSlot;
		PFN_vkDestroyPrivateDataSlot vkDestroyPrivateDataSlot;
		PFN_vkSetPrivateData vkSetPrivateData;
		PFN_vkGetPrivateData vkGetPrivateData;
		PFN_vkCmdSetEvent2 vkCmdSetEvent2;
		PFN_vkCmdResetEvent2 vkCmdResetEvent2;
		PFN_vkCmdWaitEvents2 vkCmdWaitEvents2;
		PFN_vkCmdPipelineBarrier2 vkCmdPipelineBarrier2;
		PFN_vkCmdWriteTimestamp2 vkCmdWriteTimestamp2;
		PFN_vkQueueSubmit2 vkQueueSubmit2;
		PFN_vkCmdCopyBuffer2 vkCmdCopyBuffer2;
		PFN_vkCmdCopyImage2 vkCmdCopyImage2;
		PFN_vkCmdCopyBufferToImage2 vkCmdCopyBufferToImage2;
		PFN_vkCmdCopyImageToBuffer2 vkCmdCopyImageToBuffer2;
		PFN_vkCmdBlitImage2 vkCmdBlitImage2;
		PFN_vkCmdResolveImage2 vkCmdResolveImage2;
		PFN_vkCmdBeginRendering vkCmdBeginRendering;
		PFN_vkCmdEndRendering vkCmdEndRendering;
		PFN_vkCmdSetCullMode vkCmdSetCullMode;
		PFN_vkCmdSetFrontFace vkCmdSetFrontFace;
		PFN_vkCmdSetPrimitiveTopology vkCmdSetPrimitiveTopology;
		PFN_vkCmdSetViewportWithCount vkCmdSetViewportWithCount;
		PFN_vkCmdSetScissorWithCount vkCmdSetScissorWithCount;
		PFN_vkCmdBindVertexBuffers2 vkCmdBindVertexBuffers2;
		PFN_vkCmdSetDepthTestEnable vkCmdSetDepthTestEnable;
		PFN_vkCmdSetDepthWriteEnable vkCmdSetDepthWriteEnable;
		PFN_vkCmdSetDepthCompareOp vkCmdSetDepthCompareOp;
		PFN_vkCmdSetDepthBoundsTestEnable vkCmdSetDepthBoundsTestEnable;
		PFN_vkCmdSetStencilTestEnable vkCmdSetStencilTestEnable;
		PFN_vkCmdSetStencilOp vkCmdSetStencilOp;
		PFN_vkCmdSetRasterizerDiscardEnable vkCmdSetRasterizerDiscardEnable;
		PFN_vkCmdSetDepthBiasEnable vkCmdSetDepthBiasEnable;
		PFN_vkCmdSetPrimitiveRestartEnable vkCmdSetPrimitiveRestartEnable;
		PFN_vkGetDeviceBufferMemoryRequirements vkGetDeviceBufferMemoryRequirements;
		PFN_vkGetDeviceImageMemoryRequirements vkGetDeviceImageMemoryRequirements;
		PFN_vkGetDeviceImageSparseMemoryRequirements vkGetDeviceImageSparseMemoryRequirements;
		PFN_vkGetCommandPoolMemoryConsumption vkGetCommandPoolMemoryConsumption;
		PFN_vkGetFaultData vkGetFaultData;
		PFN_vkDestroySurfaceKHR vkDestroySurfaceKHR;
		PFN_vkGetPhysicalDeviceSurfaceSupportKHR vkGetPhysicalDeviceSurfaceSupportKHR;
		PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
		PFN_vkGetPhysicalDeviceSurfaceFormatsKHR vkGetPhysicalDeviceSurfaceFormatsKHR;
		PFN_vkGetPhysicalDeviceSurfacePresentModesKHR vkGetPhysicalDeviceSurfacePresentModesKHR;
		PFN_vkCreateSwapchainKHR vkCreateSwapchainKHR;
		PFN_vkDestroySwapchainKHR vkDestroySwapchainKHR;
		PFN_vkGetSwapchainImagesKHR vkGetSwapchainImagesKHR;
		PFN_vkAcquireNextImageKHR vkAcquireNextImageKHR;
		PFN_vkQueuePresentKHR vkQueuePresentKHR;
		PFN_vkGetDeviceGroupPresentCapabilitiesKHR vkGetDeviceGroupPresentCapabilitiesKHR;
		PFN_vkGetDeviceGroupSurfacePresentModesKHR vkGetDeviceGroupSurfacePresentModesKHR;
		PFN_vkGetPhysicalDevicePresentRectanglesKHR vkGetPhysicalDevicePresentRectanglesKHR;
		PFN_vkAcquireNextImage2KHR vkAcquireNextImage2KHR;
		PFN_vkGetPhysicalDeviceDisplayPropertiesKHR vkGetPhysicalDeviceDisplayPropertiesKHR;
		PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
		PFN_vkGetDisplayPlaneSupportedDisplaysKHR vkGetDisplayPlaneSupportedDisplaysKHR;
		PFN_vkGetDisplayModePropertiesKHR vkGetDisplayModePropertiesKHR;
		PFN_vkCreateDisplayModeKHR vkCreateDisplayModeKHR;
		PFN_vkGetDisplayPlaneCapabilitiesKHR vkGetDisplayPlaneCapabilitiesKHR;
		PFN_vkCreateDisplayPlaneSurfaceKHR vkCreateDisplayPlaneSurfaceKHR;
		PFN_vkCreateSharedSwapchainsKHR vkCreateSharedSwapchainsKHR;
		PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR vkGetPhysicalDeviceVideoCapabilitiesKHR;
		PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR vkGetPhysicalDeviceVideoFormatPropertiesKHR;
		PFN_vkCreateVideoSessionKHR vkCreateVideoSessionKHR;
		PFN_vkDestroyVideoSessionKHR vkDestroyVideoSessionKHR;
		PFN_vkGetVideoSessionMemoryRequirementsKHR vkGetVideoSessionMemoryRequirementsKHR;
		PFN_vkBindVideoSessionMemoryKHR vkBindVideoSessionMemoryKHR;
		PFN_vkCreateVideoSessionParametersKHR vkCreateVideoSessionParametersKHR;
		PFN_vkUpdateVideoSessionParametersKHR vkUpdateVideoSessionParametersKHR;
		PFN_vkDestroyVideoSessionParametersKHR vkDestroyVideoSessionParametersKHR;
		PFN_vkCmdBeginVideoCodingKHR vkCmdBeginVideoCodingKHR;
		PFN_vkCmdEndVideoCodingKHR vkCmdEndVideoCodingKHR;
		PFN_vkCmdControlVideoCodingKHR vkCmdControlVideoCodingKHR;
		PFN_vkCmdDecodeVideoKHR vkCmdDecodeVideoKHR;
		PFN_vkCmdBindTransformFeedbackBuffersEXT vkCmdBindTransformFeedbackBuffersEXT;
		PFN_vkCmdBeginTransformFeedbackEXT vkCmdBeginTransformFeedbackEXT;
		PFN_vkCmdEndTransformFeedbackEXT vkCmdEndTransformFeedbackEXT;
		PFN_vkCmdBeginQueryIndexedEXT vkCmdBeginQueryIndexedEXT;
		PFN_vkCmdEndQueryIndexedEXT vkCmdEndQueryIndexedEXT;
		PFN_vkCmdDrawIndirectByteCountEXT vkCmdDrawIndirectByteCountEXT;
		PFN_vkCreateCuModuleNVX vkCreateCuModuleNVX;
		PFN_vkCreateCuFunctionNVX vkCreateCuFunctionNVX;
		PFN_vkDestroyCuModuleNVX vkDestroyCuModuleNVX;
		PFN_vkDestroyCuFunctionNVX vkDestroyCuFunctionNVX;
		PFN_vkCmdCuLaunchKernelNVX vkCmdCuLaunchKernelNVX;
		PFN_vkGetImageViewHandleNVX vkGetImageViewHandleNVX;
		PFN_vkGetImageViewAddressNVX vkGetImageViewAddressNVX;
		PFN_vkGetShaderInfoAMD vkGetShaderInfoAMD;
		PFN_vkCmdBeginRenderingKHR vkCmdBeginRenderingKHR;
		PFN_vkCmdEndRenderingKHR vkCmdEndRenderingKHR;
		PFN_vkGetPhysicalDeviceFeatures2KHR vkGetPhysicalDeviceFeatures2KHR;
		PFN_vkGetPhysicalDeviceProperties2KHR vkGetPhysicalDeviceProperties2KHR;
		PFN_vkGetPhysicalDeviceFormatProperties2KHR vkGetPhysicalDeviceFormatProperties2KHR;
		PFN_vkGetPhysicalDeviceImageFormatProperties2KHR vkGetPhysicalDeviceImageFormatProperties2KHR;
		PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR vkGetPhysicalDeviceQueueFamilyProperties2KHR;
		PFN_vkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR;
		PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
		PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR vkGetDeviceGroupPeerMemoryFeaturesKHR;
		PFN_vkCmdSetDeviceMaskKHR vkCmdSetDeviceMaskKHR;
		PFN_vkCmdDispatchBaseKHR vkCmdDispatchBaseKHR;
		PFN_vkTrimCommandPoolKHR vkTrimCommandPoolKHR;
		PFN_vkEnumeratePhysicalDeviceGroupsKHR vkEnumeratePhysicalDeviceGroupsKHR;
		PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR vkGetPhysicalDeviceExternalBufferPropertiesKHR;
		PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
		PFN_vkGetMemoryFdKHR vkGetMemoryFdKHR;
		PFN_vkGetMemoryFdPropertiesKHR vkGetMemoryFdPropertiesKHR;
		PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
		PFN_vkImportSemaphoreFdKHR vkImportSemaphoreFdKHR;
		PFN_vkGetSemaphoreFdKHR vkGetSemaphoreFdKHR;
		PFN_vkCmdPushDescriptorSetKHR vkCmdPushDescriptorSetKHR;
		PFN_vkCmdPushDescriptorSetWithTemplateKHR vkCmdPushDescriptorSetWithTemplateKHR;
		PFN_vkCmdBeginConditionalRenderingEXT vkCmdBeginConditionalRenderingEXT;
		PFN_vkCmdEndConditionalRenderingEXT vkCmdEndConditionalRenderingEXT;
		PFN_vkCreateDescriptorUpdateTemplateKHR vkCreateDescriptorUpdateTemplateKHR;
		PFN_vkDestroyDescriptorUpdateTemplateKHR vkDestroyDescriptorUpdateTemplateKHR;
		PFN_vkUpdateDescriptorSetWithTemplateKHR vkUpdateDescriptorSetWithTemplateKHR;
		PFN_vkCmdSetViewportWScalingNV vkCmdSetViewportWScalingNV;
		PFN_vkReleaseDisplayEXT vkReleaseDisplayEXT;
		PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT vkGetPhysicalDeviceSurfaceCapabilities2EXT;
		PFN_vkDisplayPowerControlEXT vkDisplayPowerControlEXT;
		PFN_vkRegisterDeviceEventEXT vkRegisterDeviceEventEXT;
		PFN_vkRegisterDisplayEventEXT vkRegisterDisplayEventEXT;
		PFN_vkGetSwapchainCounterEXT vkGetSwapchainCounterEXT;
		PFN_vkGetRefreshCycleDurationGOOGLE vkGetRefreshCycleDurationGOOGLE;
		PFN_vkGetPastPresentationTimingGOOGLE vkGetPastPresentationTimingGOOGLE;
		PFN_vkCmdSetDiscardRectangleEXT vkCmdSetDiscardRectangleEXT;
		PFN_vkCmdSetDiscardRectangleEnableEXT vkCmdSetDiscardRectangleEnableEXT;
		PFN_vkCmdSetDiscardRectangleModeEXT vkCmdSetDiscardRectangleModeEXT;
		PFN_vkSetHdrMetadataEXT vkSetHdrMetadataEXT;
		PFN_vkCreateRenderPass2KHR vkCreateRenderPass2KHR;
		PFN_vkCmdBeginRenderPass2KHR vkCmdBeginRenderPass2KHR;
		PFN_vkCmdNextSubpass2KHR vkCmdNextSubpass2KHR;
		PFN_vkCmdEndRenderPass2KHR vkCmdEndRenderPass2KHR;
		PFN_vkGetSwapchainStatusKHR vkGetSwapchainStatusKHR;
		PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR vkGetPhysicalDeviceExternalFencePropertiesKHR;
		PFN_vkImportFenceFdKHR vkImportFenceFdKHR;
		PFN_vkGetFenceFdKHR vkGetFenceFdKHR;
		PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
		PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
		PFN_vkAcquireProfilingLockKHR vkAcquireProfilingLockKHR;
		PFN_vkReleaseProfilingLockKHR vkReleaseProfilingLockKHR;
		PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR vkGetPhysicalDeviceSurfaceCapabilities2KHR;
		PFN_vkGetPhysicalDeviceSurfaceFormats2KHR vkGetPhysicalDeviceSurfaceFormats2KHR;
		PFN_vkGetPhysicalDeviceDisplayProperties2KHR vkGetPhysicalDeviceDisplayProperties2KHR;
		PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
		PFN_vkGetDisplayModeProperties2KHR vkGetDisplayModeProperties2KHR;
		PFN_vkGetDisplayPlaneCapabilities2KHR vkGetDisplayPlaneCapabilities2KHR;
		PFN_vkSetDebugUtilsObjectNameEXT vkSetDebugUtilsObjectNameEXT;
		PFN_vkSetDebugUtilsObjectTagEXT vkSetDebugUtilsObjectTagEXT;
		PFN_vkQueueBeginDebugUtilsLabelEXT vkQueueBeginDebugUtilsLabelEXT;
		PFN_vkQueueEndDebugUtilsLabelEXT vkQueueEndDebugUtilsLabelEXT;
		PFN_vkQueueInsertDebugUtilsLabelEXT vkQueueInsertDebugUtilsLabelEXT;
		PFN_vkCmdBeginDebugUtilsLabelEXT vkCmdBeginDebugUtilsLabelEXT;
		PFN_vkCmdEndDebugUtilsLabelEXT vkCmdEndDebugUtilsLabelEXT;
		PFN_vkCmdInsertDebugUtilsLabelEXT vkCmdInsertDebugUtilsLabelEXT;
		PFN_vkCreateDebugUtilsMessengerEXT vkCreateDebugUtilsMessengerEXT;
		PFN_vkDestroyDebugUtilsMessengerEXT vkDestroyDebugUtilsMessengerEXT;
		PFN_vkSubmitDebugUtilsMessageEXT vkSubmitDebugUtilsMessageEXT;
		PFN_vkDebugMarkerSetObjectTagEXT vkDebugMarkerSetObjectTagEXT;
		PFN_vkDebugMarkerSetObjectNameEXT vkDebugMarkerSetObjectNameEXT;
		PFN_vkCmdDebugMarkerBeginEXT vkCmdDebugMarkerBeginEXT;
		PFN_vkCmdDebugMarkerEndEXT vkCmdDebugMarkerEndEXT;
		PFN_vkCmdDebugMarkerInsertEXT vkCmdDebugMarkerInsertEXT;
		PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT;
		PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT;
		PFN_vkDebugReportMessageEXT vkDebugReportMessageEXT;
		PFN_vkCmdSetSampleLocationsEXT vkCmdSetSampleLocationsEXT;
		PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT vkGetPhysicalDeviceMultisamplePropertiesEXT;
		PFN_vkGetImageMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR;
		PFN_vkGetBufferMemoryRequirements2KHR vkGetBufferMemoryRequirements2KHR;
		PFN_vkGetImageSparseMemoryRequirements2KHR vkGetImageSparseMemoryRequirements2KHR;
		PFN_vkCreateAccelerationStructureKHR vkCreateAccelerationStructureKHR;
		PFN_vkDestroyAccelerationStructureKHR vkDestroyAccelerationStructureKHR;
		PFN_vkCmdBuildAccelerationStructuresKHR vkCmdBuildAccelerationStructuresKHR;
		PFN_vkCmdBuildAccelerationStructuresIndirectKHR vkCmdBuildAccelerationStructuresIndirectKHR;
		PFN_vkBuildAccelerationStructuresKHR vkBuildAccelerationStructuresKHR;
		PFN_vkCopyAccelerationStructureKHR vkCopyAccelerationStructureKHR;
		PFN_vkCopyAccelerationStructureToMemoryKHR vkCopyAccelerationStructureToMemoryKHR;
		PFN_vkCopyMemoryToAccelerationStructureKHR vkCopyMemoryToAccelerationStructureKHR;
		PFN_vkWriteAccelerationStructuresPropertiesKHR vkWriteAccelerationStructuresPropertiesKHR;
		PFN_vkCmdCopyAccelerationStructureKHR vkCmdCopyAccelerationStructureKHR;
		PFN_vkCmdCopyAccelerationStructureToMemoryKHR vkCmdCopyAccelerationStructureToMemoryKHR;
		PFN_vkCmdCopyMemoryToAccelerationStructureKHR vkCmdCopyMemoryToAccelerationStructureKHR;
		PFN_vkGetAccelerationStructureDeviceAddressKHR vkGetAccelerationStructureDeviceAddressKHR;
		PFN_vkCmdWriteAccelerationStructuresPropertiesKHR vkCmdWriteAccelerationStructuresPropertiesKHR;
		PFN_vkGetDeviceAccelerationStructureCompatibilityKHR vkGetDeviceAccelerationStructureCompatibilityKHR;
		PFN_vkGetAccelerationStructureBuildSizesKHR vkGetAccelerationStructureBuildSizesKHR;
		PFN_vkCmdTraceRaysKHR vkCmdTraceRaysKHR;
		PFN_vkCreateRayTracingPipelinesKHR vkCreateRayTracingPipelinesKHR;
		PFN_vkGetRayTracingShaderGroupHandlesKHR vkGetRayTracingShaderGroupHandlesKHR;
		PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
		PFN_vkCmdTraceRaysIndirectKHR vkCmdTraceRaysIndirectKHR;
		PFN_vkGetRayTracingShaderGroupStackSizeKHR vkGetRayTracingShaderGroupStackSizeKHR;
		PFN_vkCmdSetRayTracingPipelineStackSizeKHR vkCmdSetRayTracingPipelineStackSizeKHR;
		PFN_vkCreateSamplerYcbcrConversionKHR vkCreateSamplerYcbcrConversionKHR;
		PFN_vkDestroySamplerYcbcrConversionKHR vkDestroySamplerYcbcrConversionKHR;
		PFN_vkBindBufferMemory2KHR vkBindBufferMemory2KHR;
		PFN_vkBindImageMemory2KHR vkBindImageMemory2KHR;
		PFN_vkGetImageDrmFormatModifierPropertiesEXT vkGetImageDrmFormatModifierPropertiesEXT;
		PFN_vkCreateValidationCacheEXT vkCreateValidationCacheEXT;
		PFN_vkDestroyValidationCacheEXT vkDestroyValidationCacheEXT;
		PFN_vkMergeValidationCachesEXT vkMergeValidationCachesEXT;
		PFN_vkGetValidationCacheDataEXT vkGetValidationCacheDataEXT;
		PFN_vkCmdBindShadingRateImageNV vkCmdBindShadingRateImageNV;
		PFN_vkCmdSetViewportShadingRatePaletteNV vkCmdSetViewportShadingRatePaletteNV;
		PFN_vkCmdSetCoarseSampleOrderNV vkCmdSetCoarseSampleOrderNV;
		PFN_vkCreateAccelerationStructureNV vkCreateAccelerationStructureNV;
		PFN_vkDestroyAccelerationStructureNV vkDestroyAccelerationStructureNV;
		PFN_vkGetAccelerationStructureMemoryRequirementsNV vkGetAccelerationStructureMemoryRequirementsNV;
		PFN_vkBindAccelerationStructureMemoryNV vkBindAccelerationStructureMemoryNV;
		PFN_vkCmdBuildAccelerationStructureNV vkCmdBuildAccelerationStructureNV;
		PFN_vkCmdCopyAccelerationStructureNV vkCmdCopyAccelerationStructureNV;
		PFN_vkCmdTraceRaysNV vkCmdTraceRaysNV;
		PFN_vkCreateRayTracingPipelinesNV vkCreateRayTracingPipelinesNV;
		PFN_vkGetRayTracingShaderGroupHandlesNV vkGetRayTracingShaderGroupHandlesNV;
		PFN_vkGetAccelerationStructureHandleNV vkGetAccelerationStructureHandleNV;
		PFN_vkCmdWriteAccelerationStructuresPropertiesNV vkCmdWriteAccelerationStructuresPropertiesNV;
		PFN_vkCompileDeferredNV vkCompileDeferredNV;
		PFN_vkGetDescriptorSetLayoutSupportKHR vkGetDescriptorSetLayoutSupportKHR;
		PFN_vkCmdDrawIndirectCountKHR vkCmdDrawIndirectCountKHR;
		PFN_vkCmdDrawIndexedIndirectCountKHR vkCmdDrawIndexedIndirectCountKHR;
		PFN_vkCmdDrawIndirectCountAMD vkCmdDrawIndirectCountAMD;
		PFN_vkCmdDrawIndexedIndirectCountAMD vkCmdDrawIndexedIndirectCountAMD;
		PFN_vkGetMemoryHostPointerPropertiesEXT vkGetMemoryHostPointerPropertiesEXT;
		PFN_vkCmdWriteBufferMarkerAMD vkCmdWriteBufferMarkerAMD;
		PFN_vkCmdDrawMeshTasksNV vkCmdDrawMeshTasksNV;
		PFN_vkCmdDrawMeshTasksIndirectNV vkCmdDrawMeshTasksIndirectNV;
		PFN_vkCmdDrawMeshTasksIndirectCountNV vkCmdDrawMeshTasksIndirectCountNV;
		PFN_vkCmdSetExclusiveScissorEnableNV vkCmdSetExclusiveScissorEnableNV;
		PFN_vkCmdSetExclusiveScissorNV vkCmdSetExclusiveScissorNV;
		PFN_vkCmdSetCheckpointNV vkCmdSetCheckpointNV;
		PFN_vkGetQueueCheckpointDataNV vkGetQueueCheckpointDataNV;
		PFN_vkGetSemaphoreCounterValueKHR vkGetSemaphoreCounterValueKHR;
		PFN_vkWaitSemaphoresKHR vkWaitSemaphoresKHR;
		PFN_vkSignalSemaphoreKHR vkSignalSemaphoreKHR;
		PFN_vkInitializePerformanceApiINTEL vkInitializePerformanceApiINTEL;
		PFN_vkUninitializePerformanceApiINTEL vkUninitializePerformanceApiINTEL;
		PFN_vkCmdSetPerformanceMarkerINTEL vkCmdSetPerformanceMarkerINTEL;
		PFN_vkCmdSetPerformanceStreamMarkerINTEL vkCmdSetPerformanceStreamMarkerINTEL;
		PFN_vkCmdSetPerformanceOverrideINTEL vkCmdSetPerformanceOverrideINTEL;
		PFN_vkAcquirePerformanceConfigurationINTEL vkAcquirePerformanceConfigurationINTEL;
		PFN_vkReleasePerformanceConfigurationINTEL vkReleasePerformanceConfigurationINTEL;
		PFN_vkQueueSetPerformanceConfigurationINTEL vkQueueSetPerformanceConfigurationINTEL;
		PFN_vkGetPerformanceParameterINTEL vkGetPerformanceParameterINTEL;
		PFN_vkSetLocalDimmingAMD vkSetLocalDimmingAMD;
		PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR vkGetPhysicalDeviceFragmentShadingRatesKHR;
		PFN_vkCmdSetFragmentShadingRateKHR vkCmdSetFragmentShadingRateKHR;
		PFN_vkCmdSetRenderingAttachmentLocationsKHR vkCmdSetRenderingAttachmentLocationsKHR;
		PFN_vkCmdSetRenderingInputAttachmentIndicesKHR vkCmdSetRenderingInputAttachmentIndicesKHR;
		PFN_vkGetPhysicalDeviceToolPropertiesEXT vkGetPhysicalDeviceToolPropertiesEXT;
		PFN_vkWaitForPresentKHR vkWaitForPresentKHR;
		PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV vkGetPhysicalDeviceCooperativeMatrixPropertiesNV;
		PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
		PFN_vkCreateHeadlessSurfaceEXT vkCreateHeadlessSurfaceEXT;
		PFN_vkGetBufferDeviceAddressKHR vkGetBufferDeviceAddressKHR;
		PFN_vkGetBufferOpaqueCaptureAddressKHR vkGetBufferOpaqueCaptureAddressKHR;
		PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR vkGetDeviceMemoryOpaqueCaptureAddressKHR;
		PFN_vkGetBufferDeviceAddressEXT vkGetBufferDeviceAddressEXT;
		PFN_vkResetQueryPoolEXT vkResetQueryPoolEXT;
		PFN_vkCmdSetCullModeEXT vkCmdSetCullModeEXT;
		PFN_vkCmdSetFrontFaceEXT vkCmdSetFrontFaceEXT;
		PFN_vkCmdSetPrimitiveTopologyEXT vkCmdSetPrimitiveTopologyEXT;
		PFN_vkCmdSetViewportWithCountEXT vkCmdSetViewportWithCountEXT;
		PFN_vkCmdSetScissorWithCountEXT vkCmdSetScissorWithCountEXT;
		PFN_vkCmdBindVertexBuffers2EXT vkCmdBindVertexBuffers2EXT;
		PFN_vkCmdSetDepthTestEnableEXT vkCmdSetDepthTestEnableEXT;
		PFN_vkCmdSetDepthWriteEnableEXT vkCmdSetDepthWriteEnableEXT;
		PFN_vkCmdSetDepthCompareOpEXT vkCmdSetDepthCompareOpEXT;
		PFN_vkCmdSetDepthBoundsTestEnableEXT vkCmdSetDepthBoundsTestEnableEXT;
		PFN_vkCmdSetStencilTestEnableEXT vkCmdSetStencilTestEnableEXT;
		PFN_vkCmdSetStencilOpEXT vkCmdSetStencilOpEXT;
		PFN_vkCreateDeferredOperationKHR vkCreateDeferredOperationKHR;
		PFN_vkDestroyDeferredOperationKHR vkDestroyDeferredOperationKHR;
		PFN_vkGetDeferredOperationMaxConcurrencyKHR vkGetDeferredOperationMaxConcurrencyKHR;
		PFN_vkGetDeferredOperationResultKHR vkGetDeferredOperationResultKHR;
		PFN_vkDeferredOperationJoinKHR vkDeferredOperationJoinKHR;
		PFN_vkGetPipelineExecutablePropertiesKHR vkGetPipelineExecutablePropertiesKHR;
		PFN_vkGetPipelineExecutableStatisticsKHR vkGetPipelineExecutableStatisticsKHR;
		PFN_vkGetPipelineExecutableInternalRepresentationsKHR vkGetPipelineExecutableInternalRepresentationsKHR;
		PFN_vkCopyMemoryToImageEXT vkCopyMemoryToImageEXT;
		PFN_vkCopyImageToMemoryEXT vkCopyImageToMemoryEXT;
		PFN_vkCopyImageToImageEXT vkCopyImageToImageEXT;
		PFN_vkTransitionImageLayoutEXT vkTransitionImageLayoutEXT;
		PFN_vkGetImageSubresourceLayout2EXT vkGetImageSubresourceLayout2EXT;
		PFN_vkMapMemory2KHR vkMapMemory2KHR;
		PFN_vkUnmapMemory2KHR vkUnmapMemory2KHR;
		PFN_vkReleaseSwapchainImagesEXT vkReleaseSwapchainImagesEXT;
		PFN_vkGetGeneratedCommandsMemoryRequirementsNV vkGetGeneratedCommandsMemoryRequirementsNV;
		PFN_vkCmdPreprocessGeneratedCommandsNV vkCmdPreprocessGeneratedCommandsNV;
		PFN_vkCmdExecuteGeneratedCommandsNV vkCmdExecuteGeneratedCommandsNV;
		PFN_vkCmdBindPipelineShaderGroupNV vkCmdBindPipelineShaderGroupNV;
		PFN_vkCreateIndirectCommandsLayoutNV vkCreateIndirectCommandsLayoutNV;
		PFN_vkDestroyIndirectCommandsLayoutNV vkDestroyIndirectCommandsLayoutNV;
		PFN_vkCmdSetDepthBias2EXT vkCmdSetDepthBias2EXT;
		PFN_vkAcquireDrmDisplayEXT vkAcquireDrmDisplayEXT;
		PFN_vkGetDrmDisplayEXT vkGetDrmDisplayEXT;
		PFN_vkCreatePrivateDataSlotEXT vkCreatePrivateDataSlotEXT;
		PFN_vkDestroyPrivateDataSlotEXT vkDestroyPrivateDataSlotEXT;
		PFN_vkSetPrivateDataEXT vkSetPrivateDataEXT;
		PFN_vkGetPrivateDataEXT vkGetPrivateDataEXT;
		PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
		PFN_vkGetEncodedVideoSessionParametersKHR vkGetEncodedVideoSessionParametersKHR;
		PFN_vkCmdEncodeVideoKHR vkCmdEncodeVideoKHR;
		PFN_vkCreateCudaModuleNV vkCreateCudaModuleNV;
		PFN_vkGetCudaModuleCacheNV vkGetCudaModuleCacheNV;
		PFN_vkCreateCudaFunctionNV vkCreateCudaFunctionNV;
		PFN_vkDestroyCudaModuleNV vkDestroyCudaModuleNV;
		PFN_vkDestroyCudaFunctionNV vkDestroyCudaFunctionNV;
		PFN_vkCmdCudaLaunchKernelNV vkCmdCudaLaunchKernelNV;
		PFN_vkCmdRefreshObjectsKHR vkCmdRefreshObjectsKHR;
		PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR vkGetPhysicalDeviceRefreshableObjectTypesKHR;
		PFN_vkCmdSetEvent2KHR vkCmdSetEvent2KHR;
		PFN_vkCmdResetEvent2KHR vkCmdResetEvent2KHR;
		PFN_vkCmdWaitEvents2KHR vkCmdWaitEvents2KHR;
		PFN_vkCmdPipelineBarrier2KHR vkCmdPipelineBarrier2KHR;
		PFN_vkCmdWriteTimestamp2KHR vkCmdWriteTimestamp2KHR;
		PFN_vkQueueSubmit2KHR vkQueueSubmit2KHR;
		PFN_vkCmdWriteBufferMarker2AMD vkCmdWriteBufferMarker2AMD;
		PFN_vkGetQueueCheckpointData2NV vkGetQueueCheckpointData2NV;
		PFN_vkGetDescriptorSetLayoutSizeEXT vkGetDescriptorSetLayoutSizeEXT;
		PFN_vkGetDescriptorSetLayoutBindingOffsetEXT vkGetDescriptorSetLayoutBindingOffsetEXT;
		PFN_vkGetDescriptorEXT vkGetDescriptorEXT;
		PFN_vkCmdBindDescriptorBuffersEXT vkCmdBindDescriptorBuffersEXT;
		PFN_vkCmdSetDescriptorBufferOffsetsEXT vkCmdSetDescriptorBufferOffsetsEXT;
		PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT vkCmdBindDescriptorBufferEmbeddedSamplersEXT;
		PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT vkGetBufferOpaqueCaptureDescriptorDataEXT;
		PFN_vkGetImageOpaqueCaptureDescriptorDataEXT vkGetImageOpaqueCaptureDescriptorDataEXT;
		PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT vkGetImageViewOpaqueCaptureDescriptorDataEXT;
		PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT vkGetSamplerOpaqueCaptureDescriptorDataEXT;
		PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
		PFN_vkCmdSetFragmentShadingRateEnumNV vkCmdSetFragmentShadingRateEnumNV;
		PFN_vkCmdDrawMeshTasksEXT vkCmdDrawMeshTasksEXT;
		PFN_vkCmdDrawMeshTasksIndirectEXT vkCmdDrawMeshTasksIndirectEXT;
		PFN_vkCmdDrawMeshTasksIndirectCountEXT vkCmdDrawMeshTasksIndirectCountEXT;
		PFN_vkCmdCopyBuffer2KHR vkCmdCopyBuffer2KHR;
		PFN_vkCmdCopyImage2KHR vkCmdCopyImage2KHR;
		PFN_vkCmdCopyBufferToImage2KHR vkCmdCopyBufferToImage2KHR;
		PFN_vkCmdCopyImageToBuffer2KHR vkCmdCopyImageToBuffer2KHR;
		PFN_vkCmdBlitImage2KHR vkCmdBlitImage2KHR;
		PFN_vkCmdResolveImage2KHR vkCmdResolveImage2KHR;
		PFN_vkGetDeviceFaultInfoEXT vkGetDeviceFaultInfoEXT;
		PFN_vkCmdSetVertexInputEXT vkCmdSetVertexInputEXT;
		PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
		PFN_vkCmdSubpassShadingHUAWEI vkCmdSubpassShadingHUAWEI;
		PFN_vkCmdBindInvocationMaskHUAWEI vkCmdBindInvocationMaskHUAWEI;
		PFN_vkGetMemoryRemoteAddressNV vkGetMemoryRemoteAddressNV;
		PFN_vkGetPipelinePropertiesEXT vkGetPipelinePropertiesEXT;
		PFN_vkCmdSetPatchControlPointsEXT vkCmdSetPatchControlPointsEXT;
		PFN_vkCmdSetRasterizerDiscardEnableEXT vkCmdSetRasterizerDiscardEnableEXT;
		PFN_vkCmdSetDepthBiasEnableEXT vkCmdSetDepthBiasEnableEXT;
		PFN_vkCmdSetLogicOpEXT vkCmdSetLogicOpEXT;
		PFN_vkCmdSetPrimitiveRestartEnableEXT vkCmdSetPrimitiveRestartEnableEXT;
		PFN_vkCmdSetColorWriteEnableEXT vkCmdSetColorWriteEnableEXT;
		PFN_vkCmdTraceRaysIndirect2KHR vkCmdTraceRaysIndirect2KHR;
		PFN_vkCmdDrawMultiEXT vkCmdDrawMultiEXT;
		PFN_vkCmdDrawMultiIndexedEXT vkCmdDrawMultiIndexedEXT;
		PFN_vkCreateMicromapEXT vkCreateMicromapEXT;
		PFN_vkDestroyMicromapEXT vkDestroyMicromapEXT;
		PFN_vkCmdBuildMicromapsEXT vkCmdBuildMicromapsEXT;
		PFN_vkBuildMicromapsEXT vkBuildMicromapsEXT;
		PFN_vkCopyMicromapEXT vkCopyMicromapEXT;
		PFN_vkCopyMicromapToMemoryEXT vkCopyMicromapToMemoryEXT;
		PFN_vkCopyMemoryToMicromapEXT vkCopyMemoryToMicromapEXT;
		PFN_vkWriteMicromapsPropertiesEXT vkWriteMicromapsPropertiesEXT;
		PFN_vkCmdCopyMicromapEXT vkCmdCopyMicromapEXT;
		PFN_vkCmdCopyMicromapToMemoryEXT vkCmdCopyMicromapToMemoryEXT;
		PFN_vkCmdCopyMemoryToMicromapEXT vkCmdCopyMemoryToMicromapEXT;
		PFN_vkCmdWriteMicromapsPropertiesEXT vkCmdWriteMicromapsPropertiesEXT;
		PFN_vkGetDeviceMicromapCompatibilityEXT vkGetDeviceMicromapCompatibilityEXT;
		PFN_vkGetMicromapBuildSizesEXT vkGetMicromapBuildSizesEXT;
		PFN_vkCmdDrawClusterHUAWEI vkCmdDrawClusterHUAWEI;
		PFN_vkCmdDrawClusterIndirectHUAWEI vkCmdDrawClusterIndirectHUAWEI;
		PFN_vkSetDeviceMemoryPriorityEXT vkSetDeviceMemoryPriorityEXT;
		PFN_vkGetDeviceBufferMemoryRequirementsKHR vkGetDeviceBufferMemoryRequirementsKHR;
		PFN_vkGetDeviceImageMemoryRequirementsKHR vkGetDeviceImageMemoryRequirementsKHR;
		PFN_vkGetDeviceImageSparseMemoryRequirementsKHR vkGetDeviceImageSparseMemoryRequirementsKHR;
		PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE vkGetDescriptorSetLayoutHostMappingInfoVALVE;
		PFN_vkGetDescriptorSetHostMappingVALVE vkGetDescriptorSetHostMappingVALVE;
		PFN_vkCmdCopyMemoryIndirectNV vkCmdCopyMemoryIndirectNV;
		PFN_vkCmdCopyMemoryToImageIndirectNV vkCmdCopyMemoryToImageIndirectNV;
		PFN_vkCmdDecompressMemoryNV vkCmdDecompressMemoryNV;
		PFN_vkCmdDecompressMemoryIndirectCountNV vkCmdDecompressMemoryIndirectCountNV;
		PFN_vkGetPipelineIndirectMemoryRequirementsNV vkGetPipelineIndirectMemoryRequirementsNV;
		PFN_vkCmdUpdatePipelineIndirectBufferNV vkCmdUpdatePipelineIndirectBufferNV;
		PFN_vkGetPipelineIndirectDeviceAddressNV vkGetPipelineIndirectDeviceAddressNV;
		PFN_vkCmdSetDepthClampEnableEXT vkCmdSetDepthClampEnableEXT;
		PFN_vkCmdSetPolygonModeEXT vkCmdSetPolygonModeEXT;
		PFN_vkCmdSetRasterizationSamplesEXT vkCmdSetRasterizationSamplesEXT;
		PFN_vkCmdSetSampleMaskEXT vkCmdSetSampleMaskEXT;
		PFN_vkCmdSetAlphaToCoverageEnableEXT vkCmdSetAlphaToCoverageEnableEXT;
		PFN_vkCmdSetAlphaToOneEnableEXT vkCmdSetAlphaToOneEnableEXT;
		PFN_vkCmdSetLogicOpEnableEXT vkCmdSetLogicOpEnableEXT;
		PFN_vkCmdSetColorBlendEnableEXT vkCmdSetColorBlendEnableEXT;
		PFN_vkCmdSetColorBlendEquationEXT vkCmdSetColorBlendEquationEXT;
		PFN_vkCmdSetColorWriteMaskEXT vkCmdSetColorWriteMaskEXT;
		PFN_vkCmdSetTessellationDomainOriginEXT vkCmdSetTessellationDomainOriginEXT;
		PFN_vkCmdSetRasterizationStreamEXT vkCmdSetRasterizationStreamEXT;
		PFN_vkCmdSetConservativeRasterizationModeEXT vkCmdSetConservativeRasterizationModeEXT;
		PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT vkCmdSetExtraPrimitiveOverestimationSizeEXT;
		PFN_vkCmdSetDepthClipEnableEXT vkCmdSetDepthClipEnableEXT;
		PFN_vkCmdSetSampleLocationsEnableEXT vkCmdSetSampleLocationsEnableEXT;
		PFN_vkCmdSetColorBlendAdvancedEXT vkCmdSetColorBlendAdvancedEXT;
		PFN_vkCmdSetProvokingVertexModeEXT vkCmdSetProvokingVertexModeEXT;
		PFN_vkCmdSetLineRasterizationModeEXT vkCmdSetLineRasterizationModeEXT;
		PFN_vkCmdSetLineStippleEnableEXT vkCmdSetLineStippleEnableEXT;
		PFN_vkCmdSetDepthClipNegativeOneToOneEXT vkCmdSetDepthClipNegativeOneToOneEXT;
		PFN_vkCmdSetViewportWScalingEnableNV vkCmdSetViewportWScalingEnableNV;
		PFN_vkCmdSetViewportSwizzleNV vkCmdSetViewportSwizzleNV;
		PFN_vkCmdSetCoverageToColorEnableNV vkCmdSetCoverageToColorEnableNV;
		PFN_vkCmdSetCoverageToColorLocationNV vkCmdSetCoverageToColorLocationNV;
		PFN_vkCmdSetCoverageModulationModeNV vkCmdSetCoverageModulationModeNV;
		PFN_vkCmdSetCoverageModulationTableEnableNV vkCmdSetCoverageModulationTableEnableNV;
		PFN_vkCmdSetCoverageModulationTableNV vkCmdSetCoverageModulationTableNV;
		PFN_vkCmdSetShadingRateImageEnableNV vkCmdSetShadingRateImageEnableNV;
		PFN_vkCmdSetRepresentativeFragmentTestEnableNV vkCmdSetRepresentativeFragmentTestEnableNV;
		PFN_vkCmdSetCoverageReductionModeNV vkCmdSetCoverageReductionModeNV;
		PFN_vkGetShaderModuleIdentifierEXT vkGetShaderModuleIdentifierEXT;
		PFN_vkGetShaderModuleCreateInfoIdentifierEXT vkGetShaderModuleCreateInfoIdentifierEXT;
		PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV vkGetPhysicalDeviceOpticalFlowImageFormatsNV;
		PFN_vkCreateOpticalFlowSessionNV vkCreateOpticalFlowSessionNV;
		PFN_vkDestroyOpticalFlowSessionNV vkDestroyOpticalFlowSessionNV;
		PFN_vkBindOpticalFlowSessionImageNV vkBindOpticalFlowSessionImageNV;
		PFN_vkCmdOpticalFlowExecuteNV vkCmdOpticalFlowExecuteNV;
		PFN_vkCmdBindIndexBuffer2KHR vkCmdBindIndexBuffer2KHR;
		PFN_vkGetRenderingAreaGranularityKHR vkGetRenderingAreaGranularityKHR;
		PFN_vkGetDeviceImageSubresourceLayoutKHR vkGetDeviceImageSubresourceLayoutKHR;
		PFN_vkGetImageSubresourceLayout2KHR vkGetImageSubresourceLayout2KHR;
		PFN_vkCreateShadersEXT vkCreateShadersEXT;
		PFN_vkDestroyShaderEXT vkDestroyShaderEXT;
		PFN_vkGetShaderBinaryDataEXT vkGetShaderBinaryDataEXT;
		PFN_vkCmdBindShadersEXT vkCmdBindShadersEXT;
		PFN_vkGetFramebufferTilePropertiesQCOM vkGetFramebufferTilePropertiesQCOM;
		PFN_vkGetDynamicRenderingTilePropertiesQCOM vkGetDynamicRenderingTilePropertiesQCOM;
		PFN_vkSetLatencySleepModeNV vkSetLatencySleepModeNV;
		PFN_vkLatencySleepNV vkLatencySleepNV;
		PFN_vkSetLatencyMarkerNV vkSetLatencyMarkerNV;
		PFN_vkGetLatencyTimingsNV vkGetLatencyTimingsNV;
		PFN_vkQueueNotifyOutOfBandNV vkQueueNotifyOutOfBandNV;
		PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR;
		PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT vkCmdSetAttachmentFeedbackLoopEnableEXT;
		PFN_vkCmdSetLineStippleKHR vkCmdSetLineStippleKHR;
		PFN_vkCmdSetLineStippleEXT vkCmdSetLineStippleEXT;
		PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
		PFN_vkGetCalibratedTimestampsKHR vkGetCalibratedTimestampsKHR;
		PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT vkGetPhysicalDeviceCalibrateableTimeDomainsEXT;
		PFN_vkGetCalibratedTimestampsEXT vkGetCalibratedTimestampsEXT;
		PFN_vkCmdBindDescriptorSets2KHR vkCmdBindDescriptorSets2KHR;
		PFN_vkCmdPushConstants2KHR vkCmdPushConstants2KHR;
		PFN_vkCmdPushDescriptorSet2KHR vkCmdPushDescriptorSet2KHR;
		PFN_vkCmdPushDescriptorSetWithTemplate2KHR vkCmdPushDescriptorSetWithTemplate2KHR;
		PFN_vkCmdSetDescriptorBufferOffsets2EXT vkCmdSetDescriptorBufferOffsets2EXT;
		PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT vkCmdBindDescriptorBufferEmbeddedSamplers2EXT;
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		PFN_vkCreateXlibSurfaceKHR vkCreateXlibSurfaceKHR;
		PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR vkGetPhysicalDeviceXlibPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		PFN_vkAcquireXlibDisplayEXT vkAcquireXlibDisplayEXT;
		PFN_vkGetRandROutputDisplayEXT vkGetRandROutputDisplayEXT;
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		PFN_vkCreateXcbSurfaceKHR vkCreateXcbSurfaceKHR;
		PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR vkGetPhysicalDeviceXcbPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		PFN_vkCreateWaylandSurfaceKHR vkCreateWaylandSurfaceKHR;
		PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR vkGetPhysicalDeviceWaylandPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		PFN_vkCreateDirectFBSurfaceEXT vkCreateDirectFBSurfaceEXT;
		PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		PFN_vkCreateAndroidSurfaceKHR vkCreateAndroidSurfaceKHR;
		PFN_vkGetAndroidHardwareBufferPropertiesANDROID vkGetAndroidHardwareBufferPropertiesANDROID;
		PFN_vkGetMemoryAndroidHardwareBufferANDROID vkGetMemoryAndroidHardwareBufferANDROID;
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR;
		PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR vkGetPhysicalDeviceWin32PresentationSupportKHR;
		PFN_vkGetMemoryWin32HandleKHR vkGetMemoryWin32HandleKHR;
		PFN_vkGetMemoryWin32HandlePropertiesKHR vkGetMemoryWin32HandlePropertiesKHR;
		PFN_vkGetMemoryWin32HandleNV vkGetMemoryWin32HandleNV;
		PFN_vkImportSemaphoreWin32HandleKHR vkImportSemaphoreWin32HandleKHR;
		PFN_vkGetSemaphoreWin32HandleKHR vkGetSemaphoreWin32HandleKHR;
		PFN_vkImportFenceWin32HandleKHR vkImportFenceWin32HandleKHR;
		PFN_vkGetFenceWin32HandleKHR vkGetFenceWin32HandleKHR;
		PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT vkGetPhysicalDeviceSurfacePresentModes2EXT;
		PFN_vkAcquireFullScreenExclusiveModeEXT vkAcquireFullScreenExclusiveModeEXT;
		PFN_vkReleaseFullScreenExclusiveModeEXT vkReleaseFullScreenExclusiveModeEXT;
		PFN_vkGetDeviceGroupSurfacePresentModes2EXT vkGetDeviceGroupSurfacePresentModes2EXT;
		PFN_vkAcquireWinrtDisplayNV vkAcquireWinrtDisplayNV;
		PFN_vkGetWinrtDisplayNV vkGetWinrtDisplayNV;
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		PFN_vkCreateViSurfaceNN vkCreateViSurfaceNN;
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		PFN_vkCreateIOSSurfaceMVK vkCreateIOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		PFN_vkCreateMacOSSurfaceMVK vkCreateMacOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		PFN_vkCreateMetalSurfaceEXT vkCreateMetalSurfaceEXT;
		PFN_vkExportMetalObjectsEXT vkExportMetalObjectsEXT;
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		PFN_vkCreateImagePipeSurfaceFUCHSIA vkCreateImagePipeSurfaceFUCHSIA;
		PFN_vkGetMemoryZirconHandleFUCHSIA vkGetMemoryZirconHandleFUCHSIA;
		PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA vkGetMemoryZirconHandlePropertiesFUCHSIA;
		PFN_vkImportSemaphoreZirconHandleFUCHSIA vkImportSemaphoreZirconHandleFUCHSIA;
		PFN_vkGetSemaphoreZirconHandleFUCHSIA vkGetSemaphoreZirconHandleFUCHSIA;
		PFN_vkCreateBufferCollectionFUCHSIA vkCreateBufferCollectionFUCHSIA;
		PFN_vkSetBufferCollectionImageConstraintsFUCHSIA vkSetBufferCollectionImageConstraintsFUCHSIA;
		PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA vkSetBufferCollectionBufferConstraintsFUCHSIA;
		PFN_vkDestroyBufferCollectionFUCHSIA vkDestroyBufferCollectionFUCHSIA;
		PFN_vkGetBufferCollectionPropertiesFUCHSIA vkGetBufferCollectionPropertiesFUCHSIA;
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		PFN_vkCreateStreamDescriptorSurfaceGGP vkCreateStreamDescriptorSurfaceGGP;
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		PFN_vkGetMemorySciBufNV vkGetMemorySciBufNV;
		PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV;
		PFN_vkGetPhysicalDeviceSciBufAttributesNV vkGetPhysicalDeviceSciBufAttributesNV;
		PFN_vkCreateSemaphoreSciSyncPoolNV vkCreateSemaphoreSciSyncPoolNV;
		PFN_vkDestroySemaphoreSciSyncPoolNV vkDestroySemaphoreSciSyncPoolNV;
		PFN_vkGetFenceSciSyncFenceNV vkGetFenceSciSyncFenceNV;
		PFN_vkGetFenceSciSyncObjNV vkGetFenceSciSyncObjNV;
		PFN_vkImportFenceSciSyncFenceNV vkImportFenceSciSyncFenceNV;
		PFN_vkImportFenceSciSyncObjNV vkImportFenceSciSyncObjNV;
		PFN_vkGetPhysicalDeviceSciSyncAttributesNV vkGetPhysicalDeviceSciSyncAttributesNV;
		PFN_vkGetSemaphoreSciSyncObjNV vkGetSemaphoreSciSyncObjNV;
		PFN_vkImportSemaphoreSciSyncObjNV vkImportSemaphoreSciSyncObjNV;
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		PFN_vkCreateExecutionGraphPipelinesAMDX vkCreateExecutionGraphPipelinesAMDX;
		PFN_vkGetExecutionGraphPipelineScratchSizeAMDX vkGetExecutionGraphPipelineScratchSizeAMDX;
		PFN_vkGetExecutionGraphPipelineNodeIndexAMDX vkGetExecutionGraphPipelineNodeIndexAMDX;
		PFN_vkCmdInitializeGraphScratchMemoryAMDX vkCmdInitializeGraphScratchMemoryAMDX;
		PFN_vkCmdDispatchGraphAMDX vkCmdDispatchGraphAMDX;
		PFN_vkCmdDispatchGraphIndirectAMDX vkCmdDispatchGraphIndirectAMDX;
		PFN_vkCmdDispatchGraphIndirectCountAMDX vkCmdDispatchGraphIndirectCountAMDX;
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		PFN_vkCreateScreenSurfaceQNX vkCreateScreenSurfaceQNX;
		PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX vkGetPhysicalDeviceScreenPresentationSupportQNX;
		PFN_vkGetScreenBufferPropertiesQNX vkGetScreenBufferPropertiesQNX;
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/
		#endif /*VKBIND_NO_GLOBAL_API*/

		typedef void* VkbHandle;
		typedef void (* VkbProc)(void);

		static VkbHandle vkb_dlopen(const char* filename)
		{
		#ifdef _WIN32
		    return (VkbHandle)LoadLibraryA(filename);
		#else
		    return (VkbHandle)dlopen(filename, RTLD_NOW);
		#endif
		}

		static void vkb_dlclose(VkbHandle handle)
		{
		#ifdef _WIN32
		    FreeLibrary((HMODULE)handle);
		#else
		    dlclose((void*)handle);
		#endif
		}

		static VkbProc vkb_dlsym(VkbHandle handle, const char* symbol)
		{
		#ifdef _WIN32
		    return (VkbProc)GetProcAddress((HMODULE)handle, symbol);
		#else
		#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
		    #pragma GCC diagnostic push
		    #pragma GCC diagnostic ignored "-Wpedantic"
		#endif
		    return (VkbProc)dlsym((void*)handle, symbol);
		#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
		    #pragma GCC diagnostic pop
		#endif
		#endif
		}


		static unsigned int g_vkbInitCount = 0;
		static VkbHandle g_vkbVulkanSO = NULL;

		static VkResult vkbLoadVulkanSO()
		{
		    size_t i;

		    const char* vulkanSONames[] = {
		    #if defined(VKBIND_VULKAN_SO)
				VKBIND_VULKAN_SO,
		    #endif
		    #if defined(_WIN32)
				"vulkan-1.dll"
		    #elif defined(__APPLE__)
				/*
				The idea here is that since MoltenVK seems to be the de facto standard for Vulkan on Apple platforms at the moment we'll try
				that first. If Apple ever decides to officially support Vulkan we can perhaps consider dropping it to the bottom of the priority
				list. Not sure if this reasoning is sound, but it makes sense in my head!
				*/
				"libMoltenVK.dylib",
				"libvulkan.dylib.1",
				"libvulkan.dylib"
		    #else
				"libvulkan.so.1",
				"libvulkan.so"
		    #endif
		    };

		    for (i = 0; i < sizeof(vulkanSONames)/sizeof(vulkanSONames[0]); ++i) {
				VkbHandle handle = vkb_dlopen(vulkanSONames[i]);
				if (handle != NULL) {
				    g_vkbVulkanSO = handle;
				    return VK_SUCCESS;
				}
		    }

		    return VK_ERROR_INCOMPATIBLE_DRIVER;
		}

		static VkResult vkbLoadVulkanSymbols(VkbAPI* pAPI)
		{
		    pAPI->vkCreateInstance = (PFN_vkCreateInstance)vkb_dlsym(g_vkbVulkanSO, "vkCreateInstance");
		    pAPI->vkDestroyInstance = (PFN_vkDestroyInstance)vkb_dlsym(g_vkbVulkanSO, "vkDestroyInstance");
		    pAPI->vkEnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices)vkb_dlsym(g_vkbVulkanSO, "vkEnumeratePhysicalDevices");
		    pAPI->vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceFeatures");
		    pAPI->vkGetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceFormatProperties");
		    pAPI->vkGetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceImageFormatProperties");
		    pAPI->vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceProperties");
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceQueueFamilyProperties");
		    pAPI->vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceMemoryProperties");
		    pAPI->vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)vkb_dlsym(g_vkbVulkanSO, "vkGetInstanceProcAddr");
		    pAPI->vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceProcAddr");
		    pAPI->vkCreateDevice = (PFN_vkCreateDevice)vkb_dlsym(g_vkbVulkanSO, "vkCreateDevice");
		    pAPI->vkDestroyDevice = (PFN_vkDestroyDevice)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDevice");
		    pAPI->vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)vkb_dlsym(g_vkbVulkanSO, "vkEnumerateInstanceExtensionProperties");
		    pAPI->vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)vkb_dlsym(g_vkbVulkanSO, "vkEnumerateDeviceExtensionProperties");
		    pAPI->vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties)vkb_dlsym(g_vkbVulkanSO, "vkEnumerateInstanceLayerProperties");
		    pAPI->vkEnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties)vkb_dlsym(g_vkbVulkanSO, "vkEnumerateDeviceLayerProperties");
		    pAPI->vkGetDeviceQueue = (PFN_vkGetDeviceQueue)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceQueue");
		    pAPI->vkQueueSubmit = (PFN_vkQueueSubmit)vkb_dlsym(g_vkbVulkanSO, "vkQueueSubmit");
		    pAPI->vkQueueWaitIdle = (PFN_vkQueueWaitIdle)vkb_dlsym(g_vkbVulkanSO, "vkQueueWaitIdle");
		    pAPI->vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle)vkb_dlsym(g_vkbVulkanSO, "vkDeviceWaitIdle");
		    pAPI->vkAllocateMemory = (PFN_vkAllocateMemory)vkb_dlsym(g_vkbVulkanSO, "vkAllocateMemory");
		    pAPI->vkFreeMemory = (PFN_vkFreeMemory)vkb_dlsym(g_vkbVulkanSO, "vkFreeMemory");
		    pAPI->vkMapMemory = (PFN_vkMapMemory)vkb_dlsym(g_vkbVulkanSO, "vkMapMemory");
		    pAPI->vkUnmapMemory = (PFN_vkUnmapMemory)vkb_dlsym(g_vkbVulkanSO, "vkUnmapMemory");
		    pAPI->vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)vkb_dlsym(g_vkbVulkanSO, "vkFlushMappedMemoryRanges");
		    pAPI->vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)vkb_dlsym(g_vkbVulkanSO, "vkInvalidateMappedMemoryRanges");
		    pAPI->vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceMemoryCommitment");
		    pAPI->vkBindBufferMemory = (PFN_vkBindBufferMemory)vkb_dlsym(g_vkbVulkanSO, "vkBindBufferMemory");
		    pAPI->vkBindImageMemory = (PFN_vkBindImageMemory)vkb_dlsym(g_vkbVulkanSO, "vkBindImageMemory");
		    pAPI->vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferMemoryRequirements");
		    pAPI->vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)vkb_dlsym(g_vkbVulkanSO, "vkGetImageMemoryRequirements");
		    pAPI->vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)vkb_dlsym(g_vkbVulkanSO, "vkGetImageSparseMemoryRequirements");
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSparseImageFormatProperties");
		    pAPI->vkQueueBindSparse = (PFN_vkQueueBindSparse)vkb_dlsym(g_vkbVulkanSO, "vkQueueBindSparse");
		    pAPI->vkCreateFence = (PFN_vkCreateFence)vkb_dlsym(g_vkbVulkanSO, "vkCreateFence");
		    pAPI->vkDestroyFence = (PFN_vkDestroyFence)vkb_dlsym(g_vkbVulkanSO, "vkDestroyFence");
		    pAPI->vkResetFences = (PFN_vkResetFences)vkb_dlsym(g_vkbVulkanSO, "vkResetFences");
		    pAPI->vkGetFenceStatus = (PFN_vkGetFenceStatus)vkb_dlsym(g_vkbVulkanSO, "vkGetFenceStatus");
		    pAPI->vkWaitForFences = (PFN_vkWaitForFences)vkb_dlsym(g_vkbVulkanSO, "vkWaitForFences");
		    pAPI->vkCreateSemaphore = (PFN_vkCreateSemaphore)vkb_dlsym(g_vkbVulkanSO, "vkCreateSemaphore");
		    pAPI->vkDestroySemaphore = (PFN_vkDestroySemaphore)vkb_dlsym(g_vkbVulkanSO, "vkDestroySemaphore");
		    pAPI->vkCreateEvent = (PFN_vkCreateEvent)vkb_dlsym(g_vkbVulkanSO, "vkCreateEvent");
		    pAPI->vkDestroyEvent = (PFN_vkDestroyEvent)vkb_dlsym(g_vkbVulkanSO, "vkDestroyEvent");
		    pAPI->vkGetEventStatus = (PFN_vkGetEventStatus)vkb_dlsym(g_vkbVulkanSO, "vkGetEventStatus");
		    pAPI->vkSetEvent = (PFN_vkSetEvent)vkb_dlsym(g_vkbVulkanSO, "vkSetEvent");
		    pAPI->vkResetEvent = (PFN_vkResetEvent)vkb_dlsym(g_vkbVulkanSO, "vkResetEvent");
		    pAPI->vkCreateQueryPool = (PFN_vkCreateQueryPool)vkb_dlsym(g_vkbVulkanSO, "vkCreateQueryPool");
		    pAPI->vkDestroyQueryPool = (PFN_vkDestroyQueryPool)vkb_dlsym(g_vkbVulkanSO, "vkDestroyQueryPool");
		    pAPI->vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults)vkb_dlsym(g_vkbVulkanSO, "vkGetQueryPoolResults");
		    pAPI->vkCreateBuffer = (PFN_vkCreateBuffer)vkb_dlsym(g_vkbVulkanSO, "vkCreateBuffer");
		    pAPI->vkDestroyBuffer = (PFN_vkDestroyBuffer)vkb_dlsym(g_vkbVulkanSO, "vkDestroyBuffer");
		    pAPI->vkCreateBufferView = (PFN_vkCreateBufferView)vkb_dlsym(g_vkbVulkanSO, "vkCreateBufferView");
		    pAPI->vkDestroyBufferView = (PFN_vkDestroyBufferView)vkb_dlsym(g_vkbVulkanSO, "vkDestroyBufferView");
		    pAPI->vkCreateImage = (PFN_vkCreateImage)vkb_dlsym(g_vkbVulkanSO, "vkCreateImage");
		    pAPI->vkDestroyImage = (PFN_vkDestroyImage)vkb_dlsym(g_vkbVulkanSO, "vkDestroyImage");
		    pAPI->vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)vkb_dlsym(g_vkbVulkanSO, "vkGetImageSubresourceLayout");
		    pAPI->vkCreateImageView = (PFN_vkCreateImageView)vkb_dlsym(g_vkbVulkanSO, "vkCreateImageView");
		    pAPI->vkDestroyImageView = (PFN_vkDestroyImageView)vkb_dlsym(g_vkbVulkanSO, "vkDestroyImageView");
		    pAPI->vkCreateShaderModule = (PFN_vkCreateShaderModule)vkb_dlsym(g_vkbVulkanSO, "vkCreateShaderModule");
		    pAPI->vkDestroyShaderModule = (PFN_vkDestroyShaderModule)vkb_dlsym(g_vkbVulkanSO, "vkDestroyShaderModule");
		    pAPI->vkCreatePipelineCache = (PFN_vkCreatePipelineCache)vkb_dlsym(g_vkbVulkanSO, "vkCreatePipelineCache");
		    pAPI->vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache)vkb_dlsym(g_vkbVulkanSO, "vkDestroyPipelineCache");
		    pAPI->vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData)vkb_dlsym(g_vkbVulkanSO, "vkGetPipelineCacheData");
		    pAPI->vkMergePipelineCaches = (PFN_vkMergePipelineCaches)vkb_dlsym(g_vkbVulkanSO, "vkMergePipelineCaches");
		    pAPI->vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)vkb_dlsym(g_vkbVulkanSO, "vkCreateGraphicsPipelines");
		    pAPI->vkCreateComputePipelines = (PFN_vkCreateComputePipelines)vkb_dlsym(g_vkbVulkanSO, "vkCreateComputePipelines");
		    pAPI->vkDestroyPipeline = (PFN_vkDestroyPipeline)vkb_dlsym(g_vkbVulkanSO, "vkDestroyPipeline");
		    pAPI->vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout)vkb_dlsym(g_vkbVulkanSO, "vkCreatePipelineLayout");
		    pAPI->vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)vkb_dlsym(g_vkbVulkanSO, "vkDestroyPipelineLayout");
		    pAPI->vkCreateSampler = (PFN_vkCreateSampler)vkb_dlsym(g_vkbVulkanSO, "vkCreateSampler");
		    pAPI->vkDestroySampler = (PFN_vkDestroySampler)vkb_dlsym(g_vkbVulkanSO, "vkDestroySampler");
		    pAPI->vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)vkb_dlsym(g_vkbVulkanSO, "vkCreateDescriptorSetLayout");
		    pAPI->vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDescriptorSetLayout");
		    pAPI->vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool)vkb_dlsym(g_vkbVulkanSO, "vkCreateDescriptorPool");
		    pAPI->vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDescriptorPool");
		    pAPI->vkResetDescriptorPool = (PFN_vkResetDescriptorPool)vkb_dlsym(g_vkbVulkanSO, "vkResetDescriptorPool");
		    pAPI->vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)vkb_dlsym(g_vkbVulkanSO, "vkAllocateDescriptorSets");
		    pAPI->vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets)vkb_dlsym(g_vkbVulkanSO, "vkFreeDescriptorSets");
		    pAPI->vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)vkb_dlsym(g_vkbVulkanSO, "vkUpdateDescriptorSets");
		    pAPI->vkCreateFramebuffer = (PFN_vkCreateFramebuffer)vkb_dlsym(g_vkbVulkanSO, "vkCreateFramebuffer");
		    pAPI->vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer)vkb_dlsym(g_vkbVulkanSO, "vkDestroyFramebuffer");
		    pAPI->vkCreateRenderPass = (PFN_vkCreateRenderPass)vkb_dlsym(g_vkbVulkanSO, "vkCreateRenderPass");
		    pAPI->vkDestroyRenderPass = (PFN_vkDestroyRenderPass)vkb_dlsym(g_vkbVulkanSO, "vkDestroyRenderPass");
		    pAPI->vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)vkb_dlsym(g_vkbVulkanSO, "vkGetRenderAreaGranularity");
		    pAPI->vkCreateCommandPool = (PFN_vkCreateCommandPool)vkb_dlsym(g_vkbVulkanSO, "vkCreateCommandPool");
		    pAPI->vkDestroyCommandPool = (PFN_vkDestroyCommandPool)vkb_dlsym(g_vkbVulkanSO, "vkDestroyCommandPool");
		    pAPI->vkResetCommandPool = (PFN_vkResetCommandPool)vkb_dlsym(g_vkbVulkanSO, "vkResetCommandPool");
		    pAPI->vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)vkb_dlsym(g_vkbVulkanSO, "vkAllocateCommandBuffers");
		    pAPI->vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers)vkb_dlsym(g_vkbVulkanSO, "vkFreeCommandBuffers");
		    pAPI->vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)vkb_dlsym(g_vkbVulkanSO, "vkBeginCommandBuffer");
		    pAPI->vkEndCommandBuffer = (PFN_vkEndCommandBuffer)vkb_dlsym(g_vkbVulkanSO, "vkEndCommandBuffer");
		    pAPI->vkResetCommandBuffer = (PFN_vkResetCommandBuffer)vkb_dlsym(g_vkbVulkanSO, "vkResetCommandBuffer");
		    pAPI->vkCmdBindPipeline = (PFN_vkCmdBindPipeline)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindPipeline");
		    pAPI->vkCmdSetViewport = (PFN_vkCmdSetViewport)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetViewport");
		    pAPI->vkCmdSetScissor = (PFN_vkCmdSetScissor)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetScissor");
		    pAPI->vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetLineWidth");
		    pAPI->vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthBias");
		    pAPI->vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetBlendConstants");
		    pAPI->vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthBounds");
		    pAPI->vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetStencilCompareMask");
		    pAPI->vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetStencilWriteMask");
		    pAPI->vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetStencilReference");
		    pAPI->vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindDescriptorSets");
		    pAPI->vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindIndexBuffer");
		    pAPI->vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindVertexBuffers");
		    pAPI->vkCmdDraw = (PFN_vkCmdDraw)vkb_dlsym(g_vkbVulkanSO, "vkCmdDraw");
		    pAPI->vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndexed");
		    pAPI->vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndirect");
		    pAPI->vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndexedIndirect");
		    pAPI->vkCmdDispatch = (PFN_vkCmdDispatch)vkb_dlsym(g_vkbVulkanSO, "vkCmdDispatch");
		    pAPI->vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)vkb_dlsym(g_vkbVulkanSO, "vkCmdDispatchIndirect");
		    pAPI->vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyBuffer");
		    pAPI->vkCmdCopyImage = (PFN_vkCmdCopyImage)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyImage");
		    pAPI->vkCmdBlitImage = (PFN_vkCmdBlitImage)vkb_dlsym(g_vkbVulkanSO, "vkCmdBlitImage");
		    pAPI->vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyBufferToImage");
		    pAPI->vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyImageToBuffer");
		    pAPI->vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)vkb_dlsym(g_vkbVulkanSO, "vkCmdUpdateBuffer");
		    pAPI->vkCmdFillBuffer = (PFN_vkCmdFillBuffer)vkb_dlsym(g_vkbVulkanSO, "vkCmdFillBuffer");
		    pAPI->vkCmdClearColorImage = (PFN_vkCmdClearColorImage)vkb_dlsym(g_vkbVulkanSO, "vkCmdClearColorImage");
		    pAPI->vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)vkb_dlsym(g_vkbVulkanSO, "vkCmdClearDepthStencilImage");
		    pAPI->vkCmdClearAttachments = (PFN_vkCmdClearAttachments)vkb_dlsym(g_vkbVulkanSO, "vkCmdClearAttachments");
		    pAPI->vkCmdResolveImage = (PFN_vkCmdResolveImage)vkb_dlsym(g_vkbVulkanSO, "vkCmdResolveImage");
		    pAPI->vkCmdSetEvent = (PFN_vkCmdSetEvent)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetEvent");
		    pAPI->vkCmdResetEvent = (PFN_vkCmdResetEvent)vkb_dlsym(g_vkbVulkanSO, "vkCmdResetEvent");
		    pAPI->vkCmdWaitEvents = (PFN_vkCmdWaitEvents)vkb_dlsym(g_vkbVulkanSO, "vkCmdWaitEvents");
		    pAPI->vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)vkb_dlsym(g_vkbVulkanSO, "vkCmdPipelineBarrier");
		    pAPI->vkCmdBeginQuery = (PFN_vkCmdBeginQuery)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginQuery");
		    pAPI->vkCmdEndQuery = (PFN_vkCmdEndQuery)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndQuery");
		    pAPI->vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool)vkb_dlsym(g_vkbVulkanSO, "vkCmdResetQueryPool");
		    pAPI->vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteTimestamp");
		    pAPI->vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyQueryPoolResults");
		    pAPI->vkCmdPushConstants = (PFN_vkCmdPushConstants)vkb_dlsym(g_vkbVulkanSO, "vkCmdPushConstants");
		    pAPI->vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginRenderPass");
		    pAPI->vkCmdNextSubpass = (PFN_vkCmdNextSubpass)vkb_dlsym(g_vkbVulkanSO, "vkCmdNextSubpass");
		    pAPI->vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndRenderPass");
		    pAPI->vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands)vkb_dlsym(g_vkbVulkanSO, "vkCmdExecuteCommands");
		    pAPI->vkEnumerateInstanceVersion = (PFN_vkEnumerateInstanceVersion)vkb_dlsym(g_vkbVulkanSO, "vkEnumerateInstanceVersion");
		    pAPI->vkBindBufferMemory2 = (PFN_vkBindBufferMemory2)vkb_dlsym(g_vkbVulkanSO, "vkBindBufferMemory2");
		    pAPI->vkBindImageMemory2 = (PFN_vkBindImageMemory2)vkb_dlsym(g_vkbVulkanSO, "vkBindImageMemory2");
		    pAPI->vkGetDeviceGroupPeerMemoryFeatures = (PFN_vkGetDeviceGroupPeerMemoryFeatures)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceGroupPeerMemoryFeatures");
		    pAPI->vkCmdSetDeviceMask = (PFN_vkCmdSetDeviceMask)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDeviceMask");
		    pAPI->vkCmdDispatchBase = (PFN_vkCmdDispatchBase)vkb_dlsym(g_vkbVulkanSO, "vkCmdDispatchBase");
		    pAPI->vkEnumeratePhysicalDeviceGroups = (PFN_vkEnumeratePhysicalDeviceGroups)vkb_dlsym(g_vkbVulkanSO, "vkEnumeratePhysicalDeviceGroups");
		    pAPI->vkGetImageMemoryRequirements2 = (PFN_vkGetImageMemoryRequirements2)vkb_dlsym(g_vkbVulkanSO, "vkGetImageMemoryRequirements2");
		    pAPI->vkGetBufferMemoryRequirements2 = (PFN_vkGetBufferMemoryRequirements2)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferMemoryRequirements2");
		    pAPI->vkGetImageSparseMemoryRequirements2 = (PFN_vkGetImageSparseMemoryRequirements2)vkb_dlsym(g_vkbVulkanSO, "vkGetImageSparseMemoryRequirements2");
		    pAPI->vkGetPhysicalDeviceFeatures2 = (PFN_vkGetPhysicalDeviceFeatures2)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceFeatures2");
		    pAPI->vkGetPhysicalDeviceProperties2 = (PFN_vkGetPhysicalDeviceProperties2)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceProperties2");
		    pAPI->vkGetPhysicalDeviceFormatProperties2 = (PFN_vkGetPhysicalDeviceFormatProperties2)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceFormatProperties2");
		    pAPI->vkGetPhysicalDeviceImageFormatProperties2 = (PFN_vkGetPhysicalDeviceImageFormatProperties2)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceImageFormatProperties2");
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties2 = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceQueueFamilyProperties2");
		    pAPI->vkGetPhysicalDeviceMemoryProperties2 = (PFN_vkGetPhysicalDeviceMemoryProperties2)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceMemoryProperties2");
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2 = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSparseImageFormatProperties2");
		    pAPI->vkTrimCommandPool = (PFN_vkTrimCommandPool)vkb_dlsym(g_vkbVulkanSO, "vkTrimCommandPool");
		    pAPI->vkGetDeviceQueue2 = (PFN_vkGetDeviceQueue2)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceQueue2");
		    pAPI->vkCreateSamplerYcbcrConversion = (PFN_vkCreateSamplerYcbcrConversion)vkb_dlsym(g_vkbVulkanSO, "vkCreateSamplerYcbcrConversion");
		    pAPI->vkDestroySamplerYcbcrConversion = (PFN_vkDestroySamplerYcbcrConversion)vkb_dlsym(g_vkbVulkanSO, "vkDestroySamplerYcbcrConversion");
		    pAPI->vkCreateDescriptorUpdateTemplate = (PFN_vkCreateDescriptorUpdateTemplate)vkb_dlsym(g_vkbVulkanSO, "vkCreateDescriptorUpdateTemplate");
		    pAPI->vkDestroyDescriptorUpdateTemplate = (PFN_vkDestroyDescriptorUpdateTemplate)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDescriptorUpdateTemplate");
		    pAPI->vkUpdateDescriptorSetWithTemplate = (PFN_vkUpdateDescriptorSetWithTemplate)vkb_dlsym(g_vkbVulkanSO, "vkUpdateDescriptorSetWithTemplate");
		    pAPI->vkGetPhysicalDeviceExternalBufferProperties = (PFN_vkGetPhysicalDeviceExternalBufferProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalBufferProperties");
		    pAPI->vkGetPhysicalDeviceExternalFenceProperties = (PFN_vkGetPhysicalDeviceExternalFenceProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalFenceProperties");
		    pAPI->vkGetPhysicalDeviceExternalSemaphoreProperties = (PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalSemaphoreProperties");
		    pAPI->vkGetDescriptorSetLayoutSupport = (PFN_vkGetDescriptorSetLayoutSupport)vkb_dlsym(g_vkbVulkanSO, "vkGetDescriptorSetLayoutSupport");
		    pAPI->vkCmdDrawIndirectCount = (PFN_vkCmdDrawIndirectCount)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndirectCount");
		    pAPI->vkCmdDrawIndexedIndirectCount = (PFN_vkCmdDrawIndexedIndirectCount)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndexedIndirectCount");
		    pAPI->vkCreateRenderPass2 = (PFN_vkCreateRenderPass2)vkb_dlsym(g_vkbVulkanSO, "vkCreateRenderPass2");
		    pAPI->vkCmdBeginRenderPass2 = (PFN_vkCmdBeginRenderPass2)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginRenderPass2");
		    pAPI->vkCmdNextSubpass2 = (PFN_vkCmdNextSubpass2)vkb_dlsym(g_vkbVulkanSO, "vkCmdNextSubpass2");
		    pAPI->vkCmdEndRenderPass2 = (PFN_vkCmdEndRenderPass2)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndRenderPass2");
		    pAPI->vkResetQueryPool = (PFN_vkResetQueryPool)vkb_dlsym(g_vkbVulkanSO, "vkResetQueryPool");
		    pAPI->vkGetSemaphoreCounterValue = (PFN_vkGetSemaphoreCounterValue)vkb_dlsym(g_vkbVulkanSO, "vkGetSemaphoreCounterValue");
		    pAPI->vkWaitSemaphores = (PFN_vkWaitSemaphores)vkb_dlsym(g_vkbVulkanSO, "vkWaitSemaphores");
		    pAPI->vkSignalSemaphore = (PFN_vkSignalSemaphore)vkb_dlsym(g_vkbVulkanSO, "vkSignalSemaphore");
		    pAPI->vkGetBufferDeviceAddress = (PFN_vkGetBufferDeviceAddress)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferDeviceAddress");
		    pAPI->vkGetBufferOpaqueCaptureAddress = (PFN_vkGetBufferOpaqueCaptureAddress)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferOpaqueCaptureAddress");
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddress = (PFN_vkGetDeviceMemoryOpaqueCaptureAddress)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceMemoryOpaqueCaptureAddress");
		    pAPI->vkGetPhysicalDeviceToolProperties = (PFN_vkGetPhysicalDeviceToolProperties)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceToolProperties");
		    pAPI->vkCreatePrivateDataSlot = (PFN_vkCreatePrivateDataSlot)vkb_dlsym(g_vkbVulkanSO, "vkCreatePrivateDataSlot");
		    pAPI->vkDestroyPrivateDataSlot = (PFN_vkDestroyPrivateDataSlot)vkb_dlsym(g_vkbVulkanSO, "vkDestroyPrivateDataSlot");
		    pAPI->vkSetPrivateData = (PFN_vkSetPrivateData)vkb_dlsym(g_vkbVulkanSO, "vkSetPrivateData");
		    pAPI->vkGetPrivateData = (PFN_vkGetPrivateData)vkb_dlsym(g_vkbVulkanSO, "vkGetPrivateData");
		    pAPI->vkCmdSetEvent2 = (PFN_vkCmdSetEvent2)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetEvent2");
		    pAPI->vkCmdResetEvent2 = (PFN_vkCmdResetEvent2)vkb_dlsym(g_vkbVulkanSO, "vkCmdResetEvent2");
		    pAPI->vkCmdWaitEvents2 = (PFN_vkCmdWaitEvents2)vkb_dlsym(g_vkbVulkanSO, "vkCmdWaitEvents2");
		    pAPI->vkCmdPipelineBarrier2 = (PFN_vkCmdPipelineBarrier2)vkb_dlsym(g_vkbVulkanSO, "vkCmdPipelineBarrier2");
		    pAPI->vkCmdWriteTimestamp2 = (PFN_vkCmdWriteTimestamp2)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteTimestamp2");
		    pAPI->vkQueueSubmit2 = (PFN_vkQueueSubmit2)vkb_dlsym(g_vkbVulkanSO, "vkQueueSubmit2");
		    pAPI->vkCmdCopyBuffer2 = (PFN_vkCmdCopyBuffer2)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyBuffer2");
		    pAPI->vkCmdCopyImage2 = (PFN_vkCmdCopyImage2)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyImage2");
		    pAPI->vkCmdCopyBufferToImage2 = (PFN_vkCmdCopyBufferToImage2)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyBufferToImage2");
		    pAPI->vkCmdCopyImageToBuffer2 = (PFN_vkCmdCopyImageToBuffer2)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyImageToBuffer2");
		    pAPI->vkCmdBlitImage2 = (PFN_vkCmdBlitImage2)vkb_dlsym(g_vkbVulkanSO, "vkCmdBlitImage2");
		    pAPI->vkCmdResolveImage2 = (PFN_vkCmdResolveImage2)vkb_dlsym(g_vkbVulkanSO, "vkCmdResolveImage2");
		    pAPI->vkCmdBeginRendering = (PFN_vkCmdBeginRendering)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginRendering");
		    pAPI->vkCmdEndRendering = (PFN_vkCmdEndRendering)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndRendering");
		    pAPI->vkCmdSetCullMode = (PFN_vkCmdSetCullMode)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCullMode");
		    pAPI->vkCmdSetFrontFace = (PFN_vkCmdSetFrontFace)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetFrontFace");
		    pAPI->vkCmdSetPrimitiveTopology = (PFN_vkCmdSetPrimitiveTopology)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPrimitiveTopology");
		    pAPI->vkCmdSetViewportWithCount = (PFN_vkCmdSetViewportWithCount)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetViewportWithCount");
		    pAPI->vkCmdSetScissorWithCount = (PFN_vkCmdSetScissorWithCount)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetScissorWithCount");
		    pAPI->vkCmdBindVertexBuffers2 = (PFN_vkCmdBindVertexBuffers2)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindVertexBuffers2");
		    pAPI->vkCmdSetDepthTestEnable = (PFN_vkCmdSetDepthTestEnable)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthTestEnable");
		    pAPI->vkCmdSetDepthWriteEnable = (PFN_vkCmdSetDepthWriteEnable)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthWriteEnable");
		    pAPI->vkCmdSetDepthCompareOp = (PFN_vkCmdSetDepthCompareOp)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthCompareOp");
		    pAPI->vkCmdSetDepthBoundsTestEnable = (PFN_vkCmdSetDepthBoundsTestEnable)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthBoundsTestEnable");
		    pAPI->vkCmdSetStencilTestEnable = (PFN_vkCmdSetStencilTestEnable)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetStencilTestEnable");
		    pAPI->vkCmdSetStencilOp = (PFN_vkCmdSetStencilOp)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetStencilOp");
		    pAPI->vkCmdSetRasterizerDiscardEnable = (PFN_vkCmdSetRasterizerDiscardEnable)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRasterizerDiscardEnable");
		    pAPI->vkCmdSetDepthBiasEnable = (PFN_vkCmdSetDepthBiasEnable)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthBiasEnable");
		    pAPI->vkCmdSetPrimitiveRestartEnable = (PFN_vkCmdSetPrimitiveRestartEnable)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPrimitiveRestartEnable");
		    pAPI->vkGetDeviceBufferMemoryRequirements = (PFN_vkGetDeviceBufferMemoryRequirements)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceBufferMemoryRequirements");
		    pAPI->vkGetDeviceImageMemoryRequirements = (PFN_vkGetDeviceImageMemoryRequirements)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceImageMemoryRequirements");
		    pAPI->vkGetDeviceImageSparseMemoryRequirements = (PFN_vkGetDeviceImageSparseMemoryRequirements)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceImageSparseMemoryRequirements");
		    pAPI->vkGetCommandPoolMemoryConsumption = (PFN_vkGetCommandPoolMemoryConsumption)vkb_dlsym(g_vkbVulkanSO, "vkGetCommandPoolMemoryConsumption");
		    pAPI->vkGetFaultData = (PFN_vkGetFaultData)vkb_dlsym(g_vkbVulkanSO, "vkGetFaultData");
		    pAPI->vkDestroySurfaceKHR = (PFN_vkDestroySurfaceKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroySurfaceKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfaceSupportKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfaceFormatsKHR");
		    pAPI->vkGetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfacePresentModesKHR");
		    pAPI->vkCreateSwapchainKHR = (PFN_vkCreateSwapchainKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateSwapchainKHR");
		    pAPI->vkDestroySwapchainKHR = (PFN_vkDestroySwapchainKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroySwapchainKHR");
		    pAPI->vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetSwapchainImagesKHR");
		    pAPI->vkAcquireNextImageKHR = (PFN_vkAcquireNextImageKHR)vkb_dlsym(g_vkbVulkanSO, "vkAcquireNextImageKHR");
		    pAPI->vkQueuePresentKHR = (PFN_vkQueuePresentKHR)vkb_dlsym(g_vkbVulkanSO, "vkQueuePresentKHR");
		    pAPI->vkGetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceGroupPresentCapabilitiesKHR");
		    pAPI->vkGetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceGroupSurfacePresentModesKHR");
		    pAPI->vkGetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDevicePresentRectanglesKHR");
		    pAPI->vkAcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR)vkb_dlsym(g_vkbVulkanSO, "vkAcquireNextImage2KHR");
		    pAPI->vkGetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceDisplayPropertiesKHR");
		    pAPI->vkGetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
		    pAPI->vkGetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDisplayPlaneSupportedDisplaysKHR");
		    pAPI->vkGetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDisplayModePropertiesKHR");
		    pAPI->vkCreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateDisplayModeKHR");
		    pAPI->vkGetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDisplayPlaneCapabilitiesKHR");
		    pAPI->vkCreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateDisplayPlaneSurfaceKHR");
		    pAPI->vkCreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateSharedSwapchainsKHR");
		    pAPI->vkGetPhysicalDeviceVideoCapabilitiesKHR = (PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceVideoCapabilitiesKHR");
		    pAPI->vkGetPhysicalDeviceVideoFormatPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceVideoFormatPropertiesKHR");
		    pAPI->vkCreateVideoSessionKHR = (PFN_vkCreateVideoSessionKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateVideoSessionKHR");
		    pAPI->vkDestroyVideoSessionKHR = (PFN_vkDestroyVideoSessionKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroyVideoSessionKHR");
		    pAPI->vkGetVideoSessionMemoryRequirementsKHR = (PFN_vkGetVideoSessionMemoryRequirementsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetVideoSessionMemoryRequirementsKHR");
		    pAPI->vkBindVideoSessionMemoryKHR = (PFN_vkBindVideoSessionMemoryKHR)vkb_dlsym(g_vkbVulkanSO, "vkBindVideoSessionMemoryKHR");
		    pAPI->vkCreateVideoSessionParametersKHR = (PFN_vkCreateVideoSessionParametersKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateVideoSessionParametersKHR");
		    pAPI->vkUpdateVideoSessionParametersKHR = (PFN_vkUpdateVideoSessionParametersKHR)vkb_dlsym(g_vkbVulkanSO, "vkUpdateVideoSessionParametersKHR");
		    pAPI->vkDestroyVideoSessionParametersKHR = (PFN_vkDestroyVideoSessionParametersKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroyVideoSessionParametersKHR");
		    pAPI->vkCmdBeginVideoCodingKHR = (PFN_vkCmdBeginVideoCodingKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginVideoCodingKHR");
		    pAPI->vkCmdEndVideoCodingKHR = (PFN_vkCmdEndVideoCodingKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndVideoCodingKHR");
		    pAPI->vkCmdControlVideoCodingKHR = (PFN_vkCmdControlVideoCodingKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdControlVideoCodingKHR");
		    pAPI->vkCmdDecodeVideoKHR = (PFN_vkCmdDecodeVideoKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdDecodeVideoKHR");
		    pAPI->vkCmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindTransformFeedbackBuffersEXT");
		    pAPI->vkCmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginTransformFeedbackEXT");
		    pAPI->vkCmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndTransformFeedbackEXT");
		    pAPI->vkCmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginQueryIndexedEXT");
		    pAPI->vkCmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndQueryIndexedEXT");
		    pAPI->vkCmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndirectByteCountEXT");
		    pAPI->vkCreateCuModuleNVX = (PFN_vkCreateCuModuleNVX)vkb_dlsym(g_vkbVulkanSO, "vkCreateCuModuleNVX");
		    pAPI->vkCreateCuFunctionNVX = (PFN_vkCreateCuFunctionNVX)vkb_dlsym(g_vkbVulkanSO, "vkCreateCuFunctionNVX");
		    pAPI->vkDestroyCuModuleNVX = (PFN_vkDestroyCuModuleNVX)vkb_dlsym(g_vkbVulkanSO, "vkDestroyCuModuleNVX");
		    pAPI->vkDestroyCuFunctionNVX = (PFN_vkDestroyCuFunctionNVX)vkb_dlsym(g_vkbVulkanSO, "vkDestroyCuFunctionNVX");
		    pAPI->vkCmdCuLaunchKernelNVX = (PFN_vkCmdCuLaunchKernelNVX)vkb_dlsym(g_vkbVulkanSO, "vkCmdCuLaunchKernelNVX");
		    pAPI->vkGetImageViewHandleNVX = (PFN_vkGetImageViewHandleNVX)vkb_dlsym(g_vkbVulkanSO, "vkGetImageViewHandleNVX");
		    pAPI->vkGetImageViewAddressNVX = (PFN_vkGetImageViewAddressNVX)vkb_dlsym(g_vkbVulkanSO, "vkGetImageViewAddressNVX");
		    pAPI->vkGetShaderInfoAMD = (PFN_vkGetShaderInfoAMD)vkb_dlsym(g_vkbVulkanSO, "vkGetShaderInfoAMD");
		    pAPI->vkCmdBeginRenderingKHR = (PFN_vkCmdBeginRenderingKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginRenderingKHR");
		    pAPI->vkCmdEndRenderingKHR = (PFN_vkCmdEndRenderingKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndRenderingKHR");
		    pAPI->vkGetPhysicalDeviceFeatures2KHR = (PFN_vkGetPhysicalDeviceFeatures2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceFeatures2KHR");
		    pAPI->vkGetPhysicalDeviceProperties2KHR = (PFN_vkGetPhysicalDeviceProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceProperties2KHR");
		    pAPI->vkGetPhysicalDeviceFormatProperties2KHR = (PFN_vkGetPhysicalDeviceFormatProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceFormatProperties2KHR");
		    pAPI->vkGetPhysicalDeviceImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceImageFormatProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceImageFormatProperties2KHR");
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties2KHR = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceQueueFamilyProperties2KHR");
		    pAPI->vkGetPhysicalDeviceMemoryProperties2KHR = (PFN_vkGetPhysicalDeviceMemoryProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceMemoryProperties2KHR");
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
		    pAPI->vkGetDeviceGroupPeerMemoryFeaturesKHR = (PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceGroupPeerMemoryFeaturesKHR");
		    pAPI->vkCmdSetDeviceMaskKHR = (PFN_vkCmdSetDeviceMaskKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDeviceMaskKHR");
		    pAPI->vkCmdDispatchBaseKHR = (PFN_vkCmdDispatchBaseKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdDispatchBaseKHR");
		    pAPI->vkTrimCommandPoolKHR = (PFN_vkTrimCommandPoolKHR)vkb_dlsym(g_vkbVulkanSO, "vkTrimCommandPoolKHR");
		    pAPI->vkEnumeratePhysicalDeviceGroupsKHR = (PFN_vkEnumeratePhysicalDeviceGroupsKHR)vkb_dlsym(g_vkbVulkanSO, "vkEnumeratePhysicalDeviceGroupsKHR");
		    pAPI->vkGetPhysicalDeviceExternalBufferPropertiesKHR = (PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalBufferPropertiesKHR");
		    pAPI->vkGetPhysicalDeviceExternalImageFormatPropertiesNV = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
		    pAPI->vkGetMemoryFdKHR = (PFN_vkGetMemoryFdKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryFdKHR");
		    pAPI->vkGetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryFdPropertiesKHR");
		    pAPI->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
		    pAPI->vkImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR)vkb_dlsym(g_vkbVulkanSO, "vkImportSemaphoreFdKHR");
		    pAPI->vkGetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetSemaphoreFdKHR");
		    pAPI->vkCmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdPushDescriptorSetKHR");
		    pAPI->vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdPushDescriptorSetWithTemplateKHR");
		    pAPI->vkCmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginConditionalRenderingEXT");
		    pAPI->vkCmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndConditionalRenderingEXT");
		    pAPI->vkCreateDescriptorUpdateTemplateKHR = (PFN_vkCreateDescriptorUpdateTemplateKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateDescriptorUpdateTemplateKHR");
		    pAPI->vkDestroyDescriptorUpdateTemplateKHR = (PFN_vkDestroyDescriptorUpdateTemplateKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDescriptorUpdateTemplateKHR");
		    pAPI->vkUpdateDescriptorSetWithTemplateKHR = (PFN_vkUpdateDescriptorSetWithTemplateKHR)vkb_dlsym(g_vkbVulkanSO, "vkUpdateDescriptorSetWithTemplateKHR");
		    pAPI->vkCmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetViewportWScalingNV");
		    pAPI->vkReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT)vkb_dlsym(g_vkbVulkanSO, "vkReleaseDisplayEXT");
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
		    pAPI->vkDisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT)vkb_dlsym(g_vkbVulkanSO, "vkDisplayPowerControlEXT");
		    pAPI->vkRegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT)vkb_dlsym(g_vkbVulkanSO, "vkRegisterDeviceEventEXT");
		    pAPI->vkRegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT)vkb_dlsym(g_vkbVulkanSO, "vkRegisterDisplayEventEXT");
		    pAPI->vkGetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetSwapchainCounterEXT");
		    pAPI->vkGetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE)vkb_dlsym(g_vkbVulkanSO, "vkGetRefreshCycleDurationGOOGLE");
		    pAPI->vkGetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE)vkb_dlsym(g_vkbVulkanSO, "vkGetPastPresentationTimingGOOGLE");
		    pAPI->vkCmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDiscardRectangleEXT");
		    pAPI->vkCmdSetDiscardRectangleEnableEXT = (PFN_vkCmdSetDiscardRectangleEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDiscardRectangleEnableEXT");
		    pAPI->vkCmdSetDiscardRectangleModeEXT = (PFN_vkCmdSetDiscardRectangleModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDiscardRectangleModeEXT");
		    pAPI->vkSetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT)vkb_dlsym(g_vkbVulkanSO, "vkSetHdrMetadataEXT");
		    pAPI->vkCreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateRenderPass2KHR");
		    pAPI->vkCmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginRenderPass2KHR");
		    pAPI->vkCmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdNextSubpass2KHR");
		    pAPI->vkCmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndRenderPass2KHR");
		    pAPI->vkGetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetSwapchainStatusKHR");
		    pAPI->vkGetPhysicalDeviceExternalFencePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalFencePropertiesKHR");
		    pAPI->vkImportFenceFdKHR = (PFN_vkImportFenceFdKHR)vkb_dlsym(g_vkbVulkanSO, "vkImportFenceFdKHR");
		    pAPI->vkGetFenceFdKHR = (PFN_vkGetFenceFdKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetFenceFdKHR");
		    pAPI->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)vkb_dlsym(g_vkbVulkanSO, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
		    pAPI->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = (PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
		    pAPI->vkAcquireProfilingLockKHR = (PFN_vkAcquireProfilingLockKHR)vkb_dlsym(g_vkbVulkanSO, "vkAcquireProfilingLockKHR");
		    pAPI->vkReleaseProfilingLockKHR = (PFN_vkReleaseProfilingLockKHR)vkb_dlsym(g_vkbVulkanSO, "vkReleaseProfilingLockKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
		    pAPI->vkGetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfaceFormats2KHR");
		    pAPI->vkGetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceDisplayProperties2KHR");
		    pAPI->vkGetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
		    pAPI->vkGetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDisplayModeProperties2KHR");
		    pAPI->vkGetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDisplayPlaneCapabilities2KHR");
		    pAPI->vkSetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT)vkb_dlsym(g_vkbVulkanSO, "vkSetDebugUtilsObjectNameEXT");
		    pAPI->vkSetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT)vkb_dlsym(g_vkbVulkanSO, "vkSetDebugUtilsObjectTagEXT");
		    pAPI->vkQueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT)vkb_dlsym(g_vkbVulkanSO, "vkQueueBeginDebugUtilsLabelEXT");
		    pAPI->vkQueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT)vkb_dlsym(g_vkbVulkanSO, "vkQueueEndDebugUtilsLabelEXT");
		    pAPI->vkQueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT)vkb_dlsym(g_vkbVulkanSO, "vkQueueInsertDebugUtilsLabelEXT");
		    pAPI->vkCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBeginDebugUtilsLabelEXT");
		    pAPI->vkCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdEndDebugUtilsLabelEXT");
		    pAPI->vkCmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdInsertDebugUtilsLabelEXT");
		    pAPI->vkCreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateDebugUtilsMessengerEXT");
		    pAPI->vkDestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDebugUtilsMessengerEXT");
		    pAPI->vkSubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT)vkb_dlsym(g_vkbVulkanSO, "vkSubmitDebugUtilsMessageEXT");
		    pAPI->vkDebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT)vkb_dlsym(g_vkbVulkanSO, "vkDebugMarkerSetObjectTagEXT");
		    pAPI->vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)vkb_dlsym(g_vkbVulkanSO, "vkDebugMarkerSetObjectNameEXT");
		    pAPI->vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDebugMarkerBeginEXT");
		    pAPI->vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDebugMarkerEndEXT");
		    pAPI->vkCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDebugMarkerInsertEXT");
		    pAPI->vkCreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateDebugReportCallbackEXT");
		    pAPI->vkDestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDebugReportCallbackEXT");
		    pAPI->vkDebugReportMessageEXT = (PFN_vkDebugReportMessageEXT)vkb_dlsym(g_vkbVulkanSO, "vkDebugReportMessageEXT");
		    pAPI->vkCmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetSampleLocationsEXT");
		    pAPI->vkGetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
		    pAPI->vkGetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetImageMemoryRequirements2KHR");
		    pAPI->vkGetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferMemoryRequirements2KHR");
		    pAPI->vkGetImageSparseMemoryRequirements2KHR = (PFN_vkGetImageSparseMemoryRequirements2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetImageSparseMemoryRequirements2KHR");
		    pAPI->vkCreateAccelerationStructureKHR = (PFN_vkCreateAccelerationStructureKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateAccelerationStructureKHR");
		    pAPI->vkDestroyAccelerationStructureKHR = (PFN_vkDestroyAccelerationStructureKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroyAccelerationStructureKHR");
		    pAPI->vkCmdBuildAccelerationStructuresKHR = (PFN_vkCmdBuildAccelerationStructuresKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBuildAccelerationStructuresKHR");
		    pAPI->vkCmdBuildAccelerationStructuresIndirectKHR = (PFN_vkCmdBuildAccelerationStructuresIndirectKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBuildAccelerationStructuresIndirectKHR");
		    pAPI->vkBuildAccelerationStructuresKHR = (PFN_vkBuildAccelerationStructuresKHR)vkb_dlsym(g_vkbVulkanSO, "vkBuildAccelerationStructuresKHR");
		    pAPI->vkCopyAccelerationStructureKHR = (PFN_vkCopyAccelerationStructureKHR)vkb_dlsym(g_vkbVulkanSO, "vkCopyAccelerationStructureKHR");
		    pAPI->vkCopyAccelerationStructureToMemoryKHR = (PFN_vkCopyAccelerationStructureToMemoryKHR)vkb_dlsym(g_vkbVulkanSO, "vkCopyAccelerationStructureToMemoryKHR");
		    pAPI->vkCopyMemoryToAccelerationStructureKHR = (PFN_vkCopyMemoryToAccelerationStructureKHR)vkb_dlsym(g_vkbVulkanSO, "vkCopyMemoryToAccelerationStructureKHR");
		    pAPI->vkWriteAccelerationStructuresPropertiesKHR = (PFN_vkWriteAccelerationStructuresPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkWriteAccelerationStructuresPropertiesKHR");
		    pAPI->vkCmdCopyAccelerationStructureKHR = (PFN_vkCmdCopyAccelerationStructureKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyAccelerationStructureKHR");
		    pAPI->vkCmdCopyAccelerationStructureToMemoryKHR = (PFN_vkCmdCopyAccelerationStructureToMemoryKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyAccelerationStructureToMemoryKHR");
		    pAPI->vkCmdCopyMemoryToAccelerationStructureKHR = (PFN_vkCmdCopyMemoryToAccelerationStructureKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyMemoryToAccelerationStructureKHR");
		    pAPI->vkGetAccelerationStructureDeviceAddressKHR = (PFN_vkGetAccelerationStructureDeviceAddressKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetAccelerationStructureDeviceAddressKHR");
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesKHR = (PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteAccelerationStructuresPropertiesKHR");
		    pAPI->vkGetDeviceAccelerationStructureCompatibilityKHR = (PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceAccelerationStructureCompatibilityKHR");
		    pAPI->vkGetAccelerationStructureBuildSizesKHR = (PFN_vkGetAccelerationStructureBuildSizesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetAccelerationStructureBuildSizesKHR");
		    pAPI->vkCmdTraceRaysKHR = (PFN_vkCmdTraceRaysKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdTraceRaysKHR");
		    pAPI->vkCreateRayTracingPipelinesKHR = (PFN_vkCreateRayTracingPipelinesKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateRayTracingPipelinesKHR");
		    pAPI->vkGetRayTracingShaderGroupHandlesKHR = (PFN_vkGetRayTracingShaderGroupHandlesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetRayTracingShaderGroupHandlesKHR");
		    pAPI->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = (PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
		    pAPI->vkCmdTraceRaysIndirectKHR = (PFN_vkCmdTraceRaysIndirectKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdTraceRaysIndirectKHR");
		    pAPI->vkGetRayTracingShaderGroupStackSizeKHR = (PFN_vkGetRayTracingShaderGroupStackSizeKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetRayTracingShaderGroupStackSizeKHR");
		    pAPI->vkCmdSetRayTracingPipelineStackSizeKHR = (PFN_vkCmdSetRayTracingPipelineStackSizeKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRayTracingPipelineStackSizeKHR");
		    pAPI->vkCreateSamplerYcbcrConversionKHR = (PFN_vkCreateSamplerYcbcrConversionKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateSamplerYcbcrConversionKHR");
		    pAPI->vkDestroySamplerYcbcrConversionKHR = (PFN_vkDestroySamplerYcbcrConversionKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroySamplerYcbcrConversionKHR");
		    pAPI->vkBindBufferMemory2KHR = (PFN_vkBindBufferMemory2KHR)vkb_dlsym(g_vkbVulkanSO, "vkBindBufferMemory2KHR");
		    pAPI->vkBindImageMemory2KHR = (PFN_vkBindImageMemory2KHR)vkb_dlsym(g_vkbVulkanSO, "vkBindImageMemory2KHR");
		    pAPI->vkGetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetImageDrmFormatModifierPropertiesEXT");
		    pAPI->vkCreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateValidationCacheEXT");
		    pAPI->vkDestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT)vkb_dlsym(g_vkbVulkanSO, "vkDestroyValidationCacheEXT");
		    pAPI->vkMergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT)vkb_dlsym(g_vkbVulkanSO, "vkMergeValidationCachesEXT");
		    pAPI->vkGetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetValidationCacheDataEXT");
		    pAPI->vkCmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindShadingRateImageNV");
		    pAPI->vkCmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetViewportShadingRatePaletteNV");
		    pAPI->vkCmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCoarseSampleOrderNV");
		    pAPI->vkCreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV)vkb_dlsym(g_vkbVulkanSO, "vkCreateAccelerationStructureNV");
		    pAPI->vkDestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV)vkb_dlsym(g_vkbVulkanSO, "vkDestroyAccelerationStructureNV");
		    pAPI->vkGetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV)vkb_dlsym(g_vkbVulkanSO, "vkGetAccelerationStructureMemoryRequirementsNV");
		    pAPI->vkBindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV)vkb_dlsym(g_vkbVulkanSO, "vkBindAccelerationStructureMemoryNV");
		    pAPI->vkCmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdBuildAccelerationStructureNV");
		    pAPI->vkCmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyAccelerationStructureNV");
		    pAPI->vkCmdTraceRaysNV = (PFN_vkCmdTraceRaysNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdTraceRaysNV");
		    pAPI->vkCreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV)vkb_dlsym(g_vkbVulkanSO, "vkCreateRayTracingPipelinesNV");
		    pAPI->vkGetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV)vkb_dlsym(g_vkbVulkanSO, "vkGetRayTracingShaderGroupHandlesNV");
		    pAPI->vkGetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV)vkb_dlsym(g_vkbVulkanSO, "vkGetAccelerationStructureHandleNV");
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteAccelerationStructuresPropertiesNV");
		    pAPI->vkCompileDeferredNV = (PFN_vkCompileDeferredNV)vkb_dlsym(g_vkbVulkanSO, "vkCompileDeferredNV");
		    pAPI->vkGetDescriptorSetLayoutSupportKHR = (PFN_vkGetDescriptorSetLayoutSupportKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDescriptorSetLayoutSupportKHR");
		    pAPI->vkCmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndirectCountKHR");
		    pAPI->vkCmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndexedIndirectCountKHR");
		    pAPI->vkCmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndirectCountAMD");
		    pAPI->vkCmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawIndexedIndirectCountAMD");
		    pAPI->vkGetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryHostPointerPropertiesEXT");
		    pAPI->vkCmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteBufferMarkerAMD");
		    pAPI->vkCmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMeshTasksNV");
		    pAPI->vkCmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMeshTasksIndirectNV");
		    pAPI->vkCmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMeshTasksIndirectCountNV");
		    pAPI->vkCmdSetExclusiveScissorEnableNV = (PFN_vkCmdSetExclusiveScissorEnableNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetExclusiveScissorEnableNV");
		    pAPI->vkCmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetExclusiveScissorNV");
		    pAPI->vkCmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCheckpointNV");
		    pAPI->vkGetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV)vkb_dlsym(g_vkbVulkanSO, "vkGetQueueCheckpointDataNV");
		    pAPI->vkGetSemaphoreCounterValueKHR = (PFN_vkGetSemaphoreCounterValueKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetSemaphoreCounterValueKHR");
		    pAPI->vkWaitSemaphoresKHR = (PFN_vkWaitSemaphoresKHR)vkb_dlsym(g_vkbVulkanSO, "vkWaitSemaphoresKHR");
		    pAPI->vkSignalSemaphoreKHR = (PFN_vkSignalSemaphoreKHR)vkb_dlsym(g_vkbVulkanSO, "vkSignalSemaphoreKHR");
		    pAPI->vkInitializePerformanceApiINTEL = (PFN_vkInitializePerformanceApiINTEL)vkb_dlsym(g_vkbVulkanSO, "vkInitializePerformanceApiINTEL");
		    pAPI->vkUninitializePerformanceApiINTEL = (PFN_vkUninitializePerformanceApiINTEL)vkb_dlsym(g_vkbVulkanSO, "vkUninitializePerformanceApiINTEL");
		    pAPI->vkCmdSetPerformanceMarkerINTEL = (PFN_vkCmdSetPerformanceMarkerINTEL)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPerformanceMarkerINTEL");
		    pAPI->vkCmdSetPerformanceStreamMarkerINTEL = (PFN_vkCmdSetPerformanceStreamMarkerINTEL)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPerformanceStreamMarkerINTEL");
		    pAPI->vkCmdSetPerformanceOverrideINTEL = (PFN_vkCmdSetPerformanceOverrideINTEL)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPerformanceOverrideINTEL");
		    pAPI->vkAcquirePerformanceConfigurationINTEL = (PFN_vkAcquirePerformanceConfigurationINTEL)vkb_dlsym(g_vkbVulkanSO, "vkAcquirePerformanceConfigurationINTEL");
		    pAPI->vkReleasePerformanceConfigurationINTEL = (PFN_vkReleasePerformanceConfigurationINTEL)vkb_dlsym(g_vkbVulkanSO, "vkReleasePerformanceConfigurationINTEL");
		    pAPI->vkQueueSetPerformanceConfigurationINTEL = (PFN_vkQueueSetPerformanceConfigurationINTEL)vkb_dlsym(g_vkbVulkanSO, "vkQueueSetPerformanceConfigurationINTEL");
		    pAPI->vkGetPerformanceParameterINTEL = (PFN_vkGetPerformanceParameterINTEL)vkb_dlsym(g_vkbVulkanSO, "vkGetPerformanceParameterINTEL");
		    pAPI->vkSetLocalDimmingAMD = (PFN_vkSetLocalDimmingAMD)vkb_dlsym(g_vkbVulkanSO, "vkSetLocalDimmingAMD");
		    pAPI->vkGetPhysicalDeviceFragmentShadingRatesKHR = (PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceFragmentShadingRatesKHR");
		    pAPI->vkCmdSetFragmentShadingRateKHR = (PFN_vkCmdSetFragmentShadingRateKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetFragmentShadingRateKHR");
		    pAPI->vkCmdSetRenderingAttachmentLocationsKHR = (PFN_vkCmdSetRenderingAttachmentLocationsKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRenderingAttachmentLocationsKHR");
		    pAPI->vkCmdSetRenderingInputAttachmentIndicesKHR = (PFN_vkCmdSetRenderingInputAttachmentIndicesKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRenderingInputAttachmentIndicesKHR");
		    pAPI->vkGetPhysicalDeviceToolPropertiesEXT = (PFN_vkGetPhysicalDeviceToolPropertiesEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceToolPropertiesEXT");
		    pAPI->vkWaitForPresentKHR = (PFN_vkWaitForPresentKHR)vkb_dlsym(g_vkbVulkanSO, "vkWaitForPresentKHR");
		    pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
		    pAPI->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = (PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
		    pAPI->vkCreateHeadlessSurfaceEXT = (PFN_vkCreateHeadlessSurfaceEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateHeadlessSurfaceEXT");
		    pAPI->vkGetBufferDeviceAddressKHR = (PFN_vkGetBufferDeviceAddressKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferDeviceAddressKHR");
		    pAPI->vkGetBufferOpaqueCaptureAddressKHR = (PFN_vkGetBufferOpaqueCaptureAddressKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferOpaqueCaptureAddressKHR");
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddressKHR = (PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceMemoryOpaqueCaptureAddressKHR");
		    pAPI->vkGetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferDeviceAddressEXT");
		    pAPI->vkResetQueryPoolEXT = (PFN_vkResetQueryPoolEXT)vkb_dlsym(g_vkbVulkanSO, "vkResetQueryPoolEXT");
		    pAPI->vkCmdSetCullModeEXT = (PFN_vkCmdSetCullModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCullModeEXT");
		    pAPI->vkCmdSetFrontFaceEXT = (PFN_vkCmdSetFrontFaceEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetFrontFaceEXT");
		    pAPI->vkCmdSetPrimitiveTopologyEXT = (PFN_vkCmdSetPrimitiveTopologyEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPrimitiveTopologyEXT");
		    pAPI->vkCmdSetViewportWithCountEXT = (PFN_vkCmdSetViewportWithCountEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetViewportWithCountEXT");
		    pAPI->vkCmdSetScissorWithCountEXT = (PFN_vkCmdSetScissorWithCountEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetScissorWithCountEXT");
		    pAPI->vkCmdBindVertexBuffers2EXT = (PFN_vkCmdBindVertexBuffers2EXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindVertexBuffers2EXT");
		    pAPI->vkCmdSetDepthTestEnableEXT = (PFN_vkCmdSetDepthTestEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthTestEnableEXT");
		    pAPI->vkCmdSetDepthWriteEnableEXT = (PFN_vkCmdSetDepthWriteEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthWriteEnableEXT");
		    pAPI->vkCmdSetDepthCompareOpEXT = (PFN_vkCmdSetDepthCompareOpEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthCompareOpEXT");
		    pAPI->vkCmdSetDepthBoundsTestEnableEXT = (PFN_vkCmdSetDepthBoundsTestEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthBoundsTestEnableEXT");
		    pAPI->vkCmdSetStencilTestEnableEXT = (PFN_vkCmdSetStencilTestEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetStencilTestEnableEXT");
		    pAPI->vkCmdSetStencilOpEXT = (PFN_vkCmdSetStencilOpEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetStencilOpEXT");
		    pAPI->vkCreateDeferredOperationKHR = (PFN_vkCreateDeferredOperationKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateDeferredOperationKHR");
		    pAPI->vkDestroyDeferredOperationKHR = (PFN_vkDestroyDeferredOperationKHR)vkb_dlsym(g_vkbVulkanSO, "vkDestroyDeferredOperationKHR");
		    pAPI->vkGetDeferredOperationMaxConcurrencyKHR = (PFN_vkGetDeferredOperationMaxConcurrencyKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeferredOperationMaxConcurrencyKHR");
		    pAPI->vkGetDeferredOperationResultKHR = (PFN_vkGetDeferredOperationResultKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeferredOperationResultKHR");
		    pAPI->vkDeferredOperationJoinKHR = (PFN_vkDeferredOperationJoinKHR)vkb_dlsym(g_vkbVulkanSO, "vkDeferredOperationJoinKHR");
		    pAPI->vkGetPipelineExecutablePropertiesKHR = (PFN_vkGetPipelineExecutablePropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPipelineExecutablePropertiesKHR");
		    pAPI->vkGetPipelineExecutableStatisticsKHR = (PFN_vkGetPipelineExecutableStatisticsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPipelineExecutableStatisticsKHR");
		    pAPI->vkGetPipelineExecutableInternalRepresentationsKHR = (PFN_vkGetPipelineExecutableInternalRepresentationsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPipelineExecutableInternalRepresentationsKHR");
		    pAPI->vkCopyMemoryToImageEXT = (PFN_vkCopyMemoryToImageEXT)vkb_dlsym(g_vkbVulkanSO, "vkCopyMemoryToImageEXT");
		    pAPI->vkCopyImageToMemoryEXT = (PFN_vkCopyImageToMemoryEXT)vkb_dlsym(g_vkbVulkanSO, "vkCopyImageToMemoryEXT");
		    pAPI->vkCopyImageToImageEXT = (PFN_vkCopyImageToImageEXT)vkb_dlsym(g_vkbVulkanSO, "vkCopyImageToImageEXT");
		    pAPI->vkTransitionImageLayoutEXT = (PFN_vkTransitionImageLayoutEXT)vkb_dlsym(g_vkbVulkanSO, "vkTransitionImageLayoutEXT");
		    pAPI->vkGetImageSubresourceLayout2EXT = (PFN_vkGetImageSubresourceLayout2EXT)vkb_dlsym(g_vkbVulkanSO, "vkGetImageSubresourceLayout2EXT");
		    pAPI->vkMapMemory2KHR = (PFN_vkMapMemory2KHR)vkb_dlsym(g_vkbVulkanSO, "vkMapMemory2KHR");
		    pAPI->vkUnmapMemory2KHR = (PFN_vkUnmapMemory2KHR)vkb_dlsym(g_vkbVulkanSO, "vkUnmapMemory2KHR");
		    pAPI->vkReleaseSwapchainImagesEXT = (PFN_vkReleaseSwapchainImagesEXT)vkb_dlsym(g_vkbVulkanSO, "vkReleaseSwapchainImagesEXT");
		    pAPI->vkGetGeneratedCommandsMemoryRequirementsNV = (PFN_vkGetGeneratedCommandsMemoryRequirementsNV)vkb_dlsym(g_vkbVulkanSO, "vkGetGeneratedCommandsMemoryRequirementsNV");
		    pAPI->vkCmdPreprocessGeneratedCommandsNV = (PFN_vkCmdPreprocessGeneratedCommandsNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdPreprocessGeneratedCommandsNV");
		    pAPI->vkCmdExecuteGeneratedCommandsNV = (PFN_vkCmdExecuteGeneratedCommandsNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdExecuteGeneratedCommandsNV");
		    pAPI->vkCmdBindPipelineShaderGroupNV = (PFN_vkCmdBindPipelineShaderGroupNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindPipelineShaderGroupNV");
		    pAPI->vkCreateIndirectCommandsLayoutNV = (PFN_vkCreateIndirectCommandsLayoutNV)vkb_dlsym(g_vkbVulkanSO, "vkCreateIndirectCommandsLayoutNV");
		    pAPI->vkDestroyIndirectCommandsLayoutNV = (PFN_vkDestroyIndirectCommandsLayoutNV)vkb_dlsym(g_vkbVulkanSO, "vkDestroyIndirectCommandsLayoutNV");
		    pAPI->vkCmdSetDepthBias2EXT = (PFN_vkCmdSetDepthBias2EXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthBias2EXT");
		    pAPI->vkAcquireDrmDisplayEXT = (PFN_vkAcquireDrmDisplayEXT)vkb_dlsym(g_vkbVulkanSO, "vkAcquireDrmDisplayEXT");
		    pAPI->vkGetDrmDisplayEXT = (PFN_vkGetDrmDisplayEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetDrmDisplayEXT");
		    pAPI->vkCreatePrivateDataSlotEXT = (PFN_vkCreatePrivateDataSlotEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreatePrivateDataSlotEXT");
		    pAPI->vkDestroyPrivateDataSlotEXT = (PFN_vkDestroyPrivateDataSlotEXT)vkb_dlsym(g_vkbVulkanSO, "vkDestroyPrivateDataSlotEXT");
		    pAPI->vkSetPrivateDataEXT = (PFN_vkSetPrivateDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkSetPrivateDataEXT");
		    pAPI->vkGetPrivateDataEXT = (PFN_vkGetPrivateDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPrivateDataEXT");
		    pAPI->vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR");
		    pAPI->vkGetEncodedVideoSessionParametersKHR = (PFN_vkGetEncodedVideoSessionParametersKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetEncodedVideoSessionParametersKHR");
		    pAPI->vkCmdEncodeVideoKHR = (PFN_vkCmdEncodeVideoKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdEncodeVideoKHR");
		    pAPI->vkCreateCudaModuleNV = (PFN_vkCreateCudaModuleNV)vkb_dlsym(g_vkbVulkanSO, "vkCreateCudaModuleNV");
		    pAPI->vkGetCudaModuleCacheNV = (PFN_vkGetCudaModuleCacheNV)vkb_dlsym(g_vkbVulkanSO, "vkGetCudaModuleCacheNV");
		    pAPI->vkCreateCudaFunctionNV = (PFN_vkCreateCudaFunctionNV)vkb_dlsym(g_vkbVulkanSO, "vkCreateCudaFunctionNV");
		    pAPI->vkDestroyCudaModuleNV = (PFN_vkDestroyCudaModuleNV)vkb_dlsym(g_vkbVulkanSO, "vkDestroyCudaModuleNV");
		    pAPI->vkDestroyCudaFunctionNV = (PFN_vkDestroyCudaFunctionNV)vkb_dlsym(g_vkbVulkanSO, "vkDestroyCudaFunctionNV");
		    pAPI->vkCmdCudaLaunchKernelNV = (PFN_vkCmdCudaLaunchKernelNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdCudaLaunchKernelNV");
		    pAPI->vkCmdRefreshObjectsKHR = (PFN_vkCmdRefreshObjectsKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdRefreshObjectsKHR");
		    pAPI->vkGetPhysicalDeviceRefreshableObjectTypesKHR = (PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceRefreshableObjectTypesKHR");
		    pAPI->vkCmdSetEvent2KHR = (PFN_vkCmdSetEvent2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetEvent2KHR");
		    pAPI->vkCmdResetEvent2KHR = (PFN_vkCmdResetEvent2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdResetEvent2KHR");
		    pAPI->vkCmdWaitEvents2KHR = (PFN_vkCmdWaitEvents2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdWaitEvents2KHR");
		    pAPI->vkCmdPipelineBarrier2KHR = (PFN_vkCmdPipelineBarrier2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdPipelineBarrier2KHR");
		    pAPI->vkCmdWriteTimestamp2KHR = (PFN_vkCmdWriteTimestamp2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteTimestamp2KHR");
		    pAPI->vkQueueSubmit2KHR = (PFN_vkQueueSubmit2KHR)vkb_dlsym(g_vkbVulkanSO, "vkQueueSubmit2KHR");
		    pAPI->vkCmdWriteBufferMarker2AMD = (PFN_vkCmdWriteBufferMarker2AMD)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteBufferMarker2AMD");
		    pAPI->vkGetQueueCheckpointData2NV = (PFN_vkGetQueueCheckpointData2NV)vkb_dlsym(g_vkbVulkanSO, "vkGetQueueCheckpointData2NV");
		    pAPI->vkGetDescriptorSetLayoutSizeEXT = (PFN_vkGetDescriptorSetLayoutSizeEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetDescriptorSetLayoutSizeEXT");
		    pAPI->vkGetDescriptorSetLayoutBindingOffsetEXT = (PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetDescriptorSetLayoutBindingOffsetEXT");
		    pAPI->vkGetDescriptorEXT = (PFN_vkGetDescriptorEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetDescriptorEXT");
		    pAPI->vkCmdBindDescriptorBuffersEXT = (PFN_vkCmdBindDescriptorBuffersEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindDescriptorBuffersEXT");
		    pAPI->vkCmdSetDescriptorBufferOffsetsEXT = (PFN_vkCmdSetDescriptorBufferOffsetsEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDescriptorBufferOffsetsEXT");
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplersEXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
		    pAPI->vkGetBufferOpaqueCaptureDescriptorDataEXT = (PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetImageOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetImageOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetImageViewOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetImageViewOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetSamplerOpaqueCaptureDescriptorDataEXT = (PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetSamplerOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = (PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkCmdSetFragmentShadingRateEnumNV = (PFN_vkCmdSetFragmentShadingRateEnumNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetFragmentShadingRateEnumNV");
		    pAPI->vkCmdDrawMeshTasksEXT = (PFN_vkCmdDrawMeshTasksEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMeshTasksEXT");
		    pAPI->vkCmdDrawMeshTasksIndirectEXT = (PFN_vkCmdDrawMeshTasksIndirectEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMeshTasksIndirectEXT");
		    pAPI->vkCmdDrawMeshTasksIndirectCountEXT = (PFN_vkCmdDrawMeshTasksIndirectCountEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMeshTasksIndirectCountEXT");
		    pAPI->vkCmdCopyBuffer2KHR = (PFN_vkCmdCopyBuffer2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyBuffer2KHR");
		    pAPI->vkCmdCopyImage2KHR = (PFN_vkCmdCopyImage2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyImage2KHR");
		    pAPI->vkCmdCopyBufferToImage2KHR = (PFN_vkCmdCopyBufferToImage2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyBufferToImage2KHR");
		    pAPI->vkCmdCopyImageToBuffer2KHR = (PFN_vkCmdCopyImageToBuffer2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyImageToBuffer2KHR");
		    pAPI->vkCmdBlitImage2KHR = (PFN_vkCmdBlitImage2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBlitImage2KHR");
		    pAPI->vkCmdResolveImage2KHR = (PFN_vkCmdResolveImage2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdResolveImage2KHR");
		    pAPI->vkGetDeviceFaultInfoEXT = (PFN_vkGetDeviceFaultInfoEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceFaultInfoEXT");
		    pAPI->vkCmdSetVertexInputEXT = (PFN_vkCmdSetVertexInputEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetVertexInputEXT");
		    pAPI->vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = (PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
		    pAPI->vkCmdSubpassShadingHUAWEI = (PFN_vkCmdSubpassShadingHUAWEI)vkb_dlsym(g_vkbVulkanSO, "vkCmdSubpassShadingHUAWEI");
		    pAPI->vkCmdBindInvocationMaskHUAWEI = (PFN_vkCmdBindInvocationMaskHUAWEI)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindInvocationMaskHUAWEI");
		    pAPI->vkGetMemoryRemoteAddressNV = (PFN_vkGetMemoryRemoteAddressNV)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryRemoteAddressNV");
		    pAPI->vkGetPipelinePropertiesEXT = (PFN_vkGetPipelinePropertiesEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPipelinePropertiesEXT");
		    pAPI->vkCmdSetPatchControlPointsEXT = (PFN_vkCmdSetPatchControlPointsEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPatchControlPointsEXT");
		    pAPI->vkCmdSetRasterizerDiscardEnableEXT = (PFN_vkCmdSetRasterizerDiscardEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRasterizerDiscardEnableEXT");
		    pAPI->vkCmdSetDepthBiasEnableEXT = (PFN_vkCmdSetDepthBiasEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthBiasEnableEXT");
		    pAPI->vkCmdSetLogicOpEXT = (PFN_vkCmdSetLogicOpEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetLogicOpEXT");
		    pAPI->vkCmdSetPrimitiveRestartEnableEXT = (PFN_vkCmdSetPrimitiveRestartEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPrimitiveRestartEnableEXT");
		    pAPI->vkCmdSetColorWriteEnableEXT = (PFN_vkCmdSetColorWriteEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetColorWriteEnableEXT");
		    pAPI->vkCmdTraceRaysIndirect2KHR = (PFN_vkCmdTraceRaysIndirect2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdTraceRaysIndirect2KHR");
		    pAPI->vkCmdDrawMultiEXT = (PFN_vkCmdDrawMultiEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMultiEXT");
		    pAPI->vkCmdDrawMultiIndexedEXT = (PFN_vkCmdDrawMultiIndexedEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawMultiIndexedEXT");
		    pAPI->vkCreateMicromapEXT = (PFN_vkCreateMicromapEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateMicromapEXT");
		    pAPI->vkDestroyMicromapEXT = (PFN_vkDestroyMicromapEXT)vkb_dlsym(g_vkbVulkanSO, "vkDestroyMicromapEXT");
		    pAPI->vkCmdBuildMicromapsEXT = (PFN_vkCmdBuildMicromapsEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBuildMicromapsEXT");
		    pAPI->vkBuildMicromapsEXT = (PFN_vkBuildMicromapsEXT)vkb_dlsym(g_vkbVulkanSO, "vkBuildMicromapsEXT");
		    pAPI->vkCopyMicromapEXT = (PFN_vkCopyMicromapEXT)vkb_dlsym(g_vkbVulkanSO, "vkCopyMicromapEXT");
		    pAPI->vkCopyMicromapToMemoryEXT = (PFN_vkCopyMicromapToMemoryEXT)vkb_dlsym(g_vkbVulkanSO, "vkCopyMicromapToMemoryEXT");
		    pAPI->vkCopyMemoryToMicromapEXT = (PFN_vkCopyMemoryToMicromapEXT)vkb_dlsym(g_vkbVulkanSO, "vkCopyMemoryToMicromapEXT");
		    pAPI->vkWriteMicromapsPropertiesEXT = (PFN_vkWriteMicromapsPropertiesEXT)vkb_dlsym(g_vkbVulkanSO, "vkWriteMicromapsPropertiesEXT");
		    pAPI->vkCmdCopyMicromapEXT = (PFN_vkCmdCopyMicromapEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyMicromapEXT");
		    pAPI->vkCmdCopyMicromapToMemoryEXT = (PFN_vkCmdCopyMicromapToMemoryEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyMicromapToMemoryEXT");
		    pAPI->vkCmdCopyMemoryToMicromapEXT = (PFN_vkCmdCopyMemoryToMicromapEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyMemoryToMicromapEXT");
		    pAPI->vkCmdWriteMicromapsPropertiesEXT = (PFN_vkCmdWriteMicromapsPropertiesEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdWriteMicromapsPropertiesEXT");
		    pAPI->vkGetDeviceMicromapCompatibilityEXT = (PFN_vkGetDeviceMicromapCompatibilityEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceMicromapCompatibilityEXT");
		    pAPI->vkGetMicromapBuildSizesEXT = (PFN_vkGetMicromapBuildSizesEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetMicromapBuildSizesEXT");
		    pAPI->vkCmdDrawClusterHUAWEI = (PFN_vkCmdDrawClusterHUAWEI)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawClusterHUAWEI");
		    pAPI->vkCmdDrawClusterIndirectHUAWEI = (PFN_vkCmdDrawClusterIndirectHUAWEI)vkb_dlsym(g_vkbVulkanSO, "vkCmdDrawClusterIndirectHUAWEI");
		    pAPI->vkSetDeviceMemoryPriorityEXT = (PFN_vkSetDeviceMemoryPriorityEXT)vkb_dlsym(g_vkbVulkanSO, "vkSetDeviceMemoryPriorityEXT");
		    pAPI->vkGetDeviceBufferMemoryRequirementsKHR = (PFN_vkGetDeviceBufferMemoryRequirementsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceBufferMemoryRequirementsKHR");
		    pAPI->vkGetDeviceImageMemoryRequirementsKHR = (PFN_vkGetDeviceImageMemoryRequirementsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceImageMemoryRequirementsKHR");
		    pAPI->vkGetDeviceImageSparseMemoryRequirementsKHR = (PFN_vkGetDeviceImageSparseMemoryRequirementsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceImageSparseMemoryRequirementsKHR");
		    pAPI->vkGetDescriptorSetLayoutHostMappingInfoVALVE = (PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)vkb_dlsym(g_vkbVulkanSO, "vkGetDescriptorSetLayoutHostMappingInfoVALVE");
		    pAPI->vkGetDescriptorSetHostMappingVALVE = (PFN_vkGetDescriptorSetHostMappingVALVE)vkb_dlsym(g_vkbVulkanSO, "vkGetDescriptorSetHostMappingVALVE");
		    pAPI->vkCmdCopyMemoryIndirectNV = (PFN_vkCmdCopyMemoryIndirectNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyMemoryIndirectNV");
		    pAPI->vkCmdCopyMemoryToImageIndirectNV = (PFN_vkCmdCopyMemoryToImageIndirectNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdCopyMemoryToImageIndirectNV");
		    pAPI->vkCmdDecompressMemoryNV = (PFN_vkCmdDecompressMemoryNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdDecompressMemoryNV");
		    pAPI->vkCmdDecompressMemoryIndirectCountNV = (PFN_vkCmdDecompressMemoryIndirectCountNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdDecompressMemoryIndirectCountNV");
		    pAPI->vkGetPipelineIndirectMemoryRequirementsNV = (PFN_vkGetPipelineIndirectMemoryRequirementsNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPipelineIndirectMemoryRequirementsNV");
		    pAPI->vkCmdUpdatePipelineIndirectBufferNV = (PFN_vkCmdUpdatePipelineIndirectBufferNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdUpdatePipelineIndirectBufferNV");
		    pAPI->vkGetPipelineIndirectDeviceAddressNV = (PFN_vkGetPipelineIndirectDeviceAddressNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPipelineIndirectDeviceAddressNV");
		    pAPI->vkCmdSetDepthClampEnableEXT = (PFN_vkCmdSetDepthClampEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthClampEnableEXT");
		    pAPI->vkCmdSetPolygonModeEXT = (PFN_vkCmdSetPolygonModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetPolygonModeEXT");
		    pAPI->vkCmdSetRasterizationSamplesEXT = (PFN_vkCmdSetRasterizationSamplesEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRasterizationSamplesEXT");
		    pAPI->vkCmdSetSampleMaskEXT = (PFN_vkCmdSetSampleMaskEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetSampleMaskEXT");
		    pAPI->vkCmdSetAlphaToCoverageEnableEXT = (PFN_vkCmdSetAlphaToCoverageEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetAlphaToCoverageEnableEXT");
		    pAPI->vkCmdSetAlphaToOneEnableEXT = (PFN_vkCmdSetAlphaToOneEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetAlphaToOneEnableEXT");
		    pAPI->vkCmdSetLogicOpEnableEXT = (PFN_vkCmdSetLogicOpEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetLogicOpEnableEXT");
		    pAPI->vkCmdSetColorBlendEnableEXT = (PFN_vkCmdSetColorBlendEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetColorBlendEnableEXT");
		    pAPI->vkCmdSetColorBlendEquationEXT = (PFN_vkCmdSetColorBlendEquationEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetColorBlendEquationEXT");
		    pAPI->vkCmdSetColorWriteMaskEXT = (PFN_vkCmdSetColorWriteMaskEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetColorWriteMaskEXT");
		    pAPI->vkCmdSetTessellationDomainOriginEXT = (PFN_vkCmdSetTessellationDomainOriginEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetTessellationDomainOriginEXT");
		    pAPI->vkCmdSetRasterizationStreamEXT = (PFN_vkCmdSetRasterizationStreamEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRasterizationStreamEXT");
		    pAPI->vkCmdSetConservativeRasterizationModeEXT = (PFN_vkCmdSetConservativeRasterizationModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetConservativeRasterizationModeEXT");
		    pAPI->vkCmdSetExtraPrimitiveOverestimationSizeEXT = (PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetExtraPrimitiveOverestimationSizeEXT");
		    pAPI->vkCmdSetDepthClipEnableEXT = (PFN_vkCmdSetDepthClipEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthClipEnableEXT");
		    pAPI->vkCmdSetSampleLocationsEnableEXT = (PFN_vkCmdSetSampleLocationsEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetSampleLocationsEnableEXT");
		    pAPI->vkCmdSetColorBlendAdvancedEXT = (PFN_vkCmdSetColorBlendAdvancedEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetColorBlendAdvancedEXT");
		    pAPI->vkCmdSetProvokingVertexModeEXT = (PFN_vkCmdSetProvokingVertexModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetProvokingVertexModeEXT");
		    pAPI->vkCmdSetLineRasterizationModeEXT = (PFN_vkCmdSetLineRasterizationModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetLineRasterizationModeEXT");
		    pAPI->vkCmdSetLineStippleEnableEXT = (PFN_vkCmdSetLineStippleEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetLineStippleEnableEXT");
		    pAPI->vkCmdSetDepthClipNegativeOneToOneEXT = (PFN_vkCmdSetDepthClipNegativeOneToOneEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDepthClipNegativeOneToOneEXT");
		    pAPI->vkCmdSetViewportWScalingEnableNV = (PFN_vkCmdSetViewportWScalingEnableNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetViewportWScalingEnableNV");
		    pAPI->vkCmdSetViewportSwizzleNV = (PFN_vkCmdSetViewportSwizzleNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetViewportSwizzleNV");
		    pAPI->vkCmdSetCoverageToColorEnableNV = (PFN_vkCmdSetCoverageToColorEnableNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCoverageToColorEnableNV");
		    pAPI->vkCmdSetCoverageToColorLocationNV = (PFN_vkCmdSetCoverageToColorLocationNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCoverageToColorLocationNV");
		    pAPI->vkCmdSetCoverageModulationModeNV = (PFN_vkCmdSetCoverageModulationModeNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCoverageModulationModeNV");
		    pAPI->vkCmdSetCoverageModulationTableEnableNV = (PFN_vkCmdSetCoverageModulationTableEnableNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCoverageModulationTableEnableNV");
		    pAPI->vkCmdSetCoverageModulationTableNV = (PFN_vkCmdSetCoverageModulationTableNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCoverageModulationTableNV");
		    pAPI->vkCmdSetShadingRateImageEnableNV = (PFN_vkCmdSetShadingRateImageEnableNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetShadingRateImageEnableNV");
		    pAPI->vkCmdSetRepresentativeFragmentTestEnableNV = (PFN_vkCmdSetRepresentativeFragmentTestEnableNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetRepresentativeFragmentTestEnableNV");
		    pAPI->vkCmdSetCoverageReductionModeNV = (PFN_vkCmdSetCoverageReductionModeNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetCoverageReductionModeNV");
		    pAPI->vkGetShaderModuleIdentifierEXT = (PFN_vkGetShaderModuleIdentifierEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetShaderModuleIdentifierEXT");
		    pAPI->vkGetShaderModuleCreateInfoIdentifierEXT = (PFN_vkGetShaderModuleCreateInfoIdentifierEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetShaderModuleCreateInfoIdentifierEXT");
		    pAPI->vkGetPhysicalDeviceOpticalFlowImageFormatsNV = (PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
		    pAPI->vkCreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)vkb_dlsym(g_vkbVulkanSO, "vkCreateOpticalFlowSessionNV");
		    pAPI->vkDestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)vkb_dlsym(g_vkbVulkanSO, "vkDestroyOpticalFlowSessionNV");
		    pAPI->vkBindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)vkb_dlsym(g_vkbVulkanSO, "vkBindOpticalFlowSessionImageNV");
		    pAPI->vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)vkb_dlsym(g_vkbVulkanSO, "vkCmdOpticalFlowExecuteNV");
		    pAPI->vkCmdBindIndexBuffer2KHR = (PFN_vkCmdBindIndexBuffer2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindIndexBuffer2KHR");
		    pAPI->vkGetRenderingAreaGranularityKHR = (PFN_vkGetRenderingAreaGranularityKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetRenderingAreaGranularityKHR");
		    pAPI->vkGetDeviceImageSubresourceLayoutKHR = (PFN_vkGetDeviceImageSubresourceLayoutKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceImageSubresourceLayoutKHR");
		    pAPI->vkGetImageSubresourceLayout2KHR = (PFN_vkGetImageSubresourceLayout2KHR)vkb_dlsym(g_vkbVulkanSO, "vkGetImageSubresourceLayout2KHR");
		    pAPI->vkCreateShadersEXT = (PFN_vkCreateShadersEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateShadersEXT");
		    pAPI->vkDestroyShaderEXT = (PFN_vkDestroyShaderEXT)vkb_dlsym(g_vkbVulkanSO, "vkDestroyShaderEXT");
		    pAPI->vkGetShaderBinaryDataEXT = (PFN_vkGetShaderBinaryDataEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetShaderBinaryDataEXT");
		    pAPI->vkCmdBindShadersEXT = (PFN_vkCmdBindShadersEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindShadersEXT");
		    pAPI->vkGetFramebufferTilePropertiesQCOM = (PFN_vkGetFramebufferTilePropertiesQCOM)vkb_dlsym(g_vkbVulkanSO, "vkGetFramebufferTilePropertiesQCOM");
		    pAPI->vkGetDynamicRenderingTilePropertiesQCOM = (PFN_vkGetDynamicRenderingTilePropertiesQCOM)vkb_dlsym(g_vkbVulkanSO, "vkGetDynamicRenderingTilePropertiesQCOM");
		    pAPI->vkSetLatencySleepModeNV = (PFN_vkSetLatencySleepModeNV)vkb_dlsym(g_vkbVulkanSO, "vkSetLatencySleepModeNV");
		    pAPI->vkLatencySleepNV = (PFN_vkLatencySleepNV)vkb_dlsym(g_vkbVulkanSO, "vkLatencySleepNV");
		    pAPI->vkSetLatencyMarkerNV = (PFN_vkSetLatencyMarkerNV)vkb_dlsym(g_vkbVulkanSO, "vkSetLatencyMarkerNV");
		    pAPI->vkGetLatencyTimingsNV = (PFN_vkGetLatencyTimingsNV)vkb_dlsym(g_vkbVulkanSO, "vkGetLatencyTimingsNV");
		    pAPI->vkQueueNotifyOutOfBandNV = (PFN_vkQueueNotifyOutOfBandNV)vkb_dlsym(g_vkbVulkanSO, "vkQueueNotifyOutOfBandNV");
		    pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
		    pAPI->vkCmdSetAttachmentFeedbackLoopEnableEXT = (PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetAttachmentFeedbackLoopEnableEXT");
		    pAPI->vkCmdSetLineStippleKHR = (PFN_vkCmdSetLineStippleKHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetLineStippleKHR");
		    pAPI->vkCmdSetLineStippleEXT = (PFN_vkCmdSetLineStippleEXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetLineStippleEXT");
		    pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR");
		    pAPI->vkGetCalibratedTimestampsKHR = (PFN_vkGetCalibratedTimestampsKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetCalibratedTimestampsKHR");
		    pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
		    pAPI->vkGetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetCalibratedTimestampsEXT");
		    pAPI->vkCmdBindDescriptorSets2KHR = (PFN_vkCmdBindDescriptorSets2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindDescriptorSets2KHR");
		    pAPI->vkCmdPushConstants2KHR = (PFN_vkCmdPushConstants2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdPushConstants2KHR");
		    pAPI->vkCmdPushDescriptorSet2KHR = (PFN_vkCmdPushDescriptorSet2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdPushDescriptorSet2KHR");
		    pAPI->vkCmdPushDescriptorSetWithTemplate2KHR = (PFN_vkCmdPushDescriptorSetWithTemplate2KHR)vkb_dlsym(g_vkbVulkanSO, "vkCmdPushDescriptorSetWithTemplate2KHR");
		    pAPI->vkCmdSetDescriptorBufferOffsets2EXT = (PFN_vkCmdSetDescriptorBufferOffsets2EXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdSetDescriptorBufferOffsets2EXT");
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)vkb_dlsym(g_vkbVulkanSO, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT");
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		    pAPI->vkCreateXlibSurfaceKHR = (PFN_vkCreateXlibSurfaceKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateXlibSurfaceKHR");
		    pAPI->vkGetPhysicalDeviceXlibPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceXlibPresentationSupportKHR");
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		    pAPI->vkAcquireXlibDisplayEXT = (PFN_vkAcquireXlibDisplayEXT)vkb_dlsym(g_vkbVulkanSO, "vkAcquireXlibDisplayEXT");
		    pAPI->vkGetRandROutputDisplayEXT = (PFN_vkGetRandROutputDisplayEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetRandROutputDisplayEXT");
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		    pAPI->vkCreateXcbSurfaceKHR = (PFN_vkCreateXcbSurfaceKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateXcbSurfaceKHR");
		    pAPI->vkGetPhysicalDeviceXcbPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceXcbPresentationSupportKHR");
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		    pAPI->vkCreateWaylandSurfaceKHR = (PFN_vkCreateWaylandSurfaceKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateWaylandSurfaceKHR");
		    pAPI->vkGetPhysicalDeviceWaylandPresentationSupportKHR = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceWaylandPresentationSupportKHR");
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		    pAPI->vkCreateDirectFBSurfaceEXT = (PFN_vkCreateDirectFBSurfaceEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateDirectFBSurfaceEXT");
		    pAPI->vkGetPhysicalDeviceDirectFBPresentationSupportEXT = (PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT");
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		    pAPI->vkCreateAndroidSurfaceKHR = (PFN_vkCreateAndroidSurfaceKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateAndroidSurfaceKHR");
		    pAPI->vkGetAndroidHardwareBufferPropertiesANDROID = (PFN_vkGetAndroidHardwareBufferPropertiesANDROID)vkb_dlsym(g_vkbVulkanSO, "vkGetAndroidHardwareBufferPropertiesANDROID");
		    pAPI->vkGetMemoryAndroidHardwareBufferANDROID = (PFN_vkGetMemoryAndroidHardwareBufferANDROID)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryAndroidHardwareBufferANDROID");
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		    pAPI->vkCreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR)vkb_dlsym(g_vkbVulkanSO, "vkCreateWin32SurfaceKHR");
		    pAPI->vkGetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
		    pAPI->vkGetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryWin32HandleKHR");
		    pAPI->vkGetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryWin32HandlePropertiesKHR");
		    pAPI->vkGetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryWin32HandleNV");
		    pAPI->vkImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR)vkb_dlsym(g_vkbVulkanSO, "vkImportSemaphoreWin32HandleKHR");
		    pAPI->vkGetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetSemaphoreWin32HandleKHR");
		    pAPI->vkImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR)vkb_dlsym(g_vkbVulkanSO, "vkImportFenceWin32HandleKHR");
		    pAPI->vkGetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR)vkb_dlsym(g_vkbVulkanSO, "vkGetFenceWin32HandleKHR");
		    pAPI->vkGetPhysicalDeviceSurfacePresentModes2EXT = (PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
		    pAPI->vkAcquireFullScreenExclusiveModeEXT = (PFN_vkAcquireFullScreenExclusiveModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkAcquireFullScreenExclusiveModeEXT");
		    pAPI->vkReleaseFullScreenExclusiveModeEXT = (PFN_vkReleaseFullScreenExclusiveModeEXT)vkb_dlsym(g_vkbVulkanSO, "vkReleaseFullScreenExclusiveModeEXT");
		    pAPI->vkGetDeviceGroupSurfacePresentModes2EXT = (PFN_vkGetDeviceGroupSurfacePresentModes2EXT)vkb_dlsym(g_vkbVulkanSO, "vkGetDeviceGroupSurfacePresentModes2EXT");
		    pAPI->vkAcquireWinrtDisplayNV = (PFN_vkAcquireWinrtDisplayNV)vkb_dlsym(g_vkbVulkanSO, "vkAcquireWinrtDisplayNV");
		    pAPI->vkGetWinrtDisplayNV = (PFN_vkGetWinrtDisplayNV)vkb_dlsym(g_vkbVulkanSO, "vkGetWinrtDisplayNV");
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		    pAPI->vkCreateViSurfaceNN = (PFN_vkCreateViSurfaceNN)vkb_dlsym(g_vkbVulkanSO, "vkCreateViSurfaceNN");
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		    pAPI->vkCreateIOSSurfaceMVK = (PFN_vkCreateIOSSurfaceMVK)vkb_dlsym(g_vkbVulkanSO, "vkCreateIOSSurfaceMVK");
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		    pAPI->vkCreateMacOSSurfaceMVK = (PFN_vkCreateMacOSSurfaceMVK)vkb_dlsym(g_vkbVulkanSO, "vkCreateMacOSSurfaceMVK");
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		    pAPI->vkCreateMetalSurfaceEXT = (PFN_vkCreateMetalSurfaceEXT)vkb_dlsym(g_vkbVulkanSO, "vkCreateMetalSurfaceEXT");
		    pAPI->vkExportMetalObjectsEXT = (PFN_vkExportMetalObjectsEXT)vkb_dlsym(g_vkbVulkanSO, "vkExportMetalObjectsEXT");
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		    pAPI->vkCreateImagePipeSurfaceFUCHSIA = (PFN_vkCreateImagePipeSurfaceFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkCreateImagePipeSurfaceFUCHSIA");
		    pAPI->vkGetMemoryZirconHandleFUCHSIA = (PFN_vkGetMemoryZirconHandleFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryZirconHandleFUCHSIA");
		    pAPI->vkGetMemoryZirconHandlePropertiesFUCHSIA = (PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkGetMemoryZirconHandlePropertiesFUCHSIA");
		    pAPI->vkImportSemaphoreZirconHandleFUCHSIA = (PFN_vkImportSemaphoreZirconHandleFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkImportSemaphoreZirconHandleFUCHSIA");
		    pAPI->vkGetSemaphoreZirconHandleFUCHSIA = (PFN_vkGetSemaphoreZirconHandleFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkGetSemaphoreZirconHandleFUCHSIA");
		    pAPI->vkCreateBufferCollectionFUCHSIA = (PFN_vkCreateBufferCollectionFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkCreateBufferCollectionFUCHSIA");
		    pAPI->vkSetBufferCollectionImageConstraintsFUCHSIA = (PFN_vkSetBufferCollectionImageConstraintsFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkSetBufferCollectionImageConstraintsFUCHSIA");
		    pAPI->vkSetBufferCollectionBufferConstraintsFUCHSIA = (PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkSetBufferCollectionBufferConstraintsFUCHSIA");
		    pAPI->vkDestroyBufferCollectionFUCHSIA = (PFN_vkDestroyBufferCollectionFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkDestroyBufferCollectionFUCHSIA");
		    pAPI->vkGetBufferCollectionPropertiesFUCHSIA = (PFN_vkGetBufferCollectionPropertiesFUCHSIA)vkb_dlsym(g_vkbVulkanSO, "vkGetBufferCollectionPropertiesFUCHSIA");
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		    pAPI->vkCreateStreamDescriptorSurfaceGGP = (PFN_vkCreateStreamDescriptorSurfaceGGP)vkb_dlsym(g_vkbVulkanSO, "vkCreateStreamDescriptorSurfaceGGP");
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		    pAPI->vkGetMemorySciBufNV = (PFN_vkGetMemorySciBufNV)vkb_dlsym(g_vkbVulkanSO, "vkGetMemorySciBufNV");
		    pAPI->vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = (PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV");
		    pAPI->vkGetPhysicalDeviceSciBufAttributesNV = (PFN_vkGetPhysicalDeviceSciBufAttributesNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSciBufAttributesNV");
		    pAPI->vkCreateSemaphoreSciSyncPoolNV = (PFN_vkCreateSemaphoreSciSyncPoolNV)vkb_dlsym(g_vkbVulkanSO, "vkCreateSemaphoreSciSyncPoolNV");
		    pAPI->vkDestroySemaphoreSciSyncPoolNV = (PFN_vkDestroySemaphoreSciSyncPoolNV)vkb_dlsym(g_vkbVulkanSO, "vkDestroySemaphoreSciSyncPoolNV");
		    pAPI->vkGetFenceSciSyncFenceNV = (PFN_vkGetFenceSciSyncFenceNV)vkb_dlsym(g_vkbVulkanSO, "vkGetFenceSciSyncFenceNV");
		    pAPI->vkGetFenceSciSyncObjNV = (PFN_vkGetFenceSciSyncObjNV)vkb_dlsym(g_vkbVulkanSO, "vkGetFenceSciSyncObjNV");
		    pAPI->vkImportFenceSciSyncFenceNV = (PFN_vkImportFenceSciSyncFenceNV)vkb_dlsym(g_vkbVulkanSO, "vkImportFenceSciSyncFenceNV");
		    pAPI->vkImportFenceSciSyncObjNV = (PFN_vkImportFenceSciSyncObjNV)vkb_dlsym(g_vkbVulkanSO, "vkImportFenceSciSyncObjNV");
		    pAPI->vkGetPhysicalDeviceSciSyncAttributesNV = (PFN_vkGetPhysicalDeviceSciSyncAttributesNV)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceSciSyncAttributesNV");
		    pAPI->vkGetSemaphoreSciSyncObjNV = (PFN_vkGetSemaphoreSciSyncObjNV)vkb_dlsym(g_vkbVulkanSO, "vkGetSemaphoreSciSyncObjNV");
		    pAPI->vkImportSemaphoreSciSyncObjNV = (PFN_vkImportSemaphoreSciSyncObjNV)vkb_dlsym(g_vkbVulkanSO, "vkImportSemaphoreSciSyncObjNV");
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		    pAPI->vkCreateExecutionGraphPipelinesAMDX = (PFN_vkCreateExecutionGraphPipelinesAMDX)vkb_dlsym(g_vkbVulkanSO, "vkCreateExecutionGraphPipelinesAMDX");
		    pAPI->vkGetExecutionGraphPipelineScratchSizeAMDX = (PFN_vkGetExecutionGraphPipelineScratchSizeAMDX)vkb_dlsym(g_vkbVulkanSO, "vkGetExecutionGraphPipelineScratchSizeAMDX");
		    pAPI->vkGetExecutionGraphPipelineNodeIndexAMDX = (PFN_vkGetExecutionGraphPipelineNodeIndexAMDX)vkb_dlsym(g_vkbVulkanSO, "vkGetExecutionGraphPipelineNodeIndexAMDX");
		    pAPI->vkCmdInitializeGraphScratchMemoryAMDX = (PFN_vkCmdInitializeGraphScratchMemoryAMDX)vkb_dlsym(g_vkbVulkanSO, "vkCmdInitializeGraphScratchMemoryAMDX");
		    pAPI->vkCmdDispatchGraphAMDX = (PFN_vkCmdDispatchGraphAMDX)vkb_dlsym(g_vkbVulkanSO, "vkCmdDispatchGraphAMDX");
		    pAPI->vkCmdDispatchGraphIndirectAMDX = (PFN_vkCmdDispatchGraphIndirectAMDX)vkb_dlsym(g_vkbVulkanSO, "vkCmdDispatchGraphIndirectAMDX");
		    pAPI->vkCmdDispatchGraphIndirectCountAMDX = (PFN_vkCmdDispatchGraphIndirectCountAMDX)vkb_dlsym(g_vkbVulkanSO, "vkCmdDispatchGraphIndirectCountAMDX");
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		    pAPI->vkCreateScreenSurfaceQNX = (PFN_vkCreateScreenSurfaceQNX)vkb_dlsym(g_vkbVulkanSO, "vkCreateScreenSurfaceQNX");
		    pAPI->vkGetPhysicalDeviceScreenPresentationSupportQNX = (PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX)vkb_dlsym(g_vkbVulkanSO, "vkGetPhysicalDeviceScreenPresentationSupportQNX");
		    pAPI->vkGetScreenBufferPropertiesQNX = (PFN_vkGetScreenBufferPropertiesQNX)vkb_dlsym(g_vkbVulkanSO, "vkGetScreenBufferPropertiesQNX");
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/

		    /*
		    We can only safely guarantee that vkGetInstanceProcAddr was successfully returned from dlsym(). The Vulkan specification lists some APIs
		    that should always work with vkGetInstanceProcAddr(), so I'm going ahead and doing that here just for robustness.
		    */
		    if (pAPI->vkGetInstanceProcAddr == NULL) {
				return VK_ERROR_INITIALIZATION_FAILED;
		    }

		    pAPI->vkCreateInstance = (PFN_vkCreateInstance)pAPI->vkGetInstanceProcAddr(NULL, "vkCreateInstance");
		    pAPI->vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)pAPI->vkGetInstanceProcAddr(NULL, "vkEnumerateInstanceExtensionProperties");
		    pAPI->vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties)pAPI->vkGetInstanceProcAddr(NULL, "vkEnumerateInstanceLayerProperties");
		    pAPI->vkEnumerateInstanceVersion = (PFN_vkEnumerateInstanceVersion)pAPI->vkGetInstanceProcAddr(NULL, "vkEnumerateInstanceVersion");

		    return VK_SUCCESS;
		}

		#ifndef VKBIND_NO_GLOBAL_API
		static void vkbInitFromGlobalAPI(VkbAPI* pAPI)
		{
		    pAPI->vkCreateInstance = vkCreateInstance;
		    pAPI->vkDestroyInstance = vkDestroyInstance;
		    pAPI->vkEnumeratePhysicalDevices = vkEnumeratePhysicalDevices;
		    pAPI->vkGetPhysicalDeviceFeatures = vkGetPhysicalDeviceFeatures;
		    pAPI->vkGetPhysicalDeviceFormatProperties = vkGetPhysicalDeviceFormatProperties;
		    pAPI->vkGetPhysicalDeviceImageFormatProperties = vkGetPhysicalDeviceImageFormatProperties;
		    pAPI->vkGetPhysicalDeviceProperties = vkGetPhysicalDeviceProperties;
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties = vkGetPhysicalDeviceQueueFamilyProperties;
		    pAPI->vkGetPhysicalDeviceMemoryProperties = vkGetPhysicalDeviceMemoryProperties;
		    pAPI->vkGetInstanceProcAddr = vkGetInstanceProcAddr;
		    pAPI->vkGetDeviceProcAddr = vkGetDeviceProcAddr;
		    pAPI->vkCreateDevice = vkCreateDevice;
		    pAPI->vkDestroyDevice = vkDestroyDevice;
		    pAPI->vkEnumerateInstanceExtensionProperties = vkEnumerateInstanceExtensionProperties;
		    pAPI->vkEnumerateDeviceExtensionProperties = vkEnumerateDeviceExtensionProperties;
		    pAPI->vkEnumerateInstanceLayerProperties = vkEnumerateInstanceLayerProperties;
		    pAPI->vkEnumerateDeviceLayerProperties = vkEnumerateDeviceLayerProperties;
		    pAPI->vkGetDeviceQueue = vkGetDeviceQueue;
		    pAPI->vkQueueSubmit = vkQueueSubmit;
		    pAPI->vkQueueWaitIdle = vkQueueWaitIdle;
		    pAPI->vkDeviceWaitIdle = vkDeviceWaitIdle;
		    pAPI->vkAllocateMemory = vkAllocateMemory;
		    pAPI->vkFreeMemory = vkFreeMemory;
		    pAPI->vkMapMemory = vkMapMemory;
		    pAPI->vkUnmapMemory = vkUnmapMemory;
		    pAPI->vkFlushMappedMemoryRanges = vkFlushMappedMemoryRanges;
		    pAPI->vkInvalidateMappedMemoryRanges = vkInvalidateMappedMemoryRanges;
		    pAPI->vkGetDeviceMemoryCommitment = vkGetDeviceMemoryCommitment;
		    pAPI->vkBindBufferMemory = vkBindBufferMemory;
		    pAPI->vkBindImageMemory = vkBindImageMemory;
		    pAPI->vkGetBufferMemoryRequirements = vkGetBufferMemoryRequirements;
		    pAPI->vkGetImageMemoryRequirements = vkGetImageMemoryRequirements;
		    pAPI->vkGetImageSparseMemoryRequirements = vkGetImageSparseMemoryRequirements;
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties = vkGetPhysicalDeviceSparseImageFormatProperties;
		    pAPI->vkQueueBindSparse = vkQueueBindSparse;
		    pAPI->vkCreateFence = vkCreateFence;
		    pAPI->vkDestroyFence = vkDestroyFence;
		    pAPI->vkResetFences = vkResetFences;
		    pAPI->vkGetFenceStatus = vkGetFenceStatus;
		    pAPI->vkWaitForFences = vkWaitForFences;
		    pAPI->vkCreateSemaphore = vkCreateSemaphore;
		    pAPI->vkDestroySemaphore = vkDestroySemaphore;
		    pAPI->vkCreateEvent = vkCreateEvent;
		    pAPI->vkDestroyEvent = vkDestroyEvent;
		    pAPI->vkGetEventStatus = vkGetEventStatus;
		    pAPI->vkSetEvent = vkSetEvent;
		    pAPI->vkResetEvent = vkResetEvent;
		    pAPI->vkCreateQueryPool = vkCreateQueryPool;
		    pAPI->vkDestroyQueryPool = vkDestroyQueryPool;
		    pAPI->vkGetQueryPoolResults = vkGetQueryPoolResults;
		    pAPI->vkCreateBuffer = vkCreateBuffer;
		    pAPI->vkDestroyBuffer = vkDestroyBuffer;
		    pAPI->vkCreateBufferView = vkCreateBufferView;
		    pAPI->vkDestroyBufferView = vkDestroyBufferView;
		    pAPI->vkCreateImage = vkCreateImage;
		    pAPI->vkDestroyImage = vkDestroyImage;
		    pAPI->vkGetImageSubresourceLayout = vkGetImageSubresourceLayout;
		    pAPI->vkCreateImageView = vkCreateImageView;
		    pAPI->vkDestroyImageView = vkDestroyImageView;
		    pAPI->vkCreateShaderModule = vkCreateShaderModule;
		    pAPI->vkDestroyShaderModule = vkDestroyShaderModule;
		    pAPI->vkCreatePipelineCache = vkCreatePipelineCache;
		    pAPI->vkDestroyPipelineCache = vkDestroyPipelineCache;
		    pAPI->vkGetPipelineCacheData = vkGetPipelineCacheData;
		    pAPI->vkMergePipelineCaches = vkMergePipelineCaches;
		    pAPI->vkCreateGraphicsPipelines = vkCreateGraphicsPipelines;
		    pAPI->vkCreateComputePipelines = vkCreateComputePipelines;
		    pAPI->vkDestroyPipeline = vkDestroyPipeline;
		    pAPI->vkCreatePipelineLayout = vkCreatePipelineLayout;
		    pAPI->vkDestroyPipelineLayout = vkDestroyPipelineLayout;
		    pAPI->vkCreateSampler = vkCreateSampler;
		    pAPI->vkDestroySampler = vkDestroySampler;
		    pAPI->vkCreateDescriptorSetLayout = vkCreateDescriptorSetLayout;
		    pAPI->vkDestroyDescriptorSetLayout = vkDestroyDescriptorSetLayout;
		    pAPI->vkCreateDescriptorPool = vkCreateDescriptorPool;
		    pAPI->vkDestroyDescriptorPool = vkDestroyDescriptorPool;
		    pAPI->vkResetDescriptorPool = vkResetDescriptorPool;
		    pAPI->vkAllocateDescriptorSets = vkAllocateDescriptorSets;
		    pAPI->vkFreeDescriptorSets = vkFreeDescriptorSets;
		    pAPI->vkUpdateDescriptorSets = vkUpdateDescriptorSets;
		    pAPI->vkCreateFramebuffer = vkCreateFramebuffer;
		    pAPI->vkDestroyFramebuffer = vkDestroyFramebuffer;
		    pAPI->vkCreateRenderPass = vkCreateRenderPass;
		    pAPI->vkDestroyRenderPass = vkDestroyRenderPass;
		    pAPI->vkGetRenderAreaGranularity = vkGetRenderAreaGranularity;
		    pAPI->vkCreateCommandPool = vkCreateCommandPool;
		    pAPI->vkDestroyCommandPool = vkDestroyCommandPool;
		    pAPI->vkResetCommandPool = vkResetCommandPool;
		    pAPI->vkAllocateCommandBuffers = vkAllocateCommandBuffers;
		    pAPI->vkFreeCommandBuffers = vkFreeCommandBuffers;
		    pAPI->vkBeginCommandBuffer = vkBeginCommandBuffer;
		    pAPI->vkEndCommandBuffer = vkEndCommandBuffer;
		    pAPI->vkResetCommandBuffer = vkResetCommandBuffer;
		    pAPI->vkCmdBindPipeline = vkCmdBindPipeline;
		    pAPI->vkCmdSetViewport = vkCmdSetViewport;
		    pAPI->vkCmdSetScissor = vkCmdSetScissor;
		    pAPI->vkCmdSetLineWidth = vkCmdSetLineWidth;
		    pAPI->vkCmdSetDepthBias = vkCmdSetDepthBias;
		    pAPI->vkCmdSetBlendConstants = vkCmdSetBlendConstants;
		    pAPI->vkCmdSetDepthBounds = vkCmdSetDepthBounds;
		    pAPI->vkCmdSetStencilCompareMask = vkCmdSetStencilCompareMask;
		    pAPI->vkCmdSetStencilWriteMask = vkCmdSetStencilWriteMask;
		    pAPI->vkCmdSetStencilReference = vkCmdSetStencilReference;
		    pAPI->vkCmdBindDescriptorSets = vkCmdBindDescriptorSets;
		    pAPI->vkCmdBindIndexBuffer = vkCmdBindIndexBuffer;
		    pAPI->vkCmdBindVertexBuffers = vkCmdBindVertexBuffers;
		    pAPI->vkCmdDraw = vkCmdDraw;
		    pAPI->vkCmdDrawIndexed = vkCmdDrawIndexed;
		    pAPI->vkCmdDrawIndirect = vkCmdDrawIndirect;
		    pAPI->vkCmdDrawIndexedIndirect = vkCmdDrawIndexedIndirect;
		    pAPI->vkCmdDispatch = vkCmdDispatch;
		    pAPI->vkCmdDispatchIndirect = vkCmdDispatchIndirect;
		    pAPI->vkCmdCopyBuffer = vkCmdCopyBuffer;
		    pAPI->vkCmdCopyImage = vkCmdCopyImage;
		    pAPI->vkCmdBlitImage = vkCmdBlitImage;
		    pAPI->vkCmdCopyBufferToImage = vkCmdCopyBufferToImage;
		    pAPI->vkCmdCopyImageToBuffer = vkCmdCopyImageToBuffer;
		    pAPI->vkCmdUpdateBuffer = vkCmdUpdateBuffer;
		    pAPI->vkCmdFillBuffer = vkCmdFillBuffer;
		    pAPI->vkCmdClearColorImage = vkCmdClearColorImage;
		    pAPI->vkCmdClearDepthStencilImage = vkCmdClearDepthStencilImage;
		    pAPI->vkCmdClearAttachments = vkCmdClearAttachments;
		    pAPI->vkCmdResolveImage = vkCmdResolveImage;
		    pAPI->vkCmdSetEvent = vkCmdSetEvent;
		    pAPI->vkCmdResetEvent = vkCmdResetEvent;
		    pAPI->vkCmdWaitEvents = vkCmdWaitEvents;
		    pAPI->vkCmdPipelineBarrier = vkCmdPipelineBarrier;
		    pAPI->vkCmdBeginQuery = vkCmdBeginQuery;
		    pAPI->vkCmdEndQuery = vkCmdEndQuery;
		    pAPI->vkCmdResetQueryPool = vkCmdResetQueryPool;
		    pAPI->vkCmdWriteTimestamp = vkCmdWriteTimestamp;
		    pAPI->vkCmdCopyQueryPoolResults = vkCmdCopyQueryPoolResults;
		    pAPI->vkCmdPushConstants = vkCmdPushConstants;
		    pAPI->vkCmdBeginRenderPass = vkCmdBeginRenderPass;
		    pAPI->vkCmdNextSubpass = vkCmdNextSubpass;
		    pAPI->vkCmdEndRenderPass = vkCmdEndRenderPass;
		    pAPI->vkCmdExecuteCommands = vkCmdExecuteCommands;
		    pAPI->vkEnumerateInstanceVersion = vkEnumerateInstanceVersion;
		    pAPI->vkBindBufferMemory2 = vkBindBufferMemory2;
		    pAPI->vkBindImageMemory2 = vkBindImageMemory2;
		    pAPI->vkGetDeviceGroupPeerMemoryFeatures = vkGetDeviceGroupPeerMemoryFeatures;
		    pAPI->vkCmdSetDeviceMask = vkCmdSetDeviceMask;
		    pAPI->vkCmdDispatchBase = vkCmdDispatchBase;
		    pAPI->vkEnumeratePhysicalDeviceGroups = vkEnumeratePhysicalDeviceGroups;
		    pAPI->vkGetImageMemoryRequirements2 = vkGetImageMemoryRequirements2;
		    pAPI->vkGetBufferMemoryRequirements2 = vkGetBufferMemoryRequirements2;
		    pAPI->vkGetImageSparseMemoryRequirements2 = vkGetImageSparseMemoryRequirements2;
		    pAPI->vkGetPhysicalDeviceFeatures2 = vkGetPhysicalDeviceFeatures2;
		    pAPI->vkGetPhysicalDeviceProperties2 = vkGetPhysicalDeviceProperties2;
		    pAPI->vkGetPhysicalDeviceFormatProperties2 = vkGetPhysicalDeviceFormatProperties2;
		    pAPI->vkGetPhysicalDeviceImageFormatProperties2 = vkGetPhysicalDeviceImageFormatProperties2;
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties2 = vkGetPhysicalDeviceQueueFamilyProperties2;
		    pAPI->vkGetPhysicalDeviceMemoryProperties2 = vkGetPhysicalDeviceMemoryProperties2;
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2 = vkGetPhysicalDeviceSparseImageFormatProperties2;
		    pAPI->vkTrimCommandPool = vkTrimCommandPool;
		    pAPI->vkGetDeviceQueue2 = vkGetDeviceQueue2;
		    pAPI->vkCreateSamplerYcbcrConversion = vkCreateSamplerYcbcrConversion;
		    pAPI->vkDestroySamplerYcbcrConversion = vkDestroySamplerYcbcrConversion;
		    pAPI->vkCreateDescriptorUpdateTemplate = vkCreateDescriptorUpdateTemplate;
		    pAPI->vkDestroyDescriptorUpdateTemplate = vkDestroyDescriptorUpdateTemplate;
		    pAPI->vkUpdateDescriptorSetWithTemplate = vkUpdateDescriptorSetWithTemplate;
		    pAPI->vkGetPhysicalDeviceExternalBufferProperties = vkGetPhysicalDeviceExternalBufferProperties;
		    pAPI->vkGetPhysicalDeviceExternalFenceProperties = vkGetPhysicalDeviceExternalFenceProperties;
		    pAPI->vkGetPhysicalDeviceExternalSemaphoreProperties = vkGetPhysicalDeviceExternalSemaphoreProperties;
		    pAPI->vkGetDescriptorSetLayoutSupport = vkGetDescriptorSetLayoutSupport;
		    pAPI->vkCmdDrawIndirectCount = vkCmdDrawIndirectCount;
		    pAPI->vkCmdDrawIndexedIndirectCount = vkCmdDrawIndexedIndirectCount;
		    pAPI->vkCreateRenderPass2 = vkCreateRenderPass2;
		    pAPI->vkCmdBeginRenderPass2 = vkCmdBeginRenderPass2;
		    pAPI->vkCmdNextSubpass2 = vkCmdNextSubpass2;
		    pAPI->vkCmdEndRenderPass2 = vkCmdEndRenderPass2;
		    pAPI->vkResetQueryPool = vkResetQueryPool;
		    pAPI->vkGetSemaphoreCounterValue = vkGetSemaphoreCounterValue;
		    pAPI->vkWaitSemaphores = vkWaitSemaphores;
		    pAPI->vkSignalSemaphore = vkSignalSemaphore;
		    pAPI->vkGetBufferDeviceAddress = vkGetBufferDeviceAddress;
		    pAPI->vkGetBufferOpaqueCaptureAddress = vkGetBufferOpaqueCaptureAddress;
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddress = vkGetDeviceMemoryOpaqueCaptureAddress;
		    pAPI->vkGetPhysicalDeviceToolProperties = vkGetPhysicalDeviceToolProperties;
		    pAPI->vkCreatePrivateDataSlot = vkCreatePrivateDataSlot;
		    pAPI->vkDestroyPrivateDataSlot = vkDestroyPrivateDataSlot;
		    pAPI->vkSetPrivateData = vkSetPrivateData;
		    pAPI->vkGetPrivateData = vkGetPrivateData;
		    pAPI->vkCmdSetEvent2 = vkCmdSetEvent2;
		    pAPI->vkCmdResetEvent2 = vkCmdResetEvent2;
		    pAPI->vkCmdWaitEvents2 = vkCmdWaitEvents2;
		    pAPI->vkCmdPipelineBarrier2 = vkCmdPipelineBarrier2;
		    pAPI->vkCmdWriteTimestamp2 = vkCmdWriteTimestamp2;
		    pAPI->vkQueueSubmit2 = vkQueueSubmit2;
		    pAPI->vkCmdCopyBuffer2 = vkCmdCopyBuffer2;
		    pAPI->vkCmdCopyImage2 = vkCmdCopyImage2;
		    pAPI->vkCmdCopyBufferToImage2 = vkCmdCopyBufferToImage2;
		    pAPI->vkCmdCopyImageToBuffer2 = vkCmdCopyImageToBuffer2;
		    pAPI->vkCmdBlitImage2 = vkCmdBlitImage2;
		    pAPI->vkCmdResolveImage2 = vkCmdResolveImage2;
		    pAPI->vkCmdBeginRendering = vkCmdBeginRendering;
		    pAPI->vkCmdEndRendering = vkCmdEndRendering;
		    pAPI->vkCmdSetCullMode = vkCmdSetCullMode;
		    pAPI->vkCmdSetFrontFace = vkCmdSetFrontFace;
		    pAPI->vkCmdSetPrimitiveTopology = vkCmdSetPrimitiveTopology;
		    pAPI->vkCmdSetViewportWithCount = vkCmdSetViewportWithCount;
		    pAPI->vkCmdSetScissorWithCount = vkCmdSetScissorWithCount;
		    pAPI->vkCmdBindVertexBuffers2 = vkCmdBindVertexBuffers2;
		    pAPI->vkCmdSetDepthTestEnable = vkCmdSetDepthTestEnable;
		    pAPI->vkCmdSetDepthWriteEnable = vkCmdSetDepthWriteEnable;
		    pAPI->vkCmdSetDepthCompareOp = vkCmdSetDepthCompareOp;
		    pAPI->vkCmdSetDepthBoundsTestEnable = vkCmdSetDepthBoundsTestEnable;
		    pAPI->vkCmdSetStencilTestEnable = vkCmdSetStencilTestEnable;
		    pAPI->vkCmdSetStencilOp = vkCmdSetStencilOp;
		    pAPI->vkCmdSetRasterizerDiscardEnable = vkCmdSetRasterizerDiscardEnable;
		    pAPI->vkCmdSetDepthBiasEnable = vkCmdSetDepthBiasEnable;
		    pAPI->vkCmdSetPrimitiveRestartEnable = vkCmdSetPrimitiveRestartEnable;
		    pAPI->vkGetDeviceBufferMemoryRequirements = vkGetDeviceBufferMemoryRequirements;
		    pAPI->vkGetDeviceImageMemoryRequirements = vkGetDeviceImageMemoryRequirements;
		    pAPI->vkGetDeviceImageSparseMemoryRequirements = vkGetDeviceImageSparseMemoryRequirements;
		    pAPI->vkGetCommandPoolMemoryConsumption = vkGetCommandPoolMemoryConsumption;
		    pAPI->vkGetFaultData = vkGetFaultData;
		    pAPI->vkDestroySurfaceKHR = vkDestroySurfaceKHR;
		    pAPI->vkGetPhysicalDeviceSurfaceSupportKHR = vkGetPhysicalDeviceSurfaceSupportKHR;
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilitiesKHR = vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
		    pAPI->vkGetPhysicalDeviceSurfaceFormatsKHR = vkGetPhysicalDeviceSurfaceFormatsKHR;
		    pAPI->vkGetPhysicalDeviceSurfacePresentModesKHR = vkGetPhysicalDeviceSurfacePresentModesKHR;
		    pAPI->vkCreateSwapchainKHR = vkCreateSwapchainKHR;
		    pAPI->vkDestroySwapchainKHR = vkDestroySwapchainKHR;
		    pAPI->vkGetSwapchainImagesKHR = vkGetSwapchainImagesKHR;
		    pAPI->vkAcquireNextImageKHR = vkAcquireNextImageKHR;
		    pAPI->vkQueuePresentKHR = vkQueuePresentKHR;
		    pAPI->vkGetDeviceGroupPresentCapabilitiesKHR = vkGetDeviceGroupPresentCapabilitiesKHR;
		    pAPI->vkGetDeviceGroupSurfacePresentModesKHR = vkGetDeviceGroupSurfacePresentModesKHR;
		    pAPI->vkGetPhysicalDevicePresentRectanglesKHR = vkGetPhysicalDevicePresentRectanglesKHR;
		    pAPI->vkAcquireNextImage2KHR = vkAcquireNextImage2KHR;
		    pAPI->vkGetPhysicalDeviceDisplayPropertiesKHR = vkGetPhysicalDeviceDisplayPropertiesKHR;
		    pAPI->vkGetPhysicalDeviceDisplayPlanePropertiesKHR = vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
		    pAPI->vkGetDisplayPlaneSupportedDisplaysKHR = vkGetDisplayPlaneSupportedDisplaysKHR;
		    pAPI->vkGetDisplayModePropertiesKHR = vkGetDisplayModePropertiesKHR;
		    pAPI->vkCreateDisplayModeKHR = vkCreateDisplayModeKHR;
		    pAPI->vkGetDisplayPlaneCapabilitiesKHR = vkGetDisplayPlaneCapabilitiesKHR;
		    pAPI->vkCreateDisplayPlaneSurfaceKHR = vkCreateDisplayPlaneSurfaceKHR;
		    pAPI->vkCreateSharedSwapchainsKHR = vkCreateSharedSwapchainsKHR;
		    pAPI->vkGetPhysicalDeviceVideoCapabilitiesKHR = vkGetPhysicalDeviceVideoCapabilitiesKHR;
		    pAPI->vkGetPhysicalDeviceVideoFormatPropertiesKHR = vkGetPhysicalDeviceVideoFormatPropertiesKHR;
		    pAPI->vkCreateVideoSessionKHR = vkCreateVideoSessionKHR;
		    pAPI->vkDestroyVideoSessionKHR = vkDestroyVideoSessionKHR;
		    pAPI->vkGetVideoSessionMemoryRequirementsKHR = vkGetVideoSessionMemoryRequirementsKHR;
		    pAPI->vkBindVideoSessionMemoryKHR = vkBindVideoSessionMemoryKHR;
		    pAPI->vkCreateVideoSessionParametersKHR = vkCreateVideoSessionParametersKHR;
		    pAPI->vkUpdateVideoSessionParametersKHR = vkUpdateVideoSessionParametersKHR;
		    pAPI->vkDestroyVideoSessionParametersKHR = vkDestroyVideoSessionParametersKHR;
		    pAPI->vkCmdBeginVideoCodingKHR = vkCmdBeginVideoCodingKHR;
		    pAPI->vkCmdEndVideoCodingKHR = vkCmdEndVideoCodingKHR;
		    pAPI->vkCmdControlVideoCodingKHR = vkCmdControlVideoCodingKHR;
		    pAPI->vkCmdDecodeVideoKHR = vkCmdDecodeVideoKHR;
		    pAPI->vkCmdBindTransformFeedbackBuffersEXT = vkCmdBindTransformFeedbackBuffersEXT;
		    pAPI->vkCmdBeginTransformFeedbackEXT = vkCmdBeginTransformFeedbackEXT;
		    pAPI->vkCmdEndTransformFeedbackEXT = vkCmdEndTransformFeedbackEXT;
		    pAPI->vkCmdBeginQueryIndexedEXT = vkCmdBeginQueryIndexedEXT;
		    pAPI->vkCmdEndQueryIndexedEXT = vkCmdEndQueryIndexedEXT;
		    pAPI->vkCmdDrawIndirectByteCountEXT = vkCmdDrawIndirectByteCountEXT;
		    pAPI->vkCreateCuModuleNVX = vkCreateCuModuleNVX;
		    pAPI->vkCreateCuFunctionNVX = vkCreateCuFunctionNVX;
		    pAPI->vkDestroyCuModuleNVX = vkDestroyCuModuleNVX;
		    pAPI->vkDestroyCuFunctionNVX = vkDestroyCuFunctionNVX;
		    pAPI->vkCmdCuLaunchKernelNVX = vkCmdCuLaunchKernelNVX;
		    pAPI->vkGetImageViewHandleNVX = vkGetImageViewHandleNVX;
		    pAPI->vkGetImageViewAddressNVX = vkGetImageViewAddressNVX;
		    pAPI->vkGetShaderInfoAMD = vkGetShaderInfoAMD;
		    pAPI->vkCmdBeginRenderingKHR = vkCmdBeginRenderingKHR;
		    pAPI->vkCmdEndRenderingKHR = vkCmdEndRenderingKHR;
		    pAPI->vkGetPhysicalDeviceFeatures2KHR = vkGetPhysicalDeviceFeatures2KHR;
		    pAPI->vkGetPhysicalDeviceProperties2KHR = vkGetPhysicalDeviceProperties2KHR;
		    pAPI->vkGetPhysicalDeviceFormatProperties2KHR = vkGetPhysicalDeviceFormatProperties2KHR;
		    pAPI->vkGetPhysicalDeviceImageFormatProperties2KHR = vkGetPhysicalDeviceImageFormatProperties2KHR;
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties2KHR = vkGetPhysicalDeviceQueueFamilyProperties2KHR;
		    pAPI->vkGetPhysicalDeviceMemoryProperties2KHR = vkGetPhysicalDeviceMemoryProperties2KHR;
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2KHR = vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
		    pAPI->vkGetDeviceGroupPeerMemoryFeaturesKHR = vkGetDeviceGroupPeerMemoryFeaturesKHR;
		    pAPI->vkCmdSetDeviceMaskKHR = vkCmdSetDeviceMaskKHR;
		    pAPI->vkCmdDispatchBaseKHR = vkCmdDispatchBaseKHR;
		    pAPI->vkTrimCommandPoolKHR = vkTrimCommandPoolKHR;
		    pAPI->vkEnumeratePhysicalDeviceGroupsKHR = vkEnumeratePhysicalDeviceGroupsKHR;
		    pAPI->vkGetPhysicalDeviceExternalBufferPropertiesKHR = vkGetPhysicalDeviceExternalBufferPropertiesKHR;
		    pAPI->vkGetPhysicalDeviceExternalImageFormatPropertiesNV = vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
		    pAPI->vkGetMemoryFdKHR = vkGetMemoryFdKHR;
		    pAPI->vkGetMemoryFdPropertiesKHR = vkGetMemoryFdPropertiesKHR;
		    pAPI->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
		    pAPI->vkImportSemaphoreFdKHR = vkImportSemaphoreFdKHR;
		    pAPI->vkGetSemaphoreFdKHR = vkGetSemaphoreFdKHR;
		    pAPI->vkCmdPushDescriptorSetKHR = vkCmdPushDescriptorSetKHR;
		    pAPI->vkCmdPushDescriptorSetWithTemplateKHR = vkCmdPushDescriptorSetWithTemplateKHR;
		    pAPI->vkCmdBeginConditionalRenderingEXT = vkCmdBeginConditionalRenderingEXT;
		    pAPI->vkCmdEndConditionalRenderingEXT = vkCmdEndConditionalRenderingEXT;
		    pAPI->vkCreateDescriptorUpdateTemplateKHR = vkCreateDescriptorUpdateTemplateKHR;
		    pAPI->vkDestroyDescriptorUpdateTemplateKHR = vkDestroyDescriptorUpdateTemplateKHR;
		    pAPI->vkUpdateDescriptorSetWithTemplateKHR = vkUpdateDescriptorSetWithTemplateKHR;
		    pAPI->vkCmdSetViewportWScalingNV = vkCmdSetViewportWScalingNV;
		    pAPI->vkReleaseDisplayEXT = vkReleaseDisplayEXT;
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilities2EXT = vkGetPhysicalDeviceSurfaceCapabilities2EXT;
		    pAPI->vkDisplayPowerControlEXT = vkDisplayPowerControlEXT;
		    pAPI->vkRegisterDeviceEventEXT = vkRegisterDeviceEventEXT;
		    pAPI->vkRegisterDisplayEventEXT = vkRegisterDisplayEventEXT;
		    pAPI->vkGetSwapchainCounterEXT = vkGetSwapchainCounterEXT;
		    pAPI->vkGetRefreshCycleDurationGOOGLE = vkGetRefreshCycleDurationGOOGLE;
		    pAPI->vkGetPastPresentationTimingGOOGLE = vkGetPastPresentationTimingGOOGLE;
		    pAPI->vkCmdSetDiscardRectangleEXT = vkCmdSetDiscardRectangleEXT;
		    pAPI->vkCmdSetDiscardRectangleEnableEXT = vkCmdSetDiscardRectangleEnableEXT;
		    pAPI->vkCmdSetDiscardRectangleModeEXT = vkCmdSetDiscardRectangleModeEXT;
		    pAPI->vkSetHdrMetadataEXT = vkSetHdrMetadataEXT;
		    pAPI->vkCreateRenderPass2KHR = vkCreateRenderPass2KHR;
		    pAPI->vkCmdBeginRenderPass2KHR = vkCmdBeginRenderPass2KHR;
		    pAPI->vkCmdNextSubpass2KHR = vkCmdNextSubpass2KHR;
		    pAPI->vkCmdEndRenderPass2KHR = vkCmdEndRenderPass2KHR;
		    pAPI->vkGetSwapchainStatusKHR = vkGetSwapchainStatusKHR;
		    pAPI->vkGetPhysicalDeviceExternalFencePropertiesKHR = vkGetPhysicalDeviceExternalFencePropertiesKHR;
		    pAPI->vkImportFenceFdKHR = vkImportFenceFdKHR;
		    pAPI->vkGetFenceFdKHR = vkGetFenceFdKHR;
		    pAPI->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
		    pAPI->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
		    pAPI->vkAcquireProfilingLockKHR = vkAcquireProfilingLockKHR;
		    pAPI->vkReleaseProfilingLockKHR = vkReleaseProfilingLockKHR;
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilities2KHR = vkGetPhysicalDeviceSurfaceCapabilities2KHR;
		    pAPI->vkGetPhysicalDeviceSurfaceFormats2KHR = vkGetPhysicalDeviceSurfaceFormats2KHR;
		    pAPI->vkGetPhysicalDeviceDisplayProperties2KHR = vkGetPhysicalDeviceDisplayProperties2KHR;
		    pAPI->vkGetPhysicalDeviceDisplayPlaneProperties2KHR = vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
		    pAPI->vkGetDisplayModeProperties2KHR = vkGetDisplayModeProperties2KHR;
		    pAPI->vkGetDisplayPlaneCapabilities2KHR = vkGetDisplayPlaneCapabilities2KHR;
		    pAPI->vkSetDebugUtilsObjectNameEXT = vkSetDebugUtilsObjectNameEXT;
		    pAPI->vkSetDebugUtilsObjectTagEXT = vkSetDebugUtilsObjectTagEXT;
		    pAPI->vkQueueBeginDebugUtilsLabelEXT = vkQueueBeginDebugUtilsLabelEXT;
		    pAPI->vkQueueEndDebugUtilsLabelEXT = vkQueueEndDebugUtilsLabelEXT;
		    pAPI->vkQueueInsertDebugUtilsLabelEXT = vkQueueInsertDebugUtilsLabelEXT;
		    pAPI->vkCmdBeginDebugUtilsLabelEXT = vkCmdBeginDebugUtilsLabelEXT;
		    pAPI->vkCmdEndDebugUtilsLabelEXT = vkCmdEndDebugUtilsLabelEXT;
		    pAPI->vkCmdInsertDebugUtilsLabelEXT = vkCmdInsertDebugUtilsLabelEXT;
		    pAPI->vkCreateDebugUtilsMessengerEXT = vkCreateDebugUtilsMessengerEXT;
		    pAPI->vkDestroyDebugUtilsMessengerEXT = vkDestroyDebugUtilsMessengerEXT;
		    pAPI->vkSubmitDebugUtilsMessageEXT = vkSubmitDebugUtilsMessageEXT;
		    pAPI->vkDebugMarkerSetObjectTagEXT = vkDebugMarkerSetObjectTagEXT;
		    pAPI->vkDebugMarkerSetObjectNameEXT = vkDebugMarkerSetObjectNameEXT;
		    pAPI->vkCmdDebugMarkerBeginEXT = vkCmdDebugMarkerBeginEXT;
		    pAPI->vkCmdDebugMarkerEndEXT = vkCmdDebugMarkerEndEXT;
		    pAPI->vkCmdDebugMarkerInsertEXT = vkCmdDebugMarkerInsertEXT;
		    pAPI->vkCreateDebugReportCallbackEXT = vkCreateDebugReportCallbackEXT;
		    pAPI->vkDestroyDebugReportCallbackEXT = vkDestroyDebugReportCallbackEXT;
		    pAPI->vkDebugReportMessageEXT = vkDebugReportMessageEXT;
		    pAPI->vkCmdSetSampleLocationsEXT = vkCmdSetSampleLocationsEXT;
		    pAPI->vkGetPhysicalDeviceMultisamplePropertiesEXT = vkGetPhysicalDeviceMultisamplePropertiesEXT;
		    pAPI->vkGetImageMemoryRequirements2KHR = vkGetImageMemoryRequirements2KHR;
		    pAPI->vkGetBufferMemoryRequirements2KHR = vkGetBufferMemoryRequirements2KHR;
		    pAPI->vkGetImageSparseMemoryRequirements2KHR = vkGetImageSparseMemoryRequirements2KHR;
		    pAPI->vkCreateAccelerationStructureKHR = vkCreateAccelerationStructureKHR;
		    pAPI->vkDestroyAccelerationStructureKHR = vkDestroyAccelerationStructureKHR;
		    pAPI->vkCmdBuildAccelerationStructuresKHR = vkCmdBuildAccelerationStructuresKHR;
		    pAPI->vkCmdBuildAccelerationStructuresIndirectKHR = vkCmdBuildAccelerationStructuresIndirectKHR;
		    pAPI->vkBuildAccelerationStructuresKHR = vkBuildAccelerationStructuresKHR;
		    pAPI->vkCopyAccelerationStructureKHR = vkCopyAccelerationStructureKHR;
		    pAPI->vkCopyAccelerationStructureToMemoryKHR = vkCopyAccelerationStructureToMemoryKHR;
		    pAPI->vkCopyMemoryToAccelerationStructureKHR = vkCopyMemoryToAccelerationStructureKHR;
		    pAPI->vkWriteAccelerationStructuresPropertiesKHR = vkWriteAccelerationStructuresPropertiesKHR;
		    pAPI->vkCmdCopyAccelerationStructureKHR = vkCmdCopyAccelerationStructureKHR;
		    pAPI->vkCmdCopyAccelerationStructureToMemoryKHR = vkCmdCopyAccelerationStructureToMemoryKHR;
		    pAPI->vkCmdCopyMemoryToAccelerationStructureKHR = vkCmdCopyMemoryToAccelerationStructureKHR;
		    pAPI->vkGetAccelerationStructureDeviceAddressKHR = vkGetAccelerationStructureDeviceAddressKHR;
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesKHR = vkCmdWriteAccelerationStructuresPropertiesKHR;
		    pAPI->vkGetDeviceAccelerationStructureCompatibilityKHR = vkGetDeviceAccelerationStructureCompatibilityKHR;
		    pAPI->vkGetAccelerationStructureBuildSizesKHR = vkGetAccelerationStructureBuildSizesKHR;
		    pAPI->vkCmdTraceRaysKHR = vkCmdTraceRaysKHR;
		    pAPI->vkCreateRayTracingPipelinesKHR = vkCreateRayTracingPipelinesKHR;
		    pAPI->vkGetRayTracingShaderGroupHandlesKHR = vkGetRayTracingShaderGroupHandlesKHR;
		    pAPI->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
		    pAPI->vkCmdTraceRaysIndirectKHR = vkCmdTraceRaysIndirectKHR;
		    pAPI->vkGetRayTracingShaderGroupStackSizeKHR = vkGetRayTracingShaderGroupStackSizeKHR;
		    pAPI->vkCmdSetRayTracingPipelineStackSizeKHR = vkCmdSetRayTracingPipelineStackSizeKHR;
		    pAPI->vkCreateSamplerYcbcrConversionKHR = vkCreateSamplerYcbcrConversionKHR;
		    pAPI->vkDestroySamplerYcbcrConversionKHR = vkDestroySamplerYcbcrConversionKHR;
		    pAPI->vkBindBufferMemory2KHR = vkBindBufferMemory2KHR;
		    pAPI->vkBindImageMemory2KHR = vkBindImageMemory2KHR;
		    pAPI->vkGetImageDrmFormatModifierPropertiesEXT = vkGetImageDrmFormatModifierPropertiesEXT;
		    pAPI->vkCreateValidationCacheEXT = vkCreateValidationCacheEXT;
		    pAPI->vkDestroyValidationCacheEXT = vkDestroyValidationCacheEXT;
		    pAPI->vkMergeValidationCachesEXT = vkMergeValidationCachesEXT;
		    pAPI->vkGetValidationCacheDataEXT = vkGetValidationCacheDataEXT;
		    pAPI->vkCmdBindShadingRateImageNV = vkCmdBindShadingRateImageNV;
		    pAPI->vkCmdSetViewportShadingRatePaletteNV = vkCmdSetViewportShadingRatePaletteNV;
		    pAPI->vkCmdSetCoarseSampleOrderNV = vkCmdSetCoarseSampleOrderNV;
		    pAPI->vkCreateAccelerationStructureNV = vkCreateAccelerationStructureNV;
		    pAPI->vkDestroyAccelerationStructureNV = vkDestroyAccelerationStructureNV;
		    pAPI->vkGetAccelerationStructureMemoryRequirementsNV = vkGetAccelerationStructureMemoryRequirementsNV;
		    pAPI->vkBindAccelerationStructureMemoryNV = vkBindAccelerationStructureMemoryNV;
		    pAPI->vkCmdBuildAccelerationStructureNV = vkCmdBuildAccelerationStructureNV;
		    pAPI->vkCmdCopyAccelerationStructureNV = vkCmdCopyAccelerationStructureNV;
		    pAPI->vkCmdTraceRaysNV = vkCmdTraceRaysNV;
		    pAPI->vkCreateRayTracingPipelinesNV = vkCreateRayTracingPipelinesNV;
		    pAPI->vkGetRayTracingShaderGroupHandlesNV = vkGetRayTracingShaderGroupHandlesNV;
		    pAPI->vkGetAccelerationStructureHandleNV = vkGetAccelerationStructureHandleNV;
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesNV = vkCmdWriteAccelerationStructuresPropertiesNV;
		    pAPI->vkCompileDeferredNV = vkCompileDeferredNV;
		    pAPI->vkGetDescriptorSetLayoutSupportKHR = vkGetDescriptorSetLayoutSupportKHR;
		    pAPI->vkCmdDrawIndirectCountKHR = vkCmdDrawIndirectCountKHR;
		    pAPI->vkCmdDrawIndexedIndirectCountKHR = vkCmdDrawIndexedIndirectCountKHR;
		    pAPI->vkCmdDrawIndirectCountAMD = vkCmdDrawIndirectCountAMD;
		    pAPI->vkCmdDrawIndexedIndirectCountAMD = vkCmdDrawIndexedIndirectCountAMD;
		    pAPI->vkGetMemoryHostPointerPropertiesEXT = vkGetMemoryHostPointerPropertiesEXT;
		    pAPI->vkCmdWriteBufferMarkerAMD = vkCmdWriteBufferMarkerAMD;
		    pAPI->vkCmdDrawMeshTasksNV = vkCmdDrawMeshTasksNV;
		    pAPI->vkCmdDrawMeshTasksIndirectNV = vkCmdDrawMeshTasksIndirectNV;
		    pAPI->vkCmdDrawMeshTasksIndirectCountNV = vkCmdDrawMeshTasksIndirectCountNV;
		    pAPI->vkCmdSetExclusiveScissorEnableNV = vkCmdSetExclusiveScissorEnableNV;
		    pAPI->vkCmdSetExclusiveScissorNV = vkCmdSetExclusiveScissorNV;
		    pAPI->vkCmdSetCheckpointNV = vkCmdSetCheckpointNV;
		    pAPI->vkGetQueueCheckpointDataNV = vkGetQueueCheckpointDataNV;
		    pAPI->vkGetSemaphoreCounterValueKHR = vkGetSemaphoreCounterValueKHR;
		    pAPI->vkWaitSemaphoresKHR = vkWaitSemaphoresKHR;
		    pAPI->vkSignalSemaphoreKHR = vkSignalSemaphoreKHR;
		    pAPI->vkInitializePerformanceApiINTEL = vkInitializePerformanceApiINTEL;
		    pAPI->vkUninitializePerformanceApiINTEL = vkUninitializePerformanceApiINTEL;
		    pAPI->vkCmdSetPerformanceMarkerINTEL = vkCmdSetPerformanceMarkerINTEL;
		    pAPI->vkCmdSetPerformanceStreamMarkerINTEL = vkCmdSetPerformanceStreamMarkerINTEL;
		    pAPI->vkCmdSetPerformanceOverrideINTEL = vkCmdSetPerformanceOverrideINTEL;
		    pAPI->vkAcquirePerformanceConfigurationINTEL = vkAcquirePerformanceConfigurationINTEL;
		    pAPI->vkReleasePerformanceConfigurationINTEL = vkReleasePerformanceConfigurationINTEL;
		    pAPI->vkQueueSetPerformanceConfigurationINTEL = vkQueueSetPerformanceConfigurationINTEL;
		    pAPI->vkGetPerformanceParameterINTEL = vkGetPerformanceParameterINTEL;
		    pAPI->vkSetLocalDimmingAMD = vkSetLocalDimmingAMD;
		    pAPI->vkGetPhysicalDeviceFragmentShadingRatesKHR = vkGetPhysicalDeviceFragmentShadingRatesKHR;
		    pAPI->vkCmdSetFragmentShadingRateKHR = vkCmdSetFragmentShadingRateKHR;
		    pAPI->vkCmdSetRenderingAttachmentLocationsKHR = vkCmdSetRenderingAttachmentLocationsKHR;
		    pAPI->vkCmdSetRenderingInputAttachmentIndicesKHR = vkCmdSetRenderingInputAttachmentIndicesKHR;
		    pAPI->vkGetPhysicalDeviceToolPropertiesEXT = vkGetPhysicalDeviceToolPropertiesEXT;
		    pAPI->vkWaitForPresentKHR = vkWaitForPresentKHR;
		    pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = vkGetPhysicalDeviceCooperativeMatrixPropertiesNV;
		    pAPI->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
		    pAPI->vkCreateHeadlessSurfaceEXT = vkCreateHeadlessSurfaceEXT;
		    pAPI->vkGetBufferDeviceAddressKHR = vkGetBufferDeviceAddressKHR;
		    pAPI->vkGetBufferOpaqueCaptureAddressKHR = vkGetBufferOpaqueCaptureAddressKHR;
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddressKHR = vkGetDeviceMemoryOpaqueCaptureAddressKHR;
		    pAPI->vkGetBufferDeviceAddressEXT = vkGetBufferDeviceAddressEXT;
		    pAPI->vkResetQueryPoolEXT = vkResetQueryPoolEXT;
		    pAPI->vkCmdSetCullModeEXT = vkCmdSetCullModeEXT;
		    pAPI->vkCmdSetFrontFaceEXT = vkCmdSetFrontFaceEXT;
		    pAPI->vkCmdSetPrimitiveTopologyEXT = vkCmdSetPrimitiveTopologyEXT;
		    pAPI->vkCmdSetViewportWithCountEXT = vkCmdSetViewportWithCountEXT;
		    pAPI->vkCmdSetScissorWithCountEXT = vkCmdSetScissorWithCountEXT;
		    pAPI->vkCmdBindVertexBuffers2EXT = vkCmdBindVertexBuffers2EXT;
		    pAPI->vkCmdSetDepthTestEnableEXT = vkCmdSetDepthTestEnableEXT;
		    pAPI->vkCmdSetDepthWriteEnableEXT = vkCmdSetDepthWriteEnableEXT;
		    pAPI->vkCmdSetDepthCompareOpEXT = vkCmdSetDepthCompareOpEXT;
		    pAPI->vkCmdSetDepthBoundsTestEnableEXT = vkCmdSetDepthBoundsTestEnableEXT;
		    pAPI->vkCmdSetStencilTestEnableEXT = vkCmdSetStencilTestEnableEXT;
		    pAPI->vkCmdSetStencilOpEXT = vkCmdSetStencilOpEXT;
		    pAPI->vkCreateDeferredOperationKHR = vkCreateDeferredOperationKHR;
		    pAPI->vkDestroyDeferredOperationKHR = vkDestroyDeferredOperationKHR;
		    pAPI->vkGetDeferredOperationMaxConcurrencyKHR = vkGetDeferredOperationMaxConcurrencyKHR;
		    pAPI->vkGetDeferredOperationResultKHR = vkGetDeferredOperationResultKHR;
		    pAPI->vkDeferredOperationJoinKHR = vkDeferredOperationJoinKHR;
		    pAPI->vkGetPipelineExecutablePropertiesKHR = vkGetPipelineExecutablePropertiesKHR;
		    pAPI->vkGetPipelineExecutableStatisticsKHR = vkGetPipelineExecutableStatisticsKHR;
		    pAPI->vkGetPipelineExecutableInternalRepresentationsKHR = vkGetPipelineExecutableInternalRepresentationsKHR;
		    pAPI->vkCopyMemoryToImageEXT = vkCopyMemoryToImageEXT;
		    pAPI->vkCopyImageToMemoryEXT = vkCopyImageToMemoryEXT;
		    pAPI->vkCopyImageToImageEXT = vkCopyImageToImageEXT;
		    pAPI->vkTransitionImageLayoutEXT = vkTransitionImageLayoutEXT;
		    pAPI->vkGetImageSubresourceLayout2EXT = vkGetImageSubresourceLayout2EXT;
		    pAPI->vkMapMemory2KHR = vkMapMemory2KHR;
		    pAPI->vkUnmapMemory2KHR = vkUnmapMemory2KHR;
		    pAPI->vkReleaseSwapchainImagesEXT = vkReleaseSwapchainImagesEXT;
		    pAPI->vkGetGeneratedCommandsMemoryRequirementsNV = vkGetGeneratedCommandsMemoryRequirementsNV;
		    pAPI->vkCmdPreprocessGeneratedCommandsNV = vkCmdPreprocessGeneratedCommandsNV;
		    pAPI->vkCmdExecuteGeneratedCommandsNV = vkCmdExecuteGeneratedCommandsNV;
		    pAPI->vkCmdBindPipelineShaderGroupNV = vkCmdBindPipelineShaderGroupNV;
		    pAPI->vkCreateIndirectCommandsLayoutNV = vkCreateIndirectCommandsLayoutNV;
		    pAPI->vkDestroyIndirectCommandsLayoutNV = vkDestroyIndirectCommandsLayoutNV;
		    pAPI->vkCmdSetDepthBias2EXT = vkCmdSetDepthBias2EXT;
		    pAPI->vkAcquireDrmDisplayEXT = vkAcquireDrmDisplayEXT;
		    pAPI->vkGetDrmDisplayEXT = vkGetDrmDisplayEXT;
		    pAPI->vkCreatePrivateDataSlotEXT = vkCreatePrivateDataSlotEXT;
		    pAPI->vkDestroyPrivateDataSlotEXT = vkDestroyPrivateDataSlotEXT;
		    pAPI->vkSetPrivateDataEXT = vkSetPrivateDataEXT;
		    pAPI->vkGetPrivateDataEXT = vkGetPrivateDataEXT;
		    pAPI->vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
		    pAPI->vkGetEncodedVideoSessionParametersKHR = vkGetEncodedVideoSessionParametersKHR;
		    pAPI->vkCmdEncodeVideoKHR = vkCmdEncodeVideoKHR;
		    pAPI->vkCreateCudaModuleNV = vkCreateCudaModuleNV;
		    pAPI->vkGetCudaModuleCacheNV = vkGetCudaModuleCacheNV;
		    pAPI->vkCreateCudaFunctionNV = vkCreateCudaFunctionNV;
		    pAPI->vkDestroyCudaModuleNV = vkDestroyCudaModuleNV;
		    pAPI->vkDestroyCudaFunctionNV = vkDestroyCudaFunctionNV;
		    pAPI->vkCmdCudaLaunchKernelNV = vkCmdCudaLaunchKernelNV;
		    pAPI->vkCmdRefreshObjectsKHR = vkCmdRefreshObjectsKHR;
		    pAPI->vkGetPhysicalDeviceRefreshableObjectTypesKHR = vkGetPhysicalDeviceRefreshableObjectTypesKHR;
		    pAPI->vkCmdSetEvent2KHR = vkCmdSetEvent2KHR;
		    pAPI->vkCmdResetEvent2KHR = vkCmdResetEvent2KHR;
		    pAPI->vkCmdWaitEvents2KHR = vkCmdWaitEvents2KHR;
		    pAPI->vkCmdPipelineBarrier2KHR = vkCmdPipelineBarrier2KHR;
		    pAPI->vkCmdWriteTimestamp2KHR = vkCmdWriteTimestamp2KHR;
		    pAPI->vkQueueSubmit2KHR = vkQueueSubmit2KHR;
		    pAPI->vkCmdWriteBufferMarker2AMD = vkCmdWriteBufferMarker2AMD;
		    pAPI->vkGetQueueCheckpointData2NV = vkGetQueueCheckpointData2NV;
		    pAPI->vkGetDescriptorSetLayoutSizeEXT = vkGetDescriptorSetLayoutSizeEXT;
		    pAPI->vkGetDescriptorSetLayoutBindingOffsetEXT = vkGetDescriptorSetLayoutBindingOffsetEXT;
		    pAPI->vkGetDescriptorEXT = vkGetDescriptorEXT;
		    pAPI->vkCmdBindDescriptorBuffersEXT = vkCmdBindDescriptorBuffersEXT;
		    pAPI->vkCmdSetDescriptorBufferOffsetsEXT = vkCmdSetDescriptorBufferOffsetsEXT;
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplersEXT = vkCmdBindDescriptorBufferEmbeddedSamplersEXT;
		    pAPI->vkGetBufferOpaqueCaptureDescriptorDataEXT = vkGetBufferOpaqueCaptureDescriptorDataEXT;
		    pAPI->vkGetImageOpaqueCaptureDescriptorDataEXT = vkGetImageOpaqueCaptureDescriptorDataEXT;
		    pAPI->vkGetImageViewOpaqueCaptureDescriptorDataEXT = vkGetImageViewOpaqueCaptureDescriptorDataEXT;
		    pAPI->vkGetSamplerOpaqueCaptureDescriptorDataEXT = vkGetSamplerOpaqueCaptureDescriptorDataEXT;
		    pAPI->vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
		    pAPI->vkCmdSetFragmentShadingRateEnumNV = vkCmdSetFragmentShadingRateEnumNV;
		    pAPI->vkCmdDrawMeshTasksEXT = vkCmdDrawMeshTasksEXT;
		    pAPI->vkCmdDrawMeshTasksIndirectEXT = vkCmdDrawMeshTasksIndirectEXT;
		    pAPI->vkCmdDrawMeshTasksIndirectCountEXT = vkCmdDrawMeshTasksIndirectCountEXT;
		    pAPI->vkCmdCopyBuffer2KHR = vkCmdCopyBuffer2KHR;
		    pAPI->vkCmdCopyImage2KHR = vkCmdCopyImage2KHR;
		    pAPI->vkCmdCopyBufferToImage2KHR = vkCmdCopyBufferToImage2KHR;
		    pAPI->vkCmdCopyImageToBuffer2KHR = vkCmdCopyImageToBuffer2KHR;
		    pAPI->vkCmdBlitImage2KHR = vkCmdBlitImage2KHR;
		    pAPI->vkCmdResolveImage2KHR = vkCmdResolveImage2KHR;
		    pAPI->vkGetDeviceFaultInfoEXT = vkGetDeviceFaultInfoEXT;
		    pAPI->vkCmdSetVertexInputEXT = vkCmdSetVertexInputEXT;
		    pAPI->vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
		    pAPI->vkCmdSubpassShadingHUAWEI = vkCmdSubpassShadingHUAWEI;
		    pAPI->vkCmdBindInvocationMaskHUAWEI = vkCmdBindInvocationMaskHUAWEI;
		    pAPI->vkGetMemoryRemoteAddressNV = vkGetMemoryRemoteAddressNV;
		    pAPI->vkGetPipelinePropertiesEXT = vkGetPipelinePropertiesEXT;
		    pAPI->vkCmdSetPatchControlPointsEXT = vkCmdSetPatchControlPointsEXT;
		    pAPI->vkCmdSetRasterizerDiscardEnableEXT = vkCmdSetRasterizerDiscardEnableEXT;
		    pAPI->vkCmdSetDepthBiasEnableEXT = vkCmdSetDepthBiasEnableEXT;
		    pAPI->vkCmdSetLogicOpEXT = vkCmdSetLogicOpEXT;
		    pAPI->vkCmdSetPrimitiveRestartEnableEXT = vkCmdSetPrimitiveRestartEnableEXT;
		    pAPI->vkCmdSetColorWriteEnableEXT = vkCmdSetColorWriteEnableEXT;
		    pAPI->vkCmdTraceRaysIndirect2KHR = vkCmdTraceRaysIndirect2KHR;
		    pAPI->vkCmdDrawMultiEXT = vkCmdDrawMultiEXT;
		    pAPI->vkCmdDrawMultiIndexedEXT = vkCmdDrawMultiIndexedEXT;
		    pAPI->vkCreateMicromapEXT = vkCreateMicromapEXT;
		    pAPI->vkDestroyMicromapEXT = vkDestroyMicromapEXT;
		    pAPI->vkCmdBuildMicromapsEXT = vkCmdBuildMicromapsEXT;
		    pAPI->vkBuildMicromapsEXT = vkBuildMicromapsEXT;
		    pAPI->vkCopyMicromapEXT = vkCopyMicromapEXT;
		    pAPI->vkCopyMicromapToMemoryEXT = vkCopyMicromapToMemoryEXT;
		    pAPI->vkCopyMemoryToMicromapEXT = vkCopyMemoryToMicromapEXT;
		    pAPI->vkWriteMicromapsPropertiesEXT = vkWriteMicromapsPropertiesEXT;
		    pAPI->vkCmdCopyMicromapEXT = vkCmdCopyMicromapEXT;
		    pAPI->vkCmdCopyMicromapToMemoryEXT = vkCmdCopyMicromapToMemoryEXT;
		    pAPI->vkCmdCopyMemoryToMicromapEXT = vkCmdCopyMemoryToMicromapEXT;
		    pAPI->vkCmdWriteMicromapsPropertiesEXT = vkCmdWriteMicromapsPropertiesEXT;
		    pAPI->vkGetDeviceMicromapCompatibilityEXT = vkGetDeviceMicromapCompatibilityEXT;
		    pAPI->vkGetMicromapBuildSizesEXT = vkGetMicromapBuildSizesEXT;
		    pAPI->vkCmdDrawClusterHUAWEI = vkCmdDrawClusterHUAWEI;
		    pAPI->vkCmdDrawClusterIndirectHUAWEI = vkCmdDrawClusterIndirectHUAWEI;
		    pAPI->vkSetDeviceMemoryPriorityEXT = vkSetDeviceMemoryPriorityEXT;
		    pAPI->vkGetDeviceBufferMemoryRequirementsKHR = vkGetDeviceBufferMemoryRequirementsKHR;
		    pAPI->vkGetDeviceImageMemoryRequirementsKHR = vkGetDeviceImageMemoryRequirementsKHR;
		    pAPI->vkGetDeviceImageSparseMemoryRequirementsKHR = vkGetDeviceImageSparseMemoryRequirementsKHR;
		    pAPI->vkGetDescriptorSetLayoutHostMappingInfoVALVE = vkGetDescriptorSetLayoutHostMappingInfoVALVE;
		    pAPI->vkGetDescriptorSetHostMappingVALVE = vkGetDescriptorSetHostMappingVALVE;
		    pAPI->vkCmdCopyMemoryIndirectNV = vkCmdCopyMemoryIndirectNV;
		    pAPI->vkCmdCopyMemoryToImageIndirectNV = vkCmdCopyMemoryToImageIndirectNV;
		    pAPI->vkCmdDecompressMemoryNV = vkCmdDecompressMemoryNV;
		    pAPI->vkCmdDecompressMemoryIndirectCountNV = vkCmdDecompressMemoryIndirectCountNV;
		    pAPI->vkGetPipelineIndirectMemoryRequirementsNV = vkGetPipelineIndirectMemoryRequirementsNV;
		    pAPI->vkCmdUpdatePipelineIndirectBufferNV = vkCmdUpdatePipelineIndirectBufferNV;
		    pAPI->vkGetPipelineIndirectDeviceAddressNV = vkGetPipelineIndirectDeviceAddressNV;
		    pAPI->vkCmdSetDepthClampEnableEXT = vkCmdSetDepthClampEnableEXT;
		    pAPI->vkCmdSetPolygonModeEXT = vkCmdSetPolygonModeEXT;
		    pAPI->vkCmdSetRasterizationSamplesEXT = vkCmdSetRasterizationSamplesEXT;
		    pAPI->vkCmdSetSampleMaskEXT = vkCmdSetSampleMaskEXT;
		    pAPI->vkCmdSetAlphaToCoverageEnableEXT = vkCmdSetAlphaToCoverageEnableEXT;
		    pAPI->vkCmdSetAlphaToOneEnableEXT = vkCmdSetAlphaToOneEnableEXT;
		    pAPI->vkCmdSetLogicOpEnableEXT = vkCmdSetLogicOpEnableEXT;
		    pAPI->vkCmdSetColorBlendEnableEXT = vkCmdSetColorBlendEnableEXT;
		    pAPI->vkCmdSetColorBlendEquationEXT = vkCmdSetColorBlendEquationEXT;
		    pAPI->vkCmdSetColorWriteMaskEXT = vkCmdSetColorWriteMaskEXT;
		    pAPI->vkCmdSetTessellationDomainOriginEXT = vkCmdSetTessellationDomainOriginEXT;
		    pAPI->vkCmdSetRasterizationStreamEXT = vkCmdSetRasterizationStreamEXT;
		    pAPI->vkCmdSetConservativeRasterizationModeEXT = vkCmdSetConservativeRasterizationModeEXT;
		    pAPI->vkCmdSetExtraPrimitiveOverestimationSizeEXT = vkCmdSetExtraPrimitiveOverestimationSizeEXT;
		    pAPI->vkCmdSetDepthClipEnableEXT = vkCmdSetDepthClipEnableEXT;
		    pAPI->vkCmdSetSampleLocationsEnableEXT = vkCmdSetSampleLocationsEnableEXT;
		    pAPI->vkCmdSetColorBlendAdvancedEXT = vkCmdSetColorBlendAdvancedEXT;
		    pAPI->vkCmdSetProvokingVertexModeEXT = vkCmdSetProvokingVertexModeEXT;
		    pAPI->vkCmdSetLineRasterizationModeEXT = vkCmdSetLineRasterizationModeEXT;
		    pAPI->vkCmdSetLineStippleEnableEXT = vkCmdSetLineStippleEnableEXT;
		    pAPI->vkCmdSetDepthClipNegativeOneToOneEXT = vkCmdSetDepthClipNegativeOneToOneEXT;
		    pAPI->vkCmdSetViewportWScalingEnableNV = vkCmdSetViewportWScalingEnableNV;
		    pAPI->vkCmdSetViewportSwizzleNV = vkCmdSetViewportSwizzleNV;
		    pAPI->vkCmdSetCoverageToColorEnableNV = vkCmdSetCoverageToColorEnableNV;
		    pAPI->vkCmdSetCoverageToColorLocationNV = vkCmdSetCoverageToColorLocationNV;
		    pAPI->vkCmdSetCoverageModulationModeNV = vkCmdSetCoverageModulationModeNV;
		    pAPI->vkCmdSetCoverageModulationTableEnableNV = vkCmdSetCoverageModulationTableEnableNV;
		    pAPI->vkCmdSetCoverageModulationTableNV = vkCmdSetCoverageModulationTableNV;
		    pAPI->vkCmdSetShadingRateImageEnableNV = vkCmdSetShadingRateImageEnableNV;
		    pAPI->vkCmdSetRepresentativeFragmentTestEnableNV = vkCmdSetRepresentativeFragmentTestEnableNV;
		    pAPI->vkCmdSetCoverageReductionModeNV = vkCmdSetCoverageReductionModeNV;
		    pAPI->vkGetShaderModuleIdentifierEXT = vkGetShaderModuleIdentifierEXT;
		    pAPI->vkGetShaderModuleCreateInfoIdentifierEXT = vkGetShaderModuleCreateInfoIdentifierEXT;
		    pAPI->vkGetPhysicalDeviceOpticalFlowImageFormatsNV = vkGetPhysicalDeviceOpticalFlowImageFormatsNV;
		    pAPI->vkCreateOpticalFlowSessionNV = vkCreateOpticalFlowSessionNV;
		    pAPI->vkDestroyOpticalFlowSessionNV = vkDestroyOpticalFlowSessionNV;
		    pAPI->vkBindOpticalFlowSessionImageNV = vkBindOpticalFlowSessionImageNV;
		    pAPI->vkCmdOpticalFlowExecuteNV = vkCmdOpticalFlowExecuteNV;
		    pAPI->vkCmdBindIndexBuffer2KHR = vkCmdBindIndexBuffer2KHR;
		    pAPI->vkGetRenderingAreaGranularityKHR = vkGetRenderingAreaGranularityKHR;
		    pAPI->vkGetDeviceImageSubresourceLayoutKHR = vkGetDeviceImageSubresourceLayoutKHR;
		    pAPI->vkGetImageSubresourceLayout2KHR = vkGetImageSubresourceLayout2KHR;
		    pAPI->vkCreateShadersEXT = vkCreateShadersEXT;
		    pAPI->vkDestroyShaderEXT = vkDestroyShaderEXT;
		    pAPI->vkGetShaderBinaryDataEXT = vkGetShaderBinaryDataEXT;
		    pAPI->vkCmdBindShadersEXT = vkCmdBindShadersEXT;
		    pAPI->vkGetFramebufferTilePropertiesQCOM = vkGetFramebufferTilePropertiesQCOM;
		    pAPI->vkGetDynamicRenderingTilePropertiesQCOM = vkGetDynamicRenderingTilePropertiesQCOM;
		    pAPI->vkSetLatencySleepModeNV = vkSetLatencySleepModeNV;
		    pAPI->vkLatencySleepNV = vkLatencySleepNV;
		    pAPI->vkSetLatencyMarkerNV = vkSetLatencyMarkerNV;
		    pAPI->vkGetLatencyTimingsNV = vkGetLatencyTimingsNV;
		    pAPI->vkQueueNotifyOutOfBandNV = vkQueueNotifyOutOfBandNV;
		    pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR;
		    pAPI->vkCmdSetAttachmentFeedbackLoopEnableEXT = vkCmdSetAttachmentFeedbackLoopEnableEXT;
		    pAPI->vkCmdSetLineStippleKHR = vkCmdSetLineStippleKHR;
		    pAPI->vkCmdSetLineStippleEXT = vkCmdSetLineStippleEXT;
		    pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
		    pAPI->vkGetCalibratedTimestampsKHR = vkGetCalibratedTimestampsKHR;
		    pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = vkGetPhysicalDeviceCalibrateableTimeDomainsEXT;
		    pAPI->vkGetCalibratedTimestampsEXT = vkGetCalibratedTimestampsEXT;
		    pAPI->vkCmdBindDescriptorSets2KHR = vkCmdBindDescriptorSets2KHR;
		    pAPI->vkCmdPushConstants2KHR = vkCmdPushConstants2KHR;
		    pAPI->vkCmdPushDescriptorSet2KHR = vkCmdPushDescriptorSet2KHR;
		    pAPI->vkCmdPushDescriptorSetWithTemplate2KHR = vkCmdPushDescriptorSetWithTemplate2KHR;
		    pAPI->vkCmdSetDescriptorBufferOffsets2EXT = vkCmdSetDescriptorBufferOffsets2EXT;
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = vkCmdBindDescriptorBufferEmbeddedSamplers2EXT;
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		    pAPI->vkCreateXlibSurfaceKHR = vkCreateXlibSurfaceKHR;
		    pAPI->vkGetPhysicalDeviceXlibPresentationSupportKHR = vkGetPhysicalDeviceXlibPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		    pAPI->vkAcquireXlibDisplayEXT = vkAcquireXlibDisplayEXT;
		    pAPI->vkGetRandROutputDisplayEXT = vkGetRandROutputDisplayEXT;
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		    pAPI->vkCreateXcbSurfaceKHR = vkCreateXcbSurfaceKHR;
		    pAPI->vkGetPhysicalDeviceXcbPresentationSupportKHR = vkGetPhysicalDeviceXcbPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		    pAPI->vkCreateWaylandSurfaceKHR = vkCreateWaylandSurfaceKHR;
		    pAPI->vkGetPhysicalDeviceWaylandPresentationSupportKHR = vkGetPhysicalDeviceWaylandPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		    pAPI->vkCreateDirectFBSurfaceEXT = vkCreateDirectFBSurfaceEXT;
		    pAPI->vkGetPhysicalDeviceDirectFBPresentationSupportEXT = vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		    pAPI->vkCreateAndroidSurfaceKHR = vkCreateAndroidSurfaceKHR;
		    pAPI->vkGetAndroidHardwareBufferPropertiesANDROID = vkGetAndroidHardwareBufferPropertiesANDROID;
		    pAPI->vkGetMemoryAndroidHardwareBufferANDROID = vkGetMemoryAndroidHardwareBufferANDROID;
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		    pAPI->vkCreateWin32SurfaceKHR = vkCreateWin32SurfaceKHR;
		    pAPI->vkGetPhysicalDeviceWin32PresentationSupportKHR = vkGetPhysicalDeviceWin32PresentationSupportKHR;
		    pAPI->vkGetMemoryWin32HandleKHR = vkGetMemoryWin32HandleKHR;
		    pAPI->vkGetMemoryWin32HandlePropertiesKHR = vkGetMemoryWin32HandlePropertiesKHR;
		    pAPI->vkGetMemoryWin32HandleNV = vkGetMemoryWin32HandleNV;
		    pAPI->vkImportSemaphoreWin32HandleKHR = vkImportSemaphoreWin32HandleKHR;
		    pAPI->vkGetSemaphoreWin32HandleKHR = vkGetSemaphoreWin32HandleKHR;
		    pAPI->vkImportFenceWin32HandleKHR = vkImportFenceWin32HandleKHR;
		    pAPI->vkGetFenceWin32HandleKHR = vkGetFenceWin32HandleKHR;
		    pAPI->vkGetPhysicalDeviceSurfacePresentModes2EXT = vkGetPhysicalDeviceSurfacePresentModes2EXT;
		    pAPI->vkAcquireFullScreenExclusiveModeEXT = vkAcquireFullScreenExclusiveModeEXT;
		    pAPI->vkReleaseFullScreenExclusiveModeEXT = vkReleaseFullScreenExclusiveModeEXT;
		    pAPI->vkGetDeviceGroupSurfacePresentModes2EXT = vkGetDeviceGroupSurfacePresentModes2EXT;
		    pAPI->vkAcquireWinrtDisplayNV = vkAcquireWinrtDisplayNV;
		    pAPI->vkGetWinrtDisplayNV = vkGetWinrtDisplayNV;
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		    pAPI->vkCreateViSurfaceNN = vkCreateViSurfaceNN;
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		    pAPI->vkCreateIOSSurfaceMVK = vkCreateIOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		    pAPI->vkCreateMacOSSurfaceMVK = vkCreateMacOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		    pAPI->vkCreateMetalSurfaceEXT = vkCreateMetalSurfaceEXT;
		    pAPI->vkExportMetalObjectsEXT = vkExportMetalObjectsEXT;
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		    pAPI->vkCreateImagePipeSurfaceFUCHSIA = vkCreateImagePipeSurfaceFUCHSIA;
		    pAPI->vkGetMemoryZirconHandleFUCHSIA = vkGetMemoryZirconHandleFUCHSIA;
		    pAPI->vkGetMemoryZirconHandlePropertiesFUCHSIA = vkGetMemoryZirconHandlePropertiesFUCHSIA;
		    pAPI->vkImportSemaphoreZirconHandleFUCHSIA = vkImportSemaphoreZirconHandleFUCHSIA;
		    pAPI->vkGetSemaphoreZirconHandleFUCHSIA = vkGetSemaphoreZirconHandleFUCHSIA;
		    pAPI->vkCreateBufferCollectionFUCHSIA = vkCreateBufferCollectionFUCHSIA;
		    pAPI->vkSetBufferCollectionImageConstraintsFUCHSIA = vkSetBufferCollectionImageConstraintsFUCHSIA;
		    pAPI->vkSetBufferCollectionBufferConstraintsFUCHSIA = vkSetBufferCollectionBufferConstraintsFUCHSIA;
		    pAPI->vkDestroyBufferCollectionFUCHSIA = vkDestroyBufferCollectionFUCHSIA;
		    pAPI->vkGetBufferCollectionPropertiesFUCHSIA = vkGetBufferCollectionPropertiesFUCHSIA;
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		    pAPI->vkCreateStreamDescriptorSurfaceGGP = vkCreateStreamDescriptorSurfaceGGP;
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		    pAPI->vkGetMemorySciBufNV = vkGetMemorySciBufNV;
		    pAPI->vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV;
		    pAPI->vkGetPhysicalDeviceSciBufAttributesNV = vkGetPhysicalDeviceSciBufAttributesNV;
		    pAPI->vkCreateSemaphoreSciSyncPoolNV = vkCreateSemaphoreSciSyncPoolNV;
		    pAPI->vkDestroySemaphoreSciSyncPoolNV = vkDestroySemaphoreSciSyncPoolNV;
		    pAPI->vkGetFenceSciSyncFenceNV = vkGetFenceSciSyncFenceNV;
		    pAPI->vkGetFenceSciSyncObjNV = vkGetFenceSciSyncObjNV;
		    pAPI->vkImportFenceSciSyncFenceNV = vkImportFenceSciSyncFenceNV;
		    pAPI->vkImportFenceSciSyncObjNV = vkImportFenceSciSyncObjNV;
		    pAPI->vkGetPhysicalDeviceSciSyncAttributesNV = vkGetPhysicalDeviceSciSyncAttributesNV;
		    pAPI->vkGetSemaphoreSciSyncObjNV = vkGetSemaphoreSciSyncObjNV;
		    pAPI->vkImportSemaphoreSciSyncObjNV = vkImportSemaphoreSciSyncObjNV;
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		    pAPI->vkCreateExecutionGraphPipelinesAMDX = vkCreateExecutionGraphPipelinesAMDX;
		    pAPI->vkGetExecutionGraphPipelineScratchSizeAMDX = vkGetExecutionGraphPipelineScratchSizeAMDX;
		    pAPI->vkGetExecutionGraphPipelineNodeIndexAMDX = vkGetExecutionGraphPipelineNodeIndexAMDX;
		    pAPI->vkCmdInitializeGraphScratchMemoryAMDX = vkCmdInitializeGraphScratchMemoryAMDX;
		    pAPI->vkCmdDispatchGraphAMDX = vkCmdDispatchGraphAMDX;
		    pAPI->vkCmdDispatchGraphIndirectAMDX = vkCmdDispatchGraphIndirectAMDX;
		    pAPI->vkCmdDispatchGraphIndirectCountAMDX = vkCmdDispatchGraphIndirectCountAMDX;
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		    pAPI->vkCreateScreenSurfaceQNX = vkCreateScreenSurfaceQNX;
		    pAPI->vkGetPhysicalDeviceScreenPresentationSupportQNX = vkGetPhysicalDeviceScreenPresentationSupportQNX;
		    pAPI->vkGetScreenBufferPropertiesQNX = vkGetScreenBufferPropertiesQNX;
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/
		}
		#endif /*VKBIND_NO_GLOBAL_API*/

		VkResult vkbInit(VkbAPI* pAPI)
		{
		    VkResult result;

		    /* If the Vulkan SO has not been loaded, do that first thing. */
		    if (g_vkbInitCount == 0) {
				result = vkbLoadVulkanSO();
				if (result != VK_SUCCESS) {
				    return result;
				}
		    }

		    #if defined(VKBIND_NO_GLOBAL_API)
		    {
				/* Getting here means the global API has been disabled. Therefore the caller *must* provide a VkbAPI object. */
				if (pAPI == NULL) {
				    return VK_ERROR_INITIALIZATION_FAILED;
				} else {
				    /* Since we don't have global function pointers we'll have to use dlsym() every time we initialize. */
				    result = vkbLoadVulkanSymbols(pAPI);
				    if (result != VK_SUCCESS) {
						return result;
				    }
				}
		    }
		    #else
		    {
				if (pAPI == NULL) {
				    if (g_vkbInitCount == 0) {
						VkbAPI api;
						result = vkbInit(&api);
						if (result != VK_SUCCESS) {
						    return result;
						}

						/* The call to vkbInit() will have incremented the reference counter. Bring it back down since we're just going to increment it again later. */
				    } else {
						/* The global API has already been bound. No need to do anything here. */
				    }
				} else {
				    if (g_vkbInitCount == 0) {
						result = vkbLoadVulkanSymbols(pAPI);
						if (result != VK_SUCCESS) {
						    return result;
						}

						result = vkbBindAPI(pAPI);
						if (result != VK_SUCCESS) {
						    return result;
						}
				    } else {
						/* The global API has already been bound. We need only retrieve the pointers from the globals. Using dlsym() would be too inefficient. */
						vkbInitFromGlobalAPI(pAPI);
				    }
				}
		    }
		    #endif

		    g_vkbInitCount += 1;    /* <-- Only increment the init counter on success. */
		    return VK_SUCCESS;
		}

		void vkbUninit()
		{
		    if (g_vkbInitCount == 0) {
				return;
		    }

		    g_vkbInitCount -= 1;
		    if (g_vkbInitCount == 0) {
				vkb_dlclose(g_vkbVulkanSO);
				g_vkbVulkanSO = NULL;
		    }
		}

		VkResult vkbInitInstanceAPI(VkInstance instance, VkbAPI* pAPI)
		{
		    if (g_vkbInitCount == 0) {
				return VK_ERROR_INITIALIZATION_FAILED;  /* vkbind not initialized. */
		    }

		    if (pAPI == NULL) {
				return VK_ERROR_INITIALIZATION_FAILED;
		    }

		    /*
		    We need an instance of vkGetInstanceProcAddr(). If it's not available in pAPI we'll try pulling it
		    from global scope.
		    */
		    if (pAPI->vkGetInstanceProcAddr == NULL) {
				#if !defined(VKBIND_NO_GLOBAL_API)
				{
				    pAPI->vkGetInstanceProcAddr = vkGetInstanceProcAddr;
				}
				#endif
		    }

		    if (pAPI->vkGetInstanceProcAddr == NULL) {
				return VK_ERROR_INITIALIZATION_FAILED;  /* We don't have a vkGetInstanceProcAddr(). We need to abort. */
		    }

		    pAPI->vkCreateInstance = (PFN_vkCreateInstance)pAPI->vkGetInstanceProcAddr(instance, "vkCreateInstance");
		    pAPI->vkDestroyInstance = (PFN_vkDestroyInstance)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyInstance");
		    pAPI->vkEnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices)pAPI->vkGetInstanceProcAddr(instance, "vkEnumeratePhysicalDevices");
		    pAPI->vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures");
		    pAPI->vkGetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties");
		    pAPI->vkGetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties");
		    pAPI->vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties");
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties");
		    pAPI->vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties");
		    pAPI->vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceProcAddr");
		    pAPI->vkCreateDevice = (PFN_vkCreateDevice)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDevice");
		    pAPI->vkDestroyDevice = (PFN_vkDestroyDevice)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDevice");
		    pAPI->vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)pAPI->vkGetInstanceProcAddr(instance, "vkEnumerateInstanceExtensionProperties");
		    pAPI->vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)pAPI->vkGetInstanceProcAddr(instance, "vkEnumerateDeviceExtensionProperties");
		    pAPI->vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties)pAPI->vkGetInstanceProcAddr(instance, "vkEnumerateInstanceLayerProperties");
		    pAPI->vkEnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties)pAPI->vkGetInstanceProcAddr(instance, "vkEnumerateDeviceLayerProperties");
		    pAPI->vkGetDeviceQueue = (PFN_vkGetDeviceQueue)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceQueue");
		    pAPI->vkQueueSubmit = (PFN_vkQueueSubmit)pAPI->vkGetInstanceProcAddr(instance, "vkQueueSubmit");
		    pAPI->vkQueueWaitIdle = (PFN_vkQueueWaitIdle)pAPI->vkGetInstanceProcAddr(instance, "vkQueueWaitIdle");
		    pAPI->vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle)pAPI->vkGetInstanceProcAddr(instance, "vkDeviceWaitIdle");
		    pAPI->vkAllocateMemory = (PFN_vkAllocateMemory)pAPI->vkGetInstanceProcAddr(instance, "vkAllocateMemory");
		    pAPI->vkFreeMemory = (PFN_vkFreeMemory)pAPI->vkGetInstanceProcAddr(instance, "vkFreeMemory");
		    pAPI->vkMapMemory = (PFN_vkMapMemory)pAPI->vkGetInstanceProcAddr(instance, "vkMapMemory");
		    pAPI->vkUnmapMemory = (PFN_vkUnmapMemory)pAPI->vkGetInstanceProcAddr(instance, "vkUnmapMemory");
		    pAPI->vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)pAPI->vkGetInstanceProcAddr(instance, "vkFlushMappedMemoryRanges");
		    pAPI->vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)pAPI->vkGetInstanceProcAddr(instance, "vkInvalidateMappedMemoryRanges");
		    pAPI->vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceMemoryCommitment");
		    pAPI->vkBindBufferMemory = (PFN_vkBindBufferMemory)pAPI->vkGetInstanceProcAddr(instance, "vkBindBufferMemory");
		    pAPI->vkBindImageMemory = (PFN_vkBindImageMemory)pAPI->vkGetInstanceProcAddr(instance, "vkBindImageMemory");
		    pAPI->vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferMemoryRequirements");
		    pAPI->vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageMemoryRequirements");
		    pAPI->vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageSparseMemoryRequirements");
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties");
		    pAPI->vkQueueBindSparse = (PFN_vkQueueBindSparse)pAPI->vkGetInstanceProcAddr(instance, "vkQueueBindSparse");
		    pAPI->vkCreateFence = (PFN_vkCreateFence)pAPI->vkGetInstanceProcAddr(instance, "vkCreateFence");
		    pAPI->vkDestroyFence = (PFN_vkDestroyFence)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyFence");
		    pAPI->vkResetFences = (PFN_vkResetFences)pAPI->vkGetInstanceProcAddr(instance, "vkResetFences");
		    pAPI->vkGetFenceStatus = (PFN_vkGetFenceStatus)pAPI->vkGetInstanceProcAddr(instance, "vkGetFenceStatus");
		    pAPI->vkWaitForFences = (PFN_vkWaitForFences)pAPI->vkGetInstanceProcAddr(instance, "vkWaitForFences");
		    pAPI->vkCreateSemaphore = (PFN_vkCreateSemaphore)pAPI->vkGetInstanceProcAddr(instance, "vkCreateSemaphore");
		    pAPI->vkDestroySemaphore = (PFN_vkDestroySemaphore)pAPI->vkGetInstanceProcAddr(instance, "vkDestroySemaphore");
		    pAPI->vkCreateEvent = (PFN_vkCreateEvent)pAPI->vkGetInstanceProcAddr(instance, "vkCreateEvent");
		    pAPI->vkDestroyEvent = (PFN_vkDestroyEvent)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyEvent");
		    pAPI->vkGetEventStatus = (PFN_vkGetEventStatus)pAPI->vkGetInstanceProcAddr(instance, "vkGetEventStatus");
		    pAPI->vkSetEvent = (PFN_vkSetEvent)pAPI->vkGetInstanceProcAddr(instance, "vkSetEvent");
		    pAPI->vkResetEvent = (PFN_vkResetEvent)pAPI->vkGetInstanceProcAddr(instance, "vkResetEvent");
		    pAPI->vkCreateQueryPool = (PFN_vkCreateQueryPool)pAPI->vkGetInstanceProcAddr(instance, "vkCreateQueryPool");
		    pAPI->vkDestroyQueryPool = (PFN_vkDestroyQueryPool)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyQueryPool");
		    pAPI->vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults)pAPI->vkGetInstanceProcAddr(instance, "vkGetQueryPoolResults");
		    pAPI->vkCreateBuffer = (PFN_vkCreateBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkCreateBuffer");
		    pAPI->vkDestroyBuffer = (PFN_vkDestroyBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyBuffer");
		    pAPI->vkCreateBufferView = (PFN_vkCreateBufferView)pAPI->vkGetInstanceProcAddr(instance, "vkCreateBufferView");
		    pAPI->vkDestroyBufferView = (PFN_vkDestroyBufferView)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyBufferView");
		    pAPI->vkCreateImage = (PFN_vkCreateImage)pAPI->vkGetInstanceProcAddr(instance, "vkCreateImage");
		    pAPI->vkDestroyImage = (PFN_vkDestroyImage)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyImage");
		    pAPI->vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageSubresourceLayout");
		    pAPI->vkCreateImageView = (PFN_vkCreateImageView)pAPI->vkGetInstanceProcAddr(instance, "vkCreateImageView");
		    pAPI->vkDestroyImageView = (PFN_vkDestroyImageView)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyImageView");
		    pAPI->vkCreateShaderModule = (PFN_vkCreateShaderModule)pAPI->vkGetInstanceProcAddr(instance, "vkCreateShaderModule");
		    pAPI->vkDestroyShaderModule = (PFN_vkDestroyShaderModule)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyShaderModule");
		    pAPI->vkCreatePipelineCache = (PFN_vkCreatePipelineCache)pAPI->vkGetInstanceProcAddr(instance, "vkCreatePipelineCache");
		    pAPI->vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyPipelineCache");
		    pAPI->vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData)pAPI->vkGetInstanceProcAddr(instance, "vkGetPipelineCacheData");
		    pAPI->vkMergePipelineCaches = (PFN_vkMergePipelineCaches)pAPI->vkGetInstanceProcAddr(instance, "vkMergePipelineCaches");
		    pAPI->vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)pAPI->vkGetInstanceProcAddr(instance, "vkCreateGraphicsPipelines");
		    pAPI->vkCreateComputePipelines = (PFN_vkCreateComputePipelines)pAPI->vkGetInstanceProcAddr(instance, "vkCreateComputePipelines");
		    pAPI->vkDestroyPipeline = (PFN_vkDestroyPipeline)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyPipeline");
		    pAPI->vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout)pAPI->vkGetInstanceProcAddr(instance, "vkCreatePipelineLayout");
		    pAPI->vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyPipelineLayout");
		    pAPI->vkCreateSampler = (PFN_vkCreateSampler)pAPI->vkGetInstanceProcAddr(instance, "vkCreateSampler");
		    pAPI->vkDestroySampler = (PFN_vkDestroySampler)pAPI->vkGetInstanceProcAddr(instance, "vkDestroySampler");
		    pAPI->vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDescriptorSetLayout");
		    pAPI->vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDescriptorSetLayout");
		    pAPI->vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDescriptorPool");
		    pAPI->vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDescriptorPool");
		    pAPI->vkResetDescriptorPool = (PFN_vkResetDescriptorPool)pAPI->vkGetInstanceProcAddr(instance, "vkResetDescriptorPool");
		    pAPI->vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)pAPI->vkGetInstanceProcAddr(instance, "vkAllocateDescriptorSets");
		    pAPI->vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets)pAPI->vkGetInstanceProcAddr(instance, "vkFreeDescriptorSets");
		    pAPI->vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)pAPI->vkGetInstanceProcAddr(instance, "vkUpdateDescriptorSets");
		    pAPI->vkCreateFramebuffer = (PFN_vkCreateFramebuffer)pAPI->vkGetInstanceProcAddr(instance, "vkCreateFramebuffer");
		    pAPI->vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyFramebuffer");
		    pAPI->vkCreateRenderPass = (PFN_vkCreateRenderPass)pAPI->vkGetInstanceProcAddr(instance, "vkCreateRenderPass");
		    pAPI->vkDestroyRenderPass = (PFN_vkDestroyRenderPass)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyRenderPass");
		    pAPI->vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)pAPI->vkGetInstanceProcAddr(instance, "vkGetRenderAreaGranularity");
		    pAPI->vkCreateCommandPool = (PFN_vkCreateCommandPool)pAPI->vkGetInstanceProcAddr(instance, "vkCreateCommandPool");
		    pAPI->vkDestroyCommandPool = (PFN_vkDestroyCommandPool)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyCommandPool");
		    pAPI->vkResetCommandPool = (PFN_vkResetCommandPool)pAPI->vkGetInstanceProcAddr(instance, "vkResetCommandPool");
		    pAPI->vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)pAPI->vkGetInstanceProcAddr(instance, "vkAllocateCommandBuffers");
		    pAPI->vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers)pAPI->vkGetInstanceProcAddr(instance, "vkFreeCommandBuffers");
		    pAPI->vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkBeginCommandBuffer");
		    pAPI->vkEndCommandBuffer = (PFN_vkEndCommandBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkEndCommandBuffer");
		    pAPI->vkResetCommandBuffer = (PFN_vkResetCommandBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkResetCommandBuffer");
		    pAPI->vkCmdBindPipeline = (PFN_vkCmdBindPipeline)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindPipeline");
		    pAPI->vkCmdSetViewport = (PFN_vkCmdSetViewport)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetViewport");
		    pAPI->vkCmdSetScissor = (PFN_vkCmdSetScissor)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetScissor");
		    pAPI->vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetLineWidth");
		    pAPI->vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthBias");
		    pAPI->vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetBlendConstants");
		    pAPI->vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthBounds");
		    pAPI->vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetStencilCompareMask");
		    pAPI->vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetStencilWriteMask");
		    pAPI->vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetStencilReference");
		    pAPI->vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindDescriptorSets");
		    pAPI->vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindIndexBuffer");
		    pAPI->vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindVertexBuffers");
		    pAPI->vkCmdDraw = (PFN_vkCmdDraw)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDraw");
		    pAPI->vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndexed");
		    pAPI->vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndirect");
		    pAPI->vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndexedIndirect");
		    pAPI->vkCmdDispatch = (PFN_vkCmdDispatch)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDispatch");
		    pAPI->vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDispatchIndirect");
		    pAPI->vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyBuffer");
		    pAPI->vkCmdCopyImage = (PFN_vkCmdCopyImage)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyImage");
		    pAPI->vkCmdBlitImage = (PFN_vkCmdBlitImage)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBlitImage");
		    pAPI->vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyBufferToImage");
		    pAPI->vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyImageToBuffer");
		    pAPI->vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkCmdUpdateBuffer");
		    pAPI->vkCmdFillBuffer = (PFN_vkCmdFillBuffer)pAPI->vkGetInstanceProcAddr(instance, "vkCmdFillBuffer");
		    pAPI->vkCmdClearColorImage = (PFN_vkCmdClearColorImage)pAPI->vkGetInstanceProcAddr(instance, "vkCmdClearColorImage");
		    pAPI->vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)pAPI->vkGetInstanceProcAddr(instance, "vkCmdClearDepthStencilImage");
		    pAPI->vkCmdClearAttachments = (PFN_vkCmdClearAttachments)pAPI->vkGetInstanceProcAddr(instance, "vkCmdClearAttachments");
		    pAPI->vkCmdResolveImage = (PFN_vkCmdResolveImage)pAPI->vkGetInstanceProcAddr(instance, "vkCmdResolveImage");
		    pAPI->vkCmdSetEvent = (PFN_vkCmdSetEvent)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetEvent");
		    pAPI->vkCmdResetEvent = (PFN_vkCmdResetEvent)pAPI->vkGetInstanceProcAddr(instance, "vkCmdResetEvent");
		    pAPI->vkCmdWaitEvents = (PFN_vkCmdWaitEvents)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWaitEvents");
		    pAPI->vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPipelineBarrier");
		    pAPI->vkCmdBeginQuery = (PFN_vkCmdBeginQuery)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginQuery");
		    pAPI->vkCmdEndQuery = (PFN_vkCmdEndQuery)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndQuery");
		    pAPI->vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool)pAPI->vkGetInstanceProcAddr(instance, "vkCmdResetQueryPool");
		    pAPI->vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteTimestamp");
		    pAPI->vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyQueryPoolResults");
		    pAPI->vkCmdPushConstants = (PFN_vkCmdPushConstants)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPushConstants");
		    pAPI->vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginRenderPass");
		    pAPI->vkCmdNextSubpass = (PFN_vkCmdNextSubpass)pAPI->vkGetInstanceProcAddr(instance, "vkCmdNextSubpass");
		    pAPI->vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndRenderPass");
		    pAPI->vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands)pAPI->vkGetInstanceProcAddr(instance, "vkCmdExecuteCommands");
		    pAPI->vkEnumerateInstanceVersion = (PFN_vkEnumerateInstanceVersion)pAPI->vkGetInstanceProcAddr(instance, "vkEnumerateInstanceVersion");
		    pAPI->vkBindBufferMemory2 = (PFN_vkBindBufferMemory2)pAPI->vkGetInstanceProcAddr(instance, "vkBindBufferMemory2");
		    pAPI->vkBindImageMemory2 = (PFN_vkBindImageMemory2)pAPI->vkGetInstanceProcAddr(instance, "vkBindImageMemory2");
		    pAPI->vkGetDeviceGroupPeerMemoryFeatures = (PFN_vkGetDeviceGroupPeerMemoryFeatures)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceGroupPeerMemoryFeatures");
		    pAPI->vkCmdSetDeviceMask = (PFN_vkCmdSetDeviceMask)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDeviceMask");
		    pAPI->vkCmdDispatchBase = (PFN_vkCmdDispatchBase)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDispatchBase");
		    pAPI->vkEnumeratePhysicalDeviceGroups = (PFN_vkEnumeratePhysicalDeviceGroups)pAPI->vkGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroups");
		    pAPI->vkGetImageMemoryRequirements2 = (PFN_vkGetImageMemoryRequirements2)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageMemoryRequirements2");
		    pAPI->vkGetBufferMemoryRequirements2 = (PFN_vkGetBufferMemoryRequirements2)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferMemoryRequirements2");
		    pAPI->vkGetImageSparseMemoryRequirements2 = (PFN_vkGetImageSparseMemoryRequirements2)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageSparseMemoryRequirements2");
		    pAPI->vkGetPhysicalDeviceFeatures2 = (PFN_vkGetPhysicalDeviceFeatures2)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2");
		    pAPI->vkGetPhysicalDeviceProperties2 = (PFN_vkGetPhysicalDeviceProperties2)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2");
		    pAPI->vkGetPhysicalDeviceFormatProperties2 = (PFN_vkGetPhysicalDeviceFormatProperties2)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2");
		    pAPI->vkGetPhysicalDeviceImageFormatProperties2 = (PFN_vkGetPhysicalDeviceImageFormatProperties2)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2");
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties2 = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2");
		    pAPI->vkGetPhysicalDeviceMemoryProperties2 = (PFN_vkGetPhysicalDeviceMemoryProperties2)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2");
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2 = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2");
		    pAPI->vkTrimCommandPool = (PFN_vkTrimCommandPool)pAPI->vkGetInstanceProcAddr(instance, "vkTrimCommandPool");
		    pAPI->vkGetDeviceQueue2 = (PFN_vkGetDeviceQueue2)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceQueue2");
		    pAPI->vkCreateSamplerYcbcrConversion = (PFN_vkCreateSamplerYcbcrConversion)pAPI->vkGetInstanceProcAddr(instance, "vkCreateSamplerYcbcrConversion");
		    pAPI->vkDestroySamplerYcbcrConversion = (PFN_vkDestroySamplerYcbcrConversion)pAPI->vkGetInstanceProcAddr(instance, "vkDestroySamplerYcbcrConversion");
		    pAPI->vkCreateDescriptorUpdateTemplate = (PFN_vkCreateDescriptorUpdateTemplate)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDescriptorUpdateTemplate");
		    pAPI->vkDestroyDescriptorUpdateTemplate = (PFN_vkDestroyDescriptorUpdateTemplate)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDescriptorUpdateTemplate");
		    pAPI->vkUpdateDescriptorSetWithTemplate = (PFN_vkUpdateDescriptorSetWithTemplate)pAPI->vkGetInstanceProcAddr(instance, "vkUpdateDescriptorSetWithTemplate");
		    pAPI->vkGetPhysicalDeviceExternalBufferProperties = (PFN_vkGetPhysicalDeviceExternalBufferProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferProperties");
		    pAPI->vkGetPhysicalDeviceExternalFenceProperties = (PFN_vkGetPhysicalDeviceExternalFenceProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFenceProperties");
		    pAPI->vkGetPhysicalDeviceExternalSemaphoreProperties = (PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties");
		    pAPI->vkGetDescriptorSetLayoutSupport = (PFN_vkGetDescriptorSetLayoutSupport)pAPI->vkGetInstanceProcAddr(instance, "vkGetDescriptorSetLayoutSupport");
		    pAPI->vkCmdDrawIndirectCount = (PFN_vkCmdDrawIndirectCount)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectCount");
		    pAPI->vkCmdDrawIndexedIndirectCount = (PFN_vkCmdDrawIndexedIndirectCount)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndexedIndirectCount");
		    pAPI->vkCreateRenderPass2 = (PFN_vkCreateRenderPass2)pAPI->vkGetInstanceProcAddr(instance, "vkCreateRenderPass2");
		    pAPI->vkCmdBeginRenderPass2 = (PFN_vkCmdBeginRenderPass2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginRenderPass2");
		    pAPI->vkCmdNextSubpass2 = (PFN_vkCmdNextSubpass2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdNextSubpass2");
		    pAPI->vkCmdEndRenderPass2 = (PFN_vkCmdEndRenderPass2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndRenderPass2");
		    pAPI->vkResetQueryPool = (PFN_vkResetQueryPool)pAPI->vkGetInstanceProcAddr(instance, "vkResetQueryPool");
		    pAPI->vkGetSemaphoreCounterValue = (PFN_vkGetSemaphoreCounterValue)pAPI->vkGetInstanceProcAddr(instance, "vkGetSemaphoreCounterValue");
		    pAPI->vkWaitSemaphores = (PFN_vkWaitSemaphores)pAPI->vkGetInstanceProcAddr(instance, "vkWaitSemaphores");
		    pAPI->vkSignalSemaphore = (PFN_vkSignalSemaphore)pAPI->vkGetInstanceProcAddr(instance, "vkSignalSemaphore");
		    pAPI->vkGetBufferDeviceAddress = (PFN_vkGetBufferDeviceAddress)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferDeviceAddress");
		    pAPI->vkGetBufferOpaqueCaptureAddress = (PFN_vkGetBufferOpaqueCaptureAddress)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferOpaqueCaptureAddress");
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddress = (PFN_vkGetDeviceMemoryOpaqueCaptureAddress)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceMemoryOpaqueCaptureAddress");
		    pAPI->vkGetPhysicalDeviceToolProperties = (PFN_vkGetPhysicalDeviceToolProperties)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceToolProperties");
		    pAPI->vkCreatePrivateDataSlot = (PFN_vkCreatePrivateDataSlot)pAPI->vkGetInstanceProcAddr(instance, "vkCreatePrivateDataSlot");
		    pAPI->vkDestroyPrivateDataSlot = (PFN_vkDestroyPrivateDataSlot)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyPrivateDataSlot");
		    pAPI->vkSetPrivateData = (PFN_vkSetPrivateData)pAPI->vkGetInstanceProcAddr(instance, "vkSetPrivateData");
		    pAPI->vkGetPrivateData = (PFN_vkGetPrivateData)pAPI->vkGetInstanceProcAddr(instance, "vkGetPrivateData");
		    pAPI->vkCmdSetEvent2 = (PFN_vkCmdSetEvent2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetEvent2");
		    pAPI->vkCmdResetEvent2 = (PFN_vkCmdResetEvent2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdResetEvent2");
		    pAPI->vkCmdWaitEvents2 = (PFN_vkCmdWaitEvents2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWaitEvents2");
		    pAPI->vkCmdPipelineBarrier2 = (PFN_vkCmdPipelineBarrier2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPipelineBarrier2");
		    pAPI->vkCmdWriteTimestamp2 = (PFN_vkCmdWriteTimestamp2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteTimestamp2");
		    pAPI->vkQueueSubmit2 = (PFN_vkQueueSubmit2)pAPI->vkGetInstanceProcAddr(instance, "vkQueueSubmit2");
		    pAPI->vkCmdCopyBuffer2 = (PFN_vkCmdCopyBuffer2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyBuffer2");
		    pAPI->vkCmdCopyImage2 = (PFN_vkCmdCopyImage2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyImage2");
		    pAPI->vkCmdCopyBufferToImage2 = (PFN_vkCmdCopyBufferToImage2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyBufferToImage2");
		    pAPI->vkCmdCopyImageToBuffer2 = (PFN_vkCmdCopyImageToBuffer2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyImageToBuffer2");
		    pAPI->vkCmdBlitImage2 = (PFN_vkCmdBlitImage2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBlitImage2");
		    pAPI->vkCmdResolveImage2 = (PFN_vkCmdResolveImage2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdResolveImage2");
		    pAPI->vkCmdBeginRendering = (PFN_vkCmdBeginRendering)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginRendering");
		    pAPI->vkCmdEndRendering = (PFN_vkCmdEndRendering)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndRendering");
		    pAPI->vkCmdSetCullMode = (PFN_vkCmdSetCullMode)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCullMode");
		    pAPI->vkCmdSetFrontFace = (PFN_vkCmdSetFrontFace)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetFrontFace");
		    pAPI->vkCmdSetPrimitiveTopology = (PFN_vkCmdSetPrimitiveTopology)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPrimitiveTopology");
		    pAPI->vkCmdSetViewportWithCount = (PFN_vkCmdSetViewportWithCount)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetViewportWithCount");
		    pAPI->vkCmdSetScissorWithCount = (PFN_vkCmdSetScissorWithCount)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetScissorWithCount");
		    pAPI->vkCmdBindVertexBuffers2 = (PFN_vkCmdBindVertexBuffers2)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindVertexBuffers2");
		    pAPI->vkCmdSetDepthTestEnable = (PFN_vkCmdSetDepthTestEnable)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthTestEnable");
		    pAPI->vkCmdSetDepthWriteEnable = (PFN_vkCmdSetDepthWriteEnable)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthWriteEnable");
		    pAPI->vkCmdSetDepthCompareOp = (PFN_vkCmdSetDepthCompareOp)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthCompareOp");
		    pAPI->vkCmdSetDepthBoundsTestEnable = (PFN_vkCmdSetDepthBoundsTestEnable)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthBoundsTestEnable");
		    pAPI->vkCmdSetStencilTestEnable = (PFN_vkCmdSetStencilTestEnable)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetStencilTestEnable");
		    pAPI->vkCmdSetStencilOp = (PFN_vkCmdSetStencilOp)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetStencilOp");
		    pAPI->vkCmdSetRasterizerDiscardEnable = (PFN_vkCmdSetRasterizerDiscardEnable)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRasterizerDiscardEnable");
		    pAPI->vkCmdSetDepthBiasEnable = (PFN_vkCmdSetDepthBiasEnable)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthBiasEnable");
		    pAPI->vkCmdSetPrimitiveRestartEnable = (PFN_vkCmdSetPrimitiveRestartEnable)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPrimitiveRestartEnable");
		    pAPI->vkGetDeviceBufferMemoryRequirements = (PFN_vkGetDeviceBufferMemoryRequirements)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceBufferMemoryRequirements");
		    pAPI->vkGetDeviceImageMemoryRequirements = (PFN_vkGetDeviceImageMemoryRequirements)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceImageMemoryRequirements");
		    pAPI->vkGetDeviceImageSparseMemoryRequirements = (PFN_vkGetDeviceImageSparseMemoryRequirements)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceImageSparseMemoryRequirements");
		    pAPI->vkGetCommandPoolMemoryConsumption = (PFN_vkGetCommandPoolMemoryConsumption)pAPI->vkGetInstanceProcAddr(instance, "vkGetCommandPoolMemoryConsumption");
		    pAPI->vkGetFaultData = (PFN_vkGetFaultData)pAPI->vkGetInstanceProcAddr(instance, "vkGetFaultData");
		    pAPI->vkDestroySurfaceKHR = (PFN_vkDestroySurfaceKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroySurfaceKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceSupportKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormatsKHR");
		    pAPI->vkGetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModesKHR");
		    pAPI->vkCreateSwapchainKHR = (PFN_vkCreateSwapchainKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateSwapchainKHR");
		    pAPI->vkDestroySwapchainKHR = (PFN_vkDestroySwapchainKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroySwapchainKHR");
		    pAPI->vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetSwapchainImagesKHR");
		    pAPI->vkAcquireNextImageKHR = (PFN_vkAcquireNextImageKHR)pAPI->vkGetInstanceProcAddr(instance, "vkAcquireNextImageKHR");
		    pAPI->vkQueuePresentKHR = (PFN_vkQueuePresentKHR)pAPI->vkGetInstanceProcAddr(instance, "vkQueuePresentKHR");
		    pAPI->vkGetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceGroupPresentCapabilitiesKHR");
		    pAPI->vkGetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceGroupSurfacePresentModesKHR");
		    pAPI->vkGetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDevicePresentRectanglesKHR");
		    pAPI->vkAcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkAcquireNextImage2KHR");
		    pAPI->vkGetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR");
		    pAPI->vkGetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
		    pAPI->vkGetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR");
		    pAPI->vkGetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR");
		    pAPI->vkCreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDisplayModeKHR");
		    pAPI->vkGetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR");
		    pAPI->vkCreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR");
		    pAPI->vkCreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateSharedSwapchainsKHR");
		    pAPI->vkGetPhysicalDeviceVideoCapabilitiesKHR = (PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoCapabilitiesKHR");
		    pAPI->vkGetPhysicalDeviceVideoFormatPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoFormatPropertiesKHR");
		    pAPI->vkCreateVideoSessionKHR = (PFN_vkCreateVideoSessionKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateVideoSessionKHR");
		    pAPI->vkDestroyVideoSessionKHR = (PFN_vkDestroyVideoSessionKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyVideoSessionKHR");
		    pAPI->vkGetVideoSessionMemoryRequirementsKHR = (PFN_vkGetVideoSessionMemoryRequirementsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetVideoSessionMemoryRequirementsKHR");
		    pAPI->vkBindVideoSessionMemoryKHR = (PFN_vkBindVideoSessionMemoryKHR)pAPI->vkGetInstanceProcAddr(instance, "vkBindVideoSessionMemoryKHR");
		    pAPI->vkCreateVideoSessionParametersKHR = (PFN_vkCreateVideoSessionParametersKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateVideoSessionParametersKHR");
		    pAPI->vkUpdateVideoSessionParametersKHR = (PFN_vkUpdateVideoSessionParametersKHR)pAPI->vkGetInstanceProcAddr(instance, "vkUpdateVideoSessionParametersKHR");
		    pAPI->vkDestroyVideoSessionParametersKHR = (PFN_vkDestroyVideoSessionParametersKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyVideoSessionParametersKHR");
		    pAPI->vkCmdBeginVideoCodingKHR = (PFN_vkCmdBeginVideoCodingKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginVideoCodingKHR");
		    pAPI->vkCmdEndVideoCodingKHR = (PFN_vkCmdEndVideoCodingKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndVideoCodingKHR");
		    pAPI->vkCmdControlVideoCodingKHR = (PFN_vkCmdControlVideoCodingKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdControlVideoCodingKHR");
		    pAPI->vkCmdDecodeVideoKHR = (PFN_vkCmdDecodeVideoKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDecodeVideoKHR");
		    pAPI->vkCmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindTransformFeedbackBuffersEXT");
		    pAPI->vkCmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginTransformFeedbackEXT");
		    pAPI->vkCmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndTransformFeedbackEXT");
		    pAPI->vkCmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginQueryIndexedEXT");
		    pAPI->vkCmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndQueryIndexedEXT");
		    pAPI->vkCmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectByteCountEXT");
		    pAPI->vkCreateCuModuleNVX = (PFN_vkCreateCuModuleNVX)pAPI->vkGetInstanceProcAddr(instance, "vkCreateCuModuleNVX");
		    pAPI->vkCreateCuFunctionNVX = (PFN_vkCreateCuFunctionNVX)pAPI->vkGetInstanceProcAddr(instance, "vkCreateCuFunctionNVX");
		    pAPI->vkDestroyCuModuleNVX = (PFN_vkDestroyCuModuleNVX)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyCuModuleNVX");
		    pAPI->vkDestroyCuFunctionNVX = (PFN_vkDestroyCuFunctionNVX)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyCuFunctionNVX");
		    pAPI->vkCmdCuLaunchKernelNVX = (PFN_vkCmdCuLaunchKernelNVX)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCuLaunchKernelNVX");
		    pAPI->vkGetImageViewHandleNVX = (PFN_vkGetImageViewHandleNVX)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageViewHandleNVX");
		    pAPI->vkGetImageViewAddressNVX = (PFN_vkGetImageViewAddressNVX)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageViewAddressNVX");
		    pAPI->vkGetShaderInfoAMD = (PFN_vkGetShaderInfoAMD)pAPI->vkGetInstanceProcAddr(instance, "vkGetShaderInfoAMD");
		    pAPI->vkCmdBeginRenderingKHR = (PFN_vkCmdBeginRenderingKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginRenderingKHR");
		    pAPI->vkCmdEndRenderingKHR = (PFN_vkCmdEndRenderingKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndRenderingKHR");
		    pAPI->vkGetPhysicalDeviceFeatures2KHR = (PFN_vkGetPhysicalDeviceFeatures2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2KHR");
		    pAPI->vkGetPhysicalDeviceProperties2KHR = (PFN_vkGetPhysicalDeviceProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2KHR");
		    pAPI->vkGetPhysicalDeviceFormatProperties2KHR = (PFN_vkGetPhysicalDeviceFormatProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2KHR");
		    pAPI->vkGetPhysicalDeviceImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceImageFormatProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2KHR");
		    pAPI->vkGetPhysicalDeviceQueueFamilyProperties2KHR = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2KHR");
		    pAPI->vkGetPhysicalDeviceMemoryProperties2KHR = (PFN_vkGetPhysicalDeviceMemoryProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2KHR");
		    pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
		    pAPI->vkGetDeviceGroupPeerMemoryFeaturesKHR = (PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceGroupPeerMemoryFeaturesKHR");
		    pAPI->vkCmdSetDeviceMaskKHR = (PFN_vkCmdSetDeviceMaskKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDeviceMaskKHR");
		    pAPI->vkCmdDispatchBaseKHR = (PFN_vkCmdDispatchBaseKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDispatchBaseKHR");
		    pAPI->vkTrimCommandPoolKHR = (PFN_vkTrimCommandPoolKHR)pAPI->vkGetInstanceProcAddr(instance, "vkTrimCommandPoolKHR");
		    pAPI->vkEnumeratePhysicalDeviceGroupsKHR = (PFN_vkEnumeratePhysicalDeviceGroupsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroupsKHR");
		    pAPI->vkGetPhysicalDeviceExternalBufferPropertiesKHR = (PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR");
		    pAPI->vkGetPhysicalDeviceExternalImageFormatPropertiesNV = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
		    pAPI->vkGetMemoryFdKHR = (PFN_vkGetMemoryFdKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryFdKHR");
		    pAPI->vkGetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryFdPropertiesKHR");
		    pAPI->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
		    pAPI->vkImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR)pAPI->vkGetInstanceProcAddr(instance, "vkImportSemaphoreFdKHR");
		    pAPI->vkGetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetSemaphoreFdKHR");
		    pAPI->vkCmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPushDescriptorSetKHR");
		    pAPI->vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPushDescriptorSetWithTemplateKHR");
		    pAPI->vkCmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginConditionalRenderingEXT");
		    pAPI->vkCmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndConditionalRenderingEXT");
		    pAPI->vkCreateDescriptorUpdateTemplateKHR = (PFN_vkCreateDescriptorUpdateTemplateKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDescriptorUpdateTemplateKHR");
		    pAPI->vkDestroyDescriptorUpdateTemplateKHR = (PFN_vkDestroyDescriptorUpdateTemplateKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDescriptorUpdateTemplateKHR");
		    pAPI->vkUpdateDescriptorSetWithTemplateKHR = (PFN_vkUpdateDescriptorSetWithTemplateKHR)pAPI->vkGetInstanceProcAddr(instance, "vkUpdateDescriptorSetWithTemplateKHR");
		    pAPI->vkCmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetViewportWScalingNV");
		    pAPI->vkReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT)pAPI->vkGetInstanceProcAddr(instance, "vkReleaseDisplayEXT");
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
		    pAPI->vkDisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDisplayPowerControlEXT");
		    pAPI->vkRegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT)pAPI->vkGetInstanceProcAddr(instance, "vkRegisterDeviceEventEXT");
		    pAPI->vkRegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT)pAPI->vkGetInstanceProcAddr(instance, "vkRegisterDisplayEventEXT");
		    pAPI->vkGetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetSwapchainCounterEXT");
		    pAPI->vkGetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE)pAPI->vkGetInstanceProcAddr(instance, "vkGetRefreshCycleDurationGOOGLE");
		    pAPI->vkGetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE)pAPI->vkGetInstanceProcAddr(instance, "vkGetPastPresentationTimingGOOGLE");
		    pAPI->vkCmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDiscardRectangleEXT");
		    pAPI->vkCmdSetDiscardRectangleEnableEXT = (PFN_vkCmdSetDiscardRectangleEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDiscardRectangleEnableEXT");
		    pAPI->vkCmdSetDiscardRectangleModeEXT = (PFN_vkCmdSetDiscardRectangleModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDiscardRectangleModeEXT");
		    pAPI->vkSetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkSetHdrMetadataEXT");
		    pAPI->vkCreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateRenderPass2KHR");
		    pAPI->vkCmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginRenderPass2KHR");
		    pAPI->vkCmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdNextSubpass2KHR");
		    pAPI->vkCmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndRenderPass2KHR");
		    pAPI->vkGetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetSwapchainStatusKHR");
		    pAPI->vkGetPhysicalDeviceExternalFencePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR");
		    pAPI->vkImportFenceFdKHR = (PFN_vkImportFenceFdKHR)pAPI->vkGetInstanceProcAddr(instance, "vkImportFenceFdKHR");
		    pAPI->vkGetFenceFdKHR = (PFN_vkGetFenceFdKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetFenceFdKHR");
		    pAPI->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)pAPI->vkGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
		    pAPI->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = (PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
		    pAPI->vkAcquireProfilingLockKHR = (PFN_vkAcquireProfilingLockKHR)pAPI->vkGetInstanceProcAddr(instance, "vkAcquireProfilingLockKHR");
		    pAPI->vkReleaseProfilingLockKHR = (PFN_vkReleaseProfilingLockKHR)pAPI->vkGetInstanceProcAddr(instance, "vkReleaseProfilingLockKHR");
		    pAPI->vkGetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
		    pAPI->vkGetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormats2KHR");
		    pAPI->vkGetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayProperties2KHR");
		    pAPI->vkGetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
		    pAPI->vkGetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDisplayModeProperties2KHR");
		    pAPI->vkGetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilities2KHR");
		    pAPI->vkSetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT)pAPI->vkGetInstanceProcAddr(instance, "vkSetDebugUtilsObjectNameEXT");
		    pAPI->vkSetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT)pAPI->vkGetInstanceProcAddr(instance, "vkSetDebugUtilsObjectTagEXT");
		    pAPI->vkQueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT)pAPI->vkGetInstanceProcAddr(instance, "vkQueueBeginDebugUtilsLabelEXT");
		    pAPI->vkQueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT)pAPI->vkGetInstanceProcAddr(instance, "vkQueueEndDebugUtilsLabelEXT");
		    pAPI->vkQueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT)pAPI->vkGetInstanceProcAddr(instance, "vkQueueInsertDebugUtilsLabelEXT");
		    pAPI->vkCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBeginDebugUtilsLabelEXT");
		    pAPI->vkCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEndDebugUtilsLabelEXT");
		    pAPI->vkCmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdInsertDebugUtilsLabelEXT");
		    pAPI->vkCreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
		    pAPI->vkDestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
		    pAPI->vkSubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT)pAPI->vkGetInstanceProcAddr(instance, "vkSubmitDebugUtilsMessageEXT");
		    pAPI->vkDebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectTagEXT");
		    pAPI->vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectNameEXT");
		    pAPI->vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerBeginEXT");
		    pAPI->vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerEndEXT");
		    pAPI->vkCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerInsertEXT");
		    pAPI->vkCreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT");
		    pAPI->vkDestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT");
		    pAPI->vkDebugReportMessageEXT = (PFN_vkDebugReportMessageEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDebugReportMessageEXT");
		    pAPI->vkCmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetSampleLocationsEXT");
		    pAPI->vkGetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
		    pAPI->vkGetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageMemoryRequirements2KHR");
		    pAPI->vkGetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferMemoryRequirements2KHR");
		    pAPI->vkGetImageSparseMemoryRequirements2KHR = (PFN_vkGetImageSparseMemoryRequirements2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageSparseMemoryRequirements2KHR");
		    pAPI->vkCreateAccelerationStructureKHR = (PFN_vkCreateAccelerationStructureKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateAccelerationStructureKHR");
		    pAPI->vkDestroyAccelerationStructureKHR = (PFN_vkDestroyAccelerationStructureKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyAccelerationStructureKHR");
		    pAPI->vkCmdBuildAccelerationStructuresKHR = (PFN_vkCmdBuildAccelerationStructuresKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBuildAccelerationStructuresKHR");
		    pAPI->vkCmdBuildAccelerationStructuresIndirectKHR = (PFN_vkCmdBuildAccelerationStructuresIndirectKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBuildAccelerationStructuresIndirectKHR");
		    pAPI->vkBuildAccelerationStructuresKHR = (PFN_vkBuildAccelerationStructuresKHR)pAPI->vkGetInstanceProcAddr(instance, "vkBuildAccelerationStructuresKHR");
		    pAPI->vkCopyAccelerationStructureKHR = (PFN_vkCopyAccelerationStructureKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCopyAccelerationStructureKHR");
		    pAPI->vkCopyAccelerationStructureToMemoryKHR = (PFN_vkCopyAccelerationStructureToMemoryKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCopyAccelerationStructureToMemoryKHR");
		    pAPI->vkCopyMemoryToAccelerationStructureKHR = (PFN_vkCopyMemoryToAccelerationStructureKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCopyMemoryToAccelerationStructureKHR");
		    pAPI->vkWriteAccelerationStructuresPropertiesKHR = (PFN_vkWriteAccelerationStructuresPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkWriteAccelerationStructuresPropertiesKHR");
		    pAPI->vkCmdCopyAccelerationStructureKHR = (PFN_vkCmdCopyAccelerationStructureKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyAccelerationStructureKHR");
		    pAPI->vkCmdCopyAccelerationStructureToMemoryKHR = (PFN_vkCmdCopyAccelerationStructureToMemoryKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyAccelerationStructureToMemoryKHR");
		    pAPI->vkCmdCopyMemoryToAccelerationStructureKHR = (PFN_vkCmdCopyMemoryToAccelerationStructureKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyMemoryToAccelerationStructureKHR");
		    pAPI->vkGetAccelerationStructureDeviceAddressKHR = (PFN_vkGetAccelerationStructureDeviceAddressKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetAccelerationStructureDeviceAddressKHR");
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesKHR = (PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteAccelerationStructuresPropertiesKHR");
		    pAPI->vkGetDeviceAccelerationStructureCompatibilityKHR = (PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceAccelerationStructureCompatibilityKHR");
		    pAPI->vkGetAccelerationStructureBuildSizesKHR = (PFN_vkGetAccelerationStructureBuildSizesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetAccelerationStructureBuildSizesKHR");
		    pAPI->vkCmdTraceRaysKHR = (PFN_vkCmdTraceRaysKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdTraceRaysKHR");
		    pAPI->vkCreateRayTracingPipelinesKHR = (PFN_vkCreateRayTracingPipelinesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateRayTracingPipelinesKHR");
		    pAPI->vkGetRayTracingShaderGroupHandlesKHR = (PFN_vkGetRayTracingShaderGroupHandlesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetRayTracingShaderGroupHandlesKHR");
		    pAPI->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = (PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
		    pAPI->vkCmdTraceRaysIndirectKHR = (PFN_vkCmdTraceRaysIndirectKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdTraceRaysIndirectKHR");
		    pAPI->vkGetRayTracingShaderGroupStackSizeKHR = (PFN_vkGetRayTracingShaderGroupStackSizeKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetRayTracingShaderGroupStackSizeKHR");
		    pAPI->vkCmdSetRayTracingPipelineStackSizeKHR = (PFN_vkCmdSetRayTracingPipelineStackSizeKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRayTracingPipelineStackSizeKHR");
		    pAPI->vkCreateSamplerYcbcrConversionKHR = (PFN_vkCreateSamplerYcbcrConversionKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateSamplerYcbcrConversionKHR");
		    pAPI->vkDestroySamplerYcbcrConversionKHR = (PFN_vkDestroySamplerYcbcrConversionKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroySamplerYcbcrConversionKHR");
		    pAPI->vkBindBufferMemory2KHR = (PFN_vkBindBufferMemory2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkBindBufferMemory2KHR");
		    pAPI->vkBindImageMemory2KHR = (PFN_vkBindImageMemory2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkBindImageMemory2KHR");
		    pAPI->vkGetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageDrmFormatModifierPropertiesEXT");
		    pAPI->vkCreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateValidationCacheEXT");
		    pAPI->vkDestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyValidationCacheEXT");
		    pAPI->vkMergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkMergeValidationCachesEXT");
		    pAPI->vkGetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetValidationCacheDataEXT");
		    pAPI->vkCmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindShadingRateImageNV");
		    pAPI->vkCmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetViewportShadingRatePaletteNV");
		    pAPI->vkCmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCoarseSampleOrderNV");
		    pAPI->vkCreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV)pAPI->vkGetInstanceProcAddr(instance, "vkCreateAccelerationStructureNV");
		    pAPI->vkDestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyAccelerationStructureNV");
		    pAPI->vkGetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetAccelerationStructureMemoryRequirementsNV");
		    pAPI->vkBindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV)pAPI->vkGetInstanceProcAddr(instance, "vkBindAccelerationStructureMemoryNV");
		    pAPI->vkCmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBuildAccelerationStructureNV");
		    pAPI->vkCmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyAccelerationStructureNV");
		    pAPI->vkCmdTraceRaysNV = (PFN_vkCmdTraceRaysNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdTraceRaysNV");
		    pAPI->vkCreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV)pAPI->vkGetInstanceProcAddr(instance, "vkCreateRayTracingPipelinesNV");
		    pAPI->vkGetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetRayTracingShaderGroupHandlesNV");
		    pAPI->vkGetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetAccelerationStructureHandleNV");
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteAccelerationStructuresPropertiesNV");
		    pAPI->vkCompileDeferredNV = (PFN_vkCompileDeferredNV)pAPI->vkGetInstanceProcAddr(instance, "vkCompileDeferredNV");
		    pAPI->vkGetDescriptorSetLayoutSupportKHR = (PFN_vkGetDescriptorSetLayoutSupportKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDescriptorSetLayoutSupportKHR");
		    pAPI->vkCmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectCountKHR");
		    pAPI->vkCmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndexedIndirectCountKHR");
		    pAPI->vkCmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectCountAMD");
		    pAPI->vkCmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawIndexedIndirectCountAMD");
		    pAPI->vkGetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryHostPointerPropertiesEXT");
		    pAPI->vkCmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteBufferMarkerAMD");
		    pAPI->vkCmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMeshTasksNV");
		    pAPI->vkCmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMeshTasksIndirectNV");
		    pAPI->vkCmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMeshTasksIndirectCountNV");
		    pAPI->vkCmdSetExclusiveScissorEnableNV = (PFN_vkCmdSetExclusiveScissorEnableNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetExclusiveScissorEnableNV");
		    pAPI->vkCmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetExclusiveScissorNV");
		    pAPI->vkCmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCheckpointNV");
		    pAPI->vkGetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetQueueCheckpointDataNV");
		    pAPI->vkGetSemaphoreCounterValueKHR = (PFN_vkGetSemaphoreCounterValueKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetSemaphoreCounterValueKHR");
		    pAPI->vkWaitSemaphoresKHR = (PFN_vkWaitSemaphoresKHR)pAPI->vkGetInstanceProcAddr(instance, "vkWaitSemaphoresKHR");
		    pAPI->vkSignalSemaphoreKHR = (PFN_vkSignalSemaphoreKHR)pAPI->vkGetInstanceProcAddr(instance, "vkSignalSemaphoreKHR");
		    pAPI->vkInitializePerformanceApiINTEL = (PFN_vkInitializePerformanceApiINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkInitializePerformanceApiINTEL");
		    pAPI->vkUninitializePerformanceApiINTEL = (PFN_vkUninitializePerformanceApiINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkUninitializePerformanceApiINTEL");
		    pAPI->vkCmdSetPerformanceMarkerINTEL = (PFN_vkCmdSetPerformanceMarkerINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPerformanceMarkerINTEL");
		    pAPI->vkCmdSetPerformanceStreamMarkerINTEL = (PFN_vkCmdSetPerformanceStreamMarkerINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPerformanceStreamMarkerINTEL");
		    pAPI->vkCmdSetPerformanceOverrideINTEL = (PFN_vkCmdSetPerformanceOverrideINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPerformanceOverrideINTEL");
		    pAPI->vkAcquirePerformanceConfigurationINTEL = (PFN_vkAcquirePerformanceConfigurationINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkAcquirePerformanceConfigurationINTEL");
		    pAPI->vkReleasePerformanceConfigurationINTEL = (PFN_vkReleasePerformanceConfigurationINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkReleasePerformanceConfigurationINTEL");
		    pAPI->vkQueueSetPerformanceConfigurationINTEL = (PFN_vkQueueSetPerformanceConfigurationINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkQueueSetPerformanceConfigurationINTEL");
		    pAPI->vkGetPerformanceParameterINTEL = (PFN_vkGetPerformanceParameterINTEL)pAPI->vkGetInstanceProcAddr(instance, "vkGetPerformanceParameterINTEL");
		    pAPI->vkSetLocalDimmingAMD = (PFN_vkSetLocalDimmingAMD)pAPI->vkGetInstanceProcAddr(instance, "vkSetLocalDimmingAMD");
		    pAPI->vkGetPhysicalDeviceFragmentShadingRatesKHR = (PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFragmentShadingRatesKHR");
		    pAPI->vkCmdSetFragmentShadingRateKHR = (PFN_vkCmdSetFragmentShadingRateKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetFragmentShadingRateKHR");
		    pAPI->vkCmdSetRenderingAttachmentLocationsKHR = (PFN_vkCmdSetRenderingAttachmentLocationsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRenderingAttachmentLocationsKHR");
		    pAPI->vkCmdSetRenderingInputAttachmentIndicesKHR = (PFN_vkCmdSetRenderingInputAttachmentIndicesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRenderingInputAttachmentIndicesKHR");
		    pAPI->vkGetPhysicalDeviceToolPropertiesEXT = (PFN_vkGetPhysicalDeviceToolPropertiesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceToolPropertiesEXT");
		    pAPI->vkWaitForPresentKHR = (PFN_vkWaitForPresentKHR)pAPI->vkGetInstanceProcAddr(instance, "vkWaitForPresentKHR");
		    pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
		    pAPI->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = (PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
		    pAPI->vkCreateHeadlessSurfaceEXT = (PFN_vkCreateHeadlessSurfaceEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateHeadlessSurfaceEXT");
		    pAPI->vkGetBufferDeviceAddressKHR = (PFN_vkGetBufferDeviceAddressKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferDeviceAddressKHR");
		    pAPI->vkGetBufferOpaqueCaptureAddressKHR = (PFN_vkGetBufferOpaqueCaptureAddressKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferOpaqueCaptureAddressKHR");
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddressKHR = (PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceMemoryOpaqueCaptureAddressKHR");
		    pAPI->vkGetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferDeviceAddressEXT");
		    pAPI->vkResetQueryPoolEXT = (PFN_vkResetQueryPoolEXT)pAPI->vkGetInstanceProcAddr(instance, "vkResetQueryPoolEXT");
		    pAPI->vkCmdSetCullModeEXT = (PFN_vkCmdSetCullModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCullModeEXT");
		    pAPI->vkCmdSetFrontFaceEXT = (PFN_vkCmdSetFrontFaceEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetFrontFaceEXT");
		    pAPI->vkCmdSetPrimitiveTopologyEXT = (PFN_vkCmdSetPrimitiveTopologyEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPrimitiveTopologyEXT");
		    pAPI->vkCmdSetViewportWithCountEXT = (PFN_vkCmdSetViewportWithCountEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetViewportWithCountEXT");
		    pAPI->vkCmdSetScissorWithCountEXT = (PFN_vkCmdSetScissorWithCountEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetScissorWithCountEXT");
		    pAPI->vkCmdBindVertexBuffers2EXT = (PFN_vkCmdBindVertexBuffers2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindVertexBuffers2EXT");
		    pAPI->vkCmdSetDepthTestEnableEXT = (PFN_vkCmdSetDepthTestEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthTestEnableEXT");
		    pAPI->vkCmdSetDepthWriteEnableEXT = (PFN_vkCmdSetDepthWriteEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthWriteEnableEXT");
		    pAPI->vkCmdSetDepthCompareOpEXT = (PFN_vkCmdSetDepthCompareOpEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthCompareOpEXT");
		    pAPI->vkCmdSetDepthBoundsTestEnableEXT = (PFN_vkCmdSetDepthBoundsTestEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthBoundsTestEnableEXT");
		    pAPI->vkCmdSetStencilTestEnableEXT = (PFN_vkCmdSetStencilTestEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetStencilTestEnableEXT");
		    pAPI->vkCmdSetStencilOpEXT = (PFN_vkCmdSetStencilOpEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetStencilOpEXT");
		    pAPI->vkCreateDeferredOperationKHR = (PFN_vkCreateDeferredOperationKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDeferredOperationKHR");
		    pAPI->vkDestroyDeferredOperationKHR = (PFN_vkDestroyDeferredOperationKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyDeferredOperationKHR");
		    pAPI->vkGetDeferredOperationMaxConcurrencyKHR = (PFN_vkGetDeferredOperationMaxConcurrencyKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeferredOperationMaxConcurrencyKHR");
		    pAPI->vkGetDeferredOperationResultKHR = (PFN_vkGetDeferredOperationResultKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeferredOperationResultKHR");
		    pAPI->vkDeferredOperationJoinKHR = (PFN_vkDeferredOperationJoinKHR)pAPI->vkGetInstanceProcAddr(instance, "vkDeferredOperationJoinKHR");
		    pAPI->vkGetPipelineExecutablePropertiesKHR = (PFN_vkGetPipelineExecutablePropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPipelineExecutablePropertiesKHR");
		    pAPI->vkGetPipelineExecutableStatisticsKHR = (PFN_vkGetPipelineExecutableStatisticsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPipelineExecutableStatisticsKHR");
		    pAPI->vkGetPipelineExecutableInternalRepresentationsKHR = (PFN_vkGetPipelineExecutableInternalRepresentationsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPipelineExecutableInternalRepresentationsKHR");
		    pAPI->vkCopyMemoryToImageEXT = (PFN_vkCopyMemoryToImageEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCopyMemoryToImageEXT");
		    pAPI->vkCopyImageToMemoryEXT = (PFN_vkCopyImageToMemoryEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCopyImageToMemoryEXT");
		    pAPI->vkCopyImageToImageEXT = (PFN_vkCopyImageToImageEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCopyImageToImageEXT");
		    pAPI->vkTransitionImageLayoutEXT = (PFN_vkTransitionImageLayoutEXT)pAPI->vkGetInstanceProcAddr(instance, "vkTransitionImageLayoutEXT");
		    pAPI->vkGetImageSubresourceLayout2EXT = (PFN_vkGetImageSubresourceLayout2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageSubresourceLayout2EXT");
		    pAPI->vkMapMemory2KHR = (PFN_vkMapMemory2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkMapMemory2KHR");
		    pAPI->vkUnmapMemory2KHR = (PFN_vkUnmapMemory2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkUnmapMemory2KHR");
		    pAPI->vkReleaseSwapchainImagesEXT = (PFN_vkReleaseSwapchainImagesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkReleaseSwapchainImagesEXT");
		    pAPI->vkGetGeneratedCommandsMemoryRequirementsNV = (PFN_vkGetGeneratedCommandsMemoryRequirementsNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetGeneratedCommandsMemoryRequirementsNV");
		    pAPI->vkCmdPreprocessGeneratedCommandsNV = (PFN_vkCmdPreprocessGeneratedCommandsNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPreprocessGeneratedCommandsNV");
		    pAPI->vkCmdExecuteGeneratedCommandsNV = (PFN_vkCmdExecuteGeneratedCommandsNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdExecuteGeneratedCommandsNV");
		    pAPI->vkCmdBindPipelineShaderGroupNV = (PFN_vkCmdBindPipelineShaderGroupNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindPipelineShaderGroupNV");
		    pAPI->vkCreateIndirectCommandsLayoutNV = (PFN_vkCreateIndirectCommandsLayoutNV)pAPI->vkGetInstanceProcAddr(instance, "vkCreateIndirectCommandsLayoutNV");
		    pAPI->vkDestroyIndirectCommandsLayoutNV = (PFN_vkDestroyIndirectCommandsLayoutNV)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyIndirectCommandsLayoutNV");
		    pAPI->vkCmdSetDepthBias2EXT = (PFN_vkCmdSetDepthBias2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthBias2EXT");
		    pAPI->vkAcquireDrmDisplayEXT = (PFN_vkAcquireDrmDisplayEXT)pAPI->vkGetInstanceProcAddr(instance, "vkAcquireDrmDisplayEXT");
		    pAPI->vkGetDrmDisplayEXT = (PFN_vkGetDrmDisplayEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetDrmDisplayEXT");
		    pAPI->vkCreatePrivateDataSlotEXT = (PFN_vkCreatePrivateDataSlotEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreatePrivateDataSlotEXT");
		    pAPI->vkDestroyPrivateDataSlotEXT = (PFN_vkDestroyPrivateDataSlotEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyPrivateDataSlotEXT");
		    pAPI->vkSetPrivateDataEXT = (PFN_vkSetPrivateDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkSetPrivateDataEXT");
		    pAPI->vkGetPrivateDataEXT = (PFN_vkGetPrivateDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPrivateDataEXT");
		    pAPI->vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR");
		    pAPI->vkGetEncodedVideoSessionParametersKHR = (PFN_vkGetEncodedVideoSessionParametersKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetEncodedVideoSessionParametersKHR");
		    pAPI->vkCmdEncodeVideoKHR = (PFN_vkCmdEncodeVideoKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdEncodeVideoKHR");
		    pAPI->vkCreateCudaModuleNV = (PFN_vkCreateCudaModuleNV)pAPI->vkGetInstanceProcAddr(instance, "vkCreateCudaModuleNV");
		    pAPI->vkGetCudaModuleCacheNV = (PFN_vkGetCudaModuleCacheNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetCudaModuleCacheNV");
		    pAPI->vkCreateCudaFunctionNV = (PFN_vkCreateCudaFunctionNV)pAPI->vkGetInstanceProcAddr(instance, "vkCreateCudaFunctionNV");
		    pAPI->vkDestroyCudaModuleNV = (PFN_vkDestroyCudaModuleNV)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyCudaModuleNV");
		    pAPI->vkDestroyCudaFunctionNV = (PFN_vkDestroyCudaFunctionNV)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyCudaFunctionNV");
		    pAPI->vkCmdCudaLaunchKernelNV = (PFN_vkCmdCudaLaunchKernelNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCudaLaunchKernelNV");
		    pAPI->vkCmdRefreshObjectsKHR = (PFN_vkCmdRefreshObjectsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdRefreshObjectsKHR");
		    pAPI->vkGetPhysicalDeviceRefreshableObjectTypesKHR = (PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceRefreshableObjectTypesKHR");
		    pAPI->vkCmdSetEvent2KHR = (PFN_vkCmdSetEvent2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetEvent2KHR");
		    pAPI->vkCmdResetEvent2KHR = (PFN_vkCmdResetEvent2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdResetEvent2KHR");
		    pAPI->vkCmdWaitEvents2KHR = (PFN_vkCmdWaitEvents2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWaitEvents2KHR");
		    pAPI->vkCmdPipelineBarrier2KHR = (PFN_vkCmdPipelineBarrier2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPipelineBarrier2KHR");
		    pAPI->vkCmdWriteTimestamp2KHR = (PFN_vkCmdWriteTimestamp2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteTimestamp2KHR");
		    pAPI->vkQueueSubmit2KHR = (PFN_vkQueueSubmit2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkQueueSubmit2KHR");
		    pAPI->vkCmdWriteBufferMarker2AMD = (PFN_vkCmdWriteBufferMarker2AMD)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteBufferMarker2AMD");
		    pAPI->vkGetQueueCheckpointData2NV = (PFN_vkGetQueueCheckpointData2NV)pAPI->vkGetInstanceProcAddr(instance, "vkGetQueueCheckpointData2NV");
		    pAPI->vkGetDescriptorSetLayoutSizeEXT = (PFN_vkGetDescriptorSetLayoutSizeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetDescriptorSetLayoutSizeEXT");
		    pAPI->vkGetDescriptorSetLayoutBindingOffsetEXT = (PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetDescriptorSetLayoutBindingOffsetEXT");
		    pAPI->vkGetDescriptorEXT = (PFN_vkGetDescriptorEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetDescriptorEXT");
		    pAPI->vkCmdBindDescriptorBuffersEXT = (PFN_vkCmdBindDescriptorBuffersEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindDescriptorBuffersEXT");
		    pAPI->vkCmdSetDescriptorBufferOffsetsEXT = (PFN_vkCmdSetDescriptorBufferOffsetsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDescriptorBufferOffsetsEXT");
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplersEXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
		    pAPI->vkGetBufferOpaqueCaptureDescriptorDataEXT = (PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetImageOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetImageViewOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageViewOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetSamplerOpaqueCaptureDescriptorDataEXT = (PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetSamplerOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = (PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkCmdSetFragmentShadingRateEnumNV = (PFN_vkCmdSetFragmentShadingRateEnumNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetFragmentShadingRateEnumNV");
		    pAPI->vkCmdDrawMeshTasksEXT = (PFN_vkCmdDrawMeshTasksEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMeshTasksEXT");
		    pAPI->vkCmdDrawMeshTasksIndirectEXT = (PFN_vkCmdDrawMeshTasksIndirectEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMeshTasksIndirectEXT");
		    pAPI->vkCmdDrawMeshTasksIndirectCountEXT = (PFN_vkCmdDrawMeshTasksIndirectCountEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMeshTasksIndirectCountEXT");
		    pAPI->vkCmdCopyBuffer2KHR = (PFN_vkCmdCopyBuffer2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyBuffer2KHR");
		    pAPI->vkCmdCopyImage2KHR = (PFN_vkCmdCopyImage2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyImage2KHR");
		    pAPI->vkCmdCopyBufferToImage2KHR = (PFN_vkCmdCopyBufferToImage2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyBufferToImage2KHR");
		    pAPI->vkCmdCopyImageToBuffer2KHR = (PFN_vkCmdCopyImageToBuffer2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyImageToBuffer2KHR");
		    pAPI->vkCmdBlitImage2KHR = (PFN_vkCmdBlitImage2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBlitImage2KHR");
		    pAPI->vkCmdResolveImage2KHR = (PFN_vkCmdResolveImage2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdResolveImage2KHR");
		    pAPI->vkGetDeviceFaultInfoEXT = (PFN_vkGetDeviceFaultInfoEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceFaultInfoEXT");
		    pAPI->vkCmdSetVertexInputEXT = (PFN_vkCmdSetVertexInputEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetVertexInputEXT");
		    pAPI->vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = (PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
		    pAPI->vkCmdSubpassShadingHUAWEI = (PFN_vkCmdSubpassShadingHUAWEI)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSubpassShadingHUAWEI");
		    pAPI->vkCmdBindInvocationMaskHUAWEI = (PFN_vkCmdBindInvocationMaskHUAWEI)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindInvocationMaskHUAWEI");
		    pAPI->vkGetMemoryRemoteAddressNV = (PFN_vkGetMemoryRemoteAddressNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryRemoteAddressNV");
		    pAPI->vkGetPipelinePropertiesEXT = (PFN_vkGetPipelinePropertiesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPipelinePropertiesEXT");
		    pAPI->vkCmdSetPatchControlPointsEXT = (PFN_vkCmdSetPatchControlPointsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPatchControlPointsEXT");
		    pAPI->vkCmdSetRasterizerDiscardEnableEXT = (PFN_vkCmdSetRasterizerDiscardEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRasterizerDiscardEnableEXT");
		    pAPI->vkCmdSetDepthBiasEnableEXT = (PFN_vkCmdSetDepthBiasEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthBiasEnableEXT");
		    pAPI->vkCmdSetLogicOpEXT = (PFN_vkCmdSetLogicOpEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetLogicOpEXT");
		    pAPI->vkCmdSetPrimitiveRestartEnableEXT = (PFN_vkCmdSetPrimitiveRestartEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPrimitiveRestartEnableEXT");
		    pAPI->vkCmdSetColorWriteEnableEXT = (PFN_vkCmdSetColorWriteEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetColorWriteEnableEXT");
		    pAPI->vkCmdTraceRaysIndirect2KHR = (PFN_vkCmdTraceRaysIndirect2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdTraceRaysIndirect2KHR");
		    pAPI->vkCmdDrawMultiEXT = (PFN_vkCmdDrawMultiEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMultiEXT");
		    pAPI->vkCmdDrawMultiIndexedEXT = (PFN_vkCmdDrawMultiIndexedEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawMultiIndexedEXT");
		    pAPI->vkCreateMicromapEXT = (PFN_vkCreateMicromapEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateMicromapEXT");
		    pAPI->vkDestroyMicromapEXT = (PFN_vkDestroyMicromapEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyMicromapEXT");
		    pAPI->vkCmdBuildMicromapsEXT = (PFN_vkCmdBuildMicromapsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBuildMicromapsEXT");
		    pAPI->vkBuildMicromapsEXT = (PFN_vkBuildMicromapsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkBuildMicromapsEXT");
		    pAPI->vkCopyMicromapEXT = (PFN_vkCopyMicromapEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCopyMicromapEXT");
		    pAPI->vkCopyMicromapToMemoryEXT = (PFN_vkCopyMicromapToMemoryEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCopyMicromapToMemoryEXT");
		    pAPI->vkCopyMemoryToMicromapEXT = (PFN_vkCopyMemoryToMicromapEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCopyMemoryToMicromapEXT");
		    pAPI->vkWriteMicromapsPropertiesEXT = (PFN_vkWriteMicromapsPropertiesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkWriteMicromapsPropertiesEXT");
		    pAPI->vkCmdCopyMicromapEXT = (PFN_vkCmdCopyMicromapEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyMicromapEXT");
		    pAPI->vkCmdCopyMicromapToMemoryEXT = (PFN_vkCmdCopyMicromapToMemoryEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyMicromapToMemoryEXT");
		    pAPI->vkCmdCopyMemoryToMicromapEXT = (PFN_vkCmdCopyMemoryToMicromapEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyMemoryToMicromapEXT");
		    pAPI->vkCmdWriteMicromapsPropertiesEXT = (PFN_vkCmdWriteMicromapsPropertiesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdWriteMicromapsPropertiesEXT");
		    pAPI->vkGetDeviceMicromapCompatibilityEXT = (PFN_vkGetDeviceMicromapCompatibilityEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceMicromapCompatibilityEXT");
		    pAPI->vkGetMicromapBuildSizesEXT = (PFN_vkGetMicromapBuildSizesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetMicromapBuildSizesEXT");
		    pAPI->vkCmdDrawClusterHUAWEI = (PFN_vkCmdDrawClusterHUAWEI)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawClusterHUAWEI");
		    pAPI->vkCmdDrawClusterIndirectHUAWEI = (PFN_vkCmdDrawClusterIndirectHUAWEI)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDrawClusterIndirectHUAWEI");
		    pAPI->vkSetDeviceMemoryPriorityEXT = (PFN_vkSetDeviceMemoryPriorityEXT)pAPI->vkGetInstanceProcAddr(instance, "vkSetDeviceMemoryPriorityEXT");
		    pAPI->vkGetDeviceBufferMemoryRequirementsKHR = (PFN_vkGetDeviceBufferMemoryRequirementsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceBufferMemoryRequirementsKHR");
		    pAPI->vkGetDeviceImageMemoryRequirementsKHR = (PFN_vkGetDeviceImageMemoryRequirementsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceImageMemoryRequirementsKHR");
		    pAPI->vkGetDeviceImageSparseMemoryRequirementsKHR = (PFN_vkGetDeviceImageSparseMemoryRequirementsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceImageSparseMemoryRequirementsKHR");
		    pAPI->vkGetDescriptorSetLayoutHostMappingInfoVALVE = (PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)pAPI->vkGetInstanceProcAddr(instance, "vkGetDescriptorSetLayoutHostMappingInfoVALVE");
		    pAPI->vkGetDescriptorSetHostMappingVALVE = (PFN_vkGetDescriptorSetHostMappingVALVE)pAPI->vkGetInstanceProcAddr(instance, "vkGetDescriptorSetHostMappingVALVE");
		    pAPI->vkCmdCopyMemoryIndirectNV = (PFN_vkCmdCopyMemoryIndirectNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyMemoryIndirectNV");
		    pAPI->vkCmdCopyMemoryToImageIndirectNV = (PFN_vkCmdCopyMemoryToImageIndirectNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdCopyMemoryToImageIndirectNV");
		    pAPI->vkCmdDecompressMemoryNV = (PFN_vkCmdDecompressMemoryNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDecompressMemoryNV");
		    pAPI->vkCmdDecompressMemoryIndirectCountNV = (PFN_vkCmdDecompressMemoryIndirectCountNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDecompressMemoryIndirectCountNV");
		    pAPI->vkGetPipelineIndirectMemoryRequirementsNV = (PFN_vkGetPipelineIndirectMemoryRequirementsNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPipelineIndirectMemoryRequirementsNV");
		    pAPI->vkCmdUpdatePipelineIndirectBufferNV = (PFN_vkCmdUpdatePipelineIndirectBufferNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdUpdatePipelineIndirectBufferNV");
		    pAPI->vkGetPipelineIndirectDeviceAddressNV = (PFN_vkGetPipelineIndirectDeviceAddressNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPipelineIndirectDeviceAddressNV");
		    pAPI->vkCmdSetDepthClampEnableEXT = (PFN_vkCmdSetDepthClampEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthClampEnableEXT");
		    pAPI->vkCmdSetPolygonModeEXT = (PFN_vkCmdSetPolygonModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetPolygonModeEXT");
		    pAPI->vkCmdSetRasterizationSamplesEXT = (PFN_vkCmdSetRasterizationSamplesEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRasterizationSamplesEXT");
		    pAPI->vkCmdSetSampleMaskEXT = (PFN_vkCmdSetSampleMaskEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetSampleMaskEXT");
		    pAPI->vkCmdSetAlphaToCoverageEnableEXT = (PFN_vkCmdSetAlphaToCoverageEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetAlphaToCoverageEnableEXT");
		    pAPI->vkCmdSetAlphaToOneEnableEXT = (PFN_vkCmdSetAlphaToOneEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetAlphaToOneEnableEXT");
		    pAPI->vkCmdSetLogicOpEnableEXT = (PFN_vkCmdSetLogicOpEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetLogicOpEnableEXT");
		    pAPI->vkCmdSetColorBlendEnableEXT = (PFN_vkCmdSetColorBlendEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetColorBlendEnableEXT");
		    pAPI->vkCmdSetColorBlendEquationEXT = (PFN_vkCmdSetColorBlendEquationEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetColorBlendEquationEXT");
		    pAPI->vkCmdSetColorWriteMaskEXT = (PFN_vkCmdSetColorWriteMaskEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetColorWriteMaskEXT");
		    pAPI->vkCmdSetTessellationDomainOriginEXT = (PFN_vkCmdSetTessellationDomainOriginEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetTessellationDomainOriginEXT");
		    pAPI->vkCmdSetRasterizationStreamEXT = (PFN_vkCmdSetRasterizationStreamEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRasterizationStreamEXT");
		    pAPI->vkCmdSetConservativeRasterizationModeEXT = (PFN_vkCmdSetConservativeRasterizationModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetConservativeRasterizationModeEXT");
		    pAPI->vkCmdSetExtraPrimitiveOverestimationSizeEXT = (PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetExtraPrimitiveOverestimationSizeEXT");
		    pAPI->vkCmdSetDepthClipEnableEXT = (PFN_vkCmdSetDepthClipEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthClipEnableEXT");
		    pAPI->vkCmdSetSampleLocationsEnableEXT = (PFN_vkCmdSetSampleLocationsEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetSampleLocationsEnableEXT");
		    pAPI->vkCmdSetColorBlendAdvancedEXT = (PFN_vkCmdSetColorBlendAdvancedEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetColorBlendAdvancedEXT");
		    pAPI->vkCmdSetProvokingVertexModeEXT = (PFN_vkCmdSetProvokingVertexModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetProvokingVertexModeEXT");
		    pAPI->vkCmdSetLineRasterizationModeEXT = (PFN_vkCmdSetLineRasterizationModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetLineRasterizationModeEXT");
		    pAPI->vkCmdSetLineStippleEnableEXT = (PFN_vkCmdSetLineStippleEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetLineStippleEnableEXT");
		    pAPI->vkCmdSetDepthClipNegativeOneToOneEXT = (PFN_vkCmdSetDepthClipNegativeOneToOneEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDepthClipNegativeOneToOneEXT");
		    pAPI->vkCmdSetViewportWScalingEnableNV = (PFN_vkCmdSetViewportWScalingEnableNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetViewportWScalingEnableNV");
		    pAPI->vkCmdSetViewportSwizzleNV = (PFN_vkCmdSetViewportSwizzleNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetViewportSwizzleNV");
		    pAPI->vkCmdSetCoverageToColorEnableNV = (PFN_vkCmdSetCoverageToColorEnableNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCoverageToColorEnableNV");
		    pAPI->vkCmdSetCoverageToColorLocationNV = (PFN_vkCmdSetCoverageToColorLocationNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCoverageToColorLocationNV");
		    pAPI->vkCmdSetCoverageModulationModeNV = (PFN_vkCmdSetCoverageModulationModeNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCoverageModulationModeNV");
		    pAPI->vkCmdSetCoverageModulationTableEnableNV = (PFN_vkCmdSetCoverageModulationTableEnableNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCoverageModulationTableEnableNV");
		    pAPI->vkCmdSetCoverageModulationTableNV = (PFN_vkCmdSetCoverageModulationTableNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCoverageModulationTableNV");
		    pAPI->vkCmdSetShadingRateImageEnableNV = (PFN_vkCmdSetShadingRateImageEnableNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetShadingRateImageEnableNV");
		    pAPI->vkCmdSetRepresentativeFragmentTestEnableNV = (PFN_vkCmdSetRepresentativeFragmentTestEnableNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetRepresentativeFragmentTestEnableNV");
		    pAPI->vkCmdSetCoverageReductionModeNV = (PFN_vkCmdSetCoverageReductionModeNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetCoverageReductionModeNV");
		    pAPI->vkGetShaderModuleIdentifierEXT = (PFN_vkGetShaderModuleIdentifierEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetShaderModuleIdentifierEXT");
		    pAPI->vkGetShaderModuleCreateInfoIdentifierEXT = (PFN_vkGetShaderModuleCreateInfoIdentifierEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetShaderModuleCreateInfoIdentifierEXT");
		    pAPI->vkGetPhysicalDeviceOpticalFlowImageFormatsNV = (PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
		    pAPI->vkCreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)pAPI->vkGetInstanceProcAddr(instance, "vkCreateOpticalFlowSessionNV");
		    pAPI->vkDestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyOpticalFlowSessionNV");
		    pAPI->vkBindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)pAPI->vkGetInstanceProcAddr(instance, "vkBindOpticalFlowSessionImageNV");
		    pAPI->vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)pAPI->vkGetInstanceProcAddr(instance, "vkCmdOpticalFlowExecuteNV");
		    pAPI->vkCmdBindIndexBuffer2KHR = (PFN_vkCmdBindIndexBuffer2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindIndexBuffer2KHR");
		    pAPI->vkGetRenderingAreaGranularityKHR = (PFN_vkGetRenderingAreaGranularityKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetRenderingAreaGranularityKHR");
		    pAPI->vkGetDeviceImageSubresourceLayoutKHR = (PFN_vkGetDeviceImageSubresourceLayoutKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceImageSubresourceLayoutKHR");
		    pAPI->vkGetImageSubresourceLayout2KHR = (PFN_vkGetImageSubresourceLayout2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetImageSubresourceLayout2KHR");
		    pAPI->vkCreateShadersEXT = (PFN_vkCreateShadersEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateShadersEXT");
		    pAPI->vkDestroyShaderEXT = (PFN_vkDestroyShaderEXT)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyShaderEXT");
		    pAPI->vkGetShaderBinaryDataEXT = (PFN_vkGetShaderBinaryDataEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetShaderBinaryDataEXT");
		    pAPI->vkCmdBindShadersEXT = (PFN_vkCmdBindShadersEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindShadersEXT");
		    pAPI->vkGetFramebufferTilePropertiesQCOM = (PFN_vkGetFramebufferTilePropertiesQCOM)pAPI->vkGetInstanceProcAddr(instance, "vkGetFramebufferTilePropertiesQCOM");
		    pAPI->vkGetDynamicRenderingTilePropertiesQCOM = (PFN_vkGetDynamicRenderingTilePropertiesQCOM)pAPI->vkGetInstanceProcAddr(instance, "vkGetDynamicRenderingTilePropertiesQCOM");
		    pAPI->vkSetLatencySleepModeNV = (PFN_vkSetLatencySleepModeNV)pAPI->vkGetInstanceProcAddr(instance, "vkSetLatencySleepModeNV");
		    pAPI->vkLatencySleepNV = (PFN_vkLatencySleepNV)pAPI->vkGetInstanceProcAddr(instance, "vkLatencySleepNV");
		    pAPI->vkSetLatencyMarkerNV = (PFN_vkSetLatencyMarkerNV)pAPI->vkGetInstanceProcAddr(instance, "vkSetLatencyMarkerNV");
		    pAPI->vkGetLatencyTimingsNV = (PFN_vkGetLatencyTimingsNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetLatencyTimingsNV");
		    pAPI->vkQueueNotifyOutOfBandNV = (PFN_vkQueueNotifyOutOfBandNV)pAPI->vkGetInstanceProcAddr(instance, "vkQueueNotifyOutOfBandNV");
		    pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
		    pAPI->vkCmdSetAttachmentFeedbackLoopEnableEXT = (PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetAttachmentFeedbackLoopEnableEXT");
		    pAPI->vkCmdSetLineStippleKHR = (PFN_vkCmdSetLineStippleKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetLineStippleKHR");
		    pAPI->vkCmdSetLineStippleEXT = (PFN_vkCmdSetLineStippleEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetLineStippleEXT");
		    pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR");
		    pAPI->vkGetCalibratedTimestampsKHR = (PFN_vkGetCalibratedTimestampsKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetCalibratedTimestampsKHR");
		    pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
		    pAPI->vkGetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetCalibratedTimestampsEXT");
		    pAPI->vkCmdBindDescriptorSets2KHR = (PFN_vkCmdBindDescriptorSets2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindDescriptorSets2KHR");
		    pAPI->vkCmdPushConstants2KHR = (PFN_vkCmdPushConstants2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPushConstants2KHR");
		    pAPI->vkCmdPushDescriptorSet2KHR = (PFN_vkCmdPushDescriptorSet2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPushDescriptorSet2KHR");
		    pAPI->vkCmdPushDescriptorSetWithTemplate2KHR = (PFN_vkCmdPushDescriptorSetWithTemplate2KHR)pAPI->vkGetInstanceProcAddr(instance, "vkCmdPushDescriptorSetWithTemplate2KHR");
		    pAPI->vkCmdSetDescriptorBufferOffsets2EXT = (PFN_vkCmdSetDescriptorBufferOffsets2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdSetDescriptorBufferOffsets2EXT");
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT");
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		    pAPI->vkCreateXlibSurfaceKHR = (PFN_vkCreateXlibSurfaceKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateXlibSurfaceKHR");
		    pAPI->vkGetPhysicalDeviceXlibPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceXlibPresentationSupportKHR");
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		    pAPI->vkAcquireXlibDisplayEXT = (PFN_vkAcquireXlibDisplayEXT)pAPI->vkGetInstanceProcAddr(instance, "vkAcquireXlibDisplayEXT");
		    pAPI->vkGetRandROutputDisplayEXT = (PFN_vkGetRandROutputDisplayEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetRandROutputDisplayEXT");
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		    pAPI->vkCreateXcbSurfaceKHR = (PFN_vkCreateXcbSurfaceKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateXcbSurfaceKHR");
		    pAPI->vkGetPhysicalDeviceXcbPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceXcbPresentationSupportKHR");
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		    pAPI->vkCreateWaylandSurfaceKHR = (PFN_vkCreateWaylandSurfaceKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateWaylandSurfaceKHR");
		    pAPI->vkGetPhysicalDeviceWaylandPresentationSupportKHR = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceWaylandPresentationSupportKHR");
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		    pAPI->vkCreateDirectFBSurfaceEXT = (PFN_vkCreateDirectFBSurfaceEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateDirectFBSurfaceEXT");
		    pAPI->vkGetPhysicalDeviceDirectFBPresentationSupportEXT = (PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT");
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		    pAPI->vkCreateAndroidSurfaceKHR = (PFN_vkCreateAndroidSurfaceKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateAndroidSurfaceKHR");
		    pAPI->vkGetAndroidHardwareBufferPropertiesANDROID = (PFN_vkGetAndroidHardwareBufferPropertiesANDROID)pAPI->vkGetInstanceProcAddr(instance, "vkGetAndroidHardwareBufferPropertiesANDROID");
		    pAPI->vkGetMemoryAndroidHardwareBufferANDROID = (PFN_vkGetMemoryAndroidHardwareBufferANDROID)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryAndroidHardwareBufferANDROID");
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		    pAPI->vkCreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR)pAPI->vkGetInstanceProcAddr(instance, "vkCreateWin32SurfaceKHR");
		    pAPI->vkGetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
		    pAPI->vkGetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandleKHR");
		    pAPI->vkGetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandlePropertiesKHR");
		    pAPI->vkGetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryWin32HandleNV");
		    pAPI->vkImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR)pAPI->vkGetInstanceProcAddr(instance, "vkImportSemaphoreWin32HandleKHR");
		    pAPI->vkGetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetSemaphoreWin32HandleKHR");
		    pAPI->vkImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR)pAPI->vkGetInstanceProcAddr(instance, "vkImportFenceWin32HandleKHR");
		    pAPI->vkGetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR)pAPI->vkGetInstanceProcAddr(instance, "vkGetFenceWin32HandleKHR");
		    pAPI->vkGetPhysicalDeviceSurfacePresentModes2EXT = (PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
		    pAPI->vkAcquireFullScreenExclusiveModeEXT = (PFN_vkAcquireFullScreenExclusiveModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkAcquireFullScreenExclusiveModeEXT");
		    pAPI->vkReleaseFullScreenExclusiveModeEXT = (PFN_vkReleaseFullScreenExclusiveModeEXT)pAPI->vkGetInstanceProcAddr(instance, "vkReleaseFullScreenExclusiveModeEXT");
		    pAPI->vkGetDeviceGroupSurfacePresentModes2EXT = (PFN_vkGetDeviceGroupSurfacePresentModes2EXT)pAPI->vkGetInstanceProcAddr(instance, "vkGetDeviceGroupSurfacePresentModes2EXT");
		    pAPI->vkAcquireWinrtDisplayNV = (PFN_vkAcquireWinrtDisplayNV)pAPI->vkGetInstanceProcAddr(instance, "vkAcquireWinrtDisplayNV");
		    pAPI->vkGetWinrtDisplayNV = (PFN_vkGetWinrtDisplayNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetWinrtDisplayNV");
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		    pAPI->vkCreateViSurfaceNN = (PFN_vkCreateViSurfaceNN)pAPI->vkGetInstanceProcAddr(instance, "vkCreateViSurfaceNN");
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		    pAPI->vkCreateIOSSurfaceMVK = (PFN_vkCreateIOSSurfaceMVK)pAPI->vkGetInstanceProcAddr(instance, "vkCreateIOSSurfaceMVK");
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		    pAPI->vkCreateMacOSSurfaceMVK = (PFN_vkCreateMacOSSurfaceMVK)pAPI->vkGetInstanceProcAddr(instance, "vkCreateMacOSSurfaceMVK");
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		    pAPI->vkCreateMetalSurfaceEXT = (PFN_vkCreateMetalSurfaceEXT)pAPI->vkGetInstanceProcAddr(instance, "vkCreateMetalSurfaceEXT");
		    pAPI->vkExportMetalObjectsEXT = (PFN_vkExportMetalObjectsEXT)pAPI->vkGetInstanceProcAddr(instance, "vkExportMetalObjectsEXT");
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		    pAPI->vkCreateImagePipeSurfaceFUCHSIA = (PFN_vkCreateImagePipeSurfaceFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkCreateImagePipeSurfaceFUCHSIA");
		    pAPI->vkGetMemoryZirconHandleFUCHSIA = (PFN_vkGetMemoryZirconHandleFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryZirconHandleFUCHSIA");
		    pAPI->vkGetMemoryZirconHandlePropertiesFUCHSIA = (PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemoryZirconHandlePropertiesFUCHSIA");
		    pAPI->vkImportSemaphoreZirconHandleFUCHSIA = (PFN_vkImportSemaphoreZirconHandleFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkImportSemaphoreZirconHandleFUCHSIA");
		    pAPI->vkGetSemaphoreZirconHandleFUCHSIA = (PFN_vkGetSemaphoreZirconHandleFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkGetSemaphoreZirconHandleFUCHSIA");
		    pAPI->vkCreateBufferCollectionFUCHSIA = (PFN_vkCreateBufferCollectionFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkCreateBufferCollectionFUCHSIA");
		    pAPI->vkSetBufferCollectionImageConstraintsFUCHSIA = (PFN_vkSetBufferCollectionImageConstraintsFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkSetBufferCollectionImageConstraintsFUCHSIA");
		    pAPI->vkSetBufferCollectionBufferConstraintsFUCHSIA = (PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkSetBufferCollectionBufferConstraintsFUCHSIA");
		    pAPI->vkDestroyBufferCollectionFUCHSIA = (PFN_vkDestroyBufferCollectionFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkDestroyBufferCollectionFUCHSIA");
		    pAPI->vkGetBufferCollectionPropertiesFUCHSIA = (PFN_vkGetBufferCollectionPropertiesFUCHSIA)pAPI->vkGetInstanceProcAddr(instance, "vkGetBufferCollectionPropertiesFUCHSIA");
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		    pAPI->vkCreateStreamDescriptorSurfaceGGP = (PFN_vkCreateStreamDescriptorSurfaceGGP)pAPI->vkGetInstanceProcAddr(instance, "vkCreateStreamDescriptorSurfaceGGP");
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		    pAPI->vkGetMemorySciBufNV = (PFN_vkGetMemorySciBufNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetMemorySciBufNV");
		    pAPI->vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = (PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV");
		    pAPI->vkGetPhysicalDeviceSciBufAttributesNV = (PFN_vkGetPhysicalDeviceSciBufAttributesNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSciBufAttributesNV");
		    pAPI->vkCreateSemaphoreSciSyncPoolNV = (PFN_vkCreateSemaphoreSciSyncPoolNV)pAPI->vkGetInstanceProcAddr(instance, "vkCreateSemaphoreSciSyncPoolNV");
		    pAPI->vkDestroySemaphoreSciSyncPoolNV = (PFN_vkDestroySemaphoreSciSyncPoolNV)pAPI->vkGetInstanceProcAddr(instance, "vkDestroySemaphoreSciSyncPoolNV");
		    pAPI->vkGetFenceSciSyncFenceNV = (PFN_vkGetFenceSciSyncFenceNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetFenceSciSyncFenceNV");
		    pAPI->vkGetFenceSciSyncObjNV = (PFN_vkGetFenceSciSyncObjNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetFenceSciSyncObjNV");
		    pAPI->vkImportFenceSciSyncFenceNV = (PFN_vkImportFenceSciSyncFenceNV)pAPI->vkGetInstanceProcAddr(instance, "vkImportFenceSciSyncFenceNV");
		    pAPI->vkImportFenceSciSyncObjNV = (PFN_vkImportFenceSciSyncObjNV)pAPI->vkGetInstanceProcAddr(instance, "vkImportFenceSciSyncObjNV");
		    pAPI->vkGetPhysicalDeviceSciSyncAttributesNV = (PFN_vkGetPhysicalDeviceSciSyncAttributesNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSciSyncAttributesNV");
		    pAPI->vkGetSemaphoreSciSyncObjNV = (PFN_vkGetSemaphoreSciSyncObjNV)pAPI->vkGetInstanceProcAddr(instance, "vkGetSemaphoreSciSyncObjNV");
		    pAPI->vkImportSemaphoreSciSyncObjNV = (PFN_vkImportSemaphoreSciSyncObjNV)pAPI->vkGetInstanceProcAddr(instance, "vkImportSemaphoreSciSyncObjNV");
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		    pAPI->vkCreateExecutionGraphPipelinesAMDX = (PFN_vkCreateExecutionGraphPipelinesAMDX)pAPI->vkGetInstanceProcAddr(instance, "vkCreateExecutionGraphPipelinesAMDX");
		    pAPI->vkGetExecutionGraphPipelineScratchSizeAMDX = (PFN_vkGetExecutionGraphPipelineScratchSizeAMDX)pAPI->vkGetInstanceProcAddr(instance, "vkGetExecutionGraphPipelineScratchSizeAMDX");
		    pAPI->vkGetExecutionGraphPipelineNodeIndexAMDX = (PFN_vkGetExecutionGraphPipelineNodeIndexAMDX)pAPI->vkGetInstanceProcAddr(instance, "vkGetExecutionGraphPipelineNodeIndexAMDX");
		    pAPI->vkCmdInitializeGraphScratchMemoryAMDX = (PFN_vkCmdInitializeGraphScratchMemoryAMDX)pAPI->vkGetInstanceProcAddr(instance, "vkCmdInitializeGraphScratchMemoryAMDX");
		    pAPI->vkCmdDispatchGraphAMDX = (PFN_vkCmdDispatchGraphAMDX)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDispatchGraphAMDX");
		    pAPI->vkCmdDispatchGraphIndirectAMDX = (PFN_vkCmdDispatchGraphIndirectAMDX)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDispatchGraphIndirectAMDX");
		    pAPI->vkCmdDispatchGraphIndirectCountAMDX = (PFN_vkCmdDispatchGraphIndirectCountAMDX)pAPI->vkGetInstanceProcAddr(instance, "vkCmdDispatchGraphIndirectCountAMDX");
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		    pAPI->vkCreateScreenSurfaceQNX = (PFN_vkCreateScreenSurfaceQNX)pAPI->vkGetInstanceProcAddr(instance, "vkCreateScreenSurfaceQNX");
		    pAPI->vkGetPhysicalDeviceScreenPresentationSupportQNX = (PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX)pAPI->vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceScreenPresentationSupportQNX");
		    pAPI->vkGetScreenBufferPropertiesQNX = (PFN_vkGetScreenBufferPropertiesQNX)pAPI->vkGetInstanceProcAddr(instance, "vkGetScreenBufferPropertiesQNX");
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/

		    return VK_SUCCESS;
		}

		VkResult vkbInitDeviceAPI(VkDevice device, VkbAPI* pAPI)
		{
		    if (g_vkbInitCount == 0) {
				return VK_ERROR_INITIALIZATION_FAILED;  /* vkbind not initialized. */
		    }

		    if (pAPI == NULL) {
				return VK_ERROR_INITIALIZATION_FAILED;
		    }

		    /* We need to handle vkGetDeviceProcAddr() in a special way to ensure it's using the device-specific version instead of the per-instance version. */
		    if (pAPI->vkGetDeviceProcAddr == NULL) {
				#if !defined(VKBIND_NO_GLOBAL_API)
				{
				    pAPI->vkGetDeviceProcAddr = vkGetDeviceProcAddr;
				}
				#endif
		    }

		    if (pAPI->vkGetDeviceProcAddr == NULL) {
				return VK_ERROR_INITIALIZATION_FAILED;  /* Don't have access to vkGetDeviceProcAddr(). Make sure vkbInitInstanceAPI() is called first on pAPI. */
		    }

		    pAPI->vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceProcAddr");
		    pAPI->vkDestroyDevice = (PFN_vkDestroyDevice)pAPI->vkGetDeviceProcAddr(device, "vkDestroyDevice");
		    pAPI->vkGetDeviceQueue = (PFN_vkGetDeviceQueue)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceQueue");
		    pAPI->vkQueueSubmit = (PFN_vkQueueSubmit)pAPI->vkGetDeviceProcAddr(device, "vkQueueSubmit");
		    pAPI->vkQueueWaitIdle = (PFN_vkQueueWaitIdle)pAPI->vkGetDeviceProcAddr(device, "vkQueueWaitIdle");
		    pAPI->vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle)pAPI->vkGetDeviceProcAddr(device, "vkDeviceWaitIdle");
		    pAPI->vkAllocateMemory = (PFN_vkAllocateMemory)pAPI->vkGetDeviceProcAddr(device, "vkAllocateMemory");
		    pAPI->vkFreeMemory = (PFN_vkFreeMemory)pAPI->vkGetDeviceProcAddr(device, "vkFreeMemory");
		    pAPI->vkMapMemory = (PFN_vkMapMemory)pAPI->vkGetDeviceProcAddr(device, "vkMapMemory");
		    pAPI->vkUnmapMemory = (PFN_vkUnmapMemory)pAPI->vkGetDeviceProcAddr(device, "vkUnmapMemory");
		    pAPI->vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)pAPI->vkGetDeviceProcAddr(device, "vkFlushMappedMemoryRanges");
		    pAPI->vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)pAPI->vkGetDeviceProcAddr(device, "vkInvalidateMappedMemoryRanges");
		    pAPI->vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceMemoryCommitment");
		    pAPI->vkBindBufferMemory = (PFN_vkBindBufferMemory)pAPI->vkGetDeviceProcAddr(device, "vkBindBufferMemory");
		    pAPI->vkBindImageMemory = (PFN_vkBindImageMemory)pAPI->vkGetDeviceProcAddr(device, "vkBindImageMemory");
		    pAPI->vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements");
		    pAPI->vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)pAPI->vkGetDeviceProcAddr(device, "vkGetImageMemoryRequirements");
		    pAPI->vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)pAPI->vkGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements");
		    pAPI->vkQueueBindSparse = (PFN_vkQueueBindSparse)pAPI->vkGetDeviceProcAddr(device, "vkQueueBindSparse");
		    pAPI->vkCreateFence = (PFN_vkCreateFence)pAPI->vkGetDeviceProcAddr(device, "vkCreateFence");
		    pAPI->vkDestroyFence = (PFN_vkDestroyFence)pAPI->vkGetDeviceProcAddr(device, "vkDestroyFence");
		    pAPI->vkResetFences = (PFN_vkResetFences)pAPI->vkGetDeviceProcAddr(device, "vkResetFences");
		    pAPI->vkGetFenceStatus = (PFN_vkGetFenceStatus)pAPI->vkGetDeviceProcAddr(device, "vkGetFenceStatus");
		    pAPI->vkWaitForFences = (PFN_vkWaitForFences)pAPI->vkGetDeviceProcAddr(device, "vkWaitForFences");
		    pAPI->vkCreateSemaphore = (PFN_vkCreateSemaphore)pAPI->vkGetDeviceProcAddr(device, "vkCreateSemaphore");
		    pAPI->vkDestroySemaphore = (PFN_vkDestroySemaphore)pAPI->vkGetDeviceProcAddr(device, "vkDestroySemaphore");
		    pAPI->vkCreateEvent = (PFN_vkCreateEvent)pAPI->vkGetDeviceProcAddr(device, "vkCreateEvent");
		    pAPI->vkDestroyEvent = (PFN_vkDestroyEvent)pAPI->vkGetDeviceProcAddr(device, "vkDestroyEvent");
		    pAPI->vkGetEventStatus = (PFN_vkGetEventStatus)pAPI->vkGetDeviceProcAddr(device, "vkGetEventStatus");
		    pAPI->vkSetEvent = (PFN_vkSetEvent)pAPI->vkGetDeviceProcAddr(device, "vkSetEvent");
		    pAPI->vkResetEvent = (PFN_vkResetEvent)pAPI->vkGetDeviceProcAddr(device, "vkResetEvent");
		    pAPI->vkCreateQueryPool = (PFN_vkCreateQueryPool)pAPI->vkGetDeviceProcAddr(device, "vkCreateQueryPool");
		    pAPI->vkDestroyQueryPool = (PFN_vkDestroyQueryPool)pAPI->vkGetDeviceProcAddr(device, "vkDestroyQueryPool");
		    pAPI->vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults)pAPI->vkGetDeviceProcAddr(device, "vkGetQueryPoolResults");
		    pAPI->vkCreateBuffer = (PFN_vkCreateBuffer)pAPI->vkGetDeviceProcAddr(device, "vkCreateBuffer");
		    pAPI->vkDestroyBuffer = (PFN_vkDestroyBuffer)pAPI->vkGetDeviceProcAddr(device, "vkDestroyBuffer");
		    pAPI->vkCreateBufferView = (PFN_vkCreateBufferView)pAPI->vkGetDeviceProcAddr(device, "vkCreateBufferView");
		    pAPI->vkDestroyBufferView = (PFN_vkDestroyBufferView)pAPI->vkGetDeviceProcAddr(device, "vkDestroyBufferView");
		    pAPI->vkCreateImage = (PFN_vkCreateImage)pAPI->vkGetDeviceProcAddr(device, "vkCreateImage");
		    pAPI->vkDestroyImage = (PFN_vkDestroyImage)pAPI->vkGetDeviceProcAddr(device, "vkDestroyImage");
		    pAPI->vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)pAPI->vkGetDeviceProcAddr(device, "vkGetImageSubresourceLayout");
		    pAPI->vkCreateImageView = (PFN_vkCreateImageView)pAPI->vkGetDeviceProcAddr(device, "vkCreateImageView");
		    pAPI->vkDestroyImageView = (PFN_vkDestroyImageView)pAPI->vkGetDeviceProcAddr(device, "vkDestroyImageView");
		    pAPI->vkCreateShaderModule = (PFN_vkCreateShaderModule)pAPI->vkGetDeviceProcAddr(device, "vkCreateShaderModule");
		    pAPI->vkDestroyShaderModule = (PFN_vkDestroyShaderModule)pAPI->vkGetDeviceProcAddr(device, "vkDestroyShaderModule");
		    pAPI->vkCreatePipelineCache = (PFN_vkCreatePipelineCache)pAPI->vkGetDeviceProcAddr(device, "vkCreatePipelineCache");
		    pAPI->vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache)pAPI->vkGetDeviceProcAddr(device, "vkDestroyPipelineCache");
		    pAPI->vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData)pAPI->vkGetDeviceProcAddr(device, "vkGetPipelineCacheData");
		    pAPI->vkMergePipelineCaches = (PFN_vkMergePipelineCaches)pAPI->vkGetDeviceProcAddr(device, "vkMergePipelineCaches");
		    pAPI->vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)pAPI->vkGetDeviceProcAddr(device, "vkCreateGraphicsPipelines");
		    pAPI->vkCreateComputePipelines = (PFN_vkCreateComputePipelines)pAPI->vkGetDeviceProcAddr(device, "vkCreateComputePipelines");
		    pAPI->vkDestroyPipeline = (PFN_vkDestroyPipeline)pAPI->vkGetDeviceProcAddr(device, "vkDestroyPipeline");
		    pAPI->vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout)pAPI->vkGetDeviceProcAddr(device, "vkCreatePipelineLayout");
		    pAPI->vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)pAPI->vkGetDeviceProcAddr(device, "vkDestroyPipelineLayout");
		    pAPI->vkCreateSampler = (PFN_vkCreateSampler)pAPI->vkGetDeviceProcAddr(device, "vkCreateSampler");
		    pAPI->vkDestroySampler = (PFN_vkDestroySampler)pAPI->vkGetDeviceProcAddr(device, "vkDestroySampler");
		    pAPI->vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)pAPI->vkGetDeviceProcAddr(device, "vkCreateDescriptorSetLayout");
		    pAPI->vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)pAPI->vkGetDeviceProcAddr(device, "vkDestroyDescriptorSetLayout");
		    pAPI->vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool)pAPI->vkGetDeviceProcAddr(device, "vkCreateDescriptorPool");
		    pAPI->vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)pAPI->vkGetDeviceProcAddr(device, "vkDestroyDescriptorPool");
		    pAPI->vkResetDescriptorPool = (PFN_vkResetDescriptorPool)pAPI->vkGetDeviceProcAddr(device, "vkResetDescriptorPool");
		    pAPI->vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)pAPI->vkGetDeviceProcAddr(device, "vkAllocateDescriptorSets");
		    pAPI->vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets)pAPI->vkGetDeviceProcAddr(device, "vkFreeDescriptorSets");
		    pAPI->vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)pAPI->vkGetDeviceProcAddr(device, "vkUpdateDescriptorSets");
		    pAPI->vkCreateFramebuffer = (PFN_vkCreateFramebuffer)pAPI->vkGetDeviceProcAddr(device, "vkCreateFramebuffer");
		    pAPI->vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer)pAPI->vkGetDeviceProcAddr(device, "vkDestroyFramebuffer");
		    pAPI->vkCreateRenderPass = (PFN_vkCreateRenderPass)pAPI->vkGetDeviceProcAddr(device, "vkCreateRenderPass");
		    pAPI->vkDestroyRenderPass = (PFN_vkDestroyRenderPass)pAPI->vkGetDeviceProcAddr(device, "vkDestroyRenderPass");
		    pAPI->vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)pAPI->vkGetDeviceProcAddr(device, "vkGetRenderAreaGranularity");
		    pAPI->vkCreateCommandPool = (PFN_vkCreateCommandPool)pAPI->vkGetDeviceProcAddr(device, "vkCreateCommandPool");
		    pAPI->vkDestroyCommandPool = (PFN_vkDestroyCommandPool)pAPI->vkGetDeviceProcAddr(device, "vkDestroyCommandPool");
		    pAPI->vkResetCommandPool = (PFN_vkResetCommandPool)pAPI->vkGetDeviceProcAddr(device, "vkResetCommandPool");
		    pAPI->vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)pAPI->vkGetDeviceProcAddr(device, "vkAllocateCommandBuffers");
		    pAPI->vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers)pAPI->vkGetDeviceProcAddr(device, "vkFreeCommandBuffers");
		    pAPI->vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)pAPI->vkGetDeviceProcAddr(device, "vkBeginCommandBuffer");
		    pAPI->vkEndCommandBuffer = (PFN_vkEndCommandBuffer)pAPI->vkGetDeviceProcAddr(device, "vkEndCommandBuffer");
		    pAPI->vkResetCommandBuffer = (PFN_vkResetCommandBuffer)pAPI->vkGetDeviceProcAddr(device, "vkResetCommandBuffer");
		    pAPI->vkCmdBindPipeline = (PFN_vkCmdBindPipeline)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindPipeline");
		    pAPI->vkCmdSetViewport = (PFN_vkCmdSetViewport)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetViewport");
		    pAPI->vkCmdSetScissor = (PFN_vkCmdSetScissor)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetScissor");
		    pAPI->vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetLineWidth");
		    pAPI->vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthBias");
		    pAPI->vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetBlendConstants");
		    pAPI->vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthBounds");
		    pAPI->vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetStencilCompareMask");
		    pAPI->vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetStencilWriteMask");
		    pAPI->vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetStencilReference");
		    pAPI->vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindDescriptorSets");
		    pAPI->vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindIndexBuffer");
		    pAPI->vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindVertexBuffers");
		    pAPI->vkCmdDraw = (PFN_vkCmdDraw)pAPI->vkGetDeviceProcAddr(device, "vkCmdDraw");
		    pAPI->vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndexed");
		    pAPI->vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndirect");
		    pAPI->vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirect");
		    pAPI->vkCmdDispatch = (PFN_vkCmdDispatch)pAPI->vkGetDeviceProcAddr(device, "vkCmdDispatch");
		    pAPI->vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)pAPI->vkGetDeviceProcAddr(device, "vkCmdDispatchIndirect");
		    pAPI->vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyBuffer");
		    pAPI->vkCmdCopyImage = (PFN_vkCmdCopyImage)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyImage");
		    pAPI->vkCmdBlitImage = (PFN_vkCmdBlitImage)pAPI->vkGetDeviceProcAddr(device, "vkCmdBlitImage");
		    pAPI->vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyBufferToImage");
		    pAPI->vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer");
		    pAPI->vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)pAPI->vkGetDeviceProcAddr(device, "vkCmdUpdateBuffer");
		    pAPI->vkCmdFillBuffer = (PFN_vkCmdFillBuffer)pAPI->vkGetDeviceProcAddr(device, "vkCmdFillBuffer");
		    pAPI->vkCmdClearColorImage = (PFN_vkCmdClearColorImage)pAPI->vkGetDeviceProcAddr(device, "vkCmdClearColorImage");
		    pAPI->vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)pAPI->vkGetDeviceProcAddr(device, "vkCmdClearDepthStencilImage");
		    pAPI->vkCmdClearAttachments = (PFN_vkCmdClearAttachments)pAPI->vkGetDeviceProcAddr(device, "vkCmdClearAttachments");
		    pAPI->vkCmdResolveImage = (PFN_vkCmdResolveImage)pAPI->vkGetDeviceProcAddr(device, "vkCmdResolveImage");
		    pAPI->vkCmdSetEvent = (PFN_vkCmdSetEvent)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetEvent");
		    pAPI->vkCmdResetEvent = (PFN_vkCmdResetEvent)pAPI->vkGetDeviceProcAddr(device, "vkCmdResetEvent");
		    pAPI->vkCmdWaitEvents = (PFN_vkCmdWaitEvents)pAPI->vkGetDeviceProcAddr(device, "vkCmdWaitEvents");
		    pAPI->vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)pAPI->vkGetDeviceProcAddr(device, "vkCmdPipelineBarrier");
		    pAPI->vkCmdBeginQuery = (PFN_vkCmdBeginQuery)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginQuery");
		    pAPI->vkCmdEndQuery = (PFN_vkCmdEndQuery)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndQuery");
		    pAPI->vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool)pAPI->vkGetDeviceProcAddr(device, "vkCmdResetQueryPool");
		    pAPI->vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteTimestamp");
		    pAPI->vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyQueryPoolResults");
		    pAPI->vkCmdPushConstants = (PFN_vkCmdPushConstants)pAPI->vkGetDeviceProcAddr(device, "vkCmdPushConstants");
		    pAPI->vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginRenderPass");
		    pAPI->vkCmdNextSubpass = (PFN_vkCmdNextSubpass)pAPI->vkGetDeviceProcAddr(device, "vkCmdNextSubpass");
		    pAPI->vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndRenderPass");
		    pAPI->vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands)pAPI->vkGetDeviceProcAddr(device, "vkCmdExecuteCommands");
		    pAPI->vkBindBufferMemory2 = (PFN_vkBindBufferMemory2)pAPI->vkGetDeviceProcAddr(device, "vkBindBufferMemory2");
		    pAPI->vkBindImageMemory2 = (PFN_vkBindImageMemory2)pAPI->vkGetDeviceProcAddr(device, "vkBindImageMemory2");
		    pAPI->vkGetDeviceGroupPeerMemoryFeatures = (PFN_vkGetDeviceGroupPeerMemoryFeatures)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeatures");
		    pAPI->vkCmdSetDeviceMask = (PFN_vkCmdSetDeviceMask)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDeviceMask");
		    pAPI->vkCmdDispatchBase = (PFN_vkCmdDispatchBase)pAPI->vkGetDeviceProcAddr(device, "vkCmdDispatchBase");
		    pAPI->vkGetImageMemoryRequirements2 = (PFN_vkGetImageMemoryRequirements2)pAPI->vkGetDeviceProcAddr(device, "vkGetImageMemoryRequirements2");
		    pAPI->vkGetBufferMemoryRequirements2 = (PFN_vkGetBufferMemoryRequirements2)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2");
		    pAPI->vkGetImageSparseMemoryRequirements2 = (PFN_vkGetImageSparseMemoryRequirements2)pAPI->vkGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2");
		    pAPI->vkTrimCommandPool = (PFN_vkTrimCommandPool)pAPI->vkGetDeviceProcAddr(device, "vkTrimCommandPool");
		    pAPI->vkGetDeviceQueue2 = (PFN_vkGetDeviceQueue2)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceQueue2");
		    pAPI->vkCreateSamplerYcbcrConversion = (PFN_vkCreateSamplerYcbcrConversion)pAPI->vkGetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversion");
		    pAPI->vkDestroySamplerYcbcrConversion = (PFN_vkDestroySamplerYcbcrConversion)pAPI->vkGetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversion");
		    pAPI->vkCreateDescriptorUpdateTemplate = (PFN_vkCreateDescriptorUpdateTemplate)pAPI->vkGetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplate");
		    pAPI->vkDestroyDescriptorUpdateTemplate = (PFN_vkDestroyDescriptorUpdateTemplate)pAPI->vkGetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplate");
		    pAPI->vkUpdateDescriptorSetWithTemplate = (PFN_vkUpdateDescriptorSetWithTemplate)pAPI->vkGetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplate");
		    pAPI->vkGetDescriptorSetLayoutSupport = (PFN_vkGetDescriptorSetLayoutSupport)pAPI->vkGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupport");
		    pAPI->vkCmdDrawIndirectCount = (PFN_vkCmdDrawIndirectCount)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndirectCount");
		    pAPI->vkCmdDrawIndexedIndirectCount = (PFN_vkCmdDrawIndexedIndirectCount)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCount");
		    pAPI->vkCreateRenderPass2 = (PFN_vkCreateRenderPass2)pAPI->vkGetDeviceProcAddr(device, "vkCreateRenderPass2");
		    pAPI->vkCmdBeginRenderPass2 = (PFN_vkCmdBeginRenderPass2)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginRenderPass2");
		    pAPI->vkCmdNextSubpass2 = (PFN_vkCmdNextSubpass2)pAPI->vkGetDeviceProcAddr(device, "vkCmdNextSubpass2");
		    pAPI->vkCmdEndRenderPass2 = (PFN_vkCmdEndRenderPass2)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndRenderPass2");
		    pAPI->vkResetQueryPool = (PFN_vkResetQueryPool)pAPI->vkGetDeviceProcAddr(device, "vkResetQueryPool");
		    pAPI->vkGetSemaphoreCounterValue = (PFN_vkGetSemaphoreCounterValue)pAPI->vkGetDeviceProcAddr(device, "vkGetSemaphoreCounterValue");
		    pAPI->vkWaitSemaphores = (PFN_vkWaitSemaphores)pAPI->vkGetDeviceProcAddr(device, "vkWaitSemaphores");
		    pAPI->vkSignalSemaphore = (PFN_vkSignalSemaphore)pAPI->vkGetDeviceProcAddr(device, "vkSignalSemaphore");
		    pAPI->vkGetBufferDeviceAddress = (PFN_vkGetBufferDeviceAddress)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferDeviceAddress");
		    pAPI->vkGetBufferOpaqueCaptureAddress = (PFN_vkGetBufferOpaqueCaptureAddress)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddress");
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddress = (PFN_vkGetDeviceMemoryOpaqueCaptureAddress)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddress");
		    pAPI->vkCreatePrivateDataSlot = (PFN_vkCreatePrivateDataSlot)pAPI->vkGetDeviceProcAddr(device, "vkCreatePrivateDataSlot");
		    pAPI->vkDestroyPrivateDataSlot = (PFN_vkDestroyPrivateDataSlot)pAPI->vkGetDeviceProcAddr(device, "vkDestroyPrivateDataSlot");
		    pAPI->vkSetPrivateData = (PFN_vkSetPrivateData)pAPI->vkGetDeviceProcAddr(device, "vkSetPrivateData");
		    pAPI->vkGetPrivateData = (PFN_vkGetPrivateData)pAPI->vkGetDeviceProcAddr(device, "vkGetPrivateData");
		    pAPI->vkCmdSetEvent2 = (PFN_vkCmdSetEvent2)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetEvent2");
		    pAPI->vkCmdResetEvent2 = (PFN_vkCmdResetEvent2)pAPI->vkGetDeviceProcAddr(device, "vkCmdResetEvent2");
		    pAPI->vkCmdWaitEvents2 = (PFN_vkCmdWaitEvents2)pAPI->vkGetDeviceProcAddr(device, "vkCmdWaitEvents2");
		    pAPI->vkCmdPipelineBarrier2 = (PFN_vkCmdPipelineBarrier2)pAPI->vkGetDeviceProcAddr(device, "vkCmdPipelineBarrier2");
		    pAPI->vkCmdWriteTimestamp2 = (PFN_vkCmdWriteTimestamp2)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteTimestamp2");
		    pAPI->vkQueueSubmit2 = (PFN_vkQueueSubmit2)pAPI->vkGetDeviceProcAddr(device, "vkQueueSubmit2");
		    pAPI->vkCmdCopyBuffer2 = (PFN_vkCmdCopyBuffer2)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyBuffer2");
		    pAPI->vkCmdCopyImage2 = (PFN_vkCmdCopyImage2)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyImage2");
		    pAPI->vkCmdCopyBufferToImage2 = (PFN_vkCmdCopyBufferToImage2)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyBufferToImage2");
		    pAPI->vkCmdCopyImageToBuffer2 = (PFN_vkCmdCopyImageToBuffer2)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2");
		    pAPI->vkCmdBlitImage2 = (PFN_vkCmdBlitImage2)pAPI->vkGetDeviceProcAddr(device, "vkCmdBlitImage2");
		    pAPI->vkCmdResolveImage2 = (PFN_vkCmdResolveImage2)pAPI->vkGetDeviceProcAddr(device, "vkCmdResolveImage2");
		    pAPI->vkCmdBeginRendering = (PFN_vkCmdBeginRendering)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginRendering");
		    pAPI->vkCmdEndRendering = (PFN_vkCmdEndRendering)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndRendering");
		    pAPI->vkCmdSetCullMode = (PFN_vkCmdSetCullMode)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCullMode");
		    pAPI->vkCmdSetFrontFace = (PFN_vkCmdSetFrontFace)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetFrontFace");
		    pAPI->vkCmdSetPrimitiveTopology = (PFN_vkCmdSetPrimitiveTopology)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPrimitiveTopology");
		    pAPI->vkCmdSetViewportWithCount = (PFN_vkCmdSetViewportWithCount)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetViewportWithCount");
		    pAPI->vkCmdSetScissorWithCount = (PFN_vkCmdSetScissorWithCount)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetScissorWithCount");
		    pAPI->vkCmdBindVertexBuffers2 = (PFN_vkCmdBindVertexBuffers2)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindVertexBuffers2");
		    pAPI->vkCmdSetDepthTestEnable = (PFN_vkCmdSetDepthTestEnable)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthTestEnable");
		    pAPI->vkCmdSetDepthWriteEnable = (PFN_vkCmdSetDepthWriteEnable)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthWriteEnable");
		    pAPI->vkCmdSetDepthCompareOp = (PFN_vkCmdSetDepthCompareOp)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthCompareOp");
		    pAPI->vkCmdSetDepthBoundsTestEnable = (PFN_vkCmdSetDepthBoundsTestEnable)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnable");
		    pAPI->vkCmdSetStencilTestEnable = (PFN_vkCmdSetStencilTestEnable)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetStencilTestEnable");
		    pAPI->vkCmdSetStencilOp = (PFN_vkCmdSetStencilOp)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetStencilOp");
		    pAPI->vkCmdSetRasterizerDiscardEnable = (PFN_vkCmdSetRasterizerDiscardEnable)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnable");
		    pAPI->vkCmdSetDepthBiasEnable = (PFN_vkCmdSetDepthBiasEnable)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthBiasEnable");
		    pAPI->vkCmdSetPrimitiveRestartEnable = (PFN_vkCmdSetPrimitiveRestartEnable)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnable");
		    pAPI->vkGetDeviceBufferMemoryRequirements = (PFN_vkGetDeviceBufferMemoryRequirements)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirements");
		    pAPI->vkGetDeviceImageMemoryRequirements = (PFN_vkGetDeviceImageMemoryRequirements)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirements");
		    pAPI->vkGetDeviceImageSparseMemoryRequirements = (PFN_vkGetDeviceImageSparseMemoryRequirements)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirements");
		    pAPI->vkGetCommandPoolMemoryConsumption = (PFN_vkGetCommandPoolMemoryConsumption)pAPI->vkGetDeviceProcAddr(device, "vkGetCommandPoolMemoryConsumption");
		    pAPI->vkGetFaultData = (PFN_vkGetFaultData)pAPI->vkGetDeviceProcAddr(device, "vkGetFaultData");
		    pAPI->vkCreateSwapchainKHR = (PFN_vkCreateSwapchainKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateSwapchainKHR");
		    pAPI->vkDestroySwapchainKHR = (PFN_vkDestroySwapchainKHR)pAPI->vkGetDeviceProcAddr(device, "vkDestroySwapchainKHR");
		    pAPI->vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetSwapchainImagesKHR");
		    pAPI->vkAcquireNextImageKHR = (PFN_vkAcquireNextImageKHR)pAPI->vkGetDeviceProcAddr(device, "vkAcquireNextImageKHR");
		    pAPI->vkQueuePresentKHR = (PFN_vkQueuePresentKHR)pAPI->vkGetDeviceProcAddr(device, "vkQueuePresentKHR");
		    pAPI->vkGetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceGroupPresentCapabilitiesKHR");
		    pAPI->vkGetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModesKHR");
		    pAPI->vkAcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR)pAPI->vkGetDeviceProcAddr(device, "vkAcquireNextImage2KHR");
		    pAPI->vkCreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateSharedSwapchainsKHR");
		    pAPI->vkCreateVideoSessionKHR = (PFN_vkCreateVideoSessionKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateVideoSessionKHR");
		    pAPI->vkDestroyVideoSessionKHR = (PFN_vkDestroyVideoSessionKHR)pAPI->vkGetDeviceProcAddr(device, "vkDestroyVideoSessionKHR");
		    pAPI->vkGetVideoSessionMemoryRequirementsKHR = (PFN_vkGetVideoSessionMemoryRequirementsKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetVideoSessionMemoryRequirementsKHR");
		    pAPI->vkBindVideoSessionMemoryKHR = (PFN_vkBindVideoSessionMemoryKHR)pAPI->vkGetDeviceProcAddr(device, "vkBindVideoSessionMemoryKHR");
		    pAPI->vkCreateVideoSessionParametersKHR = (PFN_vkCreateVideoSessionParametersKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateVideoSessionParametersKHR");
		    pAPI->vkUpdateVideoSessionParametersKHR = (PFN_vkUpdateVideoSessionParametersKHR)pAPI->vkGetDeviceProcAddr(device, "vkUpdateVideoSessionParametersKHR");
		    pAPI->vkDestroyVideoSessionParametersKHR = (PFN_vkDestroyVideoSessionParametersKHR)pAPI->vkGetDeviceProcAddr(device, "vkDestroyVideoSessionParametersKHR");
		    pAPI->vkCmdBeginVideoCodingKHR = (PFN_vkCmdBeginVideoCodingKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginVideoCodingKHR");
		    pAPI->vkCmdEndVideoCodingKHR = (PFN_vkCmdEndVideoCodingKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndVideoCodingKHR");
		    pAPI->vkCmdControlVideoCodingKHR = (PFN_vkCmdControlVideoCodingKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdControlVideoCodingKHR");
		    pAPI->vkCmdDecodeVideoKHR = (PFN_vkCmdDecodeVideoKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdDecodeVideoKHR");
		    pAPI->vkCmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindTransformFeedbackBuffersEXT");
		    pAPI->vkCmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginTransformFeedbackEXT");
		    pAPI->vkCmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndTransformFeedbackEXT");
		    pAPI->vkCmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginQueryIndexedEXT");
		    pAPI->vkCmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndQueryIndexedEXT");
		    pAPI->vkCmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndirectByteCountEXT");
		    pAPI->vkCreateCuModuleNVX = (PFN_vkCreateCuModuleNVX)pAPI->vkGetDeviceProcAddr(device, "vkCreateCuModuleNVX");
		    pAPI->vkCreateCuFunctionNVX = (PFN_vkCreateCuFunctionNVX)pAPI->vkGetDeviceProcAddr(device, "vkCreateCuFunctionNVX");
		    pAPI->vkDestroyCuModuleNVX = (PFN_vkDestroyCuModuleNVX)pAPI->vkGetDeviceProcAddr(device, "vkDestroyCuModuleNVX");
		    pAPI->vkDestroyCuFunctionNVX = (PFN_vkDestroyCuFunctionNVX)pAPI->vkGetDeviceProcAddr(device, "vkDestroyCuFunctionNVX");
		    pAPI->vkCmdCuLaunchKernelNVX = (PFN_vkCmdCuLaunchKernelNVX)pAPI->vkGetDeviceProcAddr(device, "vkCmdCuLaunchKernelNVX");
		    pAPI->vkGetImageViewHandleNVX = (PFN_vkGetImageViewHandleNVX)pAPI->vkGetDeviceProcAddr(device, "vkGetImageViewHandleNVX");
		    pAPI->vkGetImageViewAddressNVX = (PFN_vkGetImageViewAddressNVX)pAPI->vkGetDeviceProcAddr(device, "vkGetImageViewAddressNVX");
		    pAPI->vkGetShaderInfoAMD = (PFN_vkGetShaderInfoAMD)pAPI->vkGetDeviceProcAddr(device, "vkGetShaderInfoAMD");
		    pAPI->vkCmdBeginRenderingKHR = (PFN_vkCmdBeginRenderingKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginRenderingKHR");
		    pAPI->vkCmdEndRenderingKHR = (PFN_vkCmdEndRenderingKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndRenderingKHR");
		    pAPI->vkGetDeviceGroupPeerMemoryFeaturesKHR = (PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeaturesKHR");
		    pAPI->vkCmdSetDeviceMaskKHR = (PFN_vkCmdSetDeviceMaskKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDeviceMaskKHR");
		    pAPI->vkCmdDispatchBaseKHR = (PFN_vkCmdDispatchBaseKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdDispatchBaseKHR");
		    pAPI->vkTrimCommandPoolKHR = (PFN_vkTrimCommandPoolKHR)pAPI->vkGetDeviceProcAddr(device, "vkTrimCommandPoolKHR");
		    pAPI->vkGetMemoryFdKHR = (PFN_vkGetMemoryFdKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryFdKHR");
		    pAPI->vkGetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryFdPropertiesKHR");
		    pAPI->vkImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR)pAPI->vkGetDeviceProcAddr(device, "vkImportSemaphoreFdKHR");
		    pAPI->vkGetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetSemaphoreFdKHR");
		    pAPI->vkCmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdPushDescriptorSetKHR");
		    pAPI->vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplateKHR");
		    pAPI->vkCmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginConditionalRenderingEXT");
		    pAPI->vkCmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndConditionalRenderingEXT");
		    pAPI->vkCreateDescriptorUpdateTemplateKHR = (PFN_vkCreateDescriptorUpdateTemplateKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplateKHR");
		    pAPI->vkDestroyDescriptorUpdateTemplateKHR = (PFN_vkDestroyDescriptorUpdateTemplateKHR)pAPI->vkGetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplateKHR");
		    pAPI->vkUpdateDescriptorSetWithTemplateKHR = (PFN_vkUpdateDescriptorSetWithTemplateKHR)pAPI->vkGetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplateKHR");
		    pAPI->vkCmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetViewportWScalingNV");
		    pAPI->vkDisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT)pAPI->vkGetDeviceProcAddr(device, "vkDisplayPowerControlEXT");
		    pAPI->vkRegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT)pAPI->vkGetDeviceProcAddr(device, "vkRegisterDeviceEventEXT");
		    pAPI->vkRegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT)pAPI->vkGetDeviceProcAddr(device, "vkRegisterDisplayEventEXT");
		    pAPI->vkGetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetSwapchainCounterEXT");
		    pAPI->vkGetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE)pAPI->vkGetDeviceProcAddr(device, "vkGetRefreshCycleDurationGOOGLE");
		    pAPI->vkGetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE)pAPI->vkGetDeviceProcAddr(device, "vkGetPastPresentationTimingGOOGLE");
		    pAPI->vkCmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEXT");
		    pAPI->vkCmdSetDiscardRectangleEnableEXT = (PFN_vkCmdSetDiscardRectangleEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEnableEXT");
		    pAPI->vkCmdSetDiscardRectangleModeEXT = (PFN_vkCmdSetDiscardRectangleModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleModeEXT");
		    pAPI->vkSetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT)pAPI->vkGetDeviceProcAddr(device, "vkSetHdrMetadataEXT");
		    pAPI->vkCreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateRenderPass2KHR");
		    pAPI->vkCmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginRenderPass2KHR");
		    pAPI->vkCmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdNextSubpass2KHR");
		    pAPI->vkCmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndRenderPass2KHR");
		    pAPI->vkGetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetSwapchainStatusKHR");
		    pAPI->vkImportFenceFdKHR = (PFN_vkImportFenceFdKHR)pAPI->vkGetDeviceProcAddr(device, "vkImportFenceFdKHR");
		    pAPI->vkGetFenceFdKHR = (PFN_vkGetFenceFdKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetFenceFdKHR");
		    pAPI->vkAcquireProfilingLockKHR = (PFN_vkAcquireProfilingLockKHR)pAPI->vkGetDeviceProcAddr(device, "vkAcquireProfilingLockKHR");
		    pAPI->vkReleaseProfilingLockKHR = (PFN_vkReleaseProfilingLockKHR)pAPI->vkGetDeviceProcAddr(device, "vkReleaseProfilingLockKHR");
		    pAPI->vkSetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT)pAPI->vkGetDeviceProcAddr(device, "vkSetDebugUtilsObjectNameEXT");
		    pAPI->vkSetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT)pAPI->vkGetDeviceProcAddr(device, "vkSetDebugUtilsObjectTagEXT");
		    pAPI->vkQueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT)pAPI->vkGetDeviceProcAddr(device, "vkQueueBeginDebugUtilsLabelEXT");
		    pAPI->vkQueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT)pAPI->vkGetDeviceProcAddr(device, "vkQueueEndDebugUtilsLabelEXT");
		    pAPI->vkQueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT)pAPI->vkGetDeviceProcAddr(device, "vkQueueInsertDebugUtilsLabelEXT");
		    pAPI->vkCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBeginDebugUtilsLabelEXT");
		    pAPI->vkCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdEndDebugUtilsLabelEXT");
		    pAPI->vkCmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdInsertDebugUtilsLabelEXT");
		    pAPI->vkDebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT)pAPI->vkGetDeviceProcAddr(device, "vkDebugMarkerSetObjectTagEXT");
		    pAPI->vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)pAPI->vkGetDeviceProcAddr(device, "vkDebugMarkerSetObjectNameEXT");
		    pAPI->vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDebugMarkerBeginEXT");
		    pAPI->vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDebugMarkerEndEXT");
		    pAPI->vkCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDebugMarkerInsertEXT");
		    pAPI->vkCmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetSampleLocationsEXT");
		    pAPI->vkGetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2KHR)pAPI->vkGetDeviceProcAddr(device, "vkGetImageMemoryRequirements2KHR");
		    pAPI->vkGetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2KHR)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2KHR");
		    pAPI->vkGetImageSparseMemoryRequirements2KHR = (PFN_vkGetImageSparseMemoryRequirements2KHR)pAPI->vkGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2KHR");
		    pAPI->vkCreateAccelerationStructureKHR = (PFN_vkCreateAccelerationStructureKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateAccelerationStructureKHR");
		    pAPI->vkDestroyAccelerationStructureKHR = (PFN_vkDestroyAccelerationStructureKHR)pAPI->vkGetDeviceProcAddr(device, "vkDestroyAccelerationStructureKHR");
		    pAPI->vkCmdBuildAccelerationStructuresKHR = (PFN_vkCmdBuildAccelerationStructuresKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresKHR");
		    pAPI->vkCmdBuildAccelerationStructuresIndirectKHR = (PFN_vkCmdBuildAccelerationStructuresIndirectKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresIndirectKHR");
		    pAPI->vkBuildAccelerationStructuresKHR = (PFN_vkBuildAccelerationStructuresKHR)pAPI->vkGetDeviceProcAddr(device, "vkBuildAccelerationStructuresKHR");
		    pAPI->vkCopyAccelerationStructureKHR = (PFN_vkCopyAccelerationStructureKHR)pAPI->vkGetDeviceProcAddr(device, "vkCopyAccelerationStructureKHR");
		    pAPI->vkCopyAccelerationStructureToMemoryKHR = (PFN_vkCopyAccelerationStructureToMemoryKHR)pAPI->vkGetDeviceProcAddr(device, "vkCopyAccelerationStructureToMemoryKHR");
		    pAPI->vkCopyMemoryToAccelerationStructureKHR = (PFN_vkCopyMemoryToAccelerationStructureKHR)pAPI->vkGetDeviceProcAddr(device, "vkCopyMemoryToAccelerationStructureKHR");
		    pAPI->vkWriteAccelerationStructuresPropertiesKHR = (PFN_vkWriteAccelerationStructuresPropertiesKHR)pAPI->vkGetDeviceProcAddr(device, "vkWriteAccelerationStructuresPropertiesKHR");
		    pAPI->vkCmdCopyAccelerationStructureKHR = (PFN_vkCmdCopyAccelerationStructureKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureKHR");
		    pAPI->vkCmdCopyAccelerationStructureToMemoryKHR = (PFN_vkCmdCopyAccelerationStructureToMemoryKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureToMemoryKHR");
		    pAPI->vkCmdCopyMemoryToAccelerationStructureKHR = (PFN_vkCmdCopyMemoryToAccelerationStructureKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyMemoryToAccelerationStructureKHR");
		    pAPI->vkGetAccelerationStructureDeviceAddressKHR = (PFN_vkGetAccelerationStructureDeviceAddressKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetAccelerationStructureDeviceAddressKHR");
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesKHR = (PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesKHR");
		    pAPI->vkGetDeviceAccelerationStructureCompatibilityKHR = (PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceAccelerationStructureCompatibilityKHR");
		    pAPI->vkGetAccelerationStructureBuildSizesKHR = (PFN_vkGetAccelerationStructureBuildSizesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetAccelerationStructureBuildSizesKHR");
		    pAPI->vkCmdTraceRaysKHR = (PFN_vkCmdTraceRaysKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdTraceRaysKHR");
		    pAPI->vkCreateRayTracingPipelinesKHR = (PFN_vkCreateRayTracingPipelinesKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateRayTracingPipelinesKHR");
		    pAPI->vkGetRayTracingShaderGroupHandlesKHR = (PFN_vkGetRayTracingShaderGroupHandlesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesKHR");
		    pAPI->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = (PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
		    pAPI->vkCmdTraceRaysIndirectKHR = (PFN_vkCmdTraceRaysIndirectKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdTraceRaysIndirectKHR");
		    pAPI->vkGetRayTracingShaderGroupStackSizeKHR = (PFN_vkGetRayTracingShaderGroupStackSizeKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupStackSizeKHR");
		    pAPI->vkCmdSetRayTracingPipelineStackSizeKHR = (PFN_vkCmdSetRayTracingPipelineStackSizeKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRayTracingPipelineStackSizeKHR");
		    pAPI->vkCreateSamplerYcbcrConversionKHR = (PFN_vkCreateSamplerYcbcrConversionKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversionKHR");
		    pAPI->vkDestroySamplerYcbcrConversionKHR = (PFN_vkDestroySamplerYcbcrConversionKHR)pAPI->vkGetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversionKHR");
		    pAPI->vkBindBufferMemory2KHR = (PFN_vkBindBufferMemory2KHR)pAPI->vkGetDeviceProcAddr(device, "vkBindBufferMemory2KHR");
		    pAPI->vkBindImageMemory2KHR = (PFN_vkBindImageMemory2KHR)pAPI->vkGetDeviceProcAddr(device, "vkBindImageMemory2KHR");
		    pAPI->vkGetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetImageDrmFormatModifierPropertiesEXT");
		    pAPI->vkCreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT)pAPI->vkGetDeviceProcAddr(device, "vkCreateValidationCacheEXT");
		    pAPI->vkDestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT)pAPI->vkGetDeviceProcAddr(device, "vkDestroyValidationCacheEXT");
		    pAPI->vkMergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT)pAPI->vkGetDeviceProcAddr(device, "vkMergeValidationCachesEXT");
		    pAPI->vkGetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetValidationCacheDataEXT");
		    pAPI->vkCmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindShadingRateImageNV");
		    pAPI->vkCmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetViewportShadingRatePaletteNV");
		    pAPI->vkCmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCoarseSampleOrderNV");
		    pAPI->vkCreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV)pAPI->vkGetDeviceProcAddr(device, "vkCreateAccelerationStructureNV");
		    pAPI->vkDestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV)pAPI->vkGetDeviceProcAddr(device, "vkDestroyAccelerationStructureNV");
		    pAPI->vkGetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV)pAPI->vkGetDeviceProcAddr(device, "vkGetAccelerationStructureMemoryRequirementsNV");
		    pAPI->vkBindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV)pAPI->vkGetDeviceProcAddr(device, "vkBindAccelerationStructureMemoryNV");
		    pAPI->vkCmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructureNV");
		    pAPI->vkCmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureNV");
		    pAPI->vkCmdTraceRaysNV = (PFN_vkCmdTraceRaysNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdTraceRaysNV");
		    pAPI->vkCreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV)pAPI->vkGetDeviceProcAddr(device, "vkCreateRayTracingPipelinesNV");
		    pAPI->vkGetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV)pAPI->vkGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesNV");
		    pAPI->vkGetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV)pAPI->vkGetDeviceProcAddr(device, "vkGetAccelerationStructureHandleNV");
		    pAPI->vkCmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesNV");
		    pAPI->vkCompileDeferredNV = (PFN_vkCompileDeferredNV)pAPI->vkGetDeviceProcAddr(device, "vkCompileDeferredNV");
		    pAPI->vkGetDescriptorSetLayoutSupportKHR = (PFN_vkGetDescriptorSetLayoutSupportKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupportKHR");
		    pAPI->vkCmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndirectCountKHR");
		    pAPI->vkCmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountKHR");
		    pAPI->vkCmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndirectCountAMD");
		    pAPI->vkCmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountAMD");
		    pAPI->vkGetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryHostPointerPropertiesEXT");
		    pAPI->vkCmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteBufferMarkerAMD");
		    pAPI->vkCmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMeshTasksNV");
		    pAPI->vkCmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectNV");
		    pAPI->vkCmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountNV");
		    pAPI->vkCmdSetExclusiveScissorEnableNV = (PFN_vkCmdSetExclusiveScissorEnableNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetExclusiveScissorEnableNV");
		    pAPI->vkCmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetExclusiveScissorNV");
		    pAPI->vkCmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCheckpointNV");
		    pAPI->vkGetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV)pAPI->vkGetDeviceProcAddr(device, "vkGetQueueCheckpointDataNV");
		    pAPI->vkGetSemaphoreCounterValueKHR = (PFN_vkGetSemaphoreCounterValueKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetSemaphoreCounterValueKHR");
		    pAPI->vkWaitSemaphoresKHR = (PFN_vkWaitSemaphoresKHR)pAPI->vkGetDeviceProcAddr(device, "vkWaitSemaphoresKHR");
		    pAPI->vkSignalSemaphoreKHR = (PFN_vkSignalSemaphoreKHR)pAPI->vkGetDeviceProcAddr(device, "vkSignalSemaphoreKHR");
		    pAPI->vkInitializePerformanceApiINTEL = (PFN_vkInitializePerformanceApiINTEL)pAPI->vkGetDeviceProcAddr(device, "vkInitializePerformanceApiINTEL");
		    pAPI->vkUninitializePerformanceApiINTEL = (PFN_vkUninitializePerformanceApiINTEL)pAPI->vkGetDeviceProcAddr(device, "vkUninitializePerformanceApiINTEL");
		    pAPI->vkCmdSetPerformanceMarkerINTEL = (PFN_vkCmdSetPerformanceMarkerINTEL)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPerformanceMarkerINTEL");
		    pAPI->vkCmdSetPerformanceStreamMarkerINTEL = (PFN_vkCmdSetPerformanceStreamMarkerINTEL)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPerformanceStreamMarkerINTEL");
		    pAPI->vkCmdSetPerformanceOverrideINTEL = (PFN_vkCmdSetPerformanceOverrideINTEL)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPerformanceOverrideINTEL");
		    pAPI->vkAcquirePerformanceConfigurationINTEL = (PFN_vkAcquirePerformanceConfigurationINTEL)pAPI->vkGetDeviceProcAddr(device, "vkAcquirePerformanceConfigurationINTEL");
		    pAPI->vkReleasePerformanceConfigurationINTEL = (PFN_vkReleasePerformanceConfigurationINTEL)pAPI->vkGetDeviceProcAddr(device, "vkReleasePerformanceConfigurationINTEL");
		    pAPI->vkQueueSetPerformanceConfigurationINTEL = (PFN_vkQueueSetPerformanceConfigurationINTEL)pAPI->vkGetDeviceProcAddr(device, "vkQueueSetPerformanceConfigurationINTEL");
		    pAPI->vkGetPerformanceParameterINTEL = (PFN_vkGetPerformanceParameterINTEL)pAPI->vkGetDeviceProcAddr(device, "vkGetPerformanceParameterINTEL");
		    pAPI->vkSetLocalDimmingAMD = (PFN_vkSetLocalDimmingAMD)pAPI->vkGetDeviceProcAddr(device, "vkSetLocalDimmingAMD");
		    pAPI->vkCmdSetFragmentShadingRateKHR = (PFN_vkCmdSetFragmentShadingRateKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateKHR");
		    pAPI->vkCmdSetRenderingAttachmentLocationsKHR = (PFN_vkCmdSetRenderingAttachmentLocationsKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRenderingAttachmentLocationsKHR");
		    pAPI->vkCmdSetRenderingInputAttachmentIndicesKHR = (PFN_vkCmdSetRenderingInputAttachmentIndicesKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRenderingInputAttachmentIndicesKHR");
		    pAPI->vkWaitForPresentKHR = (PFN_vkWaitForPresentKHR)pAPI->vkGetDeviceProcAddr(device, "vkWaitForPresentKHR");
		    pAPI->vkGetBufferDeviceAddressKHR = (PFN_vkGetBufferDeviceAddressKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferDeviceAddressKHR");
		    pAPI->vkGetBufferOpaqueCaptureAddressKHR = (PFN_vkGetBufferOpaqueCaptureAddressKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddressKHR");
		    pAPI->vkGetDeviceMemoryOpaqueCaptureAddressKHR = (PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddressKHR");
		    pAPI->vkGetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferDeviceAddressEXT");
		    pAPI->vkResetQueryPoolEXT = (PFN_vkResetQueryPoolEXT)pAPI->vkGetDeviceProcAddr(device, "vkResetQueryPoolEXT");
		    pAPI->vkCmdSetCullModeEXT = (PFN_vkCmdSetCullModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCullModeEXT");
		    pAPI->vkCmdSetFrontFaceEXT = (PFN_vkCmdSetFrontFaceEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetFrontFaceEXT");
		    pAPI->vkCmdSetPrimitiveTopologyEXT = (PFN_vkCmdSetPrimitiveTopologyEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPrimitiveTopologyEXT");
		    pAPI->vkCmdSetViewportWithCountEXT = (PFN_vkCmdSetViewportWithCountEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetViewportWithCountEXT");
		    pAPI->vkCmdSetScissorWithCountEXT = (PFN_vkCmdSetScissorWithCountEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetScissorWithCountEXT");
		    pAPI->vkCmdBindVertexBuffers2EXT = (PFN_vkCmdBindVertexBuffers2EXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindVertexBuffers2EXT");
		    pAPI->vkCmdSetDepthTestEnableEXT = (PFN_vkCmdSetDepthTestEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthTestEnableEXT");
		    pAPI->vkCmdSetDepthWriteEnableEXT = (PFN_vkCmdSetDepthWriteEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthWriteEnableEXT");
		    pAPI->vkCmdSetDepthCompareOpEXT = (PFN_vkCmdSetDepthCompareOpEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthCompareOpEXT");
		    pAPI->vkCmdSetDepthBoundsTestEnableEXT = (PFN_vkCmdSetDepthBoundsTestEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnableEXT");
		    pAPI->vkCmdSetStencilTestEnableEXT = (PFN_vkCmdSetStencilTestEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetStencilTestEnableEXT");
		    pAPI->vkCmdSetStencilOpEXT = (PFN_vkCmdSetStencilOpEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetStencilOpEXT");
		    pAPI->vkCreateDeferredOperationKHR = (PFN_vkCreateDeferredOperationKHR)pAPI->vkGetDeviceProcAddr(device, "vkCreateDeferredOperationKHR");
		    pAPI->vkDestroyDeferredOperationKHR = (PFN_vkDestroyDeferredOperationKHR)pAPI->vkGetDeviceProcAddr(device, "vkDestroyDeferredOperationKHR");
		    pAPI->vkGetDeferredOperationMaxConcurrencyKHR = (PFN_vkGetDeferredOperationMaxConcurrencyKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeferredOperationMaxConcurrencyKHR");
		    pAPI->vkGetDeferredOperationResultKHR = (PFN_vkGetDeferredOperationResultKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeferredOperationResultKHR");
		    pAPI->vkDeferredOperationJoinKHR = (PFN_vkDeferredOperationJoinKHR)pAPI->vkGetDeviceProcAddr(device, "vkDeferredOperationJoinKHR");
		    pAPI->vkGetPipelineExecutablePropertiesKHR = (PFN_vkGetPipelineExecutablePropertiesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetPipelineExecutablePropertiesKHR");
		    pAPI->vkGetPipelineExecutableStatisticsKHR = (PFN_vkGetPipelineExecutableStatisticsKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetPipelineExecutableStatisticsKHR");
		    pAPI->vkGetPipelineExecutableInternalRepresentationsKHR = (PFN_vkGetPipelineExecutableInternalRepresentationsKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetPipelineExecutableInternalRepresentationsKHR");
		    pAPI->vkCopyMemoryToImageEXT = (PFN_vkCopyMemoryToImageEXT)pAPI->vkGetDeviceProcAddr(device, "vkCopyMemoryToImageEXT");
		    pAPI->vkCopyImageToMemoryEXT = (PFN_vkCopyImageToMemoryEXT)pAPI->vkGetDeviceProcAddr(device, "vkCopyImageToMemoryEXT");
		    pAPI->vkCopyImageToImageEXT = (PFN_vkCopyImageToImageEXT)pAPI->vkGetDeviceProcAddr(device, "vkCopyImageToImageEXT");
		    pAPI->vkTransitionImageLayoutEXT = (PFN_vkTransitionImageLayoutEXT)pAPI->vkGetDeviceProcAddr(device, "vkTransitionImageLayoutEXT");
		    pAPI->vkGetImageSubresourceLayout2EXT = (PFN_vkGetImageSubresourceLayout2EXT)pAPI->vkGetDeviceProcAddr(device, "vkGetImageSubresourceLayout2EXT");
		    pAPI->vkMapMemory2KHR = (PFN_vkMapMemory2KHR)pAPI->vkGetDeviceProcAddr(device, "vkMapMemory2KHR");
		    pAPI->vkUnmapMemory2KHR = (PFN_vkUnmapMemory2KHR)pAPI->vkGetDeviceProcAddr(device, "vkUnmapMemory2KHR");
		    pAPI->vkReleaseSwapchainImagesEXT = (PFN_vkReleaseSwapchainImagesEXT)pAPI->vkGetDeviceProcAddr(device, "vkReleaseSwapchainImagesEXT");
		    pAPI->vkGetGeneratedCommandsMemoryRequirementsNV = (PFN_vkGetGeneratedCommandsMemoryRequirementsNV)pAPI->vkGetDeviceProcAddr(device, "vkGetGeneratedCommandsMemoryRequirementsNV");
		    pAPI->vkCmdPreprocessGeneratedCommandsNV = (PFN_vkCmdPreprocessGeneratedCommandsNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdPreprocessGeneratedCommandsNV");
		    pAPI->vkCmdExecuteGeneratedCommandsNV = (PFN_vkCmdExecuteGeneratedCommandsNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdExecuteGeneratedCommandsNV");
		    pAPI->vkCmdBindPipelineShaderGroupNV = (PFN_vkCmdBindPipelineShaderGroupNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindPipelineShaderGroupNV");
		    pAPI->vkCreateIndirectCommandsLayoutNV = (PFN_vkCreateIndirectCommandsLayoutNV)pAPI->vkGetDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutNV");
		    pAPI->vkDestroyIndirectCommandsLayoutNV = (PFN_vkDestroyIndirectCommandsLayoutNV)pAPI->vkGetDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutNV");
		    pAPI->vkCmdSetDepthBias2EXT = (PFN_vkCmdSetDepthBias2EXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthBias2EXT");
		    pAPI->vkCreatePrivateDataSlotEXT = (PFN_vkCreatePrivateDataSlotEXT)pAPI->vkGetDeviceProcAddr(device, "vkCreatePrivateDataSlotEXT");
		    pAPI->vkDestroyPrivateDataSlotEXT = (PFN_vkDestroyPrivateDataSlotEXT)pAPI->vkGetDeviceProcAddr(device, "vkDestroyPrivateDataSlotEXT");
		    pAPI->vkSetPrivateDataEXT = (PFN_vkSetPrivateDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkSetPrivateDataEXT");
		    pAPI->vkGetPrivateDataEXT = (PFN_vkGetPrivateDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetPrivateDataEXT");
		    pAPI->vkGetEncodedVideoSessionParametersKHR = (PFN_vkGetEncodedVideoSessionParametersKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetEncodedVideoSessionParametersKHR");
		    pAPI->vkCmdEncodeVideoKHR = (PFN_vkCmdEncodeVideoKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdEncodeVideoKHR");
		    pAPI->vkCreateCudaModuleNV = (PFN_vkCreateCudaModuleNV)pAPI->vkGetDeviceProcAddr(device, "vkCreateCudaModuleNV");
		    pAPI->vkGetCudaModuleCacheNV = (PFN_vkGetCudaModuleCacheNV)pAPI->vkGetDeviceProcAddr(device, "vkGetCudaModuleCacheNV");
		    pAPI->vkCreateCudaFunctionNV = (PFN_vkCreateCudaFunctionNV)pAPI->vkGetDeviceProcAddr(device, "vkCreateCudaFunctionNV");
		    pAPI->vkDestroyCudaModuleNV = (PFN_vkDestroyCudaModuleNV)pAPI->vkGetDeviceProcAddr(device, "vkDestroyCudaModuleNV");
		    pAPI->vkDestroyCudaFunctionNV = (PFN_vkDestroyCudaFunctionNV)pAPI->vkGetDeviceProcAddr(device, "vkDestroyCudaFunctionNV");
		    pAPI->vkCmdCudaLaunchKernelNV = (PFN_vkCmdCudaLaunchKernelNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdCudaLaunchKernelNV");
		    pAPI->vkCmdRefreshObjectsKHR = (PFN_vkCmdRefreshObjectsKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdRefreshObjectsKHR");
		    pAPI->vkCmdSetEvent2KHR = (PFN_vkCmdSetEvent2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetEvent2KHR");
		    pAPI->vkCmdResetEvent2KHR = (PFN_vkCmdResetEvent2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdResetEvent2KHR");
		    pAPI->vkCmdWaitEvents2KHR = (PFN_vkCmdWaitEvents2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdWaitEvents2KHR");
		    pAPI->vkCmdPipelineBarrier2KHR = (PFN_vkCmdPipelineBarrier2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdPipelineBarrier2KHR");
		    pAPI->vkCmdWriteTimestamp2KHR = (PFN_vkCmdWriteTimestamp2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteTimestamp2KHR");
		    pAPI->vkQueueSubmit2KHR = (PFN_vkQueueSubmit2KHR)pAPI->vkGetDeviceProcAddr(device, "vkQueueSubmit2KHR");
		    pAPI->vkCmdWriteBufferMarker2AMD = (PFN_vkCmdWriteBufferMarker2AMD)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteBufferMarker2AMD");
		    pAPI->vkGetQueueCheckpointData2NV = (PFN_vkGetQueueCheckpointData2NV)pAPI->vkGetDeviceProcAddr(device, "vkGetQueueCheckpointData2NV");
		    pAPI->vkGetDescriptorSetLayoutSizeEXT = (PFN_vkGetDescriptorSetLayoutSizeEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSizeEXT");
		    pAPI->vkGetDescriptorSetLayoutBindingOffsetEXT = (PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutBindingOffsetEXT");
		    pAPI->vkGetDescriptorEXT = (PFN_vkGetDescriptorEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetDescriptorEXT");
		    pAPI->vkCmdBindDescriptorBuffersEXT = (PFN_vkCmdBindDescriptorBuffersEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindDescriptorBuffersEXT");
		    pAPI->vkCmdSetDescriptorBufferOffsetsEXT = (PFN_vkCmdSetDescriptorBufferOffsetsEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsetsEXT");
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplersEXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
		    pAPI->vkGetBufferOpaqueCaptureDescriptorDataEXT = (PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetImageOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetImageOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetImageViewOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetImageViewOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetSamplerOpaqueCaptureDescriptorDataEXT = (PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetSamplerOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = (PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
		    pAPI->vkCmdSetFragmentShadingRateEnumNV = (PFN_vkCmdSetFragmentShadingRateEnumNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateEnumNV");
		    pAPI->vkCmdDrawMeshTasksEXT = (PFN_vkCmdDrawMeshTasksEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMeshTasksEXT");
		    pAPI->vkCmdDrawMeshTasksIndirectEXT = (PFN_vkCmdDrawMeshTasksIndirectEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectEXT");
		    pAPI->vkCmdDrawMeshTasksIndirectCountEXT = (PFN_vkCmdDrawMeshTasksIndirectCountEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountEXT");
		    pAPI->vkCmdCopyBuffer2KHR = (PFN_vkCmdCopyBuffer2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyBuffer2KHR");
		    pAPI->vkCmdCopyImage2KHR = (PFN_vkCmdCopyImage2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyImage2KHR");
		    pAPI->vkCmdCopyBufferToImage2KHR = (PFN_vkCmdCopyBufferToImage2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyBufferToImage2KHR");
		    pAPI->vkCmdCopyImageToBuffer2KHR = (PFN_vkCmdCopyImageToBuffer2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2KHR");
		    pAPI->vkCmdBlitImage2KHR = (PFN_vkCmdBlitImage2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBlitImage2KHR");
		    pAPI->vkCmdResolveImage2KHR = (PFN_vkCmdResolveImage2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdResolveImage2KHR");
		    pAPI->vkGetDeviceFaultInfoEXT = (PFN_vkGetDeviceFaultInfoEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceFaultInfoEXT");
		    pAPI->vkCmdSetVertexInputEXT = (PFN_vkCmdSetVertexInputEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetVertexInputEXT");
		    pAPI->vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = (PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
		    pAPI->vkCmdSubpassShadingHUAWEI = (PFN_vkCmdSubpassShadingHUAWEI)pAPI->vkGetDeviceProcAddr(device, "vkCmdSubpassShadingHUAWEI");
		    pAPI->vkCmdBindInvocationMaskHUAWEI = (PFN_vkCmdBindInvocationMaskHUAWEI)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindInvocationMaskHUAWEI");
		    pAPI->vkGetMemoryRemoteAddressNV = (PFN_vkGetMemoryRemoteAddressNV)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryRemoteAddressNV");
		    pAPI->vkGetPipelinePropertiesEXT = (PFN_vkGetPipelinePropertiesEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetPipelinePropertiesEXT");
		    pAPI->vkCmdSetPatchControlPointsEXT = (PFN_vkCmdSetPatchControlPointsEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPatchControlPointsEXT");
		    pAPI->vkCmdSetRasterizerDiscardEnableEXT = (PFN_vkCmdSetRasterizerDiscardEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnableEXT");
		    pAPI->vkCmdSetDepthBiasEnableEXT = (PFN_vkCmdSetDepthBiasEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthBiasEnableEXT");
		    pAPI->vkCmdSetLogicOpEXT = (PFN_vkCmdSetLogicOpEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetLogicOpEXT");
		    pAPI->vkCmdSetPrimitiveRestartEnableEXT = (PFN_vkCmdSetPrimitiveRestartEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnableEXT");
		    pAPI->vkCmdSetColorWriteEnableEXT = (PFN_vkCmdSetColorWriteEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetColorWriteEnableEXT");
		    pAPI->vkCmdTraceRaysIndirect2KHR = (PFN_vkCmdTraceRaysIndirect2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdTraceRaysIndirect2KHR");
		    pAPI->vkCmdDrawMultiEXT = (PFN_vkCmdDrawMultiEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMultiEXT");
		    pAPI->vkCmdDrawMultiIndexedEXT = (PFN_vkCmdDrawMultiIndexedEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawMultiIndexedEXT");
		    pAPI->vkCreateMicromapEXT = (PFN_vkCreateMicromapEXT)pAPI->vkGetDeviceProcAddr(device, "vkCreateMicromapEXT");
		    pAPI->vkDestroyMicromapEXT = (PFN_vkDestroyMicromapEXT)pAPI->vkGetDeviceProcAddr(device, "vkDestroyMicromapEXT");
		    pAPI->vkCmdBuildMicromapsEXT = (PFN_vkCmdBuildMicromapsEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBuildMicromapsEXT");
		    pAPI->vkBuildMicromapsEXT = (PFN_vkBuildMicromapsEXT)pAPI->vkGetDeviceProcAddr(device, "vkBuildMicromapsEXT");
		    pAPI->vkCopyMicromapEXT = (PFN_vkCopyMicromapEXT)pAPI->vkGetDeviceProcAddr(device, "vkCopyMicromapEXT");
		    pAPI->vkCopyMicromapToMemoryEXT = (PFN_vkCopyMicromapToMemoryEXT)pAPI->vkGetDeviceProcAddr(device, "vkCopyMicromapToMemoryEXT");
		    pAPI->vkCopyMemoryToMicromapEXT = (PFN_vkCopyMemoryToMicromapEXT)pAPI->vkGetDeviceProcAddr(device, "vkCopyMemoryToMicromapEXT");
		    pAPI->vkWriteMicromapsPropertiesEXT = (PFN_vkWriteMicromapsPropertiesEXT)pAPI->vkGetDeviceProcAddr(device, "vkWriteMicromapsPropertiesEXT");
		    pAPI->vkCmdCopyMicromapEXT = (PFN_vkCmdCopyMicromapEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyMicromapEXT");
		    pAPI->vkCmdCopyMicromapToMemoryEXT = (PFN_vkCmdCopyMicromapToMemoryEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyMicromapToMemoryEXT");
		    pAPI->vkCmdCopyMemoryToMicromapEXT = (PFN_vkCmdCopyMemoryToMicromapEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyMemoryToMicromapEXT");
		    pAPI->vkCmdWriteMicromapsPropertiesEXT = (PFN_vkCmdWriteMicromapsPropertiesEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdWriteMicromapsPropertiesEXT");
		    pAPI->vkGetDeviceMicromapCompatibilityEXT = (PFN_vkGetDeviceMicromapCompatibilityEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceMicromapCompatibilityEXT");
		    pAPI->vkGetMicromapBuildSizesEXT = (PFN_vkGetMicromapBuildSizesEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetMicromapBuildSizesEXT");
		    pAPI->vkCmdDrawClusterHUAWEI = (PFN_vkCmdDrawClusterHUAWEI)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawClusterHUAWEI");
		    pAPI->vkCmdDrawClusterIndirectHUAWEI = (PFN_vkCmdDrawClusterIndirectHUAWEI)pAPI->vkGetDeviceProcAddr(device, "vkCmdDrawClusterIndirectHUAWEI");
		    pAPI->vkSetDeviceMemoryPriorityEXT = (PFN_vkSetDeviceMemoryPriorityEXT)pAPI->vkGetDeviceProcAddr(device, "vkSetDeviceMemoryPriorityEXT");
		    pAPI->vkGetDeviceBufferMemoryRequirementsKHR = (PFN_vkGetDeviceBufferMemoryRequirementsKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirementsKHR");
		    pAPI->vkGetDeviceImageMemoryRequirementsKHR = (PFN_vkGetDeviceImageMemoryRequirementsKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirementsKHR");
		    pAPI->vkGetDeviceImageSparseMemoryRequirementsKHR = (PFN_vkGetDeviceImageSparseMemoryRequirementsKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirementsKHR");
		    pAPI->vkGetDescriptorSetLayoutHostMappingInfoVALVE = (PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)pAPI->vkGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutHostMappingInfoVALVE");
		    pAPI->vkGetDescriptorSetHostMappingVALVE = (PFN_vkGetDescriptorSetHostMappingVALVE)pAPI->vkGetDeviceProcAddr(device, "vkGetDescriptorSetHostMappingVALVE");
		    pAPI->vkCmdCopyMemoryIndirectNV = (PFN_vkCmdCopyMemoryIndirectNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyMemoryIndirectNV");
		    pAPI->vkCmdCopyMemoryToImageIndirectNV = (PFN_vkCmdCopyMemoryToImageIndirectNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdCopyMemoryToImageIndirectNV");
		    pAPI->vkCmdDecompressMemoryNV = (PFN_vkCmdDecompressMemoryNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdDecompressMemoryNV");
		    pAPI->vkCmdDecompressMemoryIndirectCountNV = (PFN_vkCmdDecompressMemoryIndirectCountNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdDecompressMemoryIndirectCountNV");
		    pAPI->vkGetPipelineIndirectMemoryRequirementsNV = (PFN_vkGetPipelineIndirectMemoryRequirementsNV)pAPI->vkGetDeviceProcAddr(device, "vkGetPipelineIndirectMemoryRequirementsNV");
		    pAPI->vkCmdUpdatePipelineIndirectBufferNV = (PFN_vkCmdUpdatePipelineIndirectBufferNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdUpdatePipelineIndirectBufferNV");
		    pAPI->vkGetPipelineIndirectDeviceAddressNV = (PFN_vkGetPipelineIndirectDeviceAddressNV)pAPI->vkGetDeviceProcAddr(device, "vkGetPipelineIndirectDeviceAddressNV");
		    pAPI->vkCmdSetDepthClampEnableEXT = (PFN_vkCmdSetDepthClampEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthClampEnableEXT");
		    pAPI->vkCmdSetPolygonModeEXT = (PFN_vkCmdSetPolygonModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetPolygonModeEXT");
		    pAPI->vkCmdSetRasterizationSamplesEXT = (PFN_vkCmdSetRasterizationSamplesEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRasterizationSamplesEXT");
		    pAPI->vkCmdSetSampleMaskEXT = (PFN_vkCmdSetSampleMaskEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetSampleMaskEXT");
		    pAPI->vkCmdSetAlphaToCoverageEnableEXT = (PFN_vkCmdSetAlphaToCoverageEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetAlphaToCoverageEnableEXT");
		    pAPI->vkCmdSetAlphaToOneEnableEXT = (PFN_vkCmdSetAlphaToOneEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetAlphaToOneEnableEXT");
		    pAPI->vkCmdSetLogicOpEnableEXT = (PFN_vkCmdSetLogicOpEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetLogicOpEnableEXT");
		    pAPI->vkCmdSetColorBlendEnableEXT = (PFN_vkCmdSetColorBlendEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetColorBlendEnableEXT");
		    pAPI->vkCmdSetColorBlendEquationEXT = (PFN_vkCmdSetColorBlendEquationEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetColorBlendEquationEXT");
		    pAPI->vkCmdSetColorWriteMaskEXT = (PFN_vkCmdSetColorWriteMaskEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetColorWriteMaskEXT");
		    pAPI->vkCmdSetTessellationDomainOriginEXT = (PFN_vkCmdSetTessellationDomainOriginEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetTessellationDomainOriginEXT");
		    pAPI->vkCmdSetRasterizationStreamEXT = (PFN_vkCmdSetRasterizationStreamEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRasterizationStreamEXT");
		    pAPI->vkCmdSetConservativeRasterizationModeEXT = (PFN_vkCmdSetConservativeRasterizationModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetConservativeRasterizationModeEXT");
		    pAPI->vkCmdSetExtraPrimitiveOverestimationSizeEXT = (PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetExtraPrimitiveOverestimationSizeEXT");
		    pAPI->vkCmdSetDepthClipEnableEXT = (PFN_vkCmdSetDepthClipEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthClipEnableEXT");
		    pAPI->vkCmdSetSampleLocationsEnableEXT = (PFN_vkCmdSetSampleLocationsEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetSampleLocationsEnableEXT");
		    pAPI->vkCmdSetColorBlendAdvancedEXT = (PFN_vkCmdSetColorBlendAdvancedEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetColorBlendAdvancedEXT");
		    pAPI->vkCmdSetProvokingVertexModeEXT = (PFN_vkCmdSetProvokingVertexModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetProvokingVertexModeEXT");
		    pAPI->vkCmdSetLineRasterizationModeEXT = (PFN_vkCmdSetLineRasterizationModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetLineRasterizationModeEXT");
		    pAPI->vkCmdSetLineStippleEnableEXT = (PFN_vkCmdSetLineStippleEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetLineStippleEnableEXT");
		    pAPI->vkCmdSetDepthClipNegativeOneToOneEXT = (PFN_vkCmdSetDepthClipNegativeOneToOneEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDepthClipNegativeOneToOneEXT");
		    pAPI->vkCmdSetViewportWScalingEnableNV = (PFN_vkCmdSetViewportWScalingEnableNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetViewportWScalingEnableNV");
		    pAPI->vkCmdSetViewportSwizzleNV = (PFN_vkCmdSetViewportSwizzleNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetViewportSwizzleNV");
		    pAPI->vkCmdSetCoverageToColorEnableNV = (PFN_vkCmdSetCoverageToColorEnableNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCoverageToColorEnableNV");
		    pAPI->vkCmdSetCoverageToColorLocationNV = (PFN_vkCmdSetCoverageToColorLocationNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCoverageToColorLocationNV");
		    pAPI->vkCmdSetCoverageModulationModeNV = (PFN_vkCmdSetCoverageModulationModeNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCoverageModulationModeNV");
		    pAPI->vkCmdSetCoverageModulationTableEnableNV = (PFN_vkCmdSetCoverageModulationTableEnableNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableEnableNV");
		    pAPI->vkCmdSetCoverageModulationTableNV = (PFN_vkCmdSetCoverageModulationTableNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableNV");
		    pAPI->vkCmdSetShadingRateImageEnableNV = (PFN_vkCmdSetShadingRateImageEnableNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetShadingRateImageEnableNV");
		    pAPI->vkCmdSetRepresentativeFragmentTestEnableNV = (PFN_vkCmdSetRepresentativeFragmentTestEnableNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetRepresentativeFragmentTestEnableNV");
		    pAPI->vkCmdSetCoverageReductionModeNV = (PFN_vkCmdSetCoverageReductionModeNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetCoverageReductionModeNV");
		    pAPI->vkGetShaderModuleIdentifierEXT = (PFN_vkGetShaderModuleIdentifierEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetShaderModuleIdentifierEXT");
		    pAPI->vkGetShaderModuleCreateInfoIdentifierEXT = (PFN_vkGetShaderModuleCreateInfoIdentifierEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetShaderModuleCreateInfoIdentifierEXT");
		    pAPI->vkCreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)pAPI->vkGetDeviceProcAddr(device, "vkCreateOpticalFlowSessionNV");
		    pAPI->vkDestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)pAPI->vkGetDeviceProcAddr(device, "vkDestroyOpticalFlowSessionNV");
		    pAPI->vkBindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)pAPI->vkGetDeviceProcAddr(device, "vkBindOpticalFlowSessionImageNV");
		    pAPI->vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)pAPI->vkGetDeviceProcAddr(device, "vkCmdOpticalFlowExecuteNV");
		    pAPI->vkCmdBindIndexBuffer2KHR = (PFN_vkCmdBindIndexBuffer2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindIndexBuffer2KHR");
		    pAPI->vkGetRenderingAreaGranularityKHR = (PFN_vkGetRenderingAreaGranularityKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetRenderingAreaGranularityKHR");
		    pAPI->vkGetDeviceImageSubresourceLayoutKHR = (PFN_vkGetDeviceImageSubresourceLayoutKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceImageSubresourceLayoutKHR");
		    pAPI->vkGetImageSubresourceLayout2KHR = (PFN_vkGetImageSubresourceLayout2KHR)pAPI->vkGetDeviceProcAddr(device, "vkGetImageSubresourceLayout2KHR");
		    pAPI->vkCreateShadersEXT = (PFN_vkCreateShadersEXT)pAPI->vkGetDeviceProcAddr(device, "vkCreateShadersEXT");
		    pAPI->vkDestroyShaderEXT = (PFN_vkDestroyShaderEXT)pAPI->vkGetDeviceProcAddr(device, "vkDestroyShaderEXT");
		    pAPI->vkGetShaderBinaryDataEXT = (PFN_vkGetShaderBinaryDataEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetShaderBinaryDataEXT");
		    pAPI->vkCmdBindShadersEXT = (PFN_vkCmdBindShadersEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindShadersEXT");
		    pAPI->vkGetFramebufferTilePropertiesQCOM = (PFN_vkGetFramebufferTilePropertiesQCOM)pAPI->vkGetDeviceProcAddr(device, "vkGetFramebufferTilePropertiesQCOM");
		    pAPI->vkGetDynamicRenderingTilePropertiesQCOM = (PFN_vkGetDynamicRenderingTilePropertiesQCOM)pAPI->vkGetDeviceProcAddr(device, "vkGetDynamicRenderingTilePropertiesQCOM");
		    pAPI->vkSetLatencySleepModeNV = (PFN_vkSetLatencySleepModeNV)pAPI->vkGetDeviceProcAddr(device, "vkSetLatencySleepModeNV");
		    pAPI->vkLatencySleepNV = (PFN_vkLatencySleepNV)pAPI->vkGetDeviceProcAddr(device, "vkLatencySleepNV");
		    pAPI->vkSetLatencyMarkerNV = (PFN_vkSetLatencyMarkerNV)pAPI->vkGetDeviceProcAddr(device, "vkSetLatencyMarkerNV");
		    pAPI->vkGetLatencyTimingsNV = (PFN_vkGetLatencyTimingsNV)pAPI->vkGetDeviceProcAddr(device, "vkGetLatencyTimingsNV");
		    pAPI->vkQueueNotifyOutOfBandNV = (PFN_vkQueueNotifyOutOfBandNV)pAPI->vkGetDeviceProcAddr(device, "vkQueueNotifyOutOfBandNV");
		    pAPI->vkCmdSetAttachmentFeedbackLoopEnableEXT = (PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetAttachmentFeedbackLoopEnableEXT");
		    pAPI->vkCmdSetLineStippleKHR = (PFN_vkCmdSetLineStippleKHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetLineStippleKHR");
		    pAPI->vkCmdSetLineStippleEXT = (PFN_vkCmdSetLineStippleEXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetLineStippleEXT");
		    pAPI->vkGetCalibratedTimestampsKHR = (PFN_vkGetCalibratedTimestampsKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetCalibratedTimestampsKHR");
		    pAPI->vkGetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT)pAPI->vkGetDeviceProcAddr(device, "vkGetCalibratedTimestampsEXT");
		    pAPI->vkCmdBindDescriptorSets2KHR = (PFN_vkCmdBindDescriptorSets2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindDescriptorSets2KHR");
		    pAPI->vkCmdPushConstants2KHR = (PFN_vkCmdPushConstants2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdPushConstants2KHR");
		    pAPI->vkCmdPushDescriptorSet2KHR = (PFN_vkCmdPushDescriptorSet2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdPushDescriptorSet2KHR");
		    pAPI->vkCmdPushDescriptorSetWithTemplate2KHR = (PFN_vkCmdPushDescriptorSetWithTemplate2KHR)pAPI->vkGetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplate2KHR");
		    pAPI->vkCmdSetDescriptorBufferOffsets2EXT = (PFN_vkCmdSetDescriptorBufferOffsets2EXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsets2EXT");
		    pAPI->vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)pAPI->vkGetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT");
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		    pAPI->vkGetAndroidHardwareBufferPropertiesANDROID = (PFN_vkGetAndroidHardwareBufferPropertiesANDROID)pAPI->vkGetDeviceProcAddr(device, "vkGetAndroidHardwareBufferPropertiesANDROID");
		    pAPI->vkGetMemoryAndroidHardwareBufferANDROID = (PFN_vkGetMemoryAndroidHardwareBufferANDROID)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryAndroidHardwareBufferANDROID");
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		    pAPI->vkGetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryWin32HandleKHR");
		    pAPI->vkGetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryWin32HandlePropertiesKHR");
		    pAPI->vkGetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryWin32HandleNV");
		    pAPI->vkImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR)pAPI->vkGetDeviceProcAddr(device, "vkImportSemaphoreWin32HandleKHR");
		    pAPI->vkGetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetSemaphoreWin32HandleKHR");
		    pAPI->vkImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR)pAPI->vkGetDeviceProcAddr(device, "vkImportFenceWin32HandleKHR");
		    pAPI->vkGetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR)pAPI->vkGetDeviceProcAddr(device, "vkGetFenceWin32HandleKHR");
		    pAPI->vkAcquireFullScreenExclusiveModeEXT = (PFN_vkAcquireFullScreenExclusiveModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkAcquireFullScreenExclusiveModeEXT");
		    pAPI->vkReleaseFullScreenExclusiveModeEXT = (PFN_vkReleaseFullScreenExclusiveModeEXT)pAPI->vkGetDeviceProcAddr(device, "vkReleaseFullScreenExclusiveModeEXT");
		    pAPI->vkGetDeviceGroupSurfacePresentModes2EXT = (PFN_vkGetDeviceGroupSurfacePresentModes2EXT)pAPI->vkGetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModes2EXT");
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		    pAPI->vkExportMetalObjectsEXT = (PFN_vkExportMetalObjectsEXT)pAPI->vkGetDeviceProcAddr(device, "vkExportMetalObjectsEXT");
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		    pAPI->vkGetMemoryZirconHandleFUCHSIA = (PFN_vkGetMemoryZirconHandleFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryZirconHandleFUCHSIA");
		    pAPI->vkGetMemoryZirconHandlePropertiesFUCHSIA = (PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkGetMemoryZirconHandlePropertiesFUCHSIA");
		    pAPI->vkImportSemaphoreZirconHandleFUCHSIA = (PFN_vkImportSemaphoreZirconHandleFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkImportSemaphoreZirconHandleFUCHSIA");
		    pAPI->vkGetSemaphoreZirconHandleFUCHSIA = (PFN_vkGetSemaphoreZirconHandleFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkGetSemaphoreZirconHandleFUCHSIA");
		    pAPI->vkCreateBufferCollectionFUCHSIA = (PFN_vkCreateBufferCollectionFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkCreateBufferCollectionFUCHSIA");
		    pAPI->vkSetBufferCollectionImageConstraintsFUCHSIA = (PFN_vkSetBufferCollectionImageConstraintsFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkSetBufferCollectionImageConstraintsFUCHSIA");
		    pAPI->vkSetBufferCollectionBufferConstraintsFUCHSIA = (PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkSetBufferCollectionBufferConstraintsFUCHSIA");
		    pAPI->vkDestroyBufferCollectionFUCHSIA = (PFN_vkDestroyBufferCollectionFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkDestroyBufferCollectionFUCHSIA");
		    pAPI->vkGetBufferCollectionPropertiesFUCHSIA = (PFN_vkGetBufferCollectionPropertiesFUCHSIA)pAPI->vkGetDeviceProcAddr(device, "vkGetBufferCollectionPropertiesFUCHSIA");
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		    pAPI->vkGetMemorySciBufNV = (PFN_vkGetMemorySciBufNV)pAPI->vkGetDeviceProcAddr(device, "vkGetMemorySciBufNV");
		    pAPI->vkCreateSemaphoreSciSyncPoolNV = (PFN_vkCreateSemaphoreSciSyncPoolNV)pAPI->vkGetDeviceProcAddr(device, "vkCreateSemaphoreSciSyncPoolNV");
		    pAPI->vkDestroySemaphoreSciSyncPoolNV = (PFN_vkDestroySemaphoreSciSyncPoolNV)pAPI->vkGetDeviceProcAddr(device, "vkDestroySemaphoreSciSyncPoolNV");
		    pAPI->vkGetFenceSciSyncFenceNV = (PFN_vkGetFenceSciSyncFenceNV)pAPI->vkGetDeviceProcAddr(device, "vkGetFenceSciSyncFenceNV");
		    pAPI->vkGetFenceSciSyncObjNV = (PFN_vkGetFenceSciSyncObjNV)pAPI->vkGetDeviceProcAddr(device, "vkGetFenceSciSyncObjNV");
		    pAPI->vkImportFenceSciSyncFenceNV = (PFN_vkImportFenceSciSyncFenceNV)pAPI->vkGetDeviceProcAddr(device, "vkImportFenceSciSyncFenceNV");
		    pAPI->vkImportFenceSciSyncObjNV = (PFN_vkImportFenceSciSyncObjNV)pAPI->vkGetDeviceProcAddr(device, "vkImportFenceSciSyncObjNV");
		    pAPI->vkGetSemaphoreSciSyncObjNV = (PFN_vkGetSemaphoreSciSyncObjNV)pAPI->vkGetDeviceProcAddr(device, "vkGetSemaphoreSciSyncObjNV");
		    pAPI->vkImportSemaphoreSciSyncObjNV = (PFN_vkImportSemaphoreSciSyncObjNV)pAPI->vkGetDeviceProcAddr(device, "vkImportSemaphoreSciSyncObjNV");
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		    pAPI->vkCreateExecutionGraphPipelinesAMDX = (PFN_vkCreateExecutionGraphPipelinesAMDX)pAPI->vkGetDeviceProcAddr(device, "vkCreateExecutionGraphPipelinesAMDX");
		    pAPI->vkGetExecutionGraphPipelineScratchSizeAMDX = (PFN_vkGetExecutionGraphPipelineScratchSizeAMDX)pAPI->vkGetDeviceProcAddr(device, "vkGetExecutionGraphPipelineScratchSizeAMDX");
		    pAPI->vkGetExecutionGraphPipelineNodeIndexAMDX = (PFN_vkGetExecutionGraphPipelineNodeIndexAMDX)pAPI->vkGetDeviceProcAddr(device, "vkGetExecutionGraphPipelineNodeIndexAMDX");
		    pAPI->vkCmdInitializeGraphScratchMemoryAMDX = (PFN_vkCmdInitializeGraphScratchMemoryAMDX)pAPI->vkGetDeviceProcAddr(device, "vkCmdInitializeGraphScratchMemoryAMDX");
		    pAPI->vkCmdDispatchGraphAMDX = (PFN_vkCmdDispatchGraphAMDX)pAPI->vkGetDeviceProcAddr(device, "vkCmdDispatchGraphAMDX");
		    pAPI->vkCmdDispatchGraphIndirectAMDX = (PFN_vkCmdDispatchGraphIndirectAMDX)pAPI->vkGetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectAMDX");
		    pAPI->vkCmdDispatchGraphIndirectCountAMDX = (PFN_vkCmdDispatchGraphIndirectCountAMDX)pAPI->vkGetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectCountAMDX");
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		    pAPI->vkGetScreenBufferPropertiesQNX = (PFN_vkGetScreenBufferPropertiesQNX)pAPI->vkGetDeviceProcAddr(device, "vkGetScreenBufferPropertiesQNX");
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/

		    return VK_SUCCESS;
		}

		VkResult vkbBindAPI(const VkbAPI* pAPI)
		{
		    if (pAPI == NULL) {
				return VK_ERROR_INITIALIZATION_FAILED;
		    }

		#if defined(VKBIND_NO_GLOBAL_API)
		    return VK_ERROR_INITIALIZATION_FAILED;  /* The global API has been disabled. */
		#else
		    vkCreateInstance = pAPI->vkCreateInstance;
		    vkDestroyInstance = pAPI->vkDestroyInstance;
		    vkEnumeratePhysicalDevices = pAPI->vkEnumeratePhysicalDevices;
		    vkGetPhysicalDeviceFeatures = pAPI->vkGetPhysicalDeviceFeatures;
		    vkGetPhysicalDeviceFormatProperties = pAPI->vkGetPhysicalDeviceFormatProperties;
		    vkGetPhysicalDeviceImageFormatProperties = pAPI->vkGetPhysicalDeviceImageFormatProperties;
		    vkGetPhysicalDeviceProperties = pAPI->vkGetPhysicalDeviceProperties;
		    vkGetPhysicalDeviceQueueFamilyProperties = pAPI->vkGetPhysicalDeviceQueueFamilyProperties;
		    vkGetPhysicalDeviceMemoryProperties = pAPI->vkGetPhysicalDeviceMemoryProperties;
		    vkGetInstanceProcAddr = pAPI->vkGetInstanceProcAddr;
		    vkGetDeviceProcAddr = pAPI->vkGetDeviceProcAddr;
		    vkCreateDevice = pAPI->vkCreateDevice;
		    vkDestroyDevice = pAPI->vkDestroyDevice;
		    vkEnumerateInstanceExtensionProperties = pAPI->vkEnumerateInstanceExtensionProperties;
		    vkEnumerateDeviceExtensionProperties = pAPI->vkEnumerateDeviceExtensionProperties;
		    vkEnumerateInstanceLayerProperties = pAPI->vkEnumerateInstanceLayerProperties;
		    vkEnumerateDeviceLayerProperties = pAPI->vkEnumerateDeviceLayerProperties;
		    vkGetDeviceQueue = pAPI->vkGetDeviceQueue;
		    vkQueueSubmit = pAPI->vkQueueSubmit;
		    vkQueueWaitIdle = pAPI->vkQueueWaitIdle;
		    vkDeviceWaitIdle = pAPI->vkDeviceWaitIdle;
		    vkAllocateMemory = pAPI->vkAllocateMemory;
		    vkFreeMemory = pAPI->vkFreeMemory;
		    vkMapMemory = pAPI->vkMapMemory;
		    vkUnmapMemory = pAPI->vkUnmapMemory;
		    vkFlushMappedMemoryRanges = pAPI->vkFlushMappedMemoryRanges;
		    vkInvalidateMappedMemoryRanges = pAPI->vkInvalidateMappedMemoryRanges;
		    vkGetDeviceMemoryCommitment = pAPI->vkGetDeviceMemoryCommitment;
		    vkBindBufferMemory = pAPI->vkBindBufferMemory;
		    vkBindImageMemory = pAPI->vkBindImageMemory;
		    vkGetBufferMemoryRequirements = pAPI->vkGetBufferMemoryRequirements;
		    vkGetImageMemoryRequirements = pAPI->vkGetImageMemoryRequirements;
		    vkGetImageSparseMemoryRequirements = pAPI->vkGetImageSparseMemoryRequirements;
		    vkGetPhysicalDeviceSparseImageFormatProperties = pAPI->vkGetPhysicalDeviceSparseImageFormatProperties;
		    vkQueueBindSparse = pAPI->vkQueueBindSparse;
		    vkCreateFence = pAPI->vkCreateFence;
		    vkDestroyFence = pAPI->vkDestroyFence;
		    vkResetFences = pAPI->vkResetFences;
		    vkGetFenceStatus = pAPI->vkGetFenceStatus;
		    vkWaitForFences = pAPI->vkWaitForFences;
		    vkCreateSemaphore = pAPI->vkCreateSemaphore;
		    vkDestroySemaphore = pAPI->vkDestroySemaphore;
		    vkCreateEvent = pAPI->vkCreateEvent;
		    vkDestroyEvent = pAPI->vkDestroyEvent;
		    vkGetEventStatus = pAPI->vkGetEventStatus;
		    vkSetEvent = pAPI->vkSetEvent;
		    vkResetEvent = pAPI->vkResetEvent;
		    vkCreateQueryPool = pAPI->vkCreateQueryPool;
		    vkDestroyQueryPool = pAPI->vkDestroyQueryPool;
		    vkGetQueryPoolResults = pAPI->vkGetQueryPoolResults;
		    vkCreateBuffer = pAPI->vkCreateBuffer;
		    vkDestroyBuffer = pAPI->vkDestroyBuffer;
		    vkCreateBufferView = pAPI->vkCreateBufferView;
		    vkDestroyBufferView = pAPI->vkDestroyBufferView;
		    vkCreateImage = pAPI->vkCreateImage;
		    vkDestroyImage = pAPI->vkDestroyImage;
		    vkGetImageSubresourceLayout = pAPI->vkGetImageSubresourceLayout;
		    vkCreateImageView = pAPI->vkCreateImageView;
		    vkDestroyImageView = pAPI->vkDestroyImageView;
		    vkCreateShaderModule = pAPI->vkCreateShaderModule;
		    vkDestroyShaderModule = pAPI->vkDestroyShaderModule;
		    vkCreatePipelineCache = pAPI->vkCreatePipelineCache;
		    vkDestroyPipelineCache = pAPI->vkDestroyPipelineCache;
		    vkGetPipelineCacheData = pAPI->vkGetPipelineCacheData;
		    vkMergePipelineCaches = pAPI->vkMergePipelineCaches;
		    vkCreateGraphicsPipelines = pAPI->vkCreateGraphicsPipelines;
		    vkCreateComputePipelines = pAPI->vkCreateComputePipelines;
		    vkDestroyPipeline = pAPI->vkDestroyPipeline;
		    vkCreatePipelineLayout = pAPI->vkCreatePipelineLayout;
		    vkDestroyPipelineLayout = pAPI->vkDestroyPipelineLayout;
		    vkCreateSampler = pAPI->vkCreateSampler;
		    vkDestroySampler = pAPI->vkDestroySampler;
		    vkCreateDescriptorSetLayout = pAPI->vkCreateDescriptorSetLayout;
		    vkDestroyDescriptorSetLayout = pAPI->vkDestroyDescriptorSetLayout;
		    vkCreateDescriptorPool = pAPI->vkCreateDescriptorPool;
		    vkDestroyDescriptorPool = pAPI->vkDestroyDescriptorPool;
		    vkResetDescriptorPool = pAPI->vkResetDescriptorPool;
		    vkAllocateDescriptorSets = pAPI->vkAllocateDescriptorSets;
		    vkFreeDescriptorSets = pAPI->vkFreeDescriptorSets;
		    vkUpdateDescriptorSets = pAPI->vkUpdateDescriptorSets;
		    vkCreateFramebuffer = pAPI->vkCreateFramebuffer;
		    vkDestroyFramebuffer = pAPI->vkDestroyFramebuffer;
		    vkCreateRenderPass = pAPI->vkCreateRenderPass;
		    vkDestroyRenderPass = pAPI->vkDestroyRenderPass;
		    vkGetRenderAreaGranularity = pAPI->vkGetRenderAreaGranularity;
		    vkCreateCommandPool = pAPI->vkCreateCommandPool;
		    vkDestroyCommandPool = pAPI->vkDestroyCommandPool;
		    vkResetCommandPool = pAPI->vkResetCommandPool;
		    vkAllocateCommandBuffers = pAPI->vkAllocateCommandBuffers;
		    vkFreeCommandBuffers = pAPI->vkFreeCommandBuffers;
		    vkBeginCommandBuffer = pAPI->vkBeginCommandBuffer;
		    vkEndCommandBuffer = pAPI->vkEndCommandBuffer;
		    vkResetCommandBuffer = pAPI->vkResetCommandBuffer;
		    vkCmdBindPipeline = pAPI->vkCmdBindPipeline;
		    vkCmdSetViewport = pAPI->vkCmdSetViewport;
		    vkCmdSetScissor = pAPI->vkCmdSetScissor;
		    vkCmdSetLineWidth = pAPI->vkCmdSetLineWidth;
		    vkCmdSetDepthBias = pAPI->vkCmdSetDepthBias;
		    vkCmdSetBlendConstants = pAPI->vkCmdSetBlendConstants;
		    vkCmdSetDepthBounds = pAPI->vkCmdSetDepthBounds;
		    vkCmdSetStencilCompareMask = pAPI->vkCmdSetStencilCompareMask;
		    vkCmdSetStencilWriteMask = pAPI->vkCmdSetStencilWriteMask;
		    vkCmdSetStencilReference = pAPI->vkCmdSetStencilReference;
		    vkCmdBindDescriptorSets = pAPI->vkCmdBindDescriptorSets;
		    vkCmdBindIndexBuffer = pAPI->vkCmdBindIndexBuffer;
		    vkCmdBindVertexBuffers = pAPI->vkCmdBindVertexBuffers;
		    vkCmdDraw = pAPI->vkCmdDraw;
		    vkCmdDrawIndexed = pAPI->vkCmdDrawIndexed;
		    vkCmdDrawIndirect = pAPI->vkCmdDrawIndirect;
		    vkCmdDrawIndexedIndirect = pAPI->vkCmdDrawIndexedIndirect;
		    vkCmdDispatch = pAPI->vkCmdDispatch;
		    vkCmdDispatchIndirect = pAPI->vkCmdDispatchIndirect;
		    vkCmdCopyBuffer = pAPI->vkCmdCopyBuffer;
		    vkCmdCopyImage = pAPI->vkCmdCopyImage;
		    vkCmdBlitImage = pAPI->vkCmdBlitImage;
		    vkCmdCopyBufferToImage = pAPI->vkCmdCopyBufferToImage;
		    vkCmdCopyImageToBuffer = pAPI->vkCmdCopyImageToBuffer;
		    vkCmdUpdateBuffer = pAPI->vkCmdUpdateBuffer;
		    vkCmdFillBuffer = pAPI->vkCmdFillBuffer;
		    vkCmdClearColorImage = pAPI->vkCmdClearColorImage;
		    vkCmdClearDepthStencilImage = pAPI->vkCmdClearDepthStencilImage;
		    vkCmdClearAttachments = pAPI->vkCmdClearAttachments;
		    vkCmdResolveImage = pAPI->vkCmdResolveImage;
		    vkCmdSetEvent = pAPI->vkCmdSetEvent;
		    vkCmdResetEvent = pAPI->vkCmdResetEvent;
		    vkCmdWaitEvents = pAPI->vkCmdWaitEvents;
		    vkCmdPipelineBarrier = pAPI->vkCmdPipelineBarrier;
		    vkCmdBeginQuery = pAPI->vkCmdBeginQuery;
		    vkCmdEndQuery = pAPI->vkCmdEndQuery;
		    vkCmdResetQueryPool = pAPI->vkCmdResetQueryPool;
		    vkCmdWriteTimestamp = pAPI->vkCmdWriteTimestamp;
		    vkCmdCopyQueryPoolResults = pAPI->vkCmdCopyQueryPoolResults;
		    vkCmdPushConstants = pAPI->vkCmdPushConstants;
		    vkCmdBeginRenderPass = pAPI->vkCmdBeginRenderPass;
		    vkCmdNextSubpass = pAPI->vkCmdNextSubpass;
		    vkCmdEndRenderPass = pAPI->vkCmdEndRenderPass;
		    vkCmdExecuteCommands = pAPI->vkCmdExecuteCommands;
		    vkEnumerateInstanceVersion = pAPI->vkEnumerateInstanceVersion;
		    vkBindBufferMemory2 = pAPI->vkBindBufferMemory2;
		    vkBindImageMemory2 = pAPI->vkBindImageMemory2;
		    vkGetDeviceGroupPeerMemoryFeatures = pAPI->vkGetDeviceGroupPeerMemoryFeatures;
		    vkCmdSetDeviceMask = pAPI->vkCmdSetDeviceMask;
		    vkCmdDispatchBase = pAPI->vkCmdDispatchBase;
		    vkEnumeratePhysicalDeviceGroups = pAPI->vkEnumeratePhysicalDeviceGroups;
		    vkGetImageMemoryRequirements2 = pAPI->vkGetImageMemoryRequirements2;
		    vkGetBufferMemoryRequirements2 = pAPI->vkGetBufferMemoryRequirements2;
		    vkGetImageSparseMemoryRequirements2 = pAPI->vkGetImageSparseMemoryRequirements2;
		    vkGetPhysicalDeviceFeatures2 = pAPI->vkGetPhysicalDeviceFeatures2;
		    vkGetPhysicalDeviceProperties2 = pAPI->vkGetPhysicalDeviceProperties2;
		    vkGetPhysicalDeviceFormatProperties2 = pAPI->vkGetPhysicalDeviceFormatProperties2;
		    vkGetPhysicalDeviceImageFormatProperties2 = pAPI->vkGetPhysicalDeviceImageFormatProperties2;
		    vkGetPhysicalDeviceQueueFamilyProperties2 = pAPI->vkGetPhysicalDeviceQueueFamilyProperties2;
		    vkGetPhysicalDeviceMemoryProperties2 = pAPI->vkGetPhysicalDeviceMemoryProperties2;
		    vkGetPhysicalDeviceSparseImageFormatProperties2 = pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2;
		    vkTrimCommandPool = pAPI->vkTrimCommandPool;
		    vkGetDeviceQueue2 = pAPI->vkGetDeviceQueue2;
		    vkCreateSamplerYcbcrConversion = pAPI->vkCreateSamplerYcbcrConversion;
		    vkDestroySamplerYcbcrConversion = pAPI->vkDestroySamplerYcbcrConversion;
		    vkCreateDescriptorUpdateTemplate = pAPI->vkCreateDescriptorUpdateTemplate;
		    vkDestroyDescriptorUpdateTemplate = pAPI->vkDestroyDescriptorUpdateTemplate;
		    vkUpdateDescriptorSetWithTemplate = pAPI->vkUpdateDescriptorSetWithTemplate;
		    vkGetPhysicalDeviceExternalBufferProperties = pAPI->vkGetPhysicalDeviceExternalBufferProperties;
		    vkGetPhysicalDeviceExternalFenceProperties = pAPI->vkGetPhysicalDeviceExternalFenceProperties;
		    vkGetPhysicalDeviceExternalSemaphoreProperties = pAPI->vkGetPhysicalDeviceExternalSemaphoreProperties;
		    vkGetDescriptorSetLayoutSupport = pAPI->vkGetDescriptorSetLayoutSupport;
		    vkCmdDrawIndirectCount = pAPI->vkCmdDrawIndirectCount;
		    vkCmdDrawIndexedIndirectCount = pAPI->vkCmdDrawIndexedIndirectCount;
		    vkCreateRenderPass2 = pAPI->vkCreateRenderPass2;
		    vkCmdBeginRenderPass2 = pAPI->vkCmdBeginRenderPass2;
		    vkCmdNextSubpass2 = pAPI->vkCmdNextSubpass2;
		    vkCmdEndRenderPass2 = pAPI->vkCmdEndRenderPass2;
		    vkResetQueryPool = pAPI->vkResetQueryPool;
		    vkGetSemaphoreCounterValue = pAPI->vkGetSemaphoreCounterValue;
		    vkWaitSemaphores = pAPI->vkWaitSemaphores;
		    vkSignalSemaphore = pAPI->vkSignalSemaphore;
		    vkGetBufferDeviceAddress = pAPI->vkGetBufferDeviceAddress;
		    vkGetBufferOpaqueCaptureAddress = pAPI->vkGetBufferOpaqueCaptureAddress;
		    vkGetDeviceMemoryOpaqueCaptureAddress = pAPI->vkGetDeviceMemoryOpaqueCaptureAddress;
		    vkGetPhysicalDeviceToolProperties = pAPI->vkGetPhysicalDeviceToolProperties;
		    vkCreatePrivateDataSlot = pAPI->vkCreatePrivateDataSlot;
		    vkDestroyPrivateDataSlot = pAPI->vkDestroyPrivateDataSlot;
		    vkSetPrivateData = pAPI->vkSetPrivateData;
		    vkGetPrivateData = pAPI->vkGetPrivateData;
		    vkCmdSetEvent2 = pAPI->vkCmdSetEvent2;
		    vkCmdResetEvent2 = pAPI->vkCmdResetEvent2;
		    vkCmdWaitEvents2 = pAPI->vkCmdWaitEvents2;
		    vkCmdPipelineBarrier2 = pAPI->vkCmdPipelineBarrier2;
		    vkCmdWriteTimestamp2 = pAPI->vkCmdWriteTimestamp2;
		    vkQueueSubmit2 = pAPI->vkQueueSubmit2;
		    vkCmdCopyBuffer2 = pAPI->vkCmdCopyBuffer2;
		    vkCmdCopyImage2 = pAPI->vkCmdCopyImage2;
		    vkCmdCopyBufferToImage2 = pAPI->vkCmdCopyBufferToImage2;
		    vkCmdCopyImageToBuffer2 = pAPI->vkCmdCopyImageToBuffer2;
		    vkCmdBlitImage2 = pAPI->vkCmdBlitImage2;
		    vkCmdResolveImage2 = pAPI->vkCmdResolveImage2;
		    vkCmdBeginRendering = pAPI->vkCmdBeginRendering;
		    vkCmdEndRendering = pAPI->vkCmdEndRendering;
		    vkCmdSetCullMode = pAPI->vkCmdSetCullMode;
		    vkCmdSetFrontFace = pAPI->vkCmdSetFrontFace;
		    vkCmdSetPrimitiveTopology = pAPI->vkCmdSetPrimitiveTopology;
		    vkCmdSetViewportWithCount = pAPI->vkCmdSetViewportWithCount;
		    vkCmdSetScissorWithCount = pAPI->vkCmdSetScissorWithCount;
		    vkCmdBindVertexBuffers2 = pAPI->vkCmdBindVertexBuffers2;
		    vkCmdSetDepthTestEnable = pAPI->vkCmdSetDepthTestEnable;
		    vkCmdSetDepthWriteEnable = pAPI->vkCmdSetDepthWriteEnable;
		    vkCmdSetDepthCompareOp = pAPI->vkCmdSetDepthCompareOp;
		    vkCmdSetDepthBoundsTestEnable = pAPI->vkCmdSetDepthBoundsTestEnable;
		    vkCmdSetStencilTestEnable = pAPI->vkCmdSetStencilTestEnable;
		    vkCmdSetStencilOp = pAPI->vkCmdSetStencilOp;
		    vkCmdSetRasterizerDiscardEnable = pAPI->vkCmdSetRasterizerDiscardEnable;
		    vkCmdSetDepthBiasEnable = pAPI->vkCmdSetDepthBiasEnable;
		    vkCmdSetPrimitiveRestartEnable = pAPI->vkCmdSetPrimitiveRestartEnable;
		    vkGetDeviceBufferMemoryRequirements = pAPI->vkGetDeviceBufferMemoryRequirements;
		    vkGetDeviceImageMemoryRequirements = pAPI->vkGetDeviceImageMemoryRequirements;
		    vkGetDeviceImageSparseMemoryRequirements = pAPI->vkGetDeviceImageSparseMemoryRequirements;
		    vkGetCommandPoolMemoryConsumption = pAPI->vkGetCommandPoolMemoryConsumption;
		    vkGetFaultData = pAPI->vkGetFaultData;
		    vkDestroySurfaceKHR = pAPI->vkDestroySurfaceKHR;
		    vkGetPhysicalDeviceSurfaceSupportKHR = pAPI->vkGetPhysicalDeviceSurfaceSupportKHR;
		    vkGetPhysicalDeviceSurfaceCapabilitiesKHR = pAPI->vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
		    vkGetPhysicalDeviceSurfaceFormatsKHR = pAPI->vkGetPhysicalDeviceSurfaceFormatsKHR;
		    vkGetPhysicalDeviceSurfacePresentModesKHR = pAPI->vkGetPhysicalDeviceSurfacePresentModesKHR;
		    vkCreateSwapchainKHR = pAPI->vkCreateSwapchainKHR;
		    vkDestroySwapchainKHR = pAPI->vkDestroySwapchainKHR;
		    vkGetSwapchainImagesKHR = pAPI->vkGetSwapchainImagesKHR;
		    vkAcquireNextImageKHR = pAPI->vkAcquireNextImageKHR;
		    vkQueuePresentKHR = pAPI->vkQueuePresentKHR;
		    vkGetDeviceGroupPresentCapabilitiesKHR = pAPI->vkGetDeviceGroupPresentCapabilitiesKHR;
		    vkGetDeviceGroupSurfacePresentModesKHR = pAPI->vkGetDeviceGroupSurfacePresentModesKHR;
		    vkGetPhysicalDevicePresentRectanglesKHR = pAPI->vkGetPhysicalDevicePresentRectanglesKHR;
		    vkAcquireNextImage2KHR = pAPI->vkAcquireNextImage2KHR;
		    vkGetPhysicalDeviceDisplayPropertiesKHR = pAPI->vkGetPhysicalDeviceDisplayPropertiesKHR;
		    vkGetPhysicalDeviceDisplayPlanePropertiesKHR = pAPI->vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
		    vkGetDisplayPlaneSupportedDisplaysKHR = pAPI->vkGetDisplayPlaneSupportedDisplaysKHR;
		    vkGetDisplayModePropertiesKHR = pAPI->vkGetDisplayModePropertiesKHR;
		    vkCreateDisplayModeKHR = pAPI->vkCreateDisplayModeKHR;
		    vkGetDisplayPlaneCapabilitiesKHR = pAPI->vkGetDisplayPlaneCapabilitiesKHR;
		    vkCreateDisplayPlaneSurfaceKHR = pAPI->vkCreateDisplayPlaneSurfaceKHR;
		    vkCreateSharedSwapchainsKHR = pAPI->vkCreateSharedSwapchainsKHR;
		    vkGetPhysicalDeviceVideoCapabilitiesKHR = pAPI->vkGetPhysicalDeviceVideoCapabilitiesKHR;
		    vkGetPhysicalDeviceVideoFormatPropertiesKHR = pAPI->vkGetPhysicalDeviceVideoFormatPropertiesKHR;
		    vkCreateVideoSessionKHR = pAPI->vkCreateVideoSessionKHR;
		    vkDestroyVideoSessionKHR = pAPI->vkDestroyVideoSessionKHR;
		    vkGetVideoSessionMemoryRequirementsKHR = pAPI->vkGetVideoSessionMemoryRequirementsKHR;
		    vkBindVideoSessionMemoryKHR = pAPI->vkBindVideoSessionMemoryKHR;
		    vkCreateVideoSessionParametersKHR = pAPI->vkCreateVideoSessionParametersKHR;
		    vkUpdateVideoSessionParametersKHR = pAPI->vkUpdateVideoSessionParametersKHR;
		    vkDestroyVideoSessionParametersKHR = pAPI->vkDestroyVideoSessionParametersKHR;
		    vkCmdBeginVideoCodingKHR = pAPI->vkCmdBeginVideoCodingKHR;
		    vkCmdEndVideoCodingKHR = pAPI->vkCmdEndVideoCodingKHR;
		    vkCmdControlVideoCodingKHR = pAPI->vkCmdControlVideoCodingKHR;
		    vkCmdDecodeVideoKHR = pAPI->vkCmdDecodeVideoKHR;
		    vkCmdBindTransformFeedbackBuffersEXT = pAPI->vkCmdBindTransformFeedbackBuffersEXT;
		    vkCmdBeginTransformFeedbackEXT = pAPI->vkCmdBeginTransformFeedbackEXT;
		    vkCmdEndTransformFeedbackEXT = pAPI->vkCmdEndTransformFeedbackEXT;
		    vkCmdBeginQueryIndexedEXT = pAPI->vkCmdBeginQueryIndexedEXT;
		    vkCmdEndQueryIndexedEXT = pAPI->vkCmdEndQueryIndexedEXT;
		    vkCmdDrawIndirectByteCountEXT = pAPI->vkCmdDrawIndirectByteCountEXT;
		    vkCreateCuModuleNVX = pAPI->vkCreateCuModuleNVX;
		    vkCreateCuFunctionNVX = pAPI->vkCreateCuFunctionNVX;
		    vkDestroyCuModuleNVX = pAPI->vkDestroyCuModuleNVX;
		    vkDestroyCuFunctionNVX = pAPI->vkDestroyCuFunctionNVX;
		    vkCmdCuLaunchKernelNVX = pAPI->vkCmdCuLaunchKernelNVX;
		    vkGetImageViewHandleNVX = pAPI->vkGetImageViewHandleNVX;
		    vkGetImageViewAddressNVX = pAPI->vkGetImageViewAddressNVX;
		    vkGetShaderInfoAMD = pAPI->vkGetShaderInfoAMD;
		    vkCmdBeginRenderingKHR = pAPI->vkCmdBeginRenderingKHR;
		    vkCmdEndRenderingKHR = pAPI->vkCmdEndRenderingKHR;
		    vkGetPhysicalDeviceFeatures2KHR = pAPI->vkGetPhysicalDeviceFeatures2KHR;
		    vkGetPhysicalDeviceProperties2KHR = pAPI->vkGetPhysicalDeviceProperties2KHR;
		    vkGetPhysicalDeviceFormatProperties2KHR = pAPI->vkGetPhysicalDeviceFormatProperties2KHR;
		    vkGetPhysicalDeviceImageFormatProperties2KHR = pAPI->vkGetPhysicalDeviceImageFormatProperties2KHR;
		    vkGetPhysicalDeviceQueueFamilyProperties2KHR = pAPI->vkGetPhysicalDeviceQueueFamilyProperties2KHR;
		    vkGetPhysicalDeviceMemoryProperties2KHR = pAPI->vkGetPhysicalDeviceMemoryProperties2KHR;
		    vkGetPhysicalDeviceSparseImageFormatProperties2KHR = pAPI->vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
		    vkGetDeviceGroupPeerMemoryFeaturesKHR = pAPI->vkGetDeviceGroupPeerMemoryFeaturesKHR;
		    vkCmdSetDeviceMaskKHR = pAPI->vkCmdSetDeviceMaskKHR;
		    vkCmdDispatchBaseKHR = pAPI->vkCmdDispatchBaseKHR;
		    vkTrimCommandPoolKHR = pAPI->vkTrimCommandPoolKHR;
		    vkEnumeratePhysicalDeviceGroupsKHR = pAPI->vkEnumeratePhysicalDeviceGroupsKHR;
		    vkGetPhysicalDeviceExternalBufferPropertiesKHR = pAPI->vkGetPhysicalDeviceExternalBufferPropertiesKHR;
		    vkGetPhysicalDeviceExternalImageFormatPropertiesNV = pAPI->vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
		    vkGetMemoryFdKHR = pAPI->vkGetMemoryFdKHR;
		    vkGetMemoryFdPropertiesKHR = pAPI->vkGetMemoryFdPropertiesKHR;
		    vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = pAPI->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
		    vkImportSemaphoreFdKHR = pAPI->vkImportSemaphoreFdKHR;
		    vkGetSemaphoreFdKHR = pAPI->vkGetSemaphoreFdKHR;
		    vkCmdPushDescriptorSetKHR = pAPI->vkCmdPushDescriptorSetKHR;
		    vkCmdPushDescriptorSetWithTemplateKHR = pAPI->vkCmdPushDescriptorSetWithTemplateKHR;
		    vkCmdBeginConditionalRenderingEXT = pAPI->vkCmdBeginConditionalRenderingEXT;
		    vkCmdEndConditionalRenderingEXT = pAPI->vkCmdEndConditionalRenderingEXT;
		    vkCreateDescriptorUpdateTemplateKHR = pAPI->vkCreateDescriptorUpdateTemplateKHR;
		    vkDestroyDescriptorUpdateTemplateKHR = pAPI->vkDestroyDescriptorUpdateTemplateKHR;
		    vkUpdateDescriptorSetWithTemplateKHR = pAPI->vkUpdateDescriptorSetWithTemplateKHR;
		    vkCmdSetViewportWScalingNV = pAPI->vkCmdSetViewportWScalingNV;
		    vkReleaseDisplayEXT = pAPI->vkReleaseDisplayEXT;
		    vkGetPhysicalDeviceSurfaceCapabilities2EXT = pAPI->vkGetPhysicalDeviceSurfaceCapabilities2EXT;
		    vkDisplayPowerControlEXT = pAPI->vkDisplayPowerControlEXT;
		    vkRegisterDeviceEventEXT = pAPI->vkRegisterDeviceEventEXT;
		    vkRegisterDisplayEventEXT = pAPI->vkRegisterDisplayEventEXT;
		    vkGetSwapchainCounterEXT = pAPI->vkGetSwapchainCounterEXT;
		    vkGetRefreshCycleDurationGOOGLE = pAPI->vkGetRefreshCycleDurationGOOGLE;
		    vkGetPastPresentationTimingGOOGLE = pAPI->vkGetPastPresentationTimingGOOGLE;
		    vkCmdSetDiscardRectangleEXT = pAPI->vkCmdSetDiscardRectangleEXT;
		    vkCmdSetDiscardRectangleEnableEXT = pAPI->vkCmdSetDiscardRectangleEnableEXT;
		    vkCmdSetDiscardRectangleModeEXT = pAPI->vkCmdSetDiscardRectangleModeEXT;
		    vkSetHdrMetadataEXT = pAPI->vkSetHdrMetadataEXT;
		    vkCreateRenderPass2KHR = pAPI->vkCreateRenderPass2KHR;
		    vkCmdBeginRenderPass2KHR = pAPI->vkCmdBeginRenderPass2KHR;
		    vkCmdNextSubpass2KHR = pAPI->vkCmdNextSubpass2KHR;
		    vkCmdEndRenderPass2KHR = pAPI->vkCmdEndRenderPass2KHR;
		    vkGetSwapchainStatusKHR = pAPI->vkGetSwapchainStatusKHR;
		    vkGetPhysicalDeviceExternalFencePropertiesKHR = pAPI->vkGetPhysicalDeviceExternalFencePropertiesKHR;
		    vkImportFenceFdKHR = pAPI->vkImportFenceFdKHR;
		    vkGetFenceFdKHR = pAPI->vkGetFenceFdKHR;
		    vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = pAPI->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
		    vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = pAPI->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
		    vkAcquireProfilingLockKHR = pAPI->vkAcquireProfilingLockKHR;
		    vkReleaseProfilingLockKHR = pAPI->vkReleaseProfilingLockKHR;
		    vkGetPhysicalDeviceSurfaceCapabilities2KHR = pAPI->vkGetPhysicalDeviceSurfaceCapabilities2KHR;
		    vkGetPhysicalDeviceSurfaceFormats2KHR = pAPI->vkGetPhysicalDeviceSurfaceFormats2KHR;
		    vkGetPhysicalDeviceDisplayProperties2KHR = pAPI->vkGetPhysicalDeviceDisplayProperties2KHR;
		    vkGetPhysicalDeviceDisplayPlaneProperties2KHR = pAPI->vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
		    vkGetDisplayModeProperties2KHR = pAPI->vkGetDisplayModeProperties2KHR;
		    vkGetDisplayPlaneCapabilities2KHR = pAPI->vkGetDisplayPlaneCapabilities2KHR;
		    vkSetDebugUtilsObjectNameEXT = pAPI->vkSetDebugUtilsObjectNameEXT;
		    vkSetDebugUtilsObjectTagEXT = pAPI->vkSetDebugUtilsObjectTagEXT;
		    vkQueueBeginDebugUtilsLabelEXT = pAPI->vkQueueBeginDebugUtilsLabelEXT;
		    vkQueueEndDebugUtilsLabelEXT = pAPI->vkQueueEndDebugUtilsLabelEXT;
		    vkQueueInsertDebugUtilsLabelEXT = pAPI->vkQueueInsertDebugUtilsLabelEXT;
		    vkCmdBeginDebugUtilsLabelEXT = pAPI->vkCmdBeginDebugUtilsLabelEXT;
		    vkCmdEndDebugUtilsLabelEXT = pAPI->vkCmdEndDebugUtilsLabelEXT;
		    vkCmdInsertDebugUtilsLabelEXT = pAPI->vkCmdInsertDebugUtilsLabelEXT;
		    vkCreateDebugUtilsMessengerEXT = pAPI->vkCreateDebugUtilsMessengerEXT;
		    vkDestroyDebugUtilsMessengerEXT = pAPI->vkDestroyDebugUtilsMessengerEXT;
		    vkSubmitDebugUtilsMessageEXT = pAPI->vkSubmitDebugUtilsMessageEXT;
		    vkDebugMarkerSetObjectTagEXT = pAPI->vkDebugMarkerSetObjectTagEXT;
		    vkDebugMarkerSetObjectNameEXT = pAPI->vkDebugMarkerSetObjectNameEXT;
		    vkCmdDebugMarkerBeginEXT = pAPI->vkCmdDebugMarkerBeginEXT;
		    vkCmdDebugMarkerEndEXT = pAPI->vkCmdDebugMarkerEndEXT;
		    vkCmdDebugMarkerInsertEXT = pAPI->vkCmdDebugMarkerInsertEXT;
		    vkCreateDebugReportCallbackEXT = pAPI->vkCreateDebugReportCallbackEXT;
		    vkDestroyDebugReportCallbackEXT = pAPI->vkDestroyDebugReportCallbackEXT;
		    vkDebugReportMessageEXT = pAPI->vkDebugReportMessageEXT;
		    vkCmdSetSampleLocationsEXT = pAPI->vkCmdSetSampleLocationsEXT;
		    vkGetPhysicalDeviceMultisamplePropertiesEXT = pAPI->vkGetPhysicalDeviceMultisamplePropertiesEXT;
		    vkGetImageMemoryRequirements2KHR = pAPI->vkGetImageMemoryRequirements2KHR;
		    vkGetBufferMemoryRequirements2KHR = pAPI->vkGetBufferMemoryRequirements2KHR;
		    vkGetImageSparseMemoryRequirements2KHR = pAPI->vkGetImageSparseMemoryRequirements2KHR;
		    vkCreateAccelerationStructureKHR = pAPI->vkCreateAccelerationStructureKHR;
		    vkDestroyAccelerationStructureKHR = pAPI->vkDestroyAccelerationStructureKHR;
		    vkCmdBuildAccelerationStructuresKHR = pAPI->vkCmdBuildAccelerationStructuresKHR;
		    vkCmdBuildAccelerationStructuresIndirectKHR = pAPI->vkCmdBuildAccelerationStructuresIndirectKHR;
		    vkBuildAccelerationStructuresKHR = pAPI->vkBuildAccelerationStructuresKHR;
		    vkCopyAccelerationStructureKHR = pAPI->vkCopyAccelerationStructureKHR;
		    vkCopyAccelerationStructureToMemoryKHR = pAPI->vkCopyAccelerationStructureToMemoryKHR;
		    vkCopyMemoryToAccelerationStructureKHR = pAPI->vkCopyMemoryToAccelerationStructureKHR;
		    vkWriteAccelerationStructuresPropertiesKHR = pAPI->vkWriteAccelerationStructuresPropertiesKHR;
		    vkCmdCopyAccelerationStructureKHR = pAPI->vkCmdCopyAccelerationStructureKHR;
		    vkCmdCopyAccelerationStructureToMemoryKHR = pAPI->vkCmdCopyAccelerationStructureToMemoryKHR;
		    vkCmdCopyMemoryToAccelerationStructureKHR = pAPI->vkCmdCopyMemoryToAccelerationStructureKHR;
		    vkGetAccelerationStructureDeviceAddressKHR = pAPI->vkGetAccelerationStructureDeviceAddressKHR;
		    vkCmdWriteAccelerationStructuresPropertiesKHR = pAPI->vkCmdWriteAccelerationStructuresPropertiesKHR;
		    vkGetDeviceAccelerationStructureCompatibilityKHR = pAPI->vkGetDeviceAccelerationStructureCompatibilityKHR;
		    vkGetAccelerationStructureBuildSizesKHR = pAPI->vkGetAccelerationStructureBuildSizesKHR;
		    vkCmdTraceRaysKHR = pAPI->vkCmdTraceRaysKHR;
		    vkCreateRayTracingPipelinesKHR = pAPI->vkCreateRayTracingPipelinesKHR;
		    vkGetRayTracingShaderGroupHandlesKHR = pAPI->vkGetRayTracingShaderGroupHandlesKHR;
		    vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = pAPI->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
		    vkCmdTraceRaysIndirectKHR = pAPI->vkCmdTraceRaysIndirectKHR;
		    vkGetRayTracingShaderGroupStackSizeKHR = pAPI->vkGetRayTracingShaderGroupStackSizeKHR;
		    vkCmdSetRayTracingPipelineStackSizeKHR = pAPI->vkCmdSetRayTracingPipelineStackSizeKHR;
		    vkCreateSamplerYcbcrConversionKHR = pAPI->vkCreateSamplerYcbcrConversionKHR;
		    vkDestroySamplerYcbcrConversionKHR = pAPI->vkDestroySamplerYcbcrConversionKHR;
		    vkBindBufferMemory2KHR = pAPI->vkBindBufferMemory2KHR;
		    vkBindImageMemory2KHR = pAPI->vkBindImageMemory2KHR;
		    vkGetImageDrmFormatModifierPropertiesEXT = pAPI->vkGetImageDrmFormatModifierPropertiesEXT;
		    vkCreateValidationCacheEXT = pAPI->vkCreateValidationCacheEXT;
		    vkDestroyValidationCacheEXT = pAPI->vkDestroyValidationCacheEXT;
		    vkMergeValidationCachesEXT = pAPI->vkMergeValidationCachesEXT;
		    vkGetValidationCacheDataEXT = pAPI->vkGetValidationCacheDataEXT;
		    vkCmdBindShadingRateImageNV = pAPI->vkCmdBindShadingRateImageNV;
		    vkCmdSetViewportShadingRatePaletteNV = pAPI->vkCmdSetViewportShadingRatePaletteNV;
		    vkCmdSetCoarseSampleOrderNV = pAPI->vkCmdSetCoarseSampleOrderNV;
		    vkCreateAccelerationStructureNV = pAPI->vkCreateAccelerationStructureNV;
		    vkDestroyAccelerationStructureNV = pAPI->vkDestroyAccelerationStructureNV;
		    vkGetAccelerationStructureMemoryRequirementsNV = pAPI->vkGetAccelerationStructureMemoryRequirementsNV;
		    vkBindAccelerationStructureMemoryNV = pAPI->vkBindAccelerationStructureMemoryNV;
		    vkCmdBuildAccelerationStructureNV = pAPI->vkCmdBuildAccelerationStructureNV;
		    vkCmdCopyAccelerationStructureNV = pAPI->vkCmdCopyAccelerationStructureNV;
		    vkCmdTraceRaysNV = pAPI->vkCmdTraceRaysNV;
		    vkCreateRayTracingPipelinesNV = pAPI->vkCreateRayTracingPipelinesNV;
		    vkGetRayTracingShaderGroupHandlesNV = pAPI->vkGetRayTracingShaderGroupHandlesNV;
		    vkGetAccelerationStructureHandleNV = pAPI->vkGetAccelerationStructureHandleNV;
		    vkCmdWriteAccelerationStructuresPropertiesNV = pAPI->vkCmdWriteAccelerationStructuresPropertiesNV;
		    vkCompileDeferredNV = pAPI->vkCompileDeferredNV;
		    vkGetDescriptorSetLayoutSupportKHR = pAPI->vkGetDescriptorSetLayoutSupportKHR;
		    vkCmdDrawIndirectCountKHR = pAPI->vkCmdDrawIndirectCountKHR;
		    vkCmdDrawIndexedIndirectCountKHR = pAPI->vkCmdDrawIndexedIndirectCountKHR;
		    vkCmdDrawIndirectCountAMD = pAPI->vkCmdDrawIndirectCountAMD;
		    vkCmdDrawIndexedIndirectCountAMD = pAPI->vkCmdDrawIndexedIndirectCountAMD;
		    vkGetMemoryHostPointerPropertiesEXT = pAPI->vkGetMemoryHostPointerPropertiesEXT;
		    vkCmdWriteBufferMarkerAMD = pAPI->vkCmdWriteBufferMarkerAMD;
		    vkCmdDrawMeshTasksNV = pAPI->vkCmdDrawMeshTasksNV;
		    vkCmdDrawMeshTasksIndirectNV = pAPI->vkCmdDrawMeshTasksIndirectNV;
		    vkCmdDrawMeshTasksIndirectCountNV = pAPI->vkCmdDrawMeshTasksIndirectCountNV;
		    vkCmdSetExclusiveScissorEnableNV = pAPI->vkCmdSetExclusiveScissorEnableNV;
		    vkCmdSetExclusiveScissorNV = pAPI->vkCmdSetExclusiveScissorNV;
		    vkCmdSetCheckpointNV = pAPI->vkCmdSetCheckpointNV;
		    vkGetQueueCheckpointDataNV = pAPI->vkGetQueueCheckpointDataNV;
		    vkGetSemaphoreCounterValueKHR = pAPI->vkGetSemaphoreCounterValueKHR;
		    vkWaitSemaphoresKHR = pAPI->vkWaitSemaphoresKHR;
		    vkSignalSemaphoreKHR = pAPI->vkSignalSemaphoreKHR;
		    vkInitializePerformanceApiINTEL = pAPI->vkInitializePerformanceApiINTEL;
		    vkUninitializePerformanceApiINTEL = pAPI->vkUninitializePerformanceApiINTEL;
		    vkCmdSetPerformanceMarkerINTEL = pAPI->vkCmdSetPerformanceMarkerINTEL;
		    vkCmdSetPerformanceStreamMarkerINTEL = pAPI->vkCmdSetPerformanceStreamMarkerINTEL;
		    vkCmdSetPerformanceOverrideINTEL = pAPI->vkCmdSetPerformanceOverrideINTEL;
		    vkAcquirePerformanceConfigurationINTEL = pAPI->vkAcquirePerformanceConfigurationINTEL;
		    vkReleasePerformanceConfigurationINTEL = pAPI->vkReleasePerformanceConfigurationINTEL;
		    vkQueueSetPerformanceConfigurationINTEL = pAPI->vkQueueSetPerformanceConfigurationINTEL;
		    vkGetPerformanceParameterINTEL = pAPI->vkGetPerformanceParameterINTEL;
		    vkSetLocalDimmingAMD = pAPI->vkSetLocalDimmingAMD;
		    vkGetPhysicalDeviceFragmentShadingRatesKHR = pAPI->vkGetPhysicalDeviceFragmentShadingRatesKHR;
		    vkCmdSetFragmentShadingRateKHR = pAPI->vkCmdSetFragmentShadingRateKHR;
		    vkCmdSetRenderingAttachmentLocationsKHR = pAPI->vkCmdSetRenderingAttachmentLocationsKHR;
		    vkCmdSetRenderingInputAttachmentIndicesKHR = pAPI->vkCmdSetRenderingInputAttachmentIndicesKHR;
		    vkGetPhysicalDeviceToolPropertiesEXT = pAPI->vkGetPhysicalDeviceToolPropertiesEXT;
		    vkWaitForPresentKHR = pAPI->vkWaitForPresentKHR;
		    vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV;
		    vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = pAPI->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
		    vkCreateHeadlessSurfaceEXT = pAPI->vkCreateHeadlessSurfaceEXT;
		    vkGetBufferDeviceAddressKHR = pAPI->vkGetBufferDeviceAddressKHR;
		    vkGetBufferOpaqueCaptureAddressKHR = pAPI->vkGetBufferOpaqueCaptureAddressKHR;
		    vkGetDeviceMemoryOpaqueCaptureAddressKHR = pAPI->vkGetDeviceMemoryOpaqueCaptureAddressKHR;
		    vkGetBufferDeviceAddressEXT = pAPI->vkGetBufferDeviceAddressEXT;
		    vkResetQueryPoolEXT = pAPI->vkResetQueryPoolEXT;
		    vkCmdSetCullModeEXT = pAPI->vkCmdSetCullModeEXT;
		    vkCmdSetFrontFaceEXT = pAPI->vkCmdSetFrontFaceEXT;
		    vkCmdSetPrimitiveTopologyEXT = pAPI->vkCmdSetPrimitiveTopologyEXT;
		    vkCmdSetViewportWithCountEXT = pAPI->vkCmdSetViewportWithCountEXT;
		    vkCmdSetScissorWithCountEXT = pAPI->vkCmdSetScissorWithCountEXT;
		    vkCmdBindVertexBuffers2EXT = pAPI->vkCmdBindVertexBuffers2EXT;
		    vkCmdSetDepthTestEnableEXT = pAPI->vkCmdSetDepthTestEnableEXT;
		    vkCmdSetDepthWriteEnableEXT = pAPI->vkCmdSetDepthWriteEnableEXT;
		    vkCmdSetDepthCompareOpEXT = pAPI->vkCmdSetDepthCompareOpEXT;
		    vkCmdSetDepthBoundsTestEnableEXT = pAPI->vkCmdSetDepthBoundsTestEnableEXT;
		    vkCmdSetStencilTestEnableEXT = pAPI->vkCmdSetStencilTestEnableEXT;
		    vkCmdSetStencilOpEXT = pAPI->vkCmdSetStencilOpEXT;
		    vkCreateDeferredOperationKHR = pAPI->vkCreateDeferredOperationKHR;
		    vkDestroyDeferredOperationKHR = pAPI->vkDestroyDeferredOperationKHR;
		    vkGetDeferredOperationMaxConcurrencyKHR = pAPI->vkGetDeferredOperationMaxConcurrencyKHR;
		    vkGetDeferredOperationResultKHR = pAPI->vkGetDeferredOperationResultKHR;
		    vkDeferredOperationJoinKHR = pAPI->vkDeferredOperationJoinKHR;
		    vkGetPipelineExecutablePropertiesKHR = pAPI->vkGetPipelineExecutablePropertiesKHR;
		    vkGetPipelineExecutableStatisticsKHR = pAPI->vkGetPipelineExecutableStatisticsKHR;
		    vkGetPipelineExecutableInternalRepresentationsKHR = pAPI->vkGetPipelineExecutableInternalRepresentationsKHR;
		    vkCopyMemoryToImageEXT = pAPI->vkCopyMemoryToImageEXT;
		    vkCopyImageToMemoryEXT = pAPI->vkCopyImageToMemoryEXT;
		    vkCopyImageToImageEXT = pAPI->vkCopyImageToImageEXT;
		    vkTransitionImageLayoutEXT = pAPI->vkTransitionImageLayoutEXT;
		    vkGetImageSubresourceLayout2EXT = pAPI->vkGetImageSubresourceLayout2EXT;
		    vkMapMemory2KHR = pAPI->vkMapMemory2KHR;
		    vkUnmapMemory2KHR = pAPI->vkUnmapMemory2KHR;
		    vkReleaseSwapchainImagesEXT = pAPI->vkReleaseSwapchainImagesEXT;
		    vkGetGeneratedCommandsMemoryRequirementsNV = pAPI->vkGetGeneratedCommandsMemoryRequirementsNV;
		    vkCmdPreprocessGeneratedCommandsNV = pAPI->vkCmdPreprocessGeneratedCommandsNV;
		    vkCmdExecuteGeneratedCommandsNV = pAPI->vkCmdExecuteGeneratedCommandsNV;
		    vkCmdBindPipelineShaderGroupNV = pAPI->vkCmdBindPipelineShaderGroupNV;
		    vkCreateIndirectCommandsLayoutNV = pAPI->vkCreateIndirectCommandsLayoutNV;
		    vkDestroyIndirectCommandsLayoutNV = pAPI->vkDestroyIndirectCommandsLayoutNV;
		    vkCmdSetDepthBias2EXT = pAPI->vkCmdSetDepthBias2EXT;
		    vkAcquireDrmDisplayEXT = pAPI->vkAcquireDrmDisplayEXT;
		    vkGetDrmDisplayEXT = pAPI->vkGetDrmDisplayEXT;
		    vkCreatePrivateDataSlotEXT = pAPI->vkCreatePrivateDataSlotEXT;
		    vkDestroyPrivateDataSlotEXT = pAPI->vkDestroyPrivateDataSlotEXT;
		    vkSetPrivateDataEXT = pAPI->vkSetPrivateDataEXT;
		    vkGetPrivateDataEXT = pAPI->vkGetPrivateDataEXT;
		    vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = pAPI->vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
		    vkGetEncodedVideoSessionParametersKHR = pAPI->vkGetEncodedVideoSessionParametersKHR;
		    vkCmdEncodeVideoKHR = pAPI->vkCmdEncodeVideoKHR;
		    vkCreateCudaModuleNV = pAPI->vkCreateCudaModuleNV;
		    vkGetCudaModuleCacheNV = pAPI->vkGetCudaModuleCacheNV;
		    vkCreateCudaFunctionNV = pAPI->vkCreateCudaFunctionNV;
		    vkDestroyCudaModuleNV = pAPI->vkDestroyCudaModuleNV;
		    vkDestroyCudaFunctionNV = pAPI->vkDestroyCudaFunctionNV;
		    vkCmdCudaLaunchKernelNV = pAPI->vkCmdCudaLaunchKernelNV;
		    vkCmdRefreshObjectsKHR = pAPI->vkCmdRefreshObjectsKHR;
		    vkGetPhysicalDeviceRefreshableObjectTypesKHR = pAPI->vkGetPhysicalDeviceRefreshableObjectTypesKHR;
		    vkCmdSetEvent2KHR = pAPI->vkCmdSetEvent2KHR;
		    vkCmdResetEvent2KHR = pAPI->vkCmdResetEvent2KHR;
		    vkCmdWaitEvents2KHR = pAPI->vkCmdWaitEvents2KHR;
		    vkCmdPipelineBarrier2KHR = pAPI->vkCmdPipelineBarrier2KHR;
		    vkCmdWriteTimestamp2KHR = pAPI->vkCmdWriteTimestamp2KHR;
		    vkQueueSubmit2KHR = pAPI->vkQueueSubmit2KHR;
		    vkCmdWriteBufferMarker2AMD = pAPI->vkCmdWriteBufferMarker2AMD;
		    vkGetQueueCheckpointData2NV = pAPI->vkGetQueueCheckpointData2NV;
		    vkGetDescriptorSetLayoutSizeEXT = pAPI->vkGetDescriptorSetLayoutSizeEXT;
		    vkGetDescriptorSetLayoutBindingOffsetEXT = pAPI->vkGetDescriptorSetLayoutBindingOffsetEXT;
		    vkGetDescriptorEXT = pAPI->vkGetDescriptorEXT;
		    vkCmdBindDescriptorBuffersEXT = pAPI->vkCmdBindDescriptorBuffersEXT;
		    vkCmdSetDescriptorBufferOffsetsEXT = pAPI->vkCmdSetDescriptorBufferOffsetsEXT;
		    vkCmdBindDescriptorBufferEmbeddedSamplersEXT = pAPI->vkCmdBindDescriptorBufferEmbeddedSamplersEXT;
		    vkGetBufferOpaqueCaptureDescriptorDataEXT = pAPI->vkGetBufferOpaqueCaptureDescriptorDataEXT;
		    vkGetImageOpaqueCaptureDescriptorDataEXT = pAPI->vkGetImageOpaqueCaptureDescriptorDataEXT;
		    vkGetImageViewOpaqueCaptureDescriptorDataEXT = pAPI->vkGetImageViewOpaqueCaptureDescriptorDataEXT;
		    vkGetSamplerOpaqueCaptureDescriptorDataEXT = pAPI->vkGetSamplerOpaqueCaptureDescriptorDataEXT;
		    vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = pAPI->vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
		    vkCmdSetFragmentShadingRateEnumNV = pAPI->vkCmdSetFragmentShadingRateEnumNV;
		    vkCmdDrawMeshTasksEXT = pAPI->vkCmdDrawMeshTasksEXT;
		    vkCmdDrawMeshTasksIndirectEXT = pAPI->vkCmdDrawMeshTasksIndirectEXT;
		    vkCmdDrawMeshTasksIndirectCountEXT = pAPI->vkCmdDrawMeshTasksIndirectCountEXT;
		    vkCmdCopyBuffer2KHR = pAPI->vkCmdCopyBuffer2KHR;
		    vkCmdCopyImage2KHR = pAPI->vkCmdCopyImage2KHR;
		    vkCmdCopyBufferToImage2KHR = pAPI->vkCmdCopyBufferToImage2KHR;
		    vkCmdCopyImageToBuffer2KHR = pAPI->vkCmdCopyImageToBuffer2KHR;
		    vkCmdBlitImage2KHR = pAPI->vkCmdBlitImage2KHR;
		    vkCmdResolveImage2KHR = pAPI->vkCmdResolveImage2KHR;
		    vkGetDeviceFaultInfoEXT = pAPI->vkGetDeviceFaultInfoEXT;
		    vkCmdSetVertexInputEXT = pAPI->vkCmdSetVertexInputEXT;
		    vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = pAPI->vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
		    vkCmdSubpassShadingHUAWEI = pAPI->vkCmdSubpassShadingHUAWEI;
		    vkCmdBindInvocationMaskHUAWEI = pAPI->vkCmdBindInvocationMaskHUAWEI;
		    vkGetMemoryRemoteAddressNV = pAPI->vkGetMemoryRemoteAddressNV;
		    vkGetPipelinePropertiesEXT = pAPI->vkGetPipelinePropertiesEXT;
		    vkCmdSetPatchControlPointsEXT = pAPI->vkCmdSetPatchControlPointsEXT;
		    vkCmdSetRasterizerDiscardEnableEXT = pAPI->vkCmdSetRasterizerDiscardEnableEXT;
		    vkCmdSetDepthBiasEnableEXT = pAPI->vkCmdSetDepthBiasEnableEXT;
		    vkCmdSetLogicOpEXT = pAPI->vkCmdSetLogicOpEXT;
		    vkCmdSetPrimitiveRestartEnableEXT = pAPI->vkCmdSetPrimitiveRestartEnableEXT;
		    vkCmdSetColorWriteEnableEXT = pAPI->vkCmdSetColorWriteEnableEXT;
		    vkCmdTraceRaysIndirect2KHR = pAPI->vkCmdTraceRaysIndirect2KHR;
		    vkCmdDrawMultiEXT = pAPI->vkCmdDrawMultiEXT;
		    vkCmdDrawMultiIndexedEXT = pAPI->vkCmdDrawMultiIndexedEXT;
		    vkCreateMicromapEXT = pAPI->vkCreateMicromapEXT;
		    vkDestroyMicromapEXT = pAPI->vkDestroyMicromapEXT;
		    vkCmdBuildMicromapsEXT = pAPI->vkCmdBuildMicromapsEXT;
		    vkBuildMicromapsEXT = pAPI->vkBuildMicromapsEXT;
		    vkCopyMicromapEXT = pAPI->vkCopyMicromapEXT;
		    vkCopyMicromapToMemoryEXT = pAPI->vkCopyMicromapToMemoryEXT;
		    vkCopyMemoryToMicromapEXT = pAPI->vkCopyMemoryToMicromapEXT;
		    vkWriteMicromapsPropertiesEXT = pAPI->vkWriteMicromapsPropertiesEXT;
		    vkCmdCopyMicromapEXT = pAPI->vkCmdCopyMicromapEXT;
		    vkCmdCopyMicromapToMemoryEXT = pAPI->vkCmdCopyMicromapToMemoryEXT;
		    vkCmdCopyMemoryToMicromapEXT = pAPI->vkCmdCopyMemoryToMicromapEXT;
		    vkCmdWriteMicromapsPropertiesEXT = pAPI->vkCmdWriteMicromapsPropertiesEXT;
		    vkGetDeviceMicromapCompatibilityEXT = pAPI->vkGetDeviceMicromapCompatibilityEXT;
		    vkGetMicromapBuildSizesEXT = pAPI->vkGetMicromapBuildSizesEXT;
		    vkCmdDrawClusterHUAWEI = pAPI->vkCmdDrawClusterHUAWEI;
		    vkCmdDrawClusterIndirectHUAWEI = pAPI->vkCmdDrawClusterIndirectHUAWEI;
		    vkSetDeviceMemoryPriorityEXT = pAPI->vkSetDeviceMemoryPriorityEXT;
		    vkGetDeviceBufferMemoryRequirementsKHR = pAPI->vkGetDeviceBufferMemoryRequirementsKHR;
		    vkGetDeviceImageMemoryRequirementsKHR = pAPI->vkGetDeviceImageMemoryRequirementsKHR;
		    vkGetDeviceImageSparseMemoryRequirementsKHR = pAPI->vkGetDeviceImageSparseMemoryRequirementsKHR;
		    vkGetDescriptorSetLayoutHostMappingInfoVALVE = pAPI->vkGetDescriptorSetLayoutHostMappingInfoVALVE;
		    vkGetDescriptorSetHostMappingVALVE = pAPI->vkGetDescriptorSetHostMappingVALVE;
		    vkCmdCopyMemoryIndirectNV = pAPI->vkCmdCopyMemoryIndirectNV;
		    vkCmdCopyMemoryToImageIndirectNV = pAPI->vkCmdCopyMemoryToImageIndirectNV;
		    vkCmdDecompressMemoryNV = pAPI->vkCmdDecompressMemoryNV;
		    vkCmdDecompressMemoryIndirectCountNV = pAPI->vkCmdDecompressMemoryIndirectCountNV;
		    vkGetPipelineIndirectMemoryRequirementsNV = pAPI->vkGetPipelineIndirectMemoryRequirementsNV;
		    vkCmdUpdatePipelineIndirectBufferNV = pAPI->vkCmdUpdatePipelineIndirectBufferNV;
		    vkGetPipelineIndirectDeviceAddressNV = pAPI->vkGetPipelineIndirectDeviceAddressNV;
		    vkCmdSetDepthClampEnableEXT = pAPI->vkCmdSetDepthClampEnableEXT;
		    vkCmdSetPolygonModeEXT = pAPI->vkCmdSetPolygonModeEXT;
		    vkCmdSetRasterizationSamplesEXT = pAPI->vkCmdSetRasterizationSamplesEXT;
		    vkCmdSetSampleMaskEXT = pAPI->vkCmdSetSampleMaskEXT;
		    vkCmdSetAlphaToCoverageEnableEXT = pAPI->vkCmdSetAlphaToCoverageEnableEXT;
		    vkCmdSetAlphaToOneEnableEXT = pAPI->vkCmdSetAlphaToOneEnableEXT;
		    vkCmdSetLogicOpEnableEXT = pAPI->vkCmdSetLogicOpEnableEXT;
		    vkCmdSetColorBlendEnableEXT = pAPI->vkCmdSetColorBlendEnableEXT;
		    vkCmdSetColorBlendEquationEXT = pAPI->vkCmdSetColorBlendEquationEXT;
		    vkCmdSetColorWriteMaskEXT = pAPI->vkCmdSetColorWriteMaskEXT;
		    vkCmdSetTessellationDomainOriginEXT = pAPI->vkCmdSetTessellationDomainOriginEXT;
		    vkCmdSetRasterizationStreamEXT = pAPI->vkCmdSetRasterizationStreamEXT;
		    vkCmdSetConservativeRasterizationModeEXT = pAPI->vkCmdSetConservativeRasterizationModeEXT;
		    vkCmdSetExtraPrimitiveOverestimationSizeEXT = pAPI->vkCmdSetExtraPrimitiveOverestimationSizeEXT;
		    vkCmdSetDepthClipEnableEXT = pAPI->vkCmdSetDepthClipEnableEXT;
		    vkCmdSetSampleLocationsEnableEXT = pAPI->vkCmdSetSampleLocationsEnableEXT;
		    vkCmdSetColorBlendAdvancedEXT = pAPI->vkCmdSetColorBlendAdvancedEXT;
		    vkCmdSetProvokingVertexModeEXT = pAPI->vkCmdSetProvokingVertexModeEXT;
		    vkCmdSetLineRasterizationModeEXT = pAPI->vkCmdSetLineRasterizationModeEXT;
		    vkCmdSetLineStippleEnableEXT = pAPI->vkCmdSetLineStippleEnableEXT;
		    vkCmdSetDepthClipNegativeOneToOneEXT = pAPI->vkCmdSetDepthClipNegativeOneToOneEXT;
		    vkCmdSetViewportWScalingEnableNV = pAPI->vkCmdSetViewportWScalingEnableNV;
		    vkCmdSetViewportSwizzleNV = pAPI->vkCmdSetViewportSwizzleNV;
		    vkCmdSetCoverageToColorEnableNV = pAPI->vkCmdSetCoverageToColorEnableNV;
		    vkCmdSetCoverageToColorLocationNV = pAPI->vkCmdSetCoverageToColorLocationNV;
		    vkCmdSetCoverageModulationModeNV = pAPI->vkCmdSetCoverageModulationModeNV;
		    vkCmdSetCoverageModulationTableEnableNV = pAPI->vkCmdSetCoverageModulationTableEnableNV;
		    vkCmdSetCoverageModulationTableNV = pAPI->vkCmdSetCoverageModulationTableNV;
		    vkCmdSetShadingRateImageEnableNV = pAPI->vkCmdSetShadingRateImageEnableNV;
		    vkCmdSetRepresentativeFragmentTestEnableNV = pAPI->vkCmdSetRepresentativeFragmentTestEnableNV;
		    vkCmdSetCoverageReductionModeNV = pAPI->vkCmdSetCoverageReductionModeNV;
		    vkGetShaderModuleIdentifierEXT = pAPI->vkGetShaderModuleIdentifierEXT;
		    vkGetShaderModuleCreateInfoIdentifierEXT = pAPI->vkGetShaderModuleCreateInfoIdentifierEXT;
		    vkGetPhysicalDeviceOpticalFlowImageFormatsNV = pAPI->vkGetPhysicalDeviceOpticalFlowImageFormatsNV;
		    vkCreateOpticalFlowSessionNV = pAPI->vkCreateOpticalFlowSessionNV;
		    vkDestroyOpticalFlowSessionNV = pAPI->vkDestroyOpticalFlowSessionNV;
		    vkBindOpticalFlowSessionImageNV = pAPI->vkBindOpticalFlowSessionImageNV;
		    vkCmdOpticalFlowExecuteNV = pAPI->vkCmdOpticalFlowExecuteNV;
		    vkCmdBindIndexBuffer2KHR = pAPI->vkCmdBindIndexBuffer2KHR;
		    vkGetRenderingAreaGranularityKHR = pAPI->vkGetRenderingAreaGranularityKHR;
		    vkGetDeviceImageSubresourceLayoutKHR = pAPI->vkGetDeviceImageSubresourceLayoutKHR;
		    vkGetImageSubresourceLayout2KHR = pAPI->vkGetImageSubresourceLayout2KHR;
		    vkCreateShadersEXT = pAPI->vkCreateShadersEXT;
		    vkDestroyShaderEXT = pAPI->vkDestroyShaderEXT;
		    vkGetShaderBinaryDataEXT = pAPI->vkGetShaderBinaryDataEXT;
		    vkCmdBindShadersEXT = pAPI->vkCmdBindShadersEXT;
		    vkGetFramebufferTilePropertiesQCOM = pAPI->vkGetFramebufferTilePropertiesQCOM;
		    vkGetDynamicRenderingTilePropertiesQCOM = pAPI->vkGetDynamicRenderingTilePropertiesQCOM;
		    vkSetLatencySleepModeNV = pAPI->vkSetLatencySleepModeNV;
		    vkLatencySleepNV = pAPI->vkLatencySleepNV;
		    vkSetLatencyMarkerNV = pAPI->vkSetLatencyMarkerNV;
		    vkGetLatencyTimingsNV = pAPI->vkGetLatencyTimingsNV;
		    vkQueueNotifyOutOfBandNV = pAPI->vkQueueNotifyOutOfBandNV;
		    vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = pAPI->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR;
		    vkCmdSetAttachmentFeedbackLoopEnableEXT = pAPI->vkCmdSetAttachmentFeedbackLoopEnableEXT;
		    vkCmdSetLineStippleKHR = pAPI->vkCmdSetLineStippleKHR;
		    vkCmdSetLineStippleEXT = pAPI->vkCmdSetLineStippleEXT;
		    vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
		    vkGetCalibratedTimestampsKHR = pAPI->vkGetCalibratedTimestampsKHR;
		    vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = pAPI->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT;
		    vkGetCalibratedTimestampsEXT = pAPI->vkGetCalibratedTimestampsEXT;
		    vkCmdBindDescriptorSets2KHR = pAPI->vkCmdBindDescriptorSets2KHR;
		    vkCmdPushConstants2KHR = pAPI->vkCmdPushConstants2KHR;
		    vkCmdPushDescriptorSet2KHR = pAPI->vkCmdPushDescriptorSet2KHR;
		    vkCmdPushDescriptorSetWithTemplate2KHR = pAPI->vkCmdPushDescriptorSetWithTemplate2KHR;
		    vkCmdSetDescriptorBufferOffsets2EXT = pAPI->vkCmdSetDescriptorBufferOffsets2EXT;
		    vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = pAPI->vkCmdBindDescriptorBufferEmbeddedSamplers2EXT;
		#ifdef VK_USE_PLATFORM_XLIB_KHR
		    vkCreateXlibSurfaceKHR = pAPI->vkCreateXlibSurfaceKHR;
		    vkGetPhysicalDeviceXlibPresentationSupportKHR = pAPI->vkGetPhysicalDeviceXlibPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XLIB_KHR*/
		#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
		    vkAcquireXlibDisplayEXT = pAPI->vkAcquireXlibDisplayEXT;
		    vkGetRandROutputDisplayEXT = pAPI->vkGetRandROutputDisplayEXT;
		#endif /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/
		#ifdef VK_USE_PLATFORM_XCB_KHR
		    vkCreateXcbSurfaceKHR = pAPI->vkCreateXcbSurfaceKHR;
		    vkGetPhysicalDeviceXcbPresentationSupportKHR = pAPI->vkGetPhysicalDeviceXcbPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_XCB_KHR*/
		#ifdef VK_USE_PLATFORM_WAYLAND_KHR
		    vkCreateWaylandSurfaceKHR = pAPI->vkCreateWaylandSurfaceKHR;
		    vkGetPhysicalDeviceWaylandPresentationSupportKHR = pAPI->vkGetPhysicalDeviceWaylandPresentationSupportKHR;
		#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/
		#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
		    vkCreateDirectFBSurfaceEXT = pAPI->vkCreateDirectFBSurfaceEXT;
		    vkGetPhysicalDeviceDirectFBPresentationSupportEXT = pAPI->vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
		#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/
		#ifdef VK_USE_PLATFORM_ANDROID_KHR
		    vkCreateAndroidSurfaceKHR = pAPI->vkCreateAndroidSurfaceKHR;
		    vkGetAndroidHardwareBufferPropertiesANDROID = pAPI->vkGetAndroidHardwareBufferPropertiesANDROID;
		    vkGetMemoryAndroidHardwareBufferANDROID = pAPI->vkGetMemoryAndroidHardwareBufferANDROID;
		#endif /*VK_USE_PLATFORM_ANDROID_KHR*/
		#ifdef VK_USE_PLATFORM_WIN32_KHR
		    vkCreateWin32SurfaceKHR = pAPI->vkCreateWin32SurfaceKHR;
		    vkGetPhysicalDeviceWin32PresentationSupportKHR = pAPI->vkGetPhysicalDeviceWin32PresentationSupportKHR;
		    vkGetMemoryWin32HandleKHR = pAPI->vkGetMemoryWin32HandleKHR;
		    vkGetMemoryWin32HandlePropertiesKHR = pAPI->vkGetMemoryWin32HandlePropertiesKHR;
		    vkGetMemoryWin32HandleNV = pAPI->vkGetMemoryWin32HandleNV;
		    vkImportSemaphoreWin32HandleKHR = pAPI->vkImportSemaphoreWin32HandleKHR;
		    vkGetSemaphoreWin32HandleKHR = pAPI->vkGetSemaphoreWin32HandleKHR;
		    vkImportFenceWin32HandleKHR = pAPI->vkImportFenceWin32HandleKHR;
		    vkGetFenceWin32HandleKHR = pAPI->vkGetFenceWin32HandleKHR;
		    vkGetPhysicalDeviceSurfacePresentModes2EXT = pAPI->vkGetPhysicalDeviceSurfacePresentModes2EXT;
		    vkAcquireFullScreenExclusiveModeEXT = pAPI->vkAcquireFullScreenExclusiveModeEXT;
		    vkReleaseFullScreenExclusiveModeEXT = pAPI->vkReleaseFullScreenExclusiveModeEXT;
		    vkGetDeviceGroupSurfacePresentModes2EXT = pAPI->vkGetDeviceGroupSurfacePresentModes2EXT;
		    vkAcquireWinrtDisplayNV = pAPI->vkAcquireWinrtDisplayNV;
		    vkGetWinrtDisplayNV = pAPI->vkGetWinrtDisplayNV;
		#endif /*VK_USE_PLATFORM_WIN32_KHR*/
		#ifdef VK_USE_PLATFORM_VI_NN
		    vkCreateViSurfaceNN = pAPI->vkCreateViSurfaceNN;
		#endif /*VK_USE_PLATFORM_VI_NN*/
		#ifdef VK_USE_PLATFORM_IOS_MVK
		    vkCreateIOSSurfaceMVK = pAPI->vkCreateIOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_IOS_MVK*/
		#ifdef VK_USE_PLATFORM_MACOS_MVK
		    vkCreateMacOSSurfaceMVK = pAPI->vkCreateMacOSSurfaceMVK;
		#endif /*VK_USE_PLATFORM_MACOS_MVK*/
		#ifdef VK_USE_PLATFORM_METAL_EXT
		    vkCreateMetalSurfaceEXT = pAPI->vkCreateMetalSurfaceEXT;
		    vkExportMetalObjectsEXT = pAPI->vkExportMetalObjectsEXT;
		#endif /*VK_USE_PLATFORM_METAL_EXT*/
		#ifdef VK_USE_PLATFORM_FUCHSIA
		    vkCreateImagePipeSurfaceFUCHSIA = pAPI->vkCreateImagePipeSurfaceFUCHSIA;
		    vkGetMemoryZirconHandleFUCHSIA = pAPI->vkGetMemoryZirconHandleFUCHSIA;
		    vkGetMemoryZirconHandlePropertiesFUCHSIA = pAPI->vkGetMemoryZirconHandlePropertiesFUCHSIA;
		    vkImportSemaphoreZirconHandleFUCHSIA = pAPI->vkImportSemaphoreZirconHandleFUCHSIA;
		    vkGetSemaphoreZirconHandleFUCHSIA = pAPI->vkGetSemaphoreZirconHandleFUCHSIA;
		    vkCreateBufferCollectionFUCHSIA = pAPI->vkCreateBufferCollectionFUCHSIA;
		    vkSetBufferCollectionImageConstraintsFUCHSIA = pAPI->vkSetBufferCollectionImageConstraintsFUCHSIA;
		    vkSetBufferCollectionBufferConstraintsFUCHSIA = pAPI->vkSetBufferCollectionBufferConstraintsFUCHSIA;
		    vkDestroyBufferCollectionFUCHSIA = pAPI->vkDestroyBufferCollectionFUCHSIA;
		    vkGetBufferCollectionPropertiesFUCHSIA = pAPI->vkGetBufferCollectionPropertiesFUCHSIA;
		#endif /*VK_USE_PLATFORM_FUCHSIA*/
		#ifdef VK_USE_PLATFORM_GGP
		    vkCreateStreamDescriptorSurfaceGGP = pAPI->vkCreateStreamDescriptorSurfaceGGP;
		#endif /*VK_USE_PLATFORM_GGP*/
		#ifdef VK_USE_PLATFORM_SCI
		    vkGetMemorySciBufNV = pAPI->vkGetMemorySciBufNV;
		    vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = pAPI->vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV;
		    vkGetPhysicalDeviceSciBufAttributesNV = pAPI->vkGetPhysicalDeviceSciBufAttributesNV;
		    vkCreateSemaphoreSciSyncPoolNV = pAPI->vkCreateSemaphoreSciSyncPoolNV;
		    vkDestroySemaphoreSciSyncPoolNV = pAPI->vkDestroySemaphoreSciSyncPoolNV;
		    vkGetFenceSciSyncFenceNV = pAPI->vkGetFenceSciSyncFenceNV;
		    vkGetFenceSciSyncObjNV = pAPI->vkGetFenceSciSyncObjNV;
		    vkImportFenceSciSyncFenceNV = pAPI->vkImportFenceSciSyncFenceNV;
		    vkImportFenceSciSyncObjNV = pAPI->vkImportFenceSciSyncObjNV;
		    vkGetPhysicalDeviceSciSyncAttributesNV = pAPI->vkGetPhysicalDeviceSciSyncAttributesNV;
		    vkGetSemaphoreSciSyncObjNV = pAPI->vkGetSemaphoreSciSyncObjNV;
		    vkImportSemaphoreSciSyncObjNV = pAPI->vkImportSemaphoreSciSyncObjNV;
		#endif /*VK_USE_PLATFORM_SCI*/
		#ifdef VK_ENABLE_BETA_EXTENSIONS
		    vkCreateExecutionGraphPipelinesAMDX = pAPI->vkCreateExecutionGraphPipelinesAMDX;
		    vkGetExecutionGraphPipelineScratchSizeAMDX = pAPI->vkGetExecutionGraphPipelineScratchSizeAMDX;
		    vkGetExecutionGraphPipelineNodeIndexAMDX = pAPI->vkGetExecutionGraphPipelineNodeIndexAMDX;
		    vkCmdInitializeGraphScratchMemoryAMDX = pAPI->vkCmdInitializeGraphScratchMemoryAMDX;
		    vkCmdDispatchGraphAMDX = pAPI->vkCmdDispatchGraphAMDX;
		    vkCmdDispatchGraphIndirectAMDX = pAPI->vkCmdDispatchGraphIndirectAMDX;
		    vkCmdDispatchGraphIndirectCountAMDX = pAPI->vkCmdDispatchGraphIndirectCountAMDX;
		#endif /*VK_ENABLE_BETA_EXTENSIONS*/
		#ifdef VK_USE_PLATFORM_SCREEN_QNX
		    vkCreateScreenSurfaceQNX = pAPI->vkCreateScreenSurfaceQNX;
		    vkGetPhysicalDeviceScreenPresentationSupportQNX = pAPI->vkGetPhysicalDeviceScreenPresentationSupportQNX;
		    vkGetScreenBufferPropertiesQNX = pAPI->vkGetScreenBufferPropertiesQNX;
		#endif /*VK_USE_PLATFORM_SCREEN_QNX*/

		    return VK_SUCCESS;
		#endif
		}

		#endif  /* VKBIND_IMPLEMENTATION */

	/* glad 2.0.6 GL v4.0 Core header */

		#ifndef GLAD_GL_H_
		#define GLAD_GL_H_

		#ifdef __clang__
		#pragma clang diagnostic push
		#pragma clang diagnostic ignored "-Wreserved-id-macro"
		#endif
		#ifdef __gl_h_
		  #error OpenGL (gl.h) header already included (API: gl), remove previous include!
		#endif
		#define __gl_h_ 1
		#ifdef __gl3_h_
		  #error OpenGL (gl3.h) header already included (API: gl), remove previous include!
		#endif
		#define __gl3_h_ 1
		#ifdef __glext_h_
		  #error OpenGL (glext.h) header already included (API: gl), remove previous include!
		#endif
		#define __glext_h_ 1
		#ifdef __gl3ext_h_
		  #error OpenGL (gl3ext.h) header already included (API: gl), remove previous include!
		#endif
		#define __gl3ext_h_ 1
		#ifdef __clang__
		#pragma clang diagnostic pop
		#endif

		#define GLAD_GL
		#define GLAD_OPTION_GL_HEADER_ONLY
		#define GLAD_OPTION_GL_LOADER

		#ifdef __cplusplus
		extern "C" {
		#endif

		#ifndef GLAD_PLATFORM_H_
		#define GLAD_PLATFORM_H_

		#ifndef GLAD_PLATFORM_WIN32
		  #if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__MINGW32__)
		    #define GLAD_PLATFORM_WIN32 1
		  #else
		    #define GLAD_PLATFORM_WIN32 0
		  #endif
		#endif

		#ifndef GLAD_PLATFORM_APPLE
		  #ifdef __APPLE__
		    #define GLAD_PLATFORM_APPLE 1
		  #else
		    #define GLAD_PLATFORM_APPLE 0
		  #endif
		#endif

		#ifndef GLAD_PLATFORM_EMSCRIPTEN
		  #ifdef __EMSCRIPTEN__
		    #define GLAD_PLATFORM_EMSCRIPTEN 1
		  #else
		    #define GLAD_PLATFORM_EMSCRIPTEN 0
		  #endif
		#endif

		#ifndef GLAD_PLATFORM_UWP
		  #if defined(_MSC_VER) && !defined(GLAD_INTERNAL_HAVE_WINAPIFAMILY)
		    #ifdef __has_include
		      #if __has_include(<winapifamily.h>)
		        #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
		      #endif
		    #elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
		      #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
		    #endif
		  #endif

		  #ifdef GLAD_INTERNAL_HAVE_WINAPIFAMILY
		    #include <winapifamily.h>
		    #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
		      #define GLAD_PLATFORM_UWP 1
		    #endif
		  #endif

		  #ifndef GLAD_PLATFORM_UWP
		    #define GLAD_PLATFORM_UWP 0
		  #endif
		#endif

		#ifdef __GNUC__
		  #define GLAD_GNUC_EXTENSION __extension__
		#else
		  #define GLAD_GNUC_EXTENSION
		#endif

		#define GLAD_UNUSED(x) (void)(x)

		#ifndef GLAD_API_CALL
		  #if defined(GLAD_API_CALL_EXPORT)
		    #if GLAD_PLATFORM_WIN32 || defined(__CYGWIN__)
		      #if defined(GLAD_API_CALL_EXPORT_BUILD)
		        #if defined(__GNUC__)
		          #define GLAD_API_CALL __attribute__ ((dllexport)) extern
		        #else
		          #define GLAD_API_CALL __declspec(dllexport) extern
		        #endif
		      #else
		        #if defined(__GNUC__)
		          #define GLAD_API_CALL __attribute__ ((dllimport)) extern
		        #else
		          #define GLAD_API_CALL __declspec(dllimport) extern
		        #endif
		      #endif
		    #elif defined(__GNUC__) && defined(GLAD_API_CALL_EXPORT_BUILD)
		      #define GLAD_API_CALL __attribute__ ((visibility ("default"))) extern
		    #else
		      #define GLAD_API_CALL extern
		    #endif
		  #else
		    #define GLAD_API_CALL extern
		  #endif
		#endif

		#ifdef APIENTRY
		  #define GLAD_API_PTR APIENTRY
		#elif GLAD_PLATFORM_WIN32
		  #define GLAD_API_PTR __stdcall
		#else
		  #define GLAD_API_PTR
		#endif

		#ifndef GLAPI
		#define GLAPI GLAD_API_CALL
		#endif

		#ifndef GLAPIENTRY
		#define GLAPIENTRY GLAD_API_PTR
		#endif

		#define GLAD_MAKE_VERSION(major, minor) (major * 10000 + minor)
		#define GLAD_VERSION_MAJOR(version) (version / 10000)
		#define GLAD_VERSION_MINOR(version) (version % 10000)

		#define GLAD_GENERATOR_VERSION "2.0.6"

		typedef void (*GLADapiproc)(void);

		typedef GLADapiproc (*GLADloadfunc)(const char *name);
		typedef GLADapiproc (*GLADuserptrloadfunc)(void *userptr, const char *name);

		typedef void (*GLADprecallback)(const char *name, GLADapiproc apiproc, int len_args, ...);
		typedef void (*GLADpostcallback)(void *ret, const char *name, GLADapiproc apiproc, int len_args, ...);

		#endif /* GLAD_PLATFORM_H_ */

		#define GL_ACTIVE_ATTRIBUTES 0x8B89
		#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
		#define GL_ACTIVE_SUBROUTINES 0x8DE5
		#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH 0x8E48
		#define GL_ACTIVE_SUBROUTINE_UNIFORMS 0x8DE6
		#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
		#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
		#define GL_ACTIVE_TEXTURE 0x84E0
		#define GL_ACTIVE_UNIFORMS 0x8B86
		#define GL_ACTIVE_UNIFORM_BLOCKS 0x8A36
		#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
		#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
		#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
		#define GL_ALPHA 0x1906
		#define GL_ALREADY_SIGNALED 0x911A
		#define GL_ALWAYS 0x0207
		#define GL_AND 0x1501
		#define GL_AND_INVERTED 0x1504
		#define GL_AND_REVERSE 0x1502
		#define GL_ANY_SAMPLES_PASSED 0x8C2F
		#define GL_ARRAY_BUFFER 0x8892
		#define GL_ARRAY_BUFFER_BINDING 0x8894
		#define GL_ATTACHED_SHADERS 0x8B85
		#define GL_BACK 0x0405
		#define GL_BACK_LEFT 0x0402
		#define GL_BACK_RIGHT 0x0403
		#define GL_BGR 0x80E0
		#define GL_BGRA 0x80E1
		#define GL_BGRA_INTEGER 0x8D9B
		#define GL_BGR_INTEGER 0x8D9A
		#define GL_BLEND 0x0BE2
		#define GL_BLEND_COLOR 0x8005
		#define GL_BLEND_DST 0x0BE0
		#define GL_BLEND_DST_ALPHA 0x80CA
		#define GL_BLEND_DST_RGB 0x80C8
		#define GL_BLEND_EQUATION 0x8009
		#define GL_BLEND_EQUATION_ALPHA 0x883D
		#define GL_BLEND_EQUATION_RGB 0x8009
		#define GL_BLEND_SRC 0x0BE1
		#define GL_BLEND_SRC_ALPHA 0x80CB
		#define GL_BLEND_SRC_RGB 0x80C9
		#define GL_BLUE 0x1905
		#define GL_BLUE_INTEGER 0x8D96
		#define GL_BOOL 0x8B56
		#define GL_BOOL_VEC2 0x8B57
		#define GL_BOOL_VEC3 0x8B58
		#define GL_BOOL_VEC4 0x8B59
		#define GL_BUFFER_ACCESS 0x88BB
		#define GL_BUFFER_ACCESS_FLAGS 0x911F
		#define GL_BUFFER_MAPPED 0x88BC
		#define GL_BUFFER_MAP_LENGTH 0x9120
		#define GL_BUFFER_MAP_OFFSET 0x9121
		#define GL_BUFFER_MAP_POINTER 0x88BD
		#define GL_BUFFER_SIZE 0x8764
		#define GL_BUFFER_USAGE 0x8765
		#define GL_BYTE 0x1400
		#define GL_CCW 0x0901
		#define GL_CLAMP_READ_COLOR 0x891C
		#define GL_CLAMP_TO_BORDER 0x812D
		#define GL_CLAMP_TO_EDGE 0x812F
		#define GL_CLEAR 0x1500
		#define GL_CLIP_DISTANCE0 0x3000
		#define GL_CLIP_DISTANCE1 0x3001
		#define GL_CLIP_DISTANCE2 0x3002
		#define GL_CLIP_DISTANCE3 0x3003
		#define GL_CLIP_DISTANCE4 0x3004
		#define GL_CLIP_DISTANCE5 0x3005
		#define GL_CLIP_DISTANCE6 0x3006
		#define GL_CLIP_DISTANCE7 0x3007
		#define GL_COLOR 0x1800
		#define GL_COLOR_ATTACHMENT0 0x8CE0
		#define GL_COLOR_ATTACHMENT1 0x8CE1
		#define GL_COLOR_ATTACHMENT10 0x8CEA
		#define GL_COLOR_ATTACHMENT11 0x8CEB
		#define GL_COLOR_ATTACHMENT12 0x8CEC
		#define GL_COLOR_ATTACHMENT13 0x8CED
		#define GL_COLOR_ATTACHMENT14 0x8CEE
		#define GL_COLOR_ATTACHMENT15 0x8CEF
		#define GL_COLOR_ATTACHMENT16 0x8CF0
		#define GL_COLOR_ATTACHMENT17 0x8CF1
		#define GL_COLOR_ATTACHMENT18 0x8CF2
		#define GL_COLOR_ATTACHMENT19 0x8CF3
		#define GL_COLOR_ATTACHMENT2 0x8CE2
		#define GL_COLOR_ATTACHMENT20 0x8CF4
		#define GL_COLOR_ATTACHMENT21 0x8CF5
		#define GL_COLOR_ATTACHMENT22 0x8CF6
		#define GL_COLOR_ATTACHMENT23 0x8CF7
		#define GL_COLOR_ATTACHMENT24 0x8CF8
		#define GL_COLOR_ATTACHMENT25 0x8CF9
		#define GL_COLOR_ATTACHMENT26 0x8CFA
		#define GL_COLOR_ATTACHMENT27 0x8CFB
		#define GL_COLOR_ATTACHMENT28 0x8CFC
		#define GL_COLOR_ATTACHMENT29 0x8CFD
		#define GL_COLOR_ATTACHMENT3 0x8CE3
		#define GL_COLOR_ATTACHMENT30 0x8CFE
		#define GL_COLOR_ATTACHMENT31 0x8CFF
		#define GL_COLOR_ATTACHMENT4 0x8CE4
		#define GL_COLOR_ATTACHMENT5 0x8CE5
		#define GL_COLOR_ATTACHMENT6 0x8CE6
		#define GL_COLOR_ATTACHMENT7 0x8CE7
		#define GL_COLOR_ATTACHMENT8 0x8CE8
		#define GL_COLOR_ATTACHMENT9 0x8CE9
		#define GL_COLOR_BUFFER_BIT 0x00004000
		#define GL_COLOR_CLEAR_VALUE 0x0C22
		#define GL_COLOR_LOGIC_OP 0x0BF2
		#define GL_COLOR_WRITEMASK 0x0C23
		#define GL_COMPARE_REF_TO_TEXTURE 0x884E
		#define GL_COMPATIBLE_SUBROUTINES 0x8E4B
		#define GL_COMPILE_STATUS 0x8B81
		#define GL_COMPRESSED_RED 0x8225
		#define GL_COMPRESSED_RED_RGTC1 0x8DBB
		#define GL_COMPRESSED_RG 0x8226
		#define GL_COMPRESSED_RGB 0x84ED
		#define GL_COMPRESSED_RGBA 0x84EE
		#define GL_COMPRESSED_RG_RGTC2 0x8DBD
		#define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC
		#define GL_COMPRESSED_SIGNED_RG_RGTC2 0x8DBE
		#define GL_COMPRESSED_SRGB 0x8C48
		#define GL_COMPRESSED_SRGB_ALPHA 0x8C49
		#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
		#define GL_CONDITION_SATISFIED 0x911C
		#define GL_CONSTANT_ALPHA 0x8003
		#define GL_CONSTANT_COLOR 0x8001
		#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
		#define GL_CONTEXT_CORE_PROFILE_BIT 0x00000001
		#define GL_CONTEXT_FLAGS 0x821E
		#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x00000001
		#define GL_CONTEXT_PROFILE_MASK 0x9126
		#define GL_COPY 0x1503
		#define GL_COPY_INVERTED 0x150C
		#define GL_COPY_READ_BUFFER 0x8F36
		#define GL_COPY_WRITE_BUFFER 0x8F37
		#define GL_CULL_FACE 0x0B44
		#define GL_CULL_FACE_MODE 0x0B45
		#define GL_CURRENT_PROGRAM 0x8B8D
		#define GL_CURRENT_QUERY 0x8865
		#define GL_CURRENT_VERTEX_ATTRIB 0x8626
		#define GL_CW 0x0900
		#define GL_DECR 0x1E03
		#define GL_DECR_WRAP 0x8508
		#define GL_DELETE_STATUS 0x8B80
		#define GL_DEPTH 0x1801
		#define GL_DEPTH24_STENCIL8 0x88F0
		#define GL_DEPTH32F_STENCIL8 0x8CAD
		#define GL_DEPTH_ATTACHMENT 0x8D00
		#define GL_DEPTH_BUFFER_BIT 0x00000100
		#define GL_DEPTH_CLAMP 0x864F
		#define GL_DEPTH_CLEAR_VALUE 0x0B73
		#define GL_DEPTH_COMPONENT 0x1902
		#define GL_DEPTH_COMPONENT16 0x81A5
		#define GL_DEPTH_COMPONENT24 0x81A6
		#define GL_DEPTH_COMPONENT32 0x81A7
		#define GL_DEPTH_COMPONENT32F 0x8CAC
		#define GL_DEPTH_FUNC 0x0B74
		#define GL_DEPTH_RANGE 0x0B70
		#define GL_DEPTH_STENCIL 0x84F9
		#define GL_DEPTH_STENCIL_ATTACHMENT 0x821A
		#define GL_DEPTH_TEST 0x0B71
		#define GL_DEPTH_WRITEMASK 0x0B72
		#define GL_DITHER 0x0BD0
		#define GL_DONT_CARE 0x1100
		#define GL_DOUBLE 0x140A
		#define GL_DOUBLEBUFFER 0x0C32
		#define GL_DOUBLE_MAT2 0x8F46
		#define GL_DOUBLE_MAT2x3 0x8F49
		#define GL_DOUBLE_MAT2x4 0x8F4A
		#define GL_DOUBLE_MAT3 0x8F47
		#define GL_DOUBLE_MAT3x2 0x8F4B
		#define GL_DOUBLE_MAT3x4 0x8F4C
		#define GL_DOUBLE_MAT4 0x8F48
		#define GL_DOUBLE_MAT4x2 0x8F4D
		#define GL_DOUBLE_MAT4x3 0x8F4E
		#define GL_DOUBLE_VEC2 0x8FFC
		#define GL_DOUBLE_VEC3 0x8FFD
		#define GL_DOUBLE_VEC4 0x8FFE
		#define GL_DRAW_BUFFER 0x0C01
		#define GL_DRAW_BUFFER0 0x8825
		#define GL_DRAW_BUFFER1 0x8826
		#define GL_DRAW_BUFFER10 0x882F
		#define GL_DRAW_BUFFER11 0x8830
		#define GL_DRAW_BUFFER12 0x8831
		#define GL_DRAW_BUFFER13 0x8832
		#define GL_DRAW_BUFFER14 0x8833
		#define GL_DRAW_BUFFER15 0x8834
		#define GL_DRAW_BUFFER2 0x8827
		#define GL_DRAW_BUFFER3 0x8828
		#define GL_DRAW_BUFFER4 0x8829
		#define GL_DRAW_BUFFER5 0x882A
		#define GL_DRAW_BUFFER6 0x882B
		#define GL_DRAW_BUFFER7 0x882C
		#define GL_DRAW_BUFFER8 0x882D
		#define GL_DRAW_BUFFER9 0x882E
		#define GL_DRAW_FRAMEBUFFER 0x8CA9
		#define GL_DRAW_FRAMEBUFFER_BINDING 0x8CA6
		#define GL_DRAW_INDIRECT_BUFFER 0x8F3F
		#define GL_DRAW_INDIRECT_BUFFER_BINDING 0x8F43
		#define GL_DST_ALPHA 0x0304
		#define GL_DST_COLOR 0x0306
		#define GL_DYNAMIC_COPY 0x88EA
		#define GL_DYNAMIC_DRAW 0x88E8
		#define GL_DYNAMIC_READ 0x88E9
		#define GL_ELEMENT_ARRAY_BUFFER 0x8893
		#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
		#define GL_EQUAL 0x0202
		#define GL_EQUIV 0x1509
		#define GL_EXTENSIONS 0x1F03
		#define GL_FALSE 0
		#define GL_FASTEST 0x1101
		#define GL_FILL 0x1B02
		#define GL_FIRST_VERTEX_CONVENTION 0x8E4D
		#define GL_FIXED_ONLY 0x891D
		#define GL_FLOAT 0x1406
		#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
		#define GL_FLOAT_MAT2 0x8B5A
		#define GL_FLOAT_MAT2x3 0x8B65
		#define GL_FLOAT_MAT2x4 0x8B66
		#define GL_FLOAT_MAT3 0x8B5B
		#define GL_FLOAT_MAT3x2 0x8B67
		#define GL_FLOAT_MAT3x4 0x8B68
		#define GL_FLOAT_MAT4 0x8B5C
		#define GL_FLOAT_MAT4x2 0x8B69
		#define GL_FLOAT_MAT4x3 0x8B6A
		#define GL_FLOAT_VEC2 0x8B50
		#define GL_FLOAT_VEC3 0x8B51
		#define GL_FLOAT_VEC4 0x8B52
		#define GL_FRACTIONAL_EVEN 0x8E7C
		#define GL_FRACTIONAL_ODD 0x8E7B
		#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
		#define GL_FRAGMENT_SHADER 0x8B30
		#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
		#define GL_FRAMEBUFFER 0x8D40
		#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
		#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
		#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
		#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
		#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
		#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
		#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
		#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
		#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
		#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
		#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
		#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
		#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
		#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
		#define GL_FRAMEBUFFER_BINDING 0x8CA6
		#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
		#define GL_FRAMEBUFFER_DEFAULT 0x8218
		#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
		#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
		#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
		#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
		#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
		#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
		#define GL_FRAMEBUFFER_SRGB 0x8DB9
		#define GL_FRAMEBUFFER_UNDEFINED 0x8219
		#define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
		#define GL_FRONT 0x0404
		#define GL_FRONT_AND_BACK 0x0408
		#define GL_FRONT_FACE 0x0B46
		#define GL_FRONT_LEFT 0x0400
		#define GL_FRONT_RIGHT 0x0401
		#define GL_FUNC_ADD 0x8006
		#define GL_FUNC_REVERSE_SUBTRACT 0x800B
		#define GL_FUNC_SUBTRACT 0x800A
		#define GL_GEOMETRY_INPUT_TYPE 0x8917
		#define GL_GEOMETRY_OUTPUT_TYPE 0x8918
		#define GL_GEOMETRY_SHADER 0x8DD9
		#define GL_GEOMETRY_SHADER_INVOCATIONS 0x887F
		#define GL_GEOMETRY_VERTICES_OUT 0x8916
		#define GL_GEQUAL 0x0206
		#define GL_GREATER 0x0204
		#define GL_GREEN 0x1904
		#define GL_GREEN_INTEGER 0x8D95
		#define GL_HALF_FLOAT 0x140B
		#define GL_INCR 0x1E02
		#define GL_INCR_WRAP 0x8507
		#define GL_INFO_LOG_LENGTH 0x8B84
		#define GL_INT 0x1404
		#define GL_INTERLEAVED_ATTRIBS 0x8C8C
		#define GL_INT_2_10_10_10_REV 0x8D9F
		#define GL_INT_SAMPLER_1D 0x8DC9
		#define GL_INT_SAMPLER_1D_ARRAY 0x8DCE
		#define GL_INT_SAMPLER_2D 0x8DCA
		#define GL_INT_SAMPLER_2D_ARRAY 0x8DCF
		#define GL_INT_SAMPLER_2D_MULTISAMPLE 0x9109
		#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
		#define GL_INT_SAMPLER_2D_RECT 0x8DCD
		#define GL_INT_SAMPLER_3D 0x8DCB
		#define GL_INT_SAMPLER_BUFFER 0x8DD0
		#define GL_INT_SAMPLER_CUBE 0x8DCC
		#define GL_INT_SAMPLER_CUBE_MAP_ARRAY 0x900E
		#define GL_INT_VEC2 0x8B53
		#define GL_INT_VEC3 0x8B54
		#define GL_INT_VEC4 0x8B55
		#define GL_INVALID_ENUM 0x0500
		#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
		#define GL_INVALID_INDEX 0xFFFFFFFF
		#define GL_INVALID_OPERATION 0x0502
		#define GL_INVALID_VALUE 0x0501
		#define GL_INVERT 0x150A
		#define GL_ISOLINES 0x8E7A
		#define GL_KEEP 0x1E00
		#define GL_LAST_VERTEX_CONVENTION 0x8E4E
		#define GL_LEFT 0x0406
		#define GL_LEQUAL 0x0203
		#define GL_LESS 0x0201
		#define GL_LINE 0x1B01
		#define GL_LINEAR 0x2601
		#define GL_LINEAR_MIPMAP_LINEAR 0x2703
		#define GL_LINEAR_MIPMAP_NEAREST 0x2701
		#define GL_LINES 0x0001
		#define GL_LINES_ADJACENCY 0x000A
		#define GL_LINE_LOOP 0x0002
		#define GL_LINE_SMOOTH 0x0B20
		#define GL_LINE_SMOOTH_HINT 0x0C52
		#define GL_LINE_STRIP 0x0003
		#define GL_LINE_STRIP_ADJACENCY 0x000B
		#define GL_LINE_WIDTH 0x0B21
		#define GL_LINE_WIDTH_GRANULARITY 0x0B23
		#define GL_LINE_WIDTH_RANGE 0x0B22
		#define GL_LINK_STATUS 0x8B82
		#define GL_LOGIC_OP_MODE 0x0BF0
		#define GL_LOWER_LEFT 0x8CA1
		#define GL_MAJOR_VERSION 0x821B
		#define GL_MAP_FLUSH_EXPLICIT_BIT 0x0010
		#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
		#define GL_MAP_INVALIDATE_RANGE_BIT 0x0004
		#define GL_MAP_READ_BIT 0x0001
		#define GL_MAP_UNSYNCHRONIZED_BIT 0x0020
		#define GL_MAP_WRITE_BIT 0x0002
		#define GL_MAX 0x8008
		#define GL_MAX_3D_TEXTURE_SIZE 0x8073
		#define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF
		#define GL_MAX_CLIP_DISTANCES 0x0D32
		#define GL_MAX_COLOR_ATTACHMENTS 0x8CDF
		#define GL_MAX_COLOR_TEXTURE_SAMPLES 0x910E
		#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
		#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
		#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
		#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
		#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
		#define GL_MAX_COMBINED_UNIFORM_BLOCKS 0x8A2E
		#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
		#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
		#define GL_MAX_DEPTH_TEXTURE_SAMPLES 0x910F
		#define GL_MAX_DRAW_BUFFERS 0x8824
		#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
		#define GL_MAX_ELEMENTS_INDICES 0x80E9
		#define GL_MAX_ELEMENTS_VERTICES 0x80E8
		#define GL_MAX_FRAGMENT_INPUT_COMPONENTS 0x9125
		#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
		#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS 0x8A2D
		#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
		#define GL_MAX_GEOMETRY_INPUT_COMPONENTS 0x9123
		#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
		#define GL_MAX_GEOMETRY_OUTPUT_VERTICES 0x8DE0
		#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
		#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
		#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
		#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS 0x8A2C
		#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
		#define GL_MAX_INTEGER_SAMPLES 0x9110
		#define GL_MAX_PATCH_VERTICES 0x8E7D
		#define GL_MAX_PROGRAM_TEXEL_OFFSET 0x8905
		#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
		#define GL_MAX_RECTANGLE_TEXTURE_SIZE 0x84F8
		#define GL_MAX_RENDERBUFFER_SIZE 0x84E8
		#define GL_MAX_SAMPLES 0x8D57
		#define GL_MAX_SAMPLE_MASK_WORDS 0x8E59
		#define GL_MAX_SERVER_WAIT_TIMEOUT 0x9111
		#define GL_MAX_SUBROUTINES 0x8DE7
		#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
		#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
		#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
		#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
		#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
		#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
		#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
		#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
		#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
		#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
		#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
		#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
		#define GL_MAX_TESS_GEN_LEVEL 0x8E7E
		#define GL_MAX_TESS_PATCH_COMPONENTS 0x8E84
		#define GL_MAX_TEXTURE_BUFFER_SIZE 0x8C2B
		#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
		#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
		#define GL_MAX_TEXTURE_SIZE 0x0D33
		#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
		#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
		#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
		#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
		#define GL_MAX_UNIFORM_BLOCK_SIZE 0x8A30
		#define GL_MAX_UNIFORM_BUFFER_BINDINGS 0x8A2F
		#define GL_MAX_VARYING_COMPONENTS 0x8B4B
		#define GL_MAX_VARYING_FLOATS 0x8B4B
		#define GL_MAX_VERTEX_ATTRIBS 0x8869
		#define GL_MAX_VERTEX_OUTPUT_COMPONENTS 0x9122
		#define GL_MAX_VERTEX_STREAMS 0x8E71
		#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
		#define GL_MAX_VERTEX_UNIFORM_BLOCKS 0x8A2B
		#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
		#define GL_MAX_VIEWPORT_DIMS 0x0D3A
		#define GL_MIN 0x8007
		#define GL_MINOR_VERSION 0x821C
		#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
		#define GL_MIN_PROGRAM_TEXEL_OFFSET 0x8904
		#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
		#define GL_MIN_SAMPLE_SHADING_VALUE 0x8C37
		#define GL_MIRRORED_REPEAT 0x8370
		#define GL_MULTISAMPLE 0x809D
		#define GL_NAND 0x150E
		#define GL_NEAREST 0x2600
		#define GL_NEAREST_MIPMAP_LINEAR 0x2702
		#define GL_NEAREST_MIPMAP_NEAREST 0x2700
		#define GL_NEVER 0x0200
		#define GL_NICEST 0x1102
		#define GL_NONE 0
		#define GL_NOOP 0x1505
		#define GL_NOR 0x1508
		#define GL_NOTEQUAL 0x0205
		#define GL_NO_ERROR 0
		#define GL_NUM_COMPATIBLE_SUBROUTINES 0x8E4A
		#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
		#define GL_NUM_EXTENSIONS 0x821D
		#define GL_OBJECT_TYPE 0x9112
		#define GL_ONE 1
		#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
		#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
		#define GL_ONE_MINUS_DST_ALPHA 0x0305
		#define GL_ONE_MINUS_DST_COLOR 0x0307
		#define GL_ONE_MINUS_SRC1_ALPHA 0x88FB
		#define GL_ONE_MINUS_SRC1_COLOR 0x88FA
		#define GL_ONE_MINUS_SRC_ALPHA 0x0303
		#define GL_ONE_MINUS_SRC_COLOR 0x0301
		#define GL_OR 0x1507
		#define GL_OR_INVERTED 0x150D
		#define GL_OR_REVERSE 0x150B
		#define GL_OUT_OF_MEMORY 0x0505
		#define GL_PACK_ALIGNMENT 0x0D05
		#define GL_PACK_IMAGE_HEIGHT 0x806C
		#define GL_PACK_LSB_FIRST 0x0D01
		#define GL_PACK_ROW_LENGTH 0x0D02
		#define GL_PACK_SKIP_IMAGES 0x806B
		#define GL_PACK_SKIP_PIXELS 0x0D04
		#define GL_PACK_SKIP_ROWS 0x0D03
		#define GL_PACK_SWAP_BYTES 0x0D00
		#define GL_PATCHES 0x000E
		#define GL_PATCH_DEFAULT_INNER_LEVEL 0x8E73
		#define GL_PATCH_DEFAULT_OUTER_LEVEL 0x8E74
		#define GL_PATCH_VERTICES 0x8E72
		#define GL_PIXEL_PACK_BUFFER 0x88EB
		#define GL_PIXEL_PACK_BUFFER_BINDING 0x88ED
		#define GL_PIXEL_UNPACK_BUFFER 0x88EC
		#define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
		#define GL_POINT 0x1B00
		#define GL_POINTS 0x0000
		#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
		#define GL_POINT_SIZE 0x0B11
		#define GL_POINT_SIZE_GRANULARITY 0x0B13
		#define GL_POINT_SIZE_RANGE 0x0B12
		#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
		#define GL_POLYGON_MODE 0x0B40
		#define GL_POLYGON_OFFSET_FACTOR 0x8038
		#define GL_POLYGON_OFFSET_FILL 0x8037
		#define GL_POLYGON_OFFSET_LINE 0x2A02
		#define GL_POLYGON_OFFSET_POINT 0x2A01
		#define GL_POLYGON_OFFSET_UNITS 0x2A00
		#define GL_POLYGON_SMOOTH 0x0B41
		#define GL_POLYGON_SMOOTH_HINT 0x0C53
		#define GL_PRIMITIVES_GENERATED 0x8C87
		#define GL_PRIMITIVE_RESTART 0x8F9D
		#define GL_PRIMITIVE_RESTART_INDEX 0x8F9E
		#define GL_PROGRAM_POINT_SIZE 0x8642
		#define GL_PROVOKING_VERTEX 0x8E4F
		#define GL_PROXY_TEXTURE_1D 0x8063
		#define GL_PROXY_TEXTURE_1D_ARRAY 0x8C19
		#define GL_PROXY_TEXTURE_2D 0x8064
		#define GL_PROXY_TEXTURE_2D_ARRAY 0x8C1B
		#define GL_PROXY_TEXTURE_2D_MULTISAMPLE 0x9101
		#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
		#define GL_PROXY_TEXTURE_3D 0x8070
		#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
		#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY 0x900B
		#define GL_PROXY_TEXTURE_RECTANGLE 0x84F7
		#define GL_QUADS 0x0007
		#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
		#define GL_QUERY_BY_REGION_NO_WAIT 0x8E16
		#define GL_QUERY_BY_REGION_WAIT 0x8E15
		#define GL_QUERY_COUNTER_BITS 0x8864
		#define GL_QUERY_NO_WAIT 0x8E14
		#define GL_QUERY_RESULT 0x8866
		#define GL_QUERY_RESULT_AVAILABLE 0x8867
		#define GL_QUERY_WAIT 0x8E13
		#define GL_R11F_G11F_B10F 0x8C3A
		#define GL_R16 0x822A
		#define GL_R16F 0x822D
		#define GL_R16I 0x8233
		#define GL_R16UI 0x8234
		#define GL_R16_SNORM 0x8F98
		#define GL_R32F 0x822E
		#define GL_R32I 0x8235
		#define GL_R32UI 0x8236
		#define GL_R3_G3_B2 0x2A10
		#define GL_R8 0x8229
		#define GL_R8I 0x8231
		#define GL_R8UI 0x8232
		#define GL_R8_SNORM 0x8F94
		#define GL_RASTERIZER_DISCARD 0x8C89
		#define GL_READ_BUFFER 0x0C02
		#define GL_READ_FRAMEBUFFER 0x8CA8
		#define GL_READ_FRAMEBUFFER_BINDING 0x8CAA
		#define GL_READ_ONLY 0x88B8
		#define GL_READ_WRITE 0x88BA
		#define GL_RED 0x1903
		#define GL_RED_INTEGER 0x8D94
		#define GL_RENDERBUFFER 0x8D41
		#define GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
		#define GL_RENDERBUFFER_BINDING 0x8CA7
		#define GL_RENDERBUFFER_BLUE_SIZE 0x8D52
		#define GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
		#define GL_RENDERBUFFER_GREEN_SIZE 0x8D51
		#define GL_RENDERBUFFER_HEIGHT 0x8D43
		#define GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
		#define GL_RENDERBUFFER_RED_SIZE 0x8D50
		#define GL_RENDERBUFFER_SAMPLES 0x8CAB
		#define GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
		#define GL_RENDERBUFFER_WIDTH 0x8D42
		#define GL_RENDERER 0x1F01
		#define GL_REPEAT 0x2901
		#define GL_REPLACE 0x1E01
		#define GL_RG 0x8227
		#define GL_RG16 0x822C
		#define GL_RG16F 0x822F
		#define GL_RG16I 0x8239
		#define GL_RG16UI 0x823A
		#define GL_RG16_SNORM 0x8F99
		#define GL_RG32F 0x8230
		#define GL_RG32I 0x823B
		#define GL_RG32UI 0x823C
		#define GL_RG8 0x822B
		#define GL_RG8I 0x8237
		#define GL_RG8UI 0x8238
		#define GL_RG8_SNORM 0x8F95
		#define GL_RGB 0x1907
		#define GL_RGB10 0x8052
		#define GL_RGB10_A2 0x8059
		#define GL_RGB10_A2UI 0x906F
		#define GL_RGB12 0x8053
		#define GL_RGB16 0x8054
		#define GL_RGB16F 0x881B
		#define GL_RGB16I 0x8D89
		#define GL_RGB16UI 0x8D77
		#define GL_RGB16_SNORM 0x8F9A
		#define GL_RGB32F 0x8815
		#define GL_RGB32I 0x8D83
		#define GL_RGB32UI 0x8D71
		#define GL_RGB4 0x804F
		#define GL_RGB5 0x8050
		#define GL_RGB5_A1 0x8057
		#define GL_RGB8 0x8051
		#define GL_RGB8I 0x8D8F
		#define GL_RGB8UI 0x8D7D
		#define GL_RGB8_SNORM 0x8F96
		#define GL_RGB9_E5 0x8C3D
		#define GL_RGBA 0x1908
		#define GL_RGBA12 0x805A
		#define GL_RGBA16 0x805B
		#define GL_RGBA16F 0x881A
		#define GL_RGBA16I 0x8D88
		#define GL_RGBA16UI 0x8D76
		#define GL_RGBA16_SNORM 0x8F9B
		#define GL_RGBA2 0x8055
		#define GL_RGBA32F 0x8814
		#define GL_RGBA32I 0x8D82
		#define GL_RGBA32UI 0x8D70
		#define GL_RGBA4 0x8056
		#define GL_RGBA8 0x8058
		#define GL_RGBA8I 0x8D8E
		#define GL_RGBA8UI 0x8D7C
		#define GL_RGBA8_SNORM 0x8F97
		#define GL_RGBA_INTEGER 0x8D99
		#define GL_RGB_INTEGER 0x8D98
		#define GL_RG_INTEGER 0x8228
		#define GL_RIGHT 0x0407
		#define GL_SAMPLER_1D 0x8B5D
		#define GL_SAMPLER_1D_ARRAY 0x8DC0
		#define GL_SAMPLER_1D_ARRAY_SHADOW 0x8DC3
		#define GL_SAMPLER_1D_SHADOW 0x8B61
		#define GL_SAMPLER_2D 0x8B5E
		#define GL_SAMPLER_2D_ARRAY 0x8DC1
		#define GL_SAMPLER_2D_ARRAY_SHADOW 0x8DC4
		#define GL_SAMPLER_2D_MULTISAMPLE 0x9108
		#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910B
		#define GL_SAMPLER_2D_RECT 0x8B63
		#define GL_SAMPLER_2D_RECT_SHADOW 0x8B64
		#define GL_SAMPLER_2D_SHADOW 0x8B62
		#define GL_SAMPLER_3D 0x8B5F
		#define GL_SAMPLER_BINDING 0x8919
		#define GL_SAMPLER_BUFFER 0x8DC2
		#define GL_SAMPLER_CUBE 0x8B60
		#define GL_SAMPLER_CUBE_MAP_ARRAY 0x900C
		#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW 0x900D
		#define GL_SAMPLER_CUBE_SHADOW 0x8DC5
		#define GL_SAMPLES 0x80A9
		#define GL_SAMPLES_PASSED 0x8914
		#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
		#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
		#define GL_SAMPLE_BUFFERS 0x80A8
		#define GL_SAMPLE_COVERAGE 0x80A0
		#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
		#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
		#define GL_SAMPLE_MASK 0x8E51
		#define GL_SAMPLE_MASK_VALUE 0x8E52
		#define GL_SAMPLE_POSITION 0x8E50
		#define GL_SAMPLE_SHADING 0x8C36
		#define GL_SCISSOR_BOX 0x0C10
		#define GL_SCISSOR_TEST 0x0C11
		#define GL_SEPARATE_ATTRIBS 0x8C8D
		#define GL_SET 0x150F
		#define GL_SHADER_SOURCE_LENGTH 0x8B88
		#define GL_SHADER_TYPE 0x8B4F
		#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
		#define GL_SHORT 0x1402
		#define GL_SIGNALED 0x9119
		#define GL_SIGNED_NORMALIZED 0x8F9C
		#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
		#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
		#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
		#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
		#define GL_SRC1_ALPHA 0x8589
		#define GL_SRC1_COLOR 0x88F9
		#define GL_SRC_ALPHA 0x0302
		#define GL_SRC_ALPHA_SATURATE 0x0308
		#define GL_SRC_COLOR 0x0300
		#define GL_SRGB 0x8C40
		#define GL_SRGB8 0x8C41
		#define GL_SRGB8_ALPHA8 0x8C43
		#define GL_SRGB_ALPHA 0x8C42
		#define GL_STATIC_COPY 0x88E6
		#define GL_STATIC_DRAW 0x88E4
		#define GL_STATIC_READ 0x88E5
		#define GL_STENCIL 0x1802
		#define GL_STENCIL_ATTACHMENT 0x8D20
		#define GL_STENCIL_BACK_FAIL 0x8801
		#define GL_STENCIL_BACK_FUNC 0x8800
		#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
		#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
		#define GL_STENCIL_BACK_REF 0x8CA3
		#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
		#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
		#define GL_STENCIL_BUFFER_BIT 0x00000400
		#define GL_STENCIL_CLEAR_VALUE 0x0B91
		#define GL_STENCIL_FAIL 0x0B94
		#define GL_STENCIL_FUNC 0x0B92
		#define GL_STENCIL_INDEX 0x1901
		#define GL_STENCIL_INDEX1 0x8D46
		#define GL_STENCIL_INDEX16 0x8D49
		#define GL_STENCIL_INDEX4 0x8D47
		#define GL_STENCIL_INDEX8 0x8D48
		#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
		#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
		#define GL_STENCIL_REF 0x0B97
		#define GL_STENCIL_TEST 0x0B90
		#define GL_STENCIL_VALUE_MASK 0x0B93
		#define GL_STENCIL_WRITEMASK 0x0B98
		#define GL_STEREO 0x0C33
		#define GL_STREAM_COPY 0x88E2
		#define GL_STREAM_DRAW 0x88E0
		#define GL_STREAM_READ 0x88E1
		#define GL_SUBPIXEL_BITS 0x0D50
		#define GL_SYNC_CONDITION 0x9113
		#define GL_SYNC_FENCE 0x9116
		#define GL_SYNC_FLAGS 0x9115
		#define GL_SYNC_FLUSH_COMMANDS_BIT 0x00000001
		#define GL_SYNC_GPU_COMMANDS_COMPLETE 0x9117
		#define GL_SYNC_STATUS 0x9114
		#define GL_TESS_CONTROL_OUTPUT_VERTICES 0x8E75
		#define GL_TESS_CONTROL_SHADER 0x8E88
		#define GL_TESS_EVALUATION_SHADER 0x8E87
		#define GL_TESS_GEN_MODE 0x8E76
		#define GL_TESS_GEN_POINT_MODE 0x8E79
		#define GL_TESS_GEN_SPACING 0x8E77
		#define GL_TESS_GEN_VERTEX_ORDER 0x8E78
		#define GL_TEXTURE 0x1702
		#define GL_TEXTURE0 0x84C0
		#define GL_TEXTURE1 0x84C1
		#define GL_TEXTURE10 0x84CA
		#define GL_TEXTURE11 0x84CB
		#define GL_TEXTURE12 0x84CC
		#define GL_TEXTURE13 0x84CD
		#define GL_TEXTURE14 0x84CE
		#define GL_TEXTURE15 0x84CF
		#define GL_TEXTURE16 0x84D0
		#define GL_TEXTURE17 0x84D1
		#define GL_TEXTURE18 0x84D2
		#define GL_TEXTURE19 0x84D3
		#define GL_TEXTURE2 0x84C2
		#define GL_TEXTURE20 0x84D4
		#define GL_TEXTURE21 0x84D5
		#define GL_TEXTURE22 0x84D6
		#define GL_TEXTURE23 0x84D7
		#define GL_TEXTURE24 0x84D8
		#define GL_TEXTURE25 0x84D9
		#define GL_TEXTURE26 0x84DA
		#define GL_TEXTURE27 0x84DB
		#define GL_TEXTURE28 0x84DC
		#define GL_TEXTURE29 0x84DD
		#define GL_TEXTURE3 0x84C3
		#define GL_TEXTURE30 0x84DE
		#define GL_TEXTURE31 0x84DF
		#define GL_TEXTURE4 0x84C4
		#define GL_TEXTURE5 0x84C5
		#define GL_TEXTURE6 0x84C6
		#define GL_TEXTURE7 0x84C7
		#define GL_TEXTURE8 0x84C8
		#define GL_TEXTURE9 0x84C9
		#define GL_TEXTURE_1D 0x0DE0
		#define GL_TEXTURE_1D_ARRAY 0x8C18
		#define GL_TEXTURE_2D 0x0DE1
		#define GL_TEXTURE_2D_ARRAY 0x8C1A
		#define GL_TEXTURE_2D_MULTISAMPLE 0x9100
		#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102
		#define GL_TEXTURE_3D 0x806F
		#define GL_TEXTURE_ALPHA_SIZE 0x805F
		#define GL_TEXTURE_ALPHA_TYPE 0x8C13
		#define GL_TEXTURE_BASE_LEVEL 0x813C
		#define GL_TEXTURE_BINDING_1D 0x8068
		#define GL_TEXTURE_BINDING_1D_ARRAY 0x8C1C
		#define GL_TEXTURE_BINDING_2D 0x8069
		#define GL_TEXTURE_BINDING_2D_ARRAY 0x8C1D
		#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
		#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
		#define GL_TEXTURE_BINDING_3D 0x806A
		#define GL_TEXTURE_BINDING_BUFFER 0x8C2C
		#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
		#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
		#define GL_TEXTURE_BINDING_RECTANGLE 0x84F6
		#define GL_TEXTURE_BLUE_SIZE 0x805E
		#define GL_TEXTURE_BLUE_TYPE 0x8C12
		#define GL_TEXTURE_BORDER_COLOR 0x1004
		#define GL_TEXTURE_BUFFER 0x8C2A
		#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
		#define GL_TEXTURE_COMPARE_FUNC 0x884D
		#define GL_TEXTURE_COMPARE_MODE 0x884C
		#define GL_TEXTURE_COMPRESSED 0x86A1
		#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
		#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
		#define GL_TEXTURE_CUBE_MAP 0x8513
		#define GL_TEXTURE_CUBE_MAP_ARRAY 0x9009
		#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
		#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
		#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
		#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
		#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
		#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
		#define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F
		#define GL_TEXTURE_DEPTH 0x8071
		#define GL_TEXTURE_DEPTH_SIZE 0x884A
		#define GL_TEXTURE_DEPTH_TYPE 0x8C16
		#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
		#define GL_TEXTURE_GREEN_SIZE 0x805D
		#define GL_TEXTURE_GREEN_TYPE 0x8C11
		#define GL_TEXTURE_HEIGHT 0x1001
		#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
		#define GL_TEXTURE_LOD_BIAS 0x8501
		#define GL_TEXTURE_MAG_FILTER 0x2800
		#define GL_TEXTURE_MAX_LEVEL 0x813D
		#define GL_TEXTURE_MAX_LOD 0x813B
		#define GL_TEXTURE_MIN_FILTER 0x2801
		#define GL_TEXTURE_MIN_LOD 0x813A
		#define GL_TEXTURE_RECTANGLE 0x84F5
		#define GL_TEXTURE_RED_SIZE 0x805C
		#define GL_TEXTURE_RED_TYPE 0x8C10
		#define GL_TEXTURE_SAMPLES 0x9106
		#define GL_TEXTURE_SHARED_SIZE 0x8C3F
		#define GL_TEXTURE_STENCIL_SIZE 0x88F1
		#define GL_TEXTURE_SWIZZLE_A 0x8E45
		#define GL_TEXTURE_SWIZZLE_B 0x8E44
		#define GL_TEXTURE_SWIZZLE_G 0x8E43
		#define GL_TEXTURE_SWIZZLE_R 0x8E42
		#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
		#define GL_TEXTURE_WIDTH 0x1000
		#define GL_TEXTURE_WRAP_R 0x8072
		#define GL_TEXTURE_WRAP_S 0x2802
		#define GL_TEXTURE_WRAP_T 0x2803
		#define GL_TIMEOUT_EXPIRED 0x911B
		#define GL_TIMEOUT_IGNORED 0xFFFFFFFFFFFFFFFF
		#define GL_TIMESTAMP 0x8E28
		#define GL_TIME_ELAPSED 0x88BF
		#define GL_TRANSFORM_FEEDBACK 0x8E22
		#define GL_TRANSFORM_FEEDBACK_BINDING 0x8E25
		#define GL_TRANSFORM_FEEDBACK_BUFFER 0x8C8E
		#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
		#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
		#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
		#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
		#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
		#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
		#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
		#define GL_TRANSFORM_FEEDBACK_VARYINGS 0x8C83
		#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
		#define GL_TRIANGLES 0x0004
		#define GL_TRIANGLES_ADJACENCY 0x000C
		#define GL_TRIANGLE_FAN 0x0006
		#define GL_TRIANGLE_STRIP 0x0005
		#define GL_TRIANGLE_STRIP_ADJACENCY 0x000D
		#define GL_TRUE 1
		#define GL_UNIFORM_ARRAY_STRIDE 0x8A3C
		#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS 0x8A42
		#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
		#define GL_UNIFORM_BLOCK_BINDING 0x8A3F
		#define GL_UNIFORM_BLOCK_DATA_SIZE 0x8A40
		#define GL_UNIFORM_BLOCK_INDEX 0x8A3A
		#define GL_UNIFORM_BLOCK_NAME_LENGTH 0x8A41
		#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
		#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
		#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
		#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
		#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
		#define GL_UNIFORM_BUFFER 0x8A11
		#define GL_UNIFORM_BUFFER_BINDING 0x8A28
		#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
		#define GL_UNIFORM_BUFFER_SIZE 0x8A2A
		#define GL_UNIFORM_BUFFER_START 0x8A29
		#define GL_UNIFORM_IS_ROW_MAJOR 0x8A3E
		#define GL_UNIFORM_MATRIX_STRIDE 0x8A3D
		#define GL_UNIFORM_NAME_LENGTH 0x8A39
		#define GL_UNIFORM_OFFSET 0x8A3B
		#define GL_UNIFORM_SIZE 0x8A38
		#define GL_UNIFORM_TYPE 0x8A37
		#define GL_UNPACK_ALIGNMENT 0x0CF5
		#define GL_UNPACK_IMAGE_HEIGHT 0x806E
		#define GL_UNPACK_LSB_FIRST 0x0CF1
		#define GL_UNPACK_ROW_LENGTH 0x0CF2
		#define GL_UNPACK_SKIP_IMAGES 0x806D
		#define GL_UNPACK_SKIP_PIXELS 0x0CF4
		#define GL_UNPACK_SKIP_ROWS 0x0CF3
		#define GL_UNPACK_SWAP_BYTES 0x0CF0
		#define GL_UNSIGNALED 0x9118
		#define GL_UNSIGNED_BYTE 0x1401
		#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
		#define GL_UNSIGNED_BYTE_3_3_2 0x8032
		#define GL_UNSIGNED_INT 0x1405
		#define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B
		#define GL_UNSIGNED_INT_10_10_10_2 0x8036
		#define GL_UNSIGNED_INT_24_8 0x84FA
		#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
		#define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E
		#define GL_UNSIGNED_INT_8_8_8_8 0x8035
		#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
		#define GL_UNSIGNED_INT_SAMPLER_1D 0x8DD1
		#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY 0x8DD6
		#define GL_UNSIGNED_INT_SAMPLER_2D 0x8DD2
		#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY 0x8DD7
		#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
		#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
		#define GL_UNSIGNED_INT_SAMPLER_2D_RECT 0x8DD5
		#define GL_UNSIGNED_INT_SAMPLER_3D 0x8DD3
		#define GL_UNSIGNED_INT_SAMPLER_BUFFER 0x8DD8
		#define GL_UNSIGNED_INT_SAMPLER_CUBE 0x8DD4
		#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
		#define GL_UNSIGNED_INT_VEC2 0x8DC6
		#define GL_UNSIGNED_INT_VEC3 0x8DC7
		#define GL_UNSIGNED_INT_VEC4 0x8DC8
		#define GL_UNSIGNED_NORMALIZED 0x8C17
		#define GL_UNSIGNED_SHORT 0x1403
		#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
		#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
		#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
		#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
		#define GL_UNSIGNED_SHORT_5_6_5 0x8363
		#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
		#define GL_UPPER_LEFT 0x8CA2
		#define GL_VALIDATE_STATUS 0x8B83
		#define GL_VENDOR 0x1F00
		#define GL_VERSION 0x1F02
		#define GL_VERTEX_ARRAY_BINDING 0x85B5
		#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
		#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR 0x88FE
		#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
		#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD
		#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
		#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
		#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
		#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
		#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
		#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
		#define GL_VERTEX_SHADER 0x8B31
		#define GL_VIEWPORT 0x0BA2
		#define GL_WAIT_FAILED 0x911D
		#define GL_WRITE_ONLY 0x88B9
		#define GL_XOR 0x1506
		#define GL_ZERO 0


		#ifndef __khrplatform_h_
		#define __khrplatform_h_

		/*
		** Copyright (c) 2008-2018 The Khronos Group Inc.
		**
		** Permission is hereby granted, free of charge, to any person obtaining a
		** copy of this software and/or associated documentation files (the
		** "Materials"), to deal in the Materials without restriction, including
		** without limitation the rights to use, copy, modify, merge, publish,
		** distribute, sublicense, and/or sell copies of the Materials, and to
		** permit persons to whom the Materials are furnished to do so, subject to
		** the following conditions:
		**
		** The above copyright notice and this permission notice shall be included
		** in all copies or substantial portions of the Materials.
		**
		** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
		** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
		** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
		** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
		*/

		/* Khronos platform-specific types and definitions.
		 *
		 * The master copy of khrplatform.h is maintained in the Khronos EGL
		 * Registry repository at https://github.com/KhronosGroup/EGL-Registry
		 * The last semantic modification to khrplatform.h was at commit ID:
		 *      67a3e0864c2d75ea5287b9f3d2eb74a745936692
		 *
		 * Adopters may modify this file to suit their platform. Adopters are
		 * encouraged to submit platform specific modifications to the Khronos
		 * group so that they can be included in future versions of this file.
		 * Please submit changes by filing pull requests or issues on
		 * the EGL Registry repository linked above.
		 *
		 *
		 * See the Implementer's Guidelines for information about where this file
		 * should be located on your system and for more details of its use:
		 *    http://www.khronos.org/registry/implementers_guide.pdf
		 *
		 * This file should be included as
		 *        #include <KHR/khrplatform.h>
		 * by Khronos client API header files that use its types and defines.
		 *
		 * The types in khrplatform.h should only be used to define API-specific types.
		 *
		 * Types defined in khrplatform.h:
		 *    khronos_int8_t              signed   8  bit
		 *    khronos_uint8_t             unsigned 8  bit
		 *    khronos_int16_t             signed   16 bit
		 *    khronos_uint16_t            unsigned 16 bit
		 *    khronos_int32_t             signed   32 bit
		 *    khronos_uint32_t            unsigned 32 bit
		 *    khronos_int64_t             signed   64 bit
		 *    khronos_uint64_t            unsigned 64 bit
		 *    khronos_intptr_t            signed   same number of bits as a pointer
		 *    khronos_uintptr_t           unsigned same number of bits as a pointer
		 *    khronos_ssize_t             signed   size
		 *    khronos_usize_t             unsigned size
		 *    khronos_float_t             signed   32 bit floating point
		 *    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
		 *    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
		 *                                         nanoseconds
		 *    khronos_stime_nanoseconds_t signed time interval in nanoseconds
		 *    khronos_boolean_enum_t      enumerated boolean type. This should
		 *      only be used as a base type when a client API's boolean type is
		 *      an enum. Client APIs which use an integer or other type for
		 *      booleans cannot use this as the base type for their boolean.
		 *
		 * Tokens defined in khrplatform.h:
		 *
		 *    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
		 *
		 *    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
		 *    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
		 *
		 * Calling convention macros defined in this file:
		 *    KHRONOS_APICALL
		 *    KHRONOS_GLAD_API_PTR
		 *    KHRONOS_APIATTRIBUTES
		 *
		 * These may be used in function prototypes as:
		 *
		 *      KHRONOS_APICALL void KHRONOS_GLAD_API_PTR funcname(
		 *                                  int arg1,
		 *                                  int arg2) KHRONOS_APIATTRIBUTES;
		 */

		#if defined(__SCITECH_SNAP__) && !defined(KHRONOS_STATIC)
		#   define KHRONOS_STATIC 1
		#endif

		/*-------------------------------------------------------------------------
		 * Definition of KHRONOS_APICALL
		 *-------------------------------------------------------------------------
		 * This precedes the return type of the function in the function prototype.
		 */
		#if defined(KHRONOS_STATIC)
		    /* If the preprocessor constant KHRONOS_STATIC is defined, make the
		     * header compatible with static linking. */
		#   define KHRONOS_APICALL
		#elif defined(_WIN32)
		#   define KHRONOS_APICALL __declspec(dllimport)
		#elif defined (__SYMBIAN32__)
		#   define KHRONOS_APICALL IMPORT_C
		#elif defined(__ANDROID__)
		#   define KHRONOS_APICALL __attribute__((visibility("default")))
		#else
		#   define KHRONOS_APICALL
		#endif

		/*-------------------------------------------------------------------------
		 * Definition of KHRONOS_GLAD_API_PTR
		 *-------------------------------------------------------------------------
		 * This follows the return type of the function  and precedes the function
		 * name in the function prototype.
		 */
		#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
		    /* Win32 but not WinCE */
		#   define KHRONOS_GLAD_API_PTR __stdcall
		#else
		#   define KHRONOS_GLAD_API_PTR
		#endif

		/*-------------------------------------------------------------------------
		 * Definition of KHRONOS_APIATTRIBUTES
		 *-------------------------------------------------------------------------
		 * This follows the closing parenthesis of the function prototype arguments.
		 */
		#if defined (__ARMCC_2__)
		#define KHRONOS_APIATTRIBUTES __softfp
		#else
		#define KHRONOS_APIATTRIBUTES
		#endif

		/*-------------------------------------------------------------------------
		 * basic type definitions
		 *-----------------------------------------------------------------------*/
		#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


		/*
		 * Using <stdint.h>
		 */
		#include <stdint.h>
		typedef int32_t                 khronos_int32_t;
		typedef uint32_t                khronos_uint32_t;
		typedef int64_t                 khronos_int64_t;
		typedef uint64_t                khronos_uint64_t;
		#define KHRONOS_SUPPORT_INT64   1
		#define KHRONOS_SUPPORT_FLOAT   1
		/*
		 * To support platform where unsigned long cannot be used interchangeably with
		 * inptr_t (e.g. CHERI-extended ISAs), we can use the stdint.h intptr_t.
		 * Ideally, we could just use (u)intptr_t everywhere, but this could result in
		 * ABI breakage if khronos_uintptr_t is changed from unsigned long to
		 * unsigned long long or similar (this results in different C++ name mangling).
		 * To avoid changes for existing platforms, we restrict usage of intptr_t to
		 * platforms where the size of a pointer is larger than the size of long.
		 */
		#if defined(__SIZEOF_LONG__) && defined(__SIZEOF_POINTER__)
		#if __SIZEOF_POINTER__ > __SIZEOF_LONG__
		#define KHRONOS_USE_INTPTR_T
		#endif
		#endif

		#elif defined(__VMS ) || defined(__sgi)

		/*
		 * Using <inttypes.h>
		 */
		#include <inttypes.h>
		typedef int32_t                 khronos_int32_t;
		typedef uint32_t                khronos_uint32_t;
		typedef int64_t                 khronos_int64_t;
		typedef uint64_t                khronos_uint64_t;
		#define KHRONOS_SUPPORT_INT64   1
		#define KHRONOS_SUPPORT_FLOAT   1

		#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

		/*
		 * Win32
		 */
		typedef __int32                 khronos_int32_t;
		typedef unsigned __int32        khronos_uint32_t;
		typedef __int64                 khronos_int64_t;
		typedef unsigned __int64        khronos_uint64_t;
		#define KHRONOS_SUPPORT_INT64   1
		#define KHRONOS_SUPPORT_FLOAT   1

		#elif defined(__sun__) || defined(__digital__)

		/*
		 * Sun or Digital
		 */
		typedef int                     khronos_int32_t;
		typedef unsigned int            khronos_uint32_t;
		#if defined(__arch64__) || defined(_LP64)
		typedef long int                khronos_int64_t;
		typedef unsigned long int       khronos_uint64_t;
		#else
		typedef long long int           khronos_int64_t;
		typedef unsigned long long int  khronos_uint64_t;
		#endif /* __arch64__ */
		#define KHRONOS_SUPPORT_INT64   1
		#define KHRONOS_SUPPORT_FLOAT   1

		#elif 0

		/*
		 * Hypothetical platform with no float or int64 support
		 */
		typedef int                     khronos_int32_t;
		typedef unsigned int            khronos_uint32_t;
		#define KHRONOS_SUPPORT_INT64   0
		#define KHRONOS_SUPPORT_FLOAT   0

		#else

		/*
		 * Generic fallback
		 */
		#include <stdint.h>
		typedef int32_t                 khronos_int32_t;
		typedef uint32_t                khronos_uint32_t;
		typedef int64_t                 khronos_int64_t;
		typedef uint64_t                khronos_uint64_t;
		#define KHRONOS_SUPPORT_INT64   1
		#define KHRONOS_SUPPORT_FLOAT   1

		#endif


		/*
		 * Types that are (so far) the same on all platforms
		 */
		typedef signed   char          khronos_int8_t;
		typedef unsigned char          khronos_uint8_t;
		typedef signed   short int     khronos_int16_t;
		typedef unsigned short int     khronos_uint16_t;

		/*
		 * Types that differ between LLP64 and LP64 architectures - in LLP64,
		 * pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
		 * to be the only LLP64 architecture in current use.
		 */
		#ifdef KHRONOS_USE_INTPTR_T
		typedef intptr_t               khronos_intptr_t;
		typedef uintptr_t              khronos_uintptr_t;
		#elif defined(_WIN64)
		typedef signed   long long int khronos_intptr_t;
		typedef unsigned long long int khronos_uintptr_t;
		#else
		typedef signed   long  int     khronos_intptr_t;
		typedef unsigned long  int     khronos_uintptr_t;
		#endif

		#if defined(_WIN64)
		typedef signed   long long int khronos_ssize_t;
		typedef unsigned long long int khronos_usize_t;
		#else
		typedef signed   long  int     khronos_ssize_t;
		typedef unsigned long  int     khronos_usize_t;
		#endif

		#if KHRONOS_SUPPORT_FLOAT
		/*
		 * Float type
		 */
		typedef          float         khronos_float_t;
		#endif

		#if KHRONOS_SUPPORT_INT64
		/* Time types
		 *
		 * These types can be used to represent a time interval in nanoseconds or
		 * an absolute Unadjusted System Time.  Unadjusted System Time is the number
		 * of nanoseconds since some arbitrary system event (e.g. since the last
		 * time the system booted).  The Unadjusted System Time is an unsigned
		 * 64 bit value that wraps back to 0 every 584 years.  Time intervals
		 * may be either signed or unsigned.
		 */
		typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
		typedef khronos_int64_t        khronos_stime_nanoseconds_t;
		#endif

		/*
		 * Dummy value used to pad enum types to 32 bits.
		 */
		#ifndef KHRONOS_MAX_ENUM
		#define KHRONOS_MAX_ENUM 0x7FFFFFFF
		#endif

		/*
		 * Enumerated boolean type
		 *
		 * Values other than zero should be considered to be true.  Therefore
		 * comparisons should not be made against KHRONOS_TRUE.
		 */
		typedef enum {
		    KHRONOS_FALSE = 0,
		    KHRONOS_TRUE  = 1,
		    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
		} khronos_boolean_enum_t;

		#endif /* __khrplatform_h_ */
		typedef unsigned int GLenum;
		typedef unsigned char GLboolean;
		typedef unsigned int GLbitfield;
		typedef void GLvoid;
		typedef khronos_int8_t GLbyte;
		typedef khronos_uint8_t GLubyte;
		typedef khronos_int16_t GLshort;
		typedef khronos_uint16_t GLushort;
		typedef int GLint;
		typedef unsigned int GLuint;
		typedef khronos_int32_t GLclampx;
		typedef int GLsizei;
		typedef khronos_float_t GLfloat;
		typedef khronos_float_t GLclampf;
		typedef double GLdouble;
		typedef double GLclampd;
		typedef void *GLeglClientBufferEXT;
		typedef void *GLeglImageOES;
		typedef char GLchar;
		typedef char GLcharARB;
		#ifdef __APPLE__
		typedef void *GLhandleARB;
		#else
		typedef unsigned int GLhandleARB;
		#endif
		typedef khronos_uint16_t GLhalf;
		typedef khronos_uint16_t GLhalfARB;
		typedef khronos_int32_t GLfixed;
		#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
		typedef khronos_intptr_t GLintptr;
		#else
		typedef khronos_intptr_t GLintptr;
		#endif
		#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
		typedef khronos_intptr_t GLintptrARB;
		#else
		typedef khronos_intptr_t GLintptrARB;
		#endif
		#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
		typedef khronos_ssize_t GLsizeiptr;
		#else
		typedef khronos_ssize_t GLsizeiptr;
		#endif
		#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
		typedef khronos_ssize_t GLsizeiptrARB;
		#else
		typedef khronos_ssize_t GLsizeiptrARB;
		#endif
		typedef khronos_int64_t GLint64;
		typedef khronos_int64_t GLint64EXT;
		typedef khronos_uint64_t GLuint64;
		typedef khronos_uint64_t GLuint64EXT;
		typedef struct __GLsync *GLsync;
		struct _cl_context;
		struct _cl_event;
		typedef void (GLAD_API_PTR *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
		typedef void (GLAD_API_PTR *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
		typedef void (GLAD_API_PTR *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
		typedef void (GLAD_API_PTR *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
		typedef unsigned short GLhalfNV;
		typedef GLintptr GLvdpauSurfaceNV;
		typedef void (GLAD_API_PTR *GLVULKANPROCNV)(void);


		#define GL_VERSION_1_0 1
		GLAD_API_CALL int GLAD_GL_VERSION_1_0;
		#define GL_VERSION_1_1 1
		GLAD_API_CALL int GLAD_GL_VERSION_1_1;
		#define GL_VERSION_1_2 1
		GLAD_API_CALL int GLAD_GL_VERSION_1_2;
		#define GL_VERSION_1_3 1
		GLAD_API_CALL int GLAD_GL_VERSION_1_3;
		#define GL_VERSION_1_4 1
		GLAD_API_CALL int GLAD_GL_VERSION_1_4;
		#define GL_VERSION_1_5 1
		GLAD_API_CALL int GLAD_GL_VERSION_1_5;
		#define GL_VERSION_2_0 1
		GLAD_API_CALL int GLAD_GL_VERSION_2_0;
		#define GL_VERSION_2_1 1
		GLAD_API_CALL int GLAD_GL_VERSION_2_1;
		#define GL_VERSION_3_0 1
		GLAD_API_CALL int GLAD_GL_VERSION_3_0;
		#define GL_VERSION_3_1 1
		GLAD_API_CALL int GLAD_GL_VERSION_3_1;
		#define GL_VERSION_3_2 1
		GLAD_API_CALL int GLAD_GL_VERSION_3_2;
		#define GL_VERSION_3_3 1
		GLAD_API_CALL int GLAD_GL_VERSION_3_3;
		#define GL_VERSION_4_0 1
		GLAD_API_CALL int GLAD_GL_VERSION_4_0;


		typedef void (GLAD_API_PTR *PFNGLACTIVETEXTUREPROC)(GLenum texture);
		typedef void (GLAD_API_PTR *PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
		typedef void (GLAD_API_PTR *PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
		typedef void (GLAD_API_PTR *PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
		typedef void (GLAD_API_PTR *PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
		typedef void (GLAD_API_PTR *PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
		typedef void (GLAD_API_PTR *PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
		typedef void (GLAD_API_PTR *PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
		typedef void (GLAD_API_PTR *PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
		typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
		typedef void (GLAD_API_PTR *PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
		typedef void (GLAD_API_PTR *PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
		typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
		typedef void (GLAD_API_PTR *PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
		typedef void (GLAD_API_PTR *PFNGLBINDVERTEXARRAYPROC)(GLuint array);
		typedef void (GLAD_API_PTR *PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
		typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONPROC)(GLenum mode);
		typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
		typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
		typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
		typedef void (GLAD_API_PTR *PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
		typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
		typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
		typedef void (GLAD_API_PTR *PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
		typedef void (GLAD_API_PTR *PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
		typedef void (GLAD_API_PTR *PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void * data, GLenum usage);
		typedef void (GLAD_API_PTR *PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);
		typedef GLenum (GLAD_API_PTR *PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
		typedef void (GLAD_API_PTR *PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
		typedef void (GLAD_API_PTR *PFNGLCLEARPROC)(GLbitfield mask);
		typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
		typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint * value);
		typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
		typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHPROC)(GLdouble depth);
		typedef void (GLAD_API_PTR *PFNGLCLEARSTENCILPROC)(GLint s);
		typedef GLenum (GLAD_API_PTR *PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
		typedef void (GLAD_API_PTR *PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
		typedef void (GLAD_API_PTR *PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
		typedef void (GLAD_API_PTR *PFNGLCOMPILESHADERPROC)(GLuint shader);
		typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
		typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
		typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
		typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
		typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
		typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
		typedef void (GLAD_API_PTR *PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
		typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
		typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
		typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
		typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
		typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
		typedef GLuint (GLAD_API_PTR *PFNGLCREATEPROGRAMPROC)(void);
		typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROC)(GLenum type);
		typedef void (GLAD_API_PTR *PFNGLCULLFACEPROC)(GLenum mode);
		typedef void (GLAD_API_PTR *PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint * buffers);
		typedef void (GLAD_API_PTR *PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint * framebuffers);
		typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMPROC)(GLuint program);
		typedef void (GLAD_API_PTR *PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint * ids);
		typedef void (GLAD_API_PTR *PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint * renderbuffers);
		typedef void (GLAD_API_PTR *PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint * samplers);
		typedef void (GLAD_API_PTR *PFNGLDELETESHADERPROC)(GLuint shader);
		typedef void (GLAD_API_PTR *PFNGLDELETESYNCPROC)(GLsync sync);
		typedef void (GLAD_API_PTR *PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint * textures);
		typedef void (GLAD_API_PTR *PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint * ids);
		typedef void (GLAD_API_PTR *PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint * arrays);
		typedef void (GLAD_API_PTR *PFNGLDEPTHFUNCPROC)(GLenum func);
		typedef void (GLAD_API_PTR *PFNGLDEPTHMASKPROC)(GLboolean flag);
		typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
		typedef void (GLAD_API_PTR *PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
		typedef void (GLAD_API_PTR *PFNGLDISABLEPROC)(GLenum cap);
		typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
		typedef void (GLAD_API_PTR *PFNGLDISABLEIPROC)(GLenum target, GLuint index);
		typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
		typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect);
		typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
		typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERPROC)(GLenum buf);
		typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum * bufs);
		typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices);
		typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex);
		typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect);
		typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);
		typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex);
		typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
		typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex);
		typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
		typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
		typedef void (GLAD_API_PTR *PFNGLENABLEPROC)(GLenum cap);
		typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
		typedef void (GLAD_API_PTR *PFNGLENABLEIPROC)(GLenum target, GLuint index);
		typedef void (GLAD_API_PTR *PFNGLENDCONDITIONALRENDERPROC)(void);
		typedef void (GLAD_API_PTR *PFNGLENDQUERYPROC)(GLenum target);
		typedef void (GLAD_API_PTR *PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
		typedef void (GLAD_API_PTR *PFNGLENDTRANSFORMFEEDBACKPROC)(void);
		typedef GLsync (GLAD_API_PTR *PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
		typedef void (GLAD_API_PTR *PFNGLFINISHPROC)(void);
		typedef void (GLAD_API_PTR *PFNGLFLUSHPROC)(void);
		typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
		typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
		typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
		typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
		typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
		typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
		typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
		typedef void (GLAD_API_PTR *PFNGLFRONTFACEPROC)(GLenum mode);
		typedef void (GLAD_API_PTR *PFNGLGENBUFFERSPROC)(GLsizei n, GLuint * buffers);
		typedef void (GLAD_API_PTR *PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
		typedef void (GLAD_API_PTR *PFNGLGENQUERIESPROC)(GLsizei n, GLuint * ids);
		typedef void (GLAD_API_PTR *PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
		typedef void (GLAD_API_PTR *PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint * samplers);
		typedef void (GLAD_API_PTR *PFNGLGENTEXTURESPROC)(GLsizei n, GLuint * textures);
		typedef void (GLAD_API_PTR *PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
		typedef void (GLAD_API_PTR *PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
		typedef void (GLAD_API_PTR *PFNGLGENERATEMIPMAPPROC)(GLenum target);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
		typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);
		typedef GLint (GLAD_API_PTR *PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean * data);
		typedef void (GLAD_API_PTR *PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean * data);
		typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 * params);
		typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void ** params);
		typedef void (GLAD_API_PTR *PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void * data);
		typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void * img);
		typedef void (GLAD_API_PTR *PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble * data);
		typedef GLenum (GLAD_API_PTR *PFNGLGETERRORPROC)(void);
		typedef void (GLAD_API_PTR *PFNGLGETFLOATVPROC)(GLenum pname, GLfloat * data);
		typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar * name);
		typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 * data);
		typedef void (GLAD_API_PTR *PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 * data);
		typedef void (GLAD_API_PTR *PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint * data);
		typedef void (GLAD_API_PTR *PFNGLGETINTEGERVPROC)(GLenum pname, GLint * data);
		typedef void (GLAD_API_PTR *PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat * val);
		typedef void (GLAD_API_PTR *PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
		typedef void (GLAD_API_PTR *PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint * values);
		typedef void (GLAD_API_PTR *PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 * params);
		typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 * params);
		typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint * params);
		typedef void (GLAD_API_PTR *PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint * params);
		typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat * params);
		typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
		typedef void (GLAD_API_PTR *PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
		typedef void (GLAD_API_PTR *PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint * params);
		typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGPROC)(GLenum name);
		typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
		typedef GLuint (GLAD_API_PTR *PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar * name);
		typedef GLint (GLAD_API_PTR *PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values);
		typedef void (GLAD_API_PTR *PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
		typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat * params);
		typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint * params);
		typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat * params);
		typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
		typedef GLuint (GLAD_API_PTR *PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar * uniformBlockName);
		typedef void (GLAD_API_PTR *PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices);
		typedef GLint (GLAD_API_PTR *PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar * name);
		typedef void (GLAD_API_PTR *PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint * params);
		typedef void (GLAD_API_PTR *PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble * params);
		typedef void (GLAD_API_PTR *PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat * params);
		typedef void (GLAD_API_PTR *PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint * params);
		typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint * params);
		typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void ** pointer);
		typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble * params);
		typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat * params);
		typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint * params);
		typedef void (GLAD_API_PTR *PFNGLHINTPROC)(GLenum target, GLenum mode);
		typedef GLboolean (GLAD_API_PTR *PFNGLISBUFFERPROC)(GLuint buffer);
		typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDPROC)(GLenum cap);
		typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
		typedef GLboolean (GLAD_API_PTR *PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
		typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMPROC)(GLuint program);
		typedef GLboolean (GLAD_API_PTR *PFNGLISQUERYPROC)(GLuint id);
		typedef GLboolean (GLAD_API_PTR *PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
		typedef GLboolean (GLAD_API_PTR *PFNGLISSAMPLERPROC)(GLuint sampler);
		typedef GLboolean (GLAD_API_PTR *PFNGLISSHADERPROC)(GLuint shader);
		typedef GLboolean (GLAD_API_PTR *PFNGLISSYNCPROC)(GLsync sync);
		typedef GLboolean (GLAD_API_PTR *PFNGLISTEXTUREPROC)(GLuint texture);
		typedef GLboolean (GLAD_API_PTR *PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
		typedef GLboolean (GLAD_API_PTR *PFNGLISVERTEXARRAYPROC)(GLuint array);
		typedef void (GLAD_API_PTR *PFNGLLINEWIDTHPROC)(GLfloat width);
		typedef void (GLAD_API_PTR *PFNGLLINKPROGRAMPROC)(GLuint program);
		typedef void (GLAD_API_PTR *PFNGLLOGICOPPROC)(GLenum opcode);
		typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
		typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
		typedef void (GLAD_API_PTR *PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
		typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
		typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount);
		typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex);
		typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat * values);
		typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
		typedef void (GLAD_API_PTR *PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
		typedef void (GLAD_API_PTR *PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
		typedef void (GLAD_API_PTR *PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
		typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
		typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat * params);
		typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
		typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint * params);
		typedef void (GLAD_API_PTR *PFNGLPOINTSIZEPROC)(GLfloat size);
		typedef void (GLAD_API_PTR *PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
		typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
		typedef void (GLAD_API_PTR *PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
		typedef void (GLAD_API_PTR *PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
		typedef void (GLAD_API_PTR *PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
		typedef void (GLAD_API_PTR *PFNGLREADBUFFERPROC)(GLenum src);
		typedef void (GLAD_API_PTR *PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels);
		typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
		typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
		typedef void (GLAD_API_PTR *PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
		typedef void (GLAD_API_PTR *PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
		typedef void (GLAD_API_PTR *PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
		typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
		typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint * param);
		typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
		typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat * param);
		typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
		typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
		typedef void (GLAD_API_PTR *PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
		typedef void (GLAD_API_PTR *PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length);
		typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
		typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
		typedef void (GLAD_API_PTR *PFNGLSTENCILMASKPROC)(GLuint mask);
		typedef void (GLAD_API_PTR *PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
		typedef void (GLAD_API_PTR *PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
		typedef void (GLAD_API_PTR *PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
		typedef void (GLAD_API_PTR *PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
		typedef void (GLAD_API_PTR *PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
		typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
		typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
		typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
		typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
		typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint * params);
		typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint * params);
		typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
		typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat * params);
		typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
		typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint * params);
		typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
		typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
		typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
		typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
		typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
		typedef void (GLAD_API_PTR *PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint * indices);
		typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPBUFFERPROC)(GLenum target);
		typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMPROC)(GLuint program);
		typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMPROC)(GLuint program);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort * v);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
		typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
		typedef void (GLAD_API_PTR *PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
		typedef void (GLAD_API_PTR *PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);

		GLAD_API_CALL PFNGLACTIVETEXTUREPROC glad_glActiveTexture;
		#define glActiveTexture glad_glActiveTexture
		GLAD_API_CALL PFNGLATTACHSHADERPROC glad_glAttachShader;
		#define glAttachShader glad_glAttachShader
		GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;
		#define glBeginConditionalRender glad_glBeginConditionalRender
		GLAD_API_CALL PFNGLBEGINQUERYPROC glad_glBeginQuery;
		#define glBeginQuery glad_glBeginQuery
		GLAD_API_CALL PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;
		#define glBeginQueryIndexed glad_glBeginQueryIndexed
		GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;
		#define glBeginTransformFeedback glad_glBeginTransformFeedback
		GLAD_API_CALL PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;
		#define glBindAttribLocation glad_glBindAttribLocation
		GLAD_API_CALL PFNGLBINDBUFFERPROC glad_glBindBuffer;
		#define glBindBuffer glad_glBindBuffer
		GLAD_API_CALL PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;
		#define glBindBufferBase glad_glBindBufferBase
		GLAD_API_CALL PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;
		#define glBindBufferRange glad_glBindBufferRange
		GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;
		#define glBindFragDataLocation glad_glBindFragDataLocation
		GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;
		#define glBindFragDataLocationIndexed glad_glBindFragDataLocationIndexed
		GLAD_API_CALL PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;
		#define glBindFramebuffer glad_glBindFramebuffer
		GLAD_API_CALL PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;
		#define glBindRenderbuffer glad_glBindRenderbuffer
		GLAD_API_CALL PFNGLBINDSAMPLERPROC glad_glBindSampler;
		#define glBindSampler glad_glBindSampler
		GLAD_API_CALL PFNGLBINDTEXTUREPROC glad_glBindTexture;
		#define glBindTexture glad_glBindTexture
		GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;
		#define glBindTransformFeedback glad_glBindTransformFeedback
		GLAD_API_CALL PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;
		#define glBindVertexArray glad_glBindVertexArray
		GLAD_API_CALL PFNGLBLENDCOLORPROC glad_glBlendColor;
		#define glBlendColor glad_glBlendColor
		GLAD_API_CALL PFNGLBLENDEQUATIONPROC glad_glBlendEquation;
		#define glBlendEquation glad_glBlendEquation
		GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;
		#define glBlendEquationSeparate glad_glBlendEquationSeparate
		GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;
		#define glBlendEquationSeparatei glad_glBlendEquationSeparatei
		GLAD_API_CALL PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;
		#define glBlendEquationi glad_glBlendEquationi
		GLAD_API_CALL PFNGLBLENDFUNCPROC glad_glBlendFunc;
		#define glBlendFunc glad_glBlendFunc
		GLAD_API_CALL PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;
		#define glBlendFuncSeparate glad_glBlendFuncSeparate
		GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;
		#define glBlendFuncSeparatei glad_glBlendFuncSeparatei
		GLAD_API_CALL PFNGLBLENDFUNCIPROC glad_glBlendFunci;
		#define glBlendFunci glad_glBlendFunci
		GLAD_API_CALL PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;
		#define glBlitFramebuffer glad_glBlitFramebuffer
		GLAD_API_CALL PFNGLBUFFERDATAPROC glad_glBufferData;
		#define glBufferData glad_glBufferData
		GLAD_API_CALL PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;
		#define glBufferSubData glad_glBufferSubData
		GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;
		#define glCheckFramebufferStatus glad_glCheckFramebufferStatus
		GLAD_API_CALL PFNGLCLAMPCOLORPROC glad_glClampColor;
		#define glClampColor glad_glClampColor
		GLAD_API_CALL PFNGLCLEARPROC glad_glClear;
		#define glClear glad_glClear
		GLAD_API_CALL PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;
		#define glClearBufferfi glad_glClearBufferfi
		GLAD_API_CALL PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;
		#define glClearBufferfv glad_glClearBufferfv
		GLAD_API_CALL PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;
		#define glClearBufferiv glad_glClearBufferiv
		GLAD_API_CALL PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;
		#define glClearBufferuiv glad_glClearBufferuiv
		GLAD_API_CALL PFNGLCLEARCOLORPROC glad_glClearColor;
		#define glClearColor glad_glClearColor
		GLAD_API_CALL PFNGLCLEARDEPTHPROC glad_glClearDepth;
		#define glClearDepth glad_glClearDepth
		GLAD_API_CALL PFNGLCLEARSTENCILPROC glad_glClearStencil;
		#define glClearStencil glad_glClearStencil
		GLAD_API_CALL PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;
		#define glClientWaitSync glad_glClientWaitSync
		GLAD_API_CALL PFNGLCOLORMASKPROC glad_glColorMask;
		#define glColorMask glad_glColorMask
		GLAD_API_CALL PFNGLCOLORMASKIPROC glad_glColorMaski;
		#define glColorMaski glad_glColorMaski
		GLAD_API_CALL PFNGLCOMPILESHADERPROC glad_glCompileShader;
		#define glCompileShader glad_glCompileShader
		GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;
		#define glCompressedTexImage1D glad_glCompressedTexImage1D
		GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;
		#define glCompressedTexImage2D glad_glCompressedTexImage2D
		GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;
		#define glCompressedTexImage3D glad_glCompressedTexImage3D
		GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;
		#define glCompressedTexSubImage1D glad_glCompressedTexSubImage1D
		GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;
		#define glCompressedTexSubImage2D glad_glCompressedTexSubImage2D
		GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;
		#define glCompressedTexSubImage3D glad_glCompressedTexSubImage3D
		GLAD_API_CALL PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;
		#define glCopyBufferSubData glad_glCopyBufferSubData
		GLAD_API_CALL PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;
		#define glCopyTexImage1D glad_glCopyTexImage1D
		GLAD_API_CALL PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;
		#define glCopyTexImage2D glad_glCopyTexImage2D
		GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;
		#define glCopyTexSubImage1D glad_glCopyTexSubImage1D
		GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;
		#define glCopyTexSubImage2D glad_glCopyTexSubImage2D
		GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;
		#define glCopyTexSubImage3D glad_glCopyTexSubImage3D
		GLAD_API_CALL PFNGLCREATEPROGRAMPROC glad_glCreateProgram;
		#define glCreateProgram glad_glCreateProgram
		GLAD_API_CALL PFNGLCREATESHADERPROC glad_glCreateShader;
		#define glCreateShader glad_glCreateShader
		GLAD_API_CALL PFNGLCULLFACEPROC glad_glCullFace;
		#define glCullFace glad_glCullFace
		GLAD_API_CALL PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;
		#define glDeleteBuffers glad_glDeleteBuffers
		GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;
		#define glDeleteFramebuffers glad_glDeleteFramebuffers
		GLAD_API_CALL PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;
		#define glDeleteProgram glad_glDeleteProgram
		GLAD_API_CALL PFNGLDELETEQUERIESPROC glad_glDeleteQueries;
		#define glDeleteQueries glad_glDeleteQueries
		GLAD_API_CALL PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;
		#define glDeleteRenderbuffers glad_glDeleteRenderbuffers
		GLAD_API_CALL PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;
		#define glDeleteSamplers glad_glDeleteSamplers
		GLAD_API_CALL PFNGLDELETESHADERPROC glad_glDeleteShader;
		#define glDeleteShader glad_glDeleteShader
		GLAD_API_CALL PFNGLDELETESYNCPROC glad_glDeleteSync;
		#define glDeleteSync glad_glDeleteSync
		GLAD_API_CALL PFNGLDELETETEXTURESPROC glad_glDeleteTextures;
		#define glDeleteTextures glad_glDeleteTextures
		GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;
		#define glDeleteTransformFeedbacks glad_glDeleteTransformFeedbacks
		GLAD_API_CALL PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;
		#define glDeleteVertexArrays glad_glDeleteVertexArrays
		GLAD_API_CALL PFNGLDEPTHFUNCPROC glad_glDepthFunc;
		#define glDepthFunc glad_glDepthFunc
		GLAD_API_CALL PFNGLDEPTHMASKPROC glad_glDepthMask;
		#define glDepthMask glad_glDepthMask
		GLAD_API_CALL PFNGLDEPTHRANGEPROC glad_glDepthRange;
		#define glDepthRange glad_glDepthRange
		GLAD_API_CALL PFNGLDETACHSHADERPROC glad_glDetachShader;
		#define glDetachShader glad_glDetachShader
		GLAD_API_CALL PFNGLDISABLEPROC glad_glDisable;
		#define glDisable glad_glDisable
		GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;
		#define glDisableVertexAttribArray glad_glDisableVertexAttribArray
		GLAD_API_CALL PFNGLDISABLEIPROC glad_glDisablei;
		#define glDisablei glad_glDisablei
		GLAD_API_CALL PFNGLDRAWARRAYSPROC glad_glDrawArrays;
		#define glDrawArrays glad_glDrawArrays
		GLAD_API_CALL PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;
		#define glDrawArraysIndirect glad_glDrawArraysIndirect
		GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;
		#define glDrawArraysInstanced glad_glDrawArraysInstanced
		GLAD_API_CALL PFNGLDRAWBUFFERPROC glad_glDrawBuffer;
		#define glDrawBuffer glad_glDrawBuffer
		GLAD_API_CALL PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;
		#define glDrawBuffers glad_glDrawBuffers
		GLAD_API_CALL PFNGLDRAWELEMENTSPROC glad_glDrawElements;
		#define glDrawElements glad_glDrawElements
		GLAD_API_CALL PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;
		#define glDrawElementsBaseVertex glad_glDrawElementsBaseVertex
		GLAD_API_CALL PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;
		#define glDrawElementsIndirect glad_glDrawElementsIndirect
		GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;
		#define glDrawElementsInstanced glad_glDrawElementsInstanced
		GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;
		#define glDrawElementsInstancedBaseVertex glad_glDrawElementsInstancedBaseVertex
		GLAD_API_CALL PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;
		#define glDrawRangeElements glad_glDrawRangeElements
		GLAD_API_CALL PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;
		#define glDrawRangeElementsBaseVertex glad_glDrawRangeElementsBaseVertex
		GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;
		#define glDrawTransformFeedback glad_glDrawTransformFeedback
		GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;
		#define glDrawTransformFeedbackStream glad_glDrawTransformFeedbackStream
		GLAD_API_CALL PFNGLENABLEPROC glad_glEnable;
		#define glEnable glad_glEnable
		GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;
		#define glEnableVertexAttribArray glad_glEnableVertexAttribArray
		GLAD_API_CALL PFNGLENABLEIPROC glad_glEnablei;
		#define glEnablei glad_glEnablei
		GLAD_API_CALL PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;
		#define glEndConditionalRender glad_glEndConditionalRender
		GLAD_API_CALL PFNGLENDQUERYPROC glad_glEndQuery;
		#define glEndQuery glad_glEndQuery
		GLAD_API_CALL PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;
		#define glEndQueryIndexed glad_glEndQueryIndexed
		GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;
		#define glEndTransformFeedback glad_glEndTransformFeedback
		GLAD_API_CALL PFNGLFENCESYNCPROC glad_glFenceSync;
		#define glFenceSync glad_glFenceSync
		GLAD_API_CALL PFNGLFINISHPROC glad_glFinish;
		#define glFinish glad_glFinish
		GLAD_API_CALL PFNGLFLUSHPROC glad_glFlush;
		#define glFlush glad_glFlush
		GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;
		#define glFlushMappedBufferRange glad_glFlushMappedBufferRange
		GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;
		#define glFramebufferRenderbuffer glad_glFramebufferRenderbuffer
		GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;
		#define glFramebufferTexture glad_glFramebufferTexture
		GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;
		#define glFramebufferTexture1D glad_glFramebufferTexture1D
		GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;
		#define glFramebufferTexture2D glad_glFramebufferTexture2D
		GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;
		#define glFramebufferTexture3D glad_glFramebufferTexture3D
		GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;
		#define glFramebufferTextureLayer glad_glFramebufferTextureLayer
		GLAD_API_CALL PFNGLFRONTFACEPROC glad_glFrontFace;
		#define glFrontFace glad_glFrontFace
		GLAD_API_CALL PFNGLGENBUFFERSPROC glad_glGenBuffers;
		#define glGenBuffers glad_glGenBuffers
		GLAD_API_CALL PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;
		#define glGenFramebuffers glad_glGenFramebuffers
		GLAD_API_CALL PFNGLGENQUERIESPROC glad_glGenQueries;
		#define glGenQueries glad_glGenQueries
		GLAD_API_CALL PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;
		#define glGenRenderbuffers glad_glGenRenderbuffers
		GLAD_API_CALL PFNGLGENSAMPLERSPROC glad_glGenSamplers;
		#define glGenSamplers glad_glGenSamplers
		GLAD_API_CALL PFNGLGENTEXTURESPROC glad_glGenTextures;
		#define glGenTextures glad_glGenTextures
		GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;
		#define glGenTransformFeedbacks glad_glGenTransformFeedbacks
		GLAD_API_CALL PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;
		#define glGenVertexArrays glad_glGenVertexArrays
		GLAD_API_CALL PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;
		#define glGenerateMipmap glad_glGenerateMipmap
		GLAD_API_CALL PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;
		#define glGetActiveAttrib glad_glGetActiveAttrib
		GLAD_API_CALL PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;
		#define glGetActiveSubroutineName glad_glGetActiveSubroutineName
		GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;
		#define glGetActiveSubroutineUniformName glad_glGetActiveSubroutineUniformName
		GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;
		#define glGetActiveSubroutineUniformiv glad_glGetActiveSubroutineUniformiv
		GLAD_API_CALL PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;
		#define glGetActiveUniform glad_glGetActiveUniform
		GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;
		#define glGetActiveUniformBlockName glad_glGetActiveUniformBlockName
		GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;
		#define glGetActiveUniformBlockiv glad_glGetActiveUniformBlockiv
		GLAD_API_CALL PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;
		#define glGetActiveUniformName glad_glGetActiveUniformName
		GLAD_API_CALL PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;
		#define glGetActiveUniformsiv glad_glGetActiveUniformsiv
		GLAD_API_CALL PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;
		#define glGetAttachedShaders glad_glGetAttachedShaders
		GLAD_API_CALL PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;
		#define glGetAttribLocation glad_glGetAttribLocation
		GLAD_API_CALL PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;
		#define glGetBooleani_v glad_glGetBooleani_v
		GLAD_API_CALL PFNGLGETBOOLEANVPROC glad_glGetBooleanv;
		#define glGetBooleanv glad_glGetBooleanv
		GLAD_API_CALL PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;
		#define glGetBufferParameteri64v glad_glGetBufferParameteri64v
		GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;
		#define glGetBufferParameteriv glad_glGetBufferParameteriv
		GLAD_API_CALL PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;
		#define glGetBufferPointerv glad_glGetBufferPointerv
		GLAD_API_CALL PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;
		#define glGetBufferSubData glad_glGetBufferSubData
		GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;
		#define glGetCompressedTexImage glad_glGetCompressedTexImage
		GLAD_API_CALL PFNGLGETDOUBLEVPROC glad_glGetDoublev;
		#define glGetDoublev glad_glGetDoublev
		GLAD_API_CALL PFNGLGETERRORPROC glad_glGetError;
		#define glGetError glad_glGetError
		GLAD_API_CALL PFNGLGETFLOATVPROC glad_glGetFloatv;
		#define glGetFloatv glad_glGetFloatv
		GLAD_API_CALL PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;
		#define glGetFragDataIndex glad_glGetFragDataIndex
		GLAD_API_CALL PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;
		#define glGetFragDataLocation glad_glGetFragDataLocation
		GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;
		#define glGetFramebufferAttachmentParameteriv glad_glGetFramebufferAttachmentParameteriv
		GLAD_API_CALL PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;
		#define glGetInteger64i_v glad_glGetInteger64i_v
		GLAD_API_CALL PFNGLGETINTEGER64VPROC glad_glGetInteger64v;
		#define glGetInteger64v glad_glGetInteger64v
		GLAD_API_CALL PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;
		#define glGetIntegeri_v glad_glGetIntegeri_v
		GLAD_API_CALL PFNGLGETINTEGERVPROC glad_glGetIntegerv;
		#define glGetIntegerv glad_glGetIntegerv
		GLAD_API_CALL PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;
		#define glGetMultisamplefv glad_glGetMultisamplefv
		GLAD_API_CALL PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;
		#define glGetProgramInfoLog glad_glGetProgramInfoLog
		GLAD_API_CALL PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;
		#define glGetProgramStageiv glad_glGetProgramStageiv
		GLAD_API_CALL PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;
		#define glGetProgramiv glad_glGetProgramiv
		GLAD_API_CALL PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;
		#define glGetQueryIndexediv glad_glGetQueryIndexediv
		GLAD_API_CALL PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;
		#define glGetQueryObjecti64v glad_glGetQueryObjecti64v
		GLAD_API_CALL PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;
		#define glGetQueryObjectiv glad_glGetQueryObjectiv
		GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;
		#define glGetQueryObjectui64v glad_glGetQueryObjectui64v
		GLAD_API_CALL PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;
		#define glGetQueryObjectuiv glad_glGetQueryObjectuiv
		GLAD_API_CALL PFNGLGETQUERYIVPROC glad_glGetQueryiv;
		#define glGetQueryiv glad_glGetQueryiv
		GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;
		#define glGetRenderbufferParameteriv glad_glGetRenderbufferParameteriv
		GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;
		#define glGetSamplerParameterIiv glad_glGetSamplerParameterIiv
		GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;
		#define glGetSamplerParameterIuiv glad_glGetSamplerParameterIuiv
		GLAD_API_CALL PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;
		#define glGetSamplerParameterfv glad_glGetSamplerParameterfv
		GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;
		#define glGetSamplerParameteriv glad_glGetSamplerParameteriv
		GLAD_API_CALL PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;
		#define glGetShaderInfoLog glad_glGetShaderInfoLog
		GLAD_API_CALL PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;
		#define glGetShaderSource glad_glGetShaderSource
		GLAD_API_CALL PFNGLGETSHADERIVPROC glad_glGetShaderiv;
		#define glGetShaderiv glad_glGetShaderiv
		GLAD_API_CALL PFNGLGETSTRINGPROC glad_glGetString;
		#define glGetString glad_glGetString
		GLAD_API_CALL PFNGLGETSTRINGIPROC glad_glGetStringi;
		#define glGetStringi glad_glGetStringi
		GLAD_API_CALL PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;
		#define glGetSubroutineIndex glad_glGetSubroutineIndex
		GLAD_API_CALL PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;
		#define glGetSubroutineUniformLocation glad_glGetSubroutineUniformLocation
		GLAD_API_CALL PFNGLGETSYNCIVPROC glad_glGetSynciv;
		#define glGetSynciv glad_glGetSynciv
		GLAD_API_CALL PFNGLGETTEXIMAGEPROC glad_glGetTexImage;
		#define glGetTexImage glad_glGetTexImage
		GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;
		#define glGetTexLevelParameterfv glad_glGetTexLevelParameterfv
		GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;
		#define glGetTexLevelParameteriv glad_glGetTexLevelParameteriv
		GLAD_API_CALL PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;
		#define glGetTexParameterIiv glad_glGetTexParameterIiv
		GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;
		#define glGetTexParameterIuiv glad_glGetTexParameterIuiv
		GLAD_API_CALL PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;
		#define glGetTexParameterfv glad_glGetTexParameterfv
		GLAD_API_CALL PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;
		#define glGetTexParameteriv glad_glGetTexParameteriv
		GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;
		#define glGetTransformFeedbackVarying glad_glGetTransformFeedbackVarying
		GLAD_API_CALL PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;
		#define glGetUniformBlockIndex glad_glGetUniformBlockIndex
		GLAD_API_CALL PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;
		#define glGetUniformIndices glad_glGetUniformIndices
		GLAD_API_CALL PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;
		#define glGetUniformLocation glad_glGetUniformLocation
		GLAD_API_CALL PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;
		#define glGetUniformSubroutineuiv glad_glGetUniformSubroutineuiv
		GLAD_API_CALL PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;
		#define glGetUniformdv glad_glGetUniformdv
		GLAD_API_CALL PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;
		#define glGetUniformfv glad_glGetUniformfv
		GLAD_API_CALL PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;
		#define glGetUniformiv glad_glGetUniformiv
		GLAD_API_CALL PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;
		#define glGetUniformuiv glad_glGetUniformuiv
		GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;
		#define glGetVertexAttribIiv glad_glGetVertexAttribIiv
		GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;
		#define glGetVertexAttribIuiv glad_glGetVertexAttribIuiv
		GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;
		#define glGetVertexAttribPointerv glad_glGetVertexAttribPointerv
		GLAD_API_CALL PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;
		#define glGetVertexAttribdv glad_glGetVertexAttribdv
		GLAD_API_CALL PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;
		#define glGetVertexAttribfv glad_glGetVertexAttribfv
		GLAD_API_CALL PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;
		#define glGetVertexAttribiv glad_glGetVertexAttribiv
		GLAD_API_CALL PFNGLHINTPROC glad_glHint;
		#define glHint glad_glHint
		GLAD_API_CALL PFNGLISBUFFERPROC glad_glIsBuffer;
		#define glIsBuffer glad_glIsBuffer
		GLAD_API_CALL PFNGLISENABLEDPROC glad_glIsEnabled;
		#define glIsEnabled glad_glIsEnabled
		GLAD_API_CALL PFNGLISENABLEDIPROC glad_glIsEnabledi;
		#define glIsEnabledi glad_glIsEnabledi
		GLAD_API_CALL PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;
		#define glIsFramebuffer glad_glIsFramebuffer
		GLAD_API_CALL PFNGLISPROGRAMPROC glad_glIsProgram;
		#define glIsProgram glad_glIsProgram
		GLAD_API_CALL PFNGLISQUERYPROC glad_glIsQuery;
		#define glIsQuery glad_glIsQuery
		GLAD_API_CALL PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;
		#define glIsRenderbuffer glad_glIsRenderbuffer
		GLAD_API_CALL PFNGLISSAMPLERPROC glad_glIsSampler;
		#define glIsSampler glad_glIsSampler
		GLAD_API_CALL PFNGLISSHADERPROC glad_glIsShader;
		#define glIsShader glad_glIsShader
		GLAD_API_CALL PFNGLISSYNCPROC glad_glIsSync;
		#define glIsSync glad_glIsSync
		GLAD_API_CALL PFNGLISTEXTUREPROC glad_glIsTexture;
		#define glIsTexture glad_glIsTexture
		GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;
		#define glIsTransformFeedback glad_glIsTransformFeedback
		GLAD_API_CALL PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;
		#define glIsVertexArray glad_glIsVertexArray
		GLAD_API_CALL PFNGLLINEWIDTHPROC glad_glLineWidth;
		#define glLineWidth glad_glLineWidth
		GLAD_API_CALL PFNGLLINKPROGRAMPROC glad_glLinkProgram;
		#define glLinkProgram glad_glLinkProgram
		GLAD_API_CALL PFNGLLOGICOPPROC glad_glLogicOp;
		#define glLogicOp glad_glLogicOp
		GLAD_API_CALL PFNGLMAPBUFFERPROC glad_glMapBuffer;
		#define glMapBuffer glad_glMapBuffer
		GLAD_API_CALL PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;
		#define glMapBufferRange glad_glMapBufferRange
		GLAD_API_CALL PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;
		#define glMinSampleShading glad_glMinSampleShading
		GLAD_API_CALL PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;
		#define glMultiDrawArrays glad_glMultiDrawArrays
		GLAD_API_CALL PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;
		#define glMultiDrawElements glad_glMultiDrawElements
		GLAD_API_CALL PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;
		#define glMultiDrawElementsBaseVertex glad_glMultiDrawElementsBaseVertex
		GLAD_API_CALL PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;
		#define glPatchParameterfv glad_glPatchParameterfv
		GLAD_API_CALL PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;
		#define glPatchParameteri glad_glPatchParameteri
		GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;
		#define glPauseTransformFeedback glad_glPauseTransformFeedback
		GLAD_API_CALL PFNGLPIXELSTOREFPROC glad_glPixelStoref;
		#define glPixelStoref glad_glPixelStoref
		GLAD_API_CALL PFNGLPIXELSTOREIPROC glad_glPixelStorei;
		#define glPixelStorei glad_glPixelStorei
		GLAD_API_CALL PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;
		#define glPointParameterf glad_glPointParameterf
		GLAD_API_CALL PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;
		#define glPointParameterfv glad_glPointParameterfv
		GLAD_API_CALL PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;
		#define glPointParameteri glad_glPointParameteri
		GLAD_API_CALL PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;
		#define glPointParameteriv glad_glPointParameteriv
		GLAD_API_CALL PFNGLPOINTSIZEPROC glad_glPointSize;
		#define glPointSize glad_glPointSize
		GLAD_API_CALL PFNGLPOLYGONMODEPROC glad_glPolygonMode;
		#define glPolygonMode glad_glPolygonMode
		GLAD_API_CALL PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;
		#define glPolygonOffset glad_glPolygonOffset
		GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;
		#define glPrimitiveRestartIndex glad_glPrimitiveRestartIndex
		GLAD_API_CALL PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;
		#define glProvokingVertex glad_glProvokingVertex
		GLAD_API_CALL PFNGLQUERYCOUNTERPROC glad_glQueryCounter;
		#define glQueryCounter glad_glQueryCounter
		GLAD_API_CALL PFNGLREADBUFFERPROC glad_glReadBuffer;
		#define glReadBuffer glad_glReadBuffer
		GLAD_API_CALL PFNGLREADPIXELSPROC glad_glReadPixels;
		#define glReadPixels glad_glReadPixels
		GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;
		#define glRenderbufferStorage glad_glRenderbufferStorage
		GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;
		#define glRenderbufferStorageMultisample glad_glRenderbufferStorageMultisample
		GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;
		#define glResumeTransformFeedback glad_glResumeTransformFeedback
		GLAD_API_CALL PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;
		#define glSampleCoverage glad_glSampleCoverage
		GLAD_API_CALL PFNGLSAMPLEMASKIPROC glad_glSampleMaski;
		#define glSampleMaski glad_glSampleMaski
		GLAD_API_CALL PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;
		#define glSamplerParameterIiv glad_glSamplerParameterIiv
		GLAD_API_CALL PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;
		#define glSamplerParameterIuiv glad_glSamplerParameterIuiv
		GLAD_API_CALL PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;
		#define glSamplerParameterf glad_glSamplerParameterf
		GLAD_API_CALL PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;
		#define glSamplerParameterfv glad_glSamplerParameterfv
		GLAD_API_CALL PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;
		#define glSamplerParameteri glad_glSamplerParameteri
		GLAD_API_CALL PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;
		#define glSamplerParameteriv glad_glSamplerParameteriv
		GLAD_API_CALL PFNGLSCISSORPROC glad_glScissor;
		#define glScissor glad_glScissor
		GLAD_API_CALL PFNGLSHADERSOURCEPROC glad_glShaderSource;
		#define glShaderSource glad_glShaderSource
		GLAD_API_CALL PFNGLSTENCILFUNCPROC glad_glStencilFunc;
		#define glStencilFunc glad_glStencilFunc
		GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;
		#define glStencilFuncSeparate glad_glStencilFuncSeparate
		GLAD_API_CALL PFNGLSTENCILMASKPROC glad_glStencilMask;
		#define glStencilMask glad_glStencilMask
		GLAD_API_CALL PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;
		#define glStencilMaskSeparate glad_glStencilMaskSeparate
		GLAD_API_CALL PFNGLSTENCILOPPROC glad_glStencilOp;
		#define glStencilOp glad_glStencilOp
		GLAD_API_CALL PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;
		#define glStencilOpSeparate glad_glStencilOpSeparate
		GLAD_API_CALL PFNGLTEXBUFFERPROC glad_glTexBuffer;
		#define glTexBuffer glad_glTexBuffer
		GLAD_API_CALL PFNGLTEXIMAGE1DPROC glad_glTexImage1D;
		#define glTexImage1D glad_glTexImage1D
		GLAD_API_CALL PFNGLTEXIMAGE2DPROC glad_glTexImage2D;
		#define glTexImage2D glad_glTexImage2D
		GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;
		#define glTexImage2DMultisample glad_glTexImage2DMultisample
		GLAD_API_CALL PFNGLTEXIMAGE3DPROC glad_glTexImage3D;
		#define glTexImage3D glad_glTexImage3D
		GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;
		#define glTexImage3DMultisample glad_glTexImage3DMultisample
		GLAD_API_CALL PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;
		#define glTexParameterIiv glad_glTexParameterIiv
		GLAD_API_CALL PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;
		#define glTexParameterIuiv glad_glTexParameterIuiv
		GLAD_API_CALL PFNGLTEXPARAMETERFPROC glad_glTexParameterf;
		#define glTexParameterf glad_glTexParameterf
		GLAD_API_CALL PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;
		#define glTexParameterfv glad_glTexParameterfv
		GLAD_API_CALL PFNGLTEXPARAMETERIPROC glad_glTexParameteri;
		#define glTexParameteri glad_glTexParameteri
		GLAD_API_CALL PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;
		#define glTexParameteriv glad_glTexParameteriv
		GLAD_API_CALL PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;
		#define glTexSubImage1D glad_glTexSubImage1D
		GLAD_API_CALL PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;
		#define glTexSubImage2D glad_glTexSubImage2D
		GLAD_API_CALL PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;
		#define glTexSubImage3D glad_glTexSubImage3D
		GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;
		#define glTransformFeedbackVaryings glad_glTransformFeedbackVaryings
		GLAD_API_CALL PFNGLUNIFORM1DPROC glad_glUniform1d;
		#define glUniform1d glad_glUniform1d
		GLAD_API_CALL PFNGLUNIFORM1DVPROC glad_glUniform1dv;
		#define glUniform1dv glad_glUniform1dv
		GLAD_API_CALL PFNGLUNIFORM1FPROC glad_glUniform1f;
		#define glUniform1f glad_glUniform1f
		GLAD_API_CALL PFNGLUNIFORM1FVPROC glad_glUniform1fv;
		#define glUniform1fv glad_glUniform1fv
		GLAD_API_CALL PFNGLUNIFORM1IPROC glad_glUniform1i;
		#define glUniform1i glad_glUniform1i
		GLAD_API_CALL PFNGLUNIFORM1IVPROC glad_glUniform1iv;
		#define glUniform1iv glad_glUniform1iv
		GLAD_API_CALL PFNGLUNIFORM1UIPROC glad_glUniform1ui;
		#define glUniform1ui glad_glUniform1ui
		GLAD_API_CALL PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;
		#define glUniform1uiv glad_glUniform1uiv
		GLAD_API_CALL PFNGLUNIFORM2DPROC glad_glUniform2d;
		#define glUniform2d glad_glUniform2d
		GLAD_API_CALL PFNGLUNIFORM2DVPROC glad_glUniform2dv;
		#define glUniform2dv glad_glUniform2dv
		GLAD_API_CALL PFNGLUNIFORM2FPROC glad_glUniform2f;
		#define glUniform2f glad_glUniform2f
		GLAD_API_CALL PFNGLUNIFORM2FVPROC glad_glUniform2fv;
		#define glUniform2fv glad_glUniform2fv
		GLAD_API_CALL PFNGLUNIFORM2IPROC glad_glUniform2i;
		#define glUniform2i glad_glUniform2i
		GLAD_API_CALL PFNGLUNIFORM2IVPROC glad_glUniform2iv;
		#define glUniform2iv glad_glUniform2iv
		GLAD_API_CALL PFNGLUNIFORM2UIPROC glad_glUniform2ui;
		#define glUniform2ui glad_glUniform2ui
		GLAD_API_CALL PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;
		#define glUniform2uiv glad_glUniform2uiv
		GLAD_API_CALL PFNGLUNIFORM3DPROC glad_glUniform3d;
		#define glUniform3d glad_glUniform3d
		GLAD_API_CALL PFNGLUNIFORM3DVPROC glad_glUniform3dv;
		#define glUniform3dv glad_glUniform3dv
		GLAD_API_CALL PFNGLUNIFORM3FPROC glad_glUniform3f;
		#define glUniform3f glad_glUniform3f
		GLAD_API_CALL PFNGLUNIFORM3FVPROC glad_glUniform3fv;
		#define glUniform3fv glad_glUniform3fv
		GLAD_API_CALL PFNGLUNIFORM3IPROC glad_glUniform3i;
		#define glUniform3i glad_glUniform3i
		GLAD_API_CALL PFNGLUNIFORM3IVPROC glad_glUniform3iv;
		#define glUniform3iv glad_glUniform3iv
		GLAD_API_CALL PFNGLUNIFORM3UIPROC glad_glUniform3ui;
		#define glUniform3ui glad_glUniform3ui
		GLAD_API_CALL PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;
		#define glUniform3uiv glad_glUniform3uiv
		GLAD_API_CALL PFNGLUNIFORM4DPROC glad_glUniform4d;
		#define glUniform4d glad_glUniform4d
		GLAD_API_CALL PFNGLUNIFORM4DVPROC glad_glUniform4dv;
		#define glUniform4dv glad_glUniform4dv
		GLAD_API_CALL PFNGLUNIFORM4FPROC glad_glUniform4f;
		#define glUniform4f glad_glUniform4f
		GLAD_API_CALL PFNGLUNIFORM4FVPROC glad_glUniform4fv;
		#define glUniform4fv glad_glUniform4fv
		GLAD_API_CALL PFNGLUNIFORM4IPROC glad_glUniform4i;
		#define glUniform4i glad_glUniform4i
		GLAD_API_CALL PFNGLUNIFORM4IVPROC glad_glUniform4iv;
		#define glUniform4iv glad_glUniform4iv
		GLAD_API_CALL PFNGLUNIFORM4UIPROC glad_glUniform4ui;
		#define glUniform4ui glad_glUniform4ui
		GLAD_API_CALL PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;
		#define glUniform4uiv glad_glUniform4uiv
		GLAD_API_CALL PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;
		#define glUniformBlockBinding glad_glUniformBlockBinding
		GLAD_API_CALL PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;
		#define glUniformMatrix2dv glad_glUniformMatrix2dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;
		#define glUniformMatrix2fv glad_glUniformMatrix2fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;
		#define glUniformMatrix2x3dv glad_glUniformMatrix2x3dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;
		#define glUniformMatrix2x3fv glad_glUniformMatrix2x3fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;
		#define glUniformMatrix2x4dv glad_glUniformMatrix2x4dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;
		#define glUniformMatrix2x4fv glad_glUniformMatrix2x4fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;
		#define glUniformMatrix3dv glad_glUniformMatrix3dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;
		#define glUniformMatrix3fv glad_glUniformMatrix3fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;
		#define glUniformMatrix3x2dv glad_glUniformMatrix3x2dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;
		#define glUniformMatrix3x2fv glad_glUniformMatrix3x2fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;
		#define glUniformMatrix3x4dv glad_glUniformMatrix3x4dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;
		#define glUniformMatrix3x4fv glad_glUniformMatrix3x4fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;
		#define glUniformMatrix4dv glad_glUniformMatrix4dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;
		#define glUniformMatrix4fv glad_glUniformMatrix4fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;
		#define glUniformMatrix4x2dv glad_glUniformMatrix4x2dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;
		#define glUniformMatrix4x2fv glad_glUniformMatrix4x2fv
		GLAD_API_CALL PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;
		#define glUniformMatrix4x3dv glad_glUniformMatrix4x3dv
		GLAD_API_CALL PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;
		#define glUniformMatrix4x3fv glad_glUniformMatrix4x3fv
		GLAD_API_CALL PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;
		#define glUniformSubroutinesuiv glad_glUniformSubroutinesuiv
		GLAD_API_CALL PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;
		#define glUnmapBuffer glad_glUnmapBuffer
		GLAD_API_CALL PFNGLUSEPROGRAMPROC glad_glUseProgram;
		#define glUseProgram glad_glUseProgram
		GLAD_API_CALL PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;
		#define glValidateProgram glad_glValidateProgram
		GLAD_API_CALL PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;
		#define glVertexAttrib1d glad_glVertexAttrib1d
		GLAD_API_CALL PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;
		#define glVertexAttrib1dv glad_glVertexAttrib1dv
		GLAD_API_CALL PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;
		#define glVertexAttrib1f glad_glVertexAttrib1f
		GLAD_API_CALL PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;
		#define glVertexAttrib1fv glad_glVertexAttrib1fv
		GLAD_API_CALL PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;
		#define glVertexAttrib1s glad_glVertexAttrib1s
		GLAD_API_CALL PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;
		#define glVertexAttrib1sv glad_glVertexAttrib1sv
		GLAD_API_CALL PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;
		#define glVertexAttrib2d glad_glVertexAttrib2d
		GLAD_API_CALL PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;
		#define glVertexAttrib2dv glad_glVertexAttrib2dv
		GLAD_API_CALL PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;
		#define glVertexAttrib2f glad_glVertexAttrib2f
		GLAD_API_CALL PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;
		#define glVertexAttrib2fv glad_glVertexAttrib2fv
		GLAD_API_CALL PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;
		#define glVertexAttrib2s glad_glVertexAttrib2s
		GLAD_API_CALL PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;
		#define glVertexAttrib2sv glad_glVertexAttrib2sv
		GLAD_API_CALL PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;
		#define glVertexAttrib3d glad_glVertexAttrib3d
		GLAD_API_CALL PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;
		#define glVertexAttrib3dv glad_glVertexAttrib3dv
		GLAD_API_CALL PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;
		#define glVertexAttrib3f glad_glVertexAttrib3f
		GLAD_API_CALL PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;
		#define glVertexAttrib3fv glad_glVertexAttrib3fv
		GLAD_API_CALL PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;
		#define glVertexAttrib3s glad_glVertexAttrib3s
		GLAD_API_CALL PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;
		#define glVertexAttrib3sv glad_glVertexAttrib3sv
		GLAD_API_CALL PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;
		#define glVertexAttrib4Nbv glad_glVertexAttrib4Nbv
		GLAD_API_CALL PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;
		#define glVertexAttrib4Niv glad_glVertexAttrib4Niv
		GLAD_API_CALL PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;
		#define glVertexAttrib4Nsv glad_glVertexAttrib4Nsv
		GLAD_API_CALL PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;
		#define glVertexAttrib4Nub glad_glVertexAttrib4Nub
		GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;
		#define glVertexAttrib4Nubv glad_glVertexAttrib4Nubv
		GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;
		#define glVertexAttrib4Nuiv glad_glVertexAttrib4Nuiv
		GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;
		#define glVertexAttrib4Nusv glad_glVertexAttrib4Nusv
		GLAD_API_CALL PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;
		#define glVertexAttrib4bv glad_glVertexAttrib4bv
		GLAD_API_CALL PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;
		#define glVertexAttrib4d glad_glVertexAttrib4d
		GLAD_API_CALL PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;
		#define glVertexAttrib4dv glad_glVertexAttrib4dv
		GLAD_API_CALL PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;
		#define glVertexAttrib4f glad_glVertexAttrib4f
		GLAD_API_CALL PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;
		#define glVertexAttrib4fv glad_glVertexAttrib4fv
		GLAD_API_CALL PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;
		#define glVertexAttrib4iv glad_glVertexAttrib4iv
		GLAD_API_CALL PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;
		#define glVertexAttrib4s glad_glVertexAttrib4s
		GLAD_API_CALL PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;
		#define glVertexAttrib4sv glad_glVertexAttrib4sv
		GLAD_API_CALL PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;
		#define glVertexAttrib4ubv glad_glVertexAttrib4ubv
		GLAD_API_CALL PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;
		#define glVertexAttrib4uiv glad_glVertexAttrib4uiv
		GLAD_API_CALL PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;
		#define glVertexAttrib4usv glad_glVertexAttrib4usv
		GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;
		#define glVertexAttribDivisor glad_glVertexAttribDivisor
		GLAD_API_CALL PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;
		#define glVertexAttribI1i glad_glVertexAttribI1i
		GLAD_API_CALL PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;
		#define glVertexAttribI1iv glad_glVertexAttribI1iv
		GLAD_API_CALL PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;
		#define glVertexAttribI1ui glad_glVertexAttribI1ui
		GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;
		#define glVertexAttribI1uiv glad_glVertexAttribI1uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;
		#define glVertexAttribI2i glad_glVertexAttribI2i
		GLAD_API_CALL PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;
		#define glVertexAttribI2iv glad_glVertexAttribI2iv
		GLAD_API_CALL PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;
		#define glVertexAttribI2ui glad_glVertexAttribI2ui
		GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;
		#define glVertexAttribI2uiv glad_glVertexAttribI2uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;
		#define glVertexAttribI3i glad_glVertexAttribI3i
		GLAD_API_CALL PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;
		#define glVertexAttribI3iv glad_glVertexAttribI3iv
		GLAD_API_CALL PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;
		#define glVertexAttribI3ui glad_glVertexAttribI3ui
		GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;
		#define glVertexAttribI3uiv glad_glVertexAttribI3uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;
		#define glVertexAttribI4bv glad_glVertexAttribI4bv
		GLAD_API_CALL PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;
		#define glVertexAttribI4i glad_glVertexAttribI4i
		GLAD_API_CALL PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;
		#define glVertexAttribI4iv glad_glVertexAttribI4iv
		GLAD_API_CALL PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;
		#define glVertexAttribI4sv glad_glVertexAttribI4sv
		GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;
		#define glVertexAttribI4ubv glad_glVertexAttribI4ubv
		GLAD_API_CALL PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;
		#define glVertexAttribI4ui glad_glVertexAttribI4ui
		GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;
		#define glVertexAttribI4uiv glad_glVertexAttribI4uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;
		#define glVertexAttribI4usv glad_glVertexAttribI4usv
		GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;
		#define glVertexAttribIPointer glad_glVertexAttribIPointer
		GLAD_API_CALL PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;
		#define glVertexAttribP1ui glad_glVertexAttribP1ui
		GLAD_API_CALL PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;
		#define glVertexAttribP1uiv glad_glVertexAttribP1uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;
		#define glVertexAttribP2ui glad_glVertexAttribP2ui
		GLAD_API_CALL PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;
		#define glVertexAttribP2uiv glad_glVertexAttribP2uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;
		#define glVertexAttribP3ui glad_glVertexAttribP3ui
		GLAD_API_CALL PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;
		#define glVertexAttribP3uiv glad_glVertexAttribP3uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;
		#define glVertexAttribP4ui glad_glVertexAttribP4ui
		GLAD_API_CALL PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;
		#define glVertexAttribP4uiv glad_glVertexAttribP4uiv
		GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;
		#define glVertexAttribPointer glad_glVertexAttribPointer
		GLAD_API_CALL PFNGLVIEWPORTPROC glad_glViewport;
		#define glViewport glad_glViewport
		GLAD_API_CALL PFNGLWAITSYNCPROC glad_glWaitSync;
		#define glWaitSync glad_glWaitSync





		GLAD_API_CALL int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr);
		GLAD_API_CALL int gladLoadGL( GLADloadfunc load);


		#ifdef GLAD_GL

		GLAD_API_CALL int gladLoaderLoadGL(void);
		GLAD_API_CALL void gladLoaderUnloadGL(void);

		#endif

		#ifdef __cplusplus
		}
		#endif
		#endif

	/* glad 2.0.6 GL v4.0 Core implementation */

		#define GLAD_GL_IMPLEMENTATION

		#ifdef GLAD_GL_IMPLEMENTATION
		/**
		 * SPDX-License-Identifier: (WTFPL OR CC0-1.0) AND Apache-2.0
		 */
		#include <stdio.h>
		#include <stdlib.h>
		#include <string.h>

		#ifndef GLAD_IMPL_UTIL_C_
		#define GLAD_IMPL_UTIL_C_

		#ifdef _MSC_VER
		#define GLAD_IMPL_UTIL_SSCANF sscanf_s
		#else
		#define GLAD_IMPL_UTIL_SSCANF sscanf
		#endif

		#endif /* GLAD_IMPL_UTIL_C_ */

		#ifdef __cplusplus
		extern "C" {
		#endif



		int GLAD_GL_VERSION_1_0 = 0;
		int GLAD_GL_VERSION_1_1 = 0;
		int GLAD_GL_VERSION_1_2 = 0;
		int GLAD_GL_VERSION_1_3 = 0;
		int GLAD_GL_VERSION_1_4 = 0;
		int GLAD_GL_VERSION_1_5 = 0;
		int GLAD_GL_VERSION_2_0 = 0;
		int GLAD_GL_VERSION_2_1 = 0;
		int GLAD_GL_VERSION_3_0 = 0;
		int GLAD_GL_VERSION_3_1 = 0;
		int GLAD_GL_VERSION_3_2 = 0;
		int GLAD_GL_VERSION_3_3 = 0;
		int GLAD_GL_VERSION_4_0 = 0;



		PFNGLACTIVETEXTUREPROC glad_glActiveTexture = NULL;
		PFNGLATTACHSHADERPROC glad_glAttachShader = NULL;
		PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender = NULL;
		PFNGLBEGINQUERYPROC glad_glBeginQuery = NULL;
		PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed = NULL;
		PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback = NULL;
		PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation = NULL;
		PFNGLBINDBUFFERPROC glad_glBindBuffer = NULL;
		PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase = NULL;
		PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange = NULL;
		PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation = NULL;
		PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed = NULL;
		PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer = NULL;
		PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer = NULL;
		PFNGLBINDSAMPLERPROC glad_glBindSampler = NULL;
		PFNGLBINDTEXTUREPROC glad_glBindTexture = NULL;
		PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback = NULL;
		PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray = NULL;
		PFNGLBLENDCOLORPROC glad_glBlendColor = NULL;
		PFNGLBLENDEQUATIONPROC glad_glBlendEquation = NULL;
		PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate = NULL;
		PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei = NULL;
		PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi = NULL;
		PFNGLBLENDFUNCPROC glad_glBlendFunc = NULL;
		PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate = NULL;
		PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei = NULL;
		PFNGLBLENDFUNCIPROC glad_glBlendFunci = NULL;
		PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer = NULL;
		PFNGLBUFFERDATAPROC glad_glBufferData = NULL;
		PFNGLBUFFERSUBDATAPROC glad_glBufferSubData = NULL;
		PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus = NULL;
		PFNGLCLAMPCOLORPROC glad_glClampColor = NULL;
		PFNGLCLEARPROC glad_glClear = NULL;
		PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi = NULL;
		PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv = NULL;
		PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv = NULL;
		PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv = NULL;
		PFNGLCLEARCOLORPROC glad_glClearColor = NULL;
		PFNGLCLEARDEPTHPROC glad_glClearDepth = NULL;
		PFNGLCLEARSTENCILPROC glad_glClearStencil = NULL;
		PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync = NULL;
		PFNGLCOLORMASKPROC glad_glColorMask = NULL;
		PFNGLCOLORMASKIPROC glad_glColorMaski = NULL;
		PFNGLCOMPILESHADERPROC glad_glCompileShader = NULL;
		PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D = NULL;
		PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D = NULL;
		PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D = NULL;
		PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D = NULL;
		PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D = NULL;
		PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D = NULL;
		PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData = NULL;
		PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D = NULL;
		PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D = NULL;
		PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D = NULL;
		PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D = NULL;
		PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D = NULL;
		PFNGLCREATEPROGRAMPROC glad_glCreateProgram = NULL;
		PFNGLCREATESHADERPROC glad_glCreateShader = NULL;
		PFNGLCULLFACEPROC glad_glCullFace = NULL;
		PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers = NULL;
		PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers = NULL;
		PFNGLDELETEPROGRAMPROC glad_glDeleteProgram = NULL;
		PFNGLDELETEQUERIESPROC glad_glDeleteQueries = NULL;
		PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers = NULL;
		PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers = NULL;
		PFNGLDELETESHADERPROC glad_glDeleteShader = NULL;
		PFNGLDELETESYNCPROC glad_glDeleteSync = NULL;
		PFNGLDELETETEXTURESPROC glad_glDeleteTextures = NULL;
		PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks = NULL;
		PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays = NULL;
		PFNGLDEPTHFUNCPROC glad_glDepthFunc = NULL;
		PFNGLDEPTHMASKPROC glad_glDepthMask = NULL;
		PFNGLDEPTHRANGEPROC glad_glDepthRange = NULL;
		PFNGLDETACHSHADERPROC glad_glDetachShader = NULL;
		PFNGLDISABLEPROC glad_glDisable = NULL;
		PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray = NULL;
		PFNGLDISABLEIPROC glad_glDisablei = NULL;
		PFNGLDRAWARRAYSPROC glad_glDrawArrays = NULL;
		PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect = NULL;
		PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced = NULL;
		PFNGLDRAWBUFFERPROC glad_glDrawBuffer = NULL;
		PFNGLDRAWBUFFERSPROC glad_glDrawBuffers = NULL;
		PFNGLDRAWELEMENTSPROC glad_glDrawElements = NULL;
		PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex = NULL;
		PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect = NULL;
		PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced = NULL;
		PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex = NULL;
		PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements = NULL;
		PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex = NULL;
		PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback = NULL;
		PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream = NULL;
		PFNGLENABLEPROC glad_glEnable = NULL;
		PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray = NULL;
		PFNGLENABLEIPROC glad_glEnablei = NULL;
		PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender = NULL;
		PFNGLENDQUERYPROC glad_glEndQuery = NULL;
		PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed = NULL;
		PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback = NULL;
		PFNGLFENCESYNCPROC glad_glFenceSync = NULL;
		PFNGLFINISHPROC glad_glFinish = NULL;
		PFNGLFLUSHPROC glad_glFlush = NULL;
		PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange = NULL;
		PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer = NULL;
		PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture = NULL;
		PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D = NULL;
		PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D = NULL;
		PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D = NULL;
		PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer = NULL;
		PFNGLFRONTFACEPROC glad_glFrontFace = NULL;
		PFNGLGENBUFFERSPROC glad_glGenBuffers = NULL;
		PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers = NULL;
		PFNGLGENQUERIESPROC glad_glGenQueries = NULL;
		PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers = NULL;
		PFNGLGENSAMPLERSPROC glad_glGenSamplers = NULL;
		PFNGLGENTEXTURESPROC glad_glGenTextures = NULL;
		PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = NULL;
		PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = NULL;
		PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = NULL;
		PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = NULL;
		PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = NULL;
		PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName = NULL;
		PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv = NULL;
		PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform = NULL;
		PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName = NULL;
		PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv = NULL;
		PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName = NULL;
		PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv = NULL;
		PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders = NULL;
		PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation = NULL;
		PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v = NULL;
		PFNGLGETBOOLEANVPROC glad_glGetBooleanv = NULL;
		PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v = NULL;
		PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv = NULL;
		PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv = NULL;
		PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData = NULL;
		PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage = NULL;
		PFNGLGETDOUBLEVPROC glad_glGetDoublev = NULL;
		PFNGLGETERRORPROC glad_glGetError = NULL;
		PFNGLGETFLOATVPROC glad_glGetFloatv = NULL;
		PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex = NULL;
		PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation = NULL;
		PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv = NULL;
		PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v = NULL;
		PFNGLGETINTEGER64VPROC glad_glGetInteger64v = NULL;
		PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v = NULL;
		PFNGLGETINTEGERVPROC glad_glGetIntegerv = NULL;
		PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv = NULL;
		PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog = NULL;
		PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv = NULL;
		PFNGLGETPROGRAMIVPROC glad_glGetProgramiv = NULL;
		PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv = NULL;
		PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v = NULL;
		PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv = NULL;
		PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v = NULL;
		PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv = NULL;
		PFNGLGETQUERYIVPROC glad_glGetQueryiv = NULL;
		PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv = NULL;
		PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv = NULL;
		PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv = NULL;
		PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv = NULL;
		PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv = NULL;
		PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog = NULL;
		PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource = NULL;
		PFNGLGETSHADERIVPROC glad_glGetShaderiv = NULL;
		PFNGLGETSTRINGPROC glad_glGetString = NULL;
		PFNGLGETSTRINGIPROC glad_glGetStringi = NULL;
		PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex = NULL;
		PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation = NULL;
		PFNGLGETSYNCIVPROC glad_glGetSynciv = NULL;
		PFNGLGETTEXIMAGEPROC glad_glGetTexImage = NULL;
		PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv = NULL;
		PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv = NULL;
		PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv = NULL;
		PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv = NULL;
		PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv = NULL;
		PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv = NULL;
		PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying = NULL;
		PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex = NULL;
		PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices = NULL;
		PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation = NULL;
		PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv = NULL;
		PFNGLGETUNIFORMDVPROC glad_glGetUniformdv = NULL;
		PFNGLGETUNIFORMFVPROC glad_glGetUniformfv = NULL;
		PFNGLGETUNIFORMIVPROC glad_glGetUniformiv = NULL;
		PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv = NULL;
		PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv = NULL;
		PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv = NULL;
		PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv = NULL;
		PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv = NULL;
		PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv = NULL;
		PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv = NULL;
		PFNGLHINTPROC glad_glHint = NULL;
		PFNGLISBUFFERPROC glad_glIsBuffer = NULL;
		PFNGLISENABLEDPROC glad_glIsEnabled = NULL;
		PFNGLISENABLEDIPROC glad_glIsEnabledi = NULL;
		PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer = NULL;
		PFNGLISPROGRAMPROC glad_glIsProgram = NULL;
		PFNGLISQUERYPROC glad_glIsQuery = NULL;
		PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer = NULL;
		PFNGLISSAMPLERPROC glad_glIsSampler = NULL;
		PFNGLISSHADERPROC glad_glIsShader = NULL;
		PFNGLISSYNCPROC glad_glIsSync = NULL;
		PFNGLISTEXTUREPROC glad_glIsTexture = NULL;
		PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback = NULL;
		PFNGLISVERTEXARRAYPROC glad_glIsVertexArray = NULL;
		PFNGLLINEWIDTHPROC glad_glLineWidth = NULL;
		PFNGLLINKPROGRAMPROC glad_glLinkProgram = NULL;
		PFNGLLOGICOPPROC glad_glLogicOp = NULL;
		PFNGLMAPBUFFERPROC glad_glMapBuffer = NULL;
		PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange = NULL;
		PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading = NULL;
		PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays = NULL;
		PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements = NULL;
		PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex = NULL;
		PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv = NULL;
		PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri = NULL;
		PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback = NULL;
		PFNGLPIXELSTOREFPROC glad_glPixelStoref = NULL;
		PFNGLPIXELSTOREIPROC glad_glPixelStorei = NULL;
		PFNGLPOINTPARAMETERFPROC glad_glPointParameterf = NULL;
		PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv = NULL;
		PFNGLPOINTPARAMETERIPROC glad_glPointParameteri = NULL;
		PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv = NULL;
		PFNGLPOINTSIZEPROC glad_glPointSize = NULL;
		PFNGLPOLYGONMODEPROC glad_glPolygonMode = NULL;
		PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset = NULL;
		PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex = NULL;
		PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex = NULL;
		PFNGLQUERYCOUNTERPROC glad_glQueryCounter = NULL;
		PFNGLREADBUFFERPROC glad_glReadBuffer = NULL;
		PFNGLREADPIXELSPROC glad_glReadPixels = NULL;
		PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage = NULL;
		PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample = NULL;
		PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback = NULL;
		PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage = NULL;
		PFNGLSAMPLEMASKIPROC glad_glSampleMaski = NULL;
		PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv = NULL;
		PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv = NULL;
		PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf = NULL;
		PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv = NULL;
		PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri = NULL;
		PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv = NULL;
		PFNGLSCISSORPROC glad_glScissor = NULL;
		PFNGLSHADERSOURCEPROC glad_glShaderSource = NULL;
		PFNGLSTENCILFUNCPROC glad_glStencilFunc = NULL;
		PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate = NULL;
		PFNGLSTENCILMASKPROC glad_glStencilMask = NULL;
		PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate = NULL;
		PFNGLSTENCILOPPROC glad_glStencilOp = NULL;
		PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate = NULL;
		PFNGLTEXBUFFERPROC glad_glTexBuffer = NULL;
		PFNGLTEXIMAGE1DPROC glad_glTexImage1D = NULL;
		PFNGLTEXIMAGE2DPROC glad_glTexImage2D = NULL;
		PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample = NULL;
		PFNGLTEXIMAGE3DPROC glad_glTexImage3D = NULL;
		PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample = NULL;
		PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv = NULL;
		PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv = NULL;
		PFNGLTEXPARAMETERFPROC glad_glTexParameterf = NULL;
		PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv = NULL;
		PFNGLTEXPARAMETERIPROC glad_glTexParameteri = NULL;
		PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv = NULL;
		PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D = NULL;
		PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D = NULL;
		PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D = NULL;
		PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings = NULL;
		PFNGLUNIFORM1DPROC glad_glUniform1d = NULL;
		PFNGLUNIFORM1DVPROC glad_glUniform1dv = NULL;
		PFNGLUNIFORM1FPROC glad_glUniform1f = NULL;
		PFNGLUNIFORM1FVPROC glad_glUniform1fv = NULL;
		PFNGLUNIFORM1IPROC glad_glUniform1i = NULL;
		PFNGLUNIFORM1IVPROC glad_glUniform1iv = NULL;
		PFNGLUNIFORM1UIPROC glad_glUniform1ui = NULL;
		PFNGLUNIFORM1UIVPROC glad_glUniform1uiv = NULL;
		PFNGLUNIFORM2DPROC glad_glUniform2d = NULL;
		PFNGLUNIFORM2DVPROC glad_glUniform2dv = NULL;
		PFNGLUNIFORM2FPROC glad_glUniform2f = NULL;
		PFNGLUNIFORM2FVPROC glad_glUniform2fv = NULL;
		PFNGLUNIFORM2IPROC glad_glUniform2i = NULL;
		PFNGLUNIFORM2IVPROC glad_glUniform2iv = NULL;
		PFNGLUNIFORM2UIPROC glad_glUniform2ui = NULL;
		PFNGLUNIFORM2UIVPROC glad_glUniform2uiv = NULL;
		PFNGLUNIFORM3DPROC glad_glUniform3d = NULL;
		PFNGLUNIFORM3DVPROC glad_glUniform3dv = NULL;
		PFNGLUNIFORM3FPROC glad_glUniform3f = NULL;
		PFNGLUNIFORM3FVPROC glad_glUniform3fv = NULL;
		PFNGLUNIFORM3IPROC glad_glUniform3i = NULL;
		PFNGLUNIFORM3IVPROC glad_glUniform3iv = NULL;
		PFNGLUNIFORM3UIPROC glad_glUniform3ui = NULL;
		PFNGLUNIFORM3UIVPROC glad_glUniform3uiv = NULL;
		PFNGLUNIFORM4DPROC glad_glUniform4d = NULL;
		PFNGLUNIFORM4DVPROC glad_glUniform4dv = NULL;
		PFNGLUNIFORM4FPROC glad_glUniform4f = NULL;
		PFNGLUNIFORM4FVPROC glad_glUniform4fv = NULL;
		PFNGLUNIFORM4IPROC glad_glUniform4i = NULL;
		PFNGLUNIFORM4IVPROC glad_glUniform4iv = NULL;
		PFNGLUNIFORM4UIPROC glad_glUniform4ui = NULL;
		PFNGLUNIFORM4UIVPROC glad_glUniform4uiv = NULL;
		PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding = NULL;
		PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv = NULL;
		PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv = NULL;
		PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv = NULL;
		PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv = NULL;
		PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv = NULL;
		PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv = NULL;
		PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv = NULL;
		PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv = NULL;
		PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv = NULL;
		PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv = NULL;
		PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv = NULL;
		PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv = NULL;
		PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv = NULL;
		PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv = NULL;
		PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv = NULL;
		PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv = NULL;
		PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv = NULL;
		PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv = NULL;
		PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv = NULL;
		PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer = NULL;
		PFNGLUSEPROGRAMPROC glad_glUseProgram = NULL;
		PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram = NULL;
		PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d = NULL;
		PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv = NULL;
		PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f = NULL;
		PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv = NULL;
		PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s = NULL;
		PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv = NULL;
		PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d = NULL;
		PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv = NULL;
		PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f = NULL;
		PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv = NULL;
		PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s = NULL;
		PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv = NULL;
		PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d = NULL;
		PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv = NULL;
		PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f = NULL;
		PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv = NULL;
		PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s = NULL;
		PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv = NULL;
		PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv = NULL;
		PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv = NULL;
		PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv = NULL;
		PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub = NULL;
		PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv = NULL;
		PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv = NULL;
		PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv = NULL;
		PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv = NULL;
		PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d = NULL;
		PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv = NULL;
		PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f = NULL;
		PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv = NULL;
		PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv = NULL;
		PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s = NULL;
		PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv = NULL;
		PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv = NULL;
		PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv = NULL;
		PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv = NULL;
		PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor = NULL;
		PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i = NULL;
		PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv = NULL;
		PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui = NULL;
		PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv = NULL;
		PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i = NULL;
		PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv = NULL;
		PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui = NULL;
		PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv = NULL;
		PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i = NULL;
		PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv = NULL;
		PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui = NULL;
		PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv = NULL;
		PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv = NULL;
		PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i = NULL;
		PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv = NULL;
		PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv = NULL;
		PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv = NULL;
		PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui = NULL;
		PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv = NULL;
		PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv = NULL;
		PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer = NULL;
		PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui = NULL;
		PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv = NULL;
		PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui = NULL;
		PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv = NULL;
		PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui = NULL;
		PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv = NULL;
		PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui = NULL;
		PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv = NULL;
		PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer = NULL;
		PFNGLVIEWPORTPROC glad_glViewport = NULL;
		PFNGLWAITSYNCPROC glad_glWaitSync = NULL;


		static void glad_gl_load_GL_VERSION_1_0( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_1_0) return;
		    glad_glBlendFunc = (PFNGLBLENDFUNCPROC) load(userptr, "glBlendFunc");
		    glad_glClear = (PFNGLCLEARPROC) load(userptr, "glClear");
		    glad_glClearColor = (PFNGLCLEARCOLORPROC) load(userptr, "glClearColor");
		    glad_glClearDepth = (PFNGLCLEARDEPTHPROC) load(userptr, "glClearDepth");
		    glad_glClearStencil = (PFNGLCLEARSTENCILPROC) load(userptr, "glClearStencil");
		    glad_glColorMask = (PFNGLCOLORMASKPROC) load(userptr, "glColorMask");
		    glad_glCullFace = (PFNGLCULLFACEPROC) load(userptr, "glCullFace");
		    glad_glDepthFunc = (PFNGLDEPTHFUNCPROC) load(userptr, "glDepthFunc");
		    glad_glDepthMask = (PFNGLDEPTHMASKPROC) load(userptr, "glDepthMask");
		    glad_glDepthRange = (PFNGLDEPTHRANGEPROC) load(userptr, "glDepthRange");
		    glad_glDisable = (PFNGLDISABLEPROC) load(userptr, "glDisable");
		    glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC) load(userptr, "glDrawBuffer");
		    glad_glEnable = (PFNGLENABLEPROC) load(userptr, "glEnable");
		    glad_glFinish = (PFNGLFINISHPROC) load(userptr, "glFinish");
		    glad_glFlush = (PFNGLFLUSHPROC) load(userptr, "glFlush");
		    glad_glFrontFace = (PFNGLFRONTFACEPROC) load(userptr, "glFrontFace");
		    glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC) load(userptr, "glGetBooleanv");
		    glad_glGetDoublev = (PFNGLGETDOUBLEVPROC) load(userptr, "glGetDoublev");
		    glad_glGetError = (PFNGLGETERRORPROC) load(userptr, "glGetError");
		    glad_glGetFloatv = (PFNGLGETFLOATVPROC) load(userptr, "glGetFloatv");
		    glad_glGetIntegerv = (PFNGLGETINTEGERVPROC) load(userptr, "glGetIntegerv");
		    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
		    glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC) load(userptr, "glGetTexImage");
		    glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC) load(userptr, "glGetTexLevelParameterfv");
		    glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC) load(userptr, "glGetTexLevelParameteriv");
		    glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC) load(userptr, "glGetTexParameterfv");
		    glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC) load(userptr, "glGetTexParameteriv");
		    glad_glHint = (PFNGLHINTPROC) load(userptr, "glHint");
		    glad_glIsEnabled = (PFNGLISENABLEDPROC) load(userptr, "glIsEnabled");
		    glad_glLineWidth = (PFNGLLINEWIDTHPROC) load(userptr, "glLineWidth");
		    glad_glLogicOp = (PFNGLLOGICOPPROC) load(userptr, "glLogicOp");
		    glad_glPixelStoref = (PFNGLPIXELSTOREFPROC) load(userptr, "glPixelStoref");
		    glad_glPixelStorei = (PFNGLPIXELSTOREIPROC) load(userptr, "glPixelStorei");
		    glad_glPointSize = (PFNGLPOINTSIZEPROC) load(userptr, "glPointSize");
		    glad_glPolygonMode = (PFNGLPOLYGONMODEPROC) load(userptr, "glPolygonMode");
		    glad_glReadBuffer = (PFNGLREADBUFFERPROC) load(userptr, "glReadBuffer");
		    glad_glReadPixels = (PFNGLREADPIXELSPROC) load(userptr, "glReadPixels");
		    glad_glScissor = (PFNGLSCISSORPROC) load(userptr, "glScissor");
		    glad_glStencilFunc = (PFNGLSTENCILFUNCPROC) load(userptr, "glStencilFunc");
		    glad_glStencilMask = (PFNGLSTENCILMASKPROC) load(userptr, "glStencilMask");
		    glad_glStencilOp = (PFNGLSTENCILOPPROC) load(userptr, "glStencilOp");
		    glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC) load(userptr, "glTexImage1D");
		    glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC) load(userptr, "glTexImage2D");
		    glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC) load(userptr, "glTexParameterf");
		    glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC) load(userptr, "glTexParameterfv");
		    glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC) load(userptr, "glTexParameteri");
		    glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC) load(userptr, "glTexParameteriv");
		    glad_glViewport = (PFNGLVIEWPORTPROC) load(userptr, "glViewport");
		}
		static void glad_gl_load_GL_VERSION_1_1( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_1_1) return;
		    glad_glBindTexture = (PFNGLBINDTEXTUREPROC) load(userptr, "glBindTexture");
		    glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC) load(userptr, "glCopyTexImage1D");
		    glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC) load(userptr, "glCopyTexImage2D");
		    glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC) load(userptr, "glCopyTexSubImage1D");
		    glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC) load(userptr, "glCopyTexSubImage2D");
		    glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC) load(userptr, "glDeleteTextures");
		    glad_glDrawArrays = (PFNGLDRAWARRAYSPROC) load(userptr, "glDrawArrays");
		    glad_glDrawElements = (PFNGLDRAWELEMENTSPROC) load(userptr, "glDrawElements");
		    glad_glGenTextures = (PFNGLGENTEXTURESPROC) load(userptr, "glGenTextures");
		    glad_glIsTexture = (PFNGLISTEXTUREPROC) load(userptr, "glIsTexture");
		    glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC) load(userptr, "glPolygonOffset");
		    glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC) load(userptr, "glTexSubImage1D");
		    glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC) load(userptr, "glTexSubImage2D");
		}
		static void glad_gl_load_GL_VERSION_1_2( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_1_2) return;
		    glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC) load(userptr, "glCopyTexSubImage3D");
		    glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC) load(userptr, "glDrawRangeElements");
		    glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC) load(userptr, "glTexImage3D");
		    glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC) load(userptr, "glTexSubImage3D");
		}
		static void glad_gl_load_GL_VERSION_1_3( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_1_3) return;
		    glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC) load(userptr, "glActiveTexture");
		    glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC) load(userptr, "glCompressedTexImage1D");
		    glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC) load(userptr, "glCompressedTexImage2D");
		    glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC) load(userptr, "glCompressedTexImage3D");
		    glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) load(userptr, "glCompressedTexSubImage1D");
		    glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) load(userptr, "glCompressedTexSubImage2D");
		    glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) load(userptr, "glCompressedTexSubImage3D");
		    glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetCompressedTexImage");
		    glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC) load(userptr, "glSampleCoverage");
		}
		static void glad_gl_load_GL_VERSION_1_4( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_1_4) return;
		    glad_glBlendColor = (PFNGLBLENDCOLORPROC) load(userptr, "glBlendColor");
		    glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC) load(userptr, "glBlendEquation");
		    glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC) load(userptr, "glBlendFuncSeparate");
		    glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC) load(userptr, "glMultiDrawArrays");
		    glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC) load(userptr, "glMultiDrawElements");
		    glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC) load(userptr, "glPointParameterf");
		    glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC) load(userptr, "glPointParameterfv");
		    glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC) load(userptr, "glPointParameteri");
		    glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC) load(userptr, "glPointParameteriv");
		}
		static void glad_gl_load_GL_VERSION_1_5( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_1_5) return;
		    glad_glBeginQuery = (PFNGLBEGINQUERYPROC) load(userptr, "glBeginQuery");
		    glad_glBindBuffer = (PFNGLBINDBUFFERPROC) load(userptr, "glBindBuffer");
		    glad_glBufferData = (PFNGLBUFFERDATAPROC) load(userptr, "glBufferData");
		    glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC) load(userptr, "glBufferSubData");
		    glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC) load(userptr, "glDeleteBuffers");
		    glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC) load(userptr, "glDeleteQueries");
		    glad_glEndQuery = (PFNGLENDQUERYPROC) load(userptr, "glEndQuery");
		    glad_glGenBuffers = (PFNGLGENBUFFERSPROC) load(userptr, "glGenBuffers");
		    glad_glGenQueries = (PFNGLGENQUERIESPROC) load(userptr, "glGenQueries");
		    glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) load(userptr, "glGetBufferParameteriv");
		    glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) load(userptr, "glGetBufferPointerv");
		    glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) load(userptr, "glGetBufferSubData");
		    glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) load(userptr, "glGetQueryObjectiv");
		    glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) load(userptr, "glGetQueryObjectuiv");
		    glad_glGetQueryiv = (PFNGLGETQUERYIVPROC) load(userptr, "glGetQueryiv");
		    glad_glIsBuffer = (PFNGLISBUFFERPROC) load(userptr, "glIsBuffer");
		    glad_glIsQuery = (PFNGLISQUERYPROC) load(userptr, "glIsQuery");
		    glad_glMapBuffer = (PFNGLMAPBUFFERPROC) load(userptr, "glMapBuffer");
		    glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC) load(userptr, "glUnmapBuffer");
		}
		static void glad_gl_load_GL_VERSION_2_0( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_2_0) return;
		    glad_glAttachShader = (PFNGLATTACHSHADERPROC) load(userptr, "glAttachShader");
		    glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC) load(userptr, "glBindAttribLocation");
		    glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC) load(userptr, "glBlendEquationSeparate");
		    glad_glCompileShader = (PFNGLCOMPILESHADERPROC) load(userptr, "glCompileShader");
		    glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC) load(userptr, "glCreateProgram");
		    glad_glCreateShader = (PFNGLCREATESHADERPROC) load(userptr, "glCreateShader");
		    glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC) load(userptr, "glDeleteProgram");
		    glad_glDeleteShader = (PFNGLDELETESHADERPROC) load(userptr, "glDeleteShader");
		    glad_glDetachShader = (PFNGLDETACHSHADERPROC) load(userptr, "glDetachShader");
		    glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) load(userptr, "glDisableVertexAttribArray");
		    glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) load(userptr, "glDrawBuffers");
		    glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) load(userptr, "glEnableVertexAttribArray");
		    glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC) load(userptr, "glGetActiveAttrib");
		    glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC) load(userptr, "glGetActiveUniform");
		    glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC) load(userptr, "glGetAttachedShaders");
		    glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC) load(userptr, "glGetAttribLocation");
		    glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) load(userptr, "glGetProgramInfoLog");
		    glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC) load(userptr, "glGetProgramiv");
		    glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) load(userptr, "glGetShaderInfoLog");
		    glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC) load(userptr, "glGetShaderSource");
		    glad_glGetShaderiv = (PFNGLGETSHADERIVPROC) load(userptr, "glGetShaderiv");
		    glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) load(userptr, "glGetUniformLocation");
		    glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC) load(userptr, "glGetUniformfv");
		    glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC) load(userptr, "glGetUniformiv");
		    glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) load(userptr, "glGetVertexAttribPointerv");
		    glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) load(userptr, "glGetVertexAttribdv");
		    glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) load(userptr, "glGetVertexAttribfv");
		    glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) load(userptr, "glGetVertexAttribiv");
		    glad_glIsProgram = (PFNGLISPROGRAMPROC) load(userptr, "glIsProgram");
		    glad_glIsShader = (PFNGLISSHADERPROC) load(userptr, "glIsShader");
		    glad_glLinkProgram = (PFNGLLINKPROGRAMPROC) load(userptr, "glLinkProgram");
		    glad_glShaderSource = (PFNGLSHADERSOURCEPROC) load(userptr, "glShaderSource");
		    glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC) load(userptr, "glStencilFuncSeparate");
		    glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC) load(userptr, "glStencilMaskSeparate");
		    glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC) load(userptr, "glStencilOpSeparate");
		    glad_glUniform1f = (PFNGLUNIFORM1FPROC) load(userptr, "glUniform1f");
		    glad_glUniform1fv = (PFNGLUNIFORM1FVPROC) load(userptr, "glUniform1fv");
		    glad_glUniform1i = (PFNGLUNIFORM1IPROC) load(userptr, "glUniform1i");
		    glad_glUniform1iv = (PFNGLUNIFORM1IVPROC) load(userptr, "glUniform1iv");
		    glad_glUniform2f = (PFNGLUNIFORM2FPROC) load(userptr, "glUniform2f");
		    glad_glUniform2fv = (PFNGLUNIFORM2FVPROC) load(userptr, "glUniform2fv");
		    glad_glUniform2i = (PFNGLUNIFORM2IPROC) load(userptr, "glUniform2i");
		    glad_glUniform2iv = (PFNGLUNIFORM2IVPROC) load(userptr, "glUniform2iv");
		    glad_glUniform3f = (PFNGLUNIFORM3FPROC) load(userptr, "glUniform3f");
		    glad_glUniform3fv = (PFNGLUNIFORM3FVPROC) load(userptr, "glUniform3fv");
		    glad_glUniform3i = (PFNGLUNIFORM3IPROC) load(userptr, "glUniform3i");
		    glad_glUniform3iv = (PFNGLUNIFORM3IVPROC) load(userptr, "glUniform3iv");
		    glad_glUniform4f = (PFNGLUNIFORM4FPROC) load(userptr, "glUniform4f");
		    glad_glUniform4fv = (PFNGLUNIFORM4FVPROC) load(userptr, "glUniform4fv");
		    glad_glUniform4i = (PFNGLUNIFORM4IPROC) load(userptr, "glUniform4i");
		    glad_glUniform4iv = (PFNGLUNIFORM4IVPROC) load(userptr, "glUniform4iv");
		    glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC) load(userptr, "glUniformMatrix2fv");
		    glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC) load(userptr, "glUniformMatrix3fv");
		    glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC) load(userptr, "glUniformMatrix4fv");
		    glad_glUseProgram = (PFNGLUSEPROGRAMPROC) load(userptr, "glUseProgram");
		    glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC) load(userptr, "glValidateProgram");
		    glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) load(userptr, "glVertexAttrib1d");
		    glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) load(userptr, "glVertexAttrib1dv");
		    glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) load(userptr, "glVertexAttrib1f");
		    glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) load(userptr, "glVertexAttrib1fv");
		    glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) load(userptr, "glVertexAttrib1s");
		    glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) load(userptr, "glVertexAttrib1sv");
		    glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) load(userptr, "glVertexAttrib2d");
		    glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) load(userptr, "glVertexAttrib2dv");
		    glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) load(userptr, "glVertexAttrib2f");
		    glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) load(userptr, "glVertexAttrib2fv");
		    glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) load(userptr, "glVertexAttrib2s");
		    glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) load(userptr, "glVertexAttrib2sv");
		    glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) load(userptr, "glVertexAttrib3d");
		    glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) load(userptr, "glVertexAttrib3dv");
		    glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) load(userptr, "glVertexAttrib3f");
		    glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) load(userptr, "glVertexAttrib3fv");
		    glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) load(userptr, "glVertexAttrib3s");
		    glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) load(userptr, "glVertexAttrib3sv");
		    glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC) load(userptr, "glVertexAttrib4Nbv");
		    glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC) load(userptr, "glVertexAttrib4Niv");
		    glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC) load(userptr, "glVertexAttrib4Nsv");
		    glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) load(userptr, "glVertexAttrib4Nub");
		    glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) load(userptr, "glVertexAttrib4Nubv");
		    glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC) load(userptr, "glVertexAttrib4Nuiv");
		    glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC) load(userptr, "glVertexAttrib4Nusv");
		    glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC) load(userptr, "glVertexAttrib4bv");
		    glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) load(userptr, "glVertexAttrib4d");
		    glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) load(userptr, "glVertexAttrib4dv");
		    glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) load(userptr, "glVertexAttrib4f");
		    glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) load(userptr, "glVertexAttrib4fv");
		    glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC) load(userptr, "glVertexAttrib4iv");
		    glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) load(userptr, "glVertexAttrib4s");
		    glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) load(userptr, "glVertexAttrib4sv");
		    glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC) load(userptr, "glVertexAttrib4ubv");
		    glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC) load(userptr, "glVertexAttrib4uiv");
		    glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC) load(userptr, "glVertexAttrib4usv");
		    glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) load(userptr, "glVertexAttribPointer");
		}
		static void glad_gl_load_GL_VERSION_2_1( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_2_1) return;
		    glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC) load(userptr, "glUniformMatrix2x3fv");
		    glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC) load(userptr, "glUniformMatrix2x4fv");
		    glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC) load(userptr, "glUniformMatrix3x2fv");
		    glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC) load(userptr, "glUniformMatrix3x4fv");
		    glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC) load(userptr, "glUniformMatrix4x2fv");
		    glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC) load(userptr, "glUniformMatrix4x3fv");
		}
		static void glad_gl_load_GL_VERSION_3_0( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_3_0) return;
		    glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC) load(userptr, "glBeginConditionalRender");
		    glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) load(userptr, "glBeginTransformFeedback");
		    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
		    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
		    glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC) load(userptr, "glBindFragDataLocation");
		    glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) load(userptr, "glBindFramebuffer");
		    glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) load(userptr, "glBindRenderbuffer");
		    glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) load(userptr, "glBindVertexArray");
		    glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) load(userptr, "glBlitFramebuffer");
		    glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckFramebufferStatus");
		    glad_glClampColor = (PFNGLCLAMPCOLORPROC) load(userptr, "glClampColor");
		    glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC) load(userptr, "glClearBufferfi");
		    glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC) load(userptr, "glClearBufferfv");
		    glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC) load(userptr, "glClearBufferiv");
		    glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC) load(userptr, "glClearBufferuiv");
		    glad_glColorMaski = (PFNGLCOLORMASKIPROC) load(userptr, "glColorMaski");
		    glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) load(userptr, "glDeleteFramebuffers");
		    glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) load(userptr, "glDeleteRenderbuffers");
		    glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) load(userptr, "glDeleteVertexArrays");
		    glad_glDisablei = (PFNGLDISABLEIPROC) load(userptr, "glDisablei");
		    glad_glEnablei = (PFNGLENABLEIPROC) load(userptr, "glEnablei");
		    glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC) load(userptr, "glEndConditionalRender");
		    glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) load(userptr, "glEndTransformFeedback");
		    glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) load(userptr, "glFlushMappedBufferRange");
		    glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glFramebufferRenderbuffer");
		    glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) load(userptr, "glFramebufferTexture1D");
		    glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) load(userptr, "glFramebufferTexture2D");
		    glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) load(userptr, "glFramebufferTexture3D");
		    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
		    glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) load(userptr, "glGenFramebuffers");
		    glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) load(userptr, "glGenRenderbuffers");
		    glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) load(userptr, "glGenVertexArrays");
		    glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) load(userptr, "glGenerateMipmap");
		    glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) load(userptr, "glGetBooleani_v");
		    glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC) load(userptr, "glGetFragDataLocation");
		    glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetFramebufferAttachmentParameteriv");
		    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
		    glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetRenderbufferParameteriv");
		    glad_glGetStringi = (PFNGLGETSTRINGIPROC) load(userptr, "glGetStringi");
		    glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC) load(userptr, "glGetTexParameterIiv");
		    glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC) load(userptr, "glGetTexParameterIuiv");
		    glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) load(userptr, "glGetTransformFeedbackVarying");
		    glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC) load(userptr, "glGetUniformuiv");
		    glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC) load(userptr, "glGetVertexAttribIiv");
		    glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC) load(userptr, "glGetVertexAttribIuiv");
		    glad_glIsEnabledi = (PFNGLISENABLEDIPROC) load(userptr, "glIsEnabledi");
		    glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) load(userptr, "glIsFramebuffer");
		    glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) load(userptr, "glIsRenderbuffer");
		    glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) load(userptr, "glIsVertexArray");
		    glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) load(userptr, "glMapBufferRange");
		    glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) load(userptr, "glRenderbufferStorage");
		    glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glRenderbufferStorageMultisample");
		    glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC) load(userptr, "glTexParameterIiv");
		    glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC) load(userptr, "glTexParameterIuiv");
		    glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC) load(userptr, "glTransformFeedbackVaryings");
		    glad_glUniform1ui = (PFNGLUNIFORM1UIPROC) load(userptr, "glUniform1ui");
		    glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC) load(userptr, "glUniform1uiv");
		    glad_glUniform2ui = (PFNGLUNIFORM2UIPROC) load(userptr, "glUniform2ui");
		    glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC) load(userptr, "glUniform2uiv");
		    glad_glUniform3ui = (PFNGLUNIFORM3UIPROC) load(userptr, "glUniform3ui");
		    glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC) load(userptr, "glUniform3uiv");
		    glad_glUniform4ui = (PFNGLUNIFORM4UIPROC) load(userptr, "glUniform4ui");
		    glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC) load(userptr, "glUniform4uiv");
		    glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC) load(userptr, "glVertexAttribI1i");
		    glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC) load(userptr, "glVertexAttribI1iv");
		    glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC) load(userptr, "glVertexAttribI1ui");
		    glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC) load(userptr, "glVertexAttribI1uiv");
		    glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC) load(userptr, "glVertexAttribI2i");
		    glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC) load(userptr, "glVertexAttribI2iv");
		    glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC) load(userptr, "glVertexAttribI2ui");
		    glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC) load(userptr, "glVertexAttribI2uiv");
		    glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC) load(userptr, "glVertexAttribI3i");
		    glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC) load(userptr, "glVertexAttribI3iv");
		    glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC) load(userptr, "glVertexAttribI3ui");
		    glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC) load(userptr, "glVertexAttribI3uiv");
		    glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC) load(userptr, "glVertexAttribI4bv");
		    glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC) load(userptr, "glVertexAttribI4i");
		    glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC) load(userptr, "glVertexAttribI4iv");
		    glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC) load(userptr, "glVertexAttribI4sv");
		    glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC) load(userptr, "glVertexAttribI4ubv");
		    glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC) load(userptr, "glVertexAttribI4ui");
		    glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC) load(userptr, "glVertexAttribI4uiv");
		    glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC) load(userptr, "glVertexAttribI4usv");
		    glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC) load(userptr, "glVertexAttribIPointer");
		}
		static void glad_gl_load_GL_VERSION_3_1( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_3_1) return;
		    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
		    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
		    glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) load(userptr, "glCopyBufferSubData");
		    glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, "glDrawArraysInstanced");
		    glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, "glDrawElementsInstanced");
		    glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) load(userptr, "glGetActiveUniformBlockName");
		    glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) load(userptr, "glGetActiveUniformBlockiv");
		    glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) load(userptr, "glGetActiveUniformName");
		    glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) load(userptr, "glGetActiveUniformsiv");
		    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
		    glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) load(userptr, "glGetUniformBlockIndex");
		    glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) load(userptr, "glGetUniformIndices");
		    glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC) load(userptr, "glPrimitiveRestartIndex");
		    glad_glTexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, "glTexBuffer");
		    glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) load(userptr, "glUniformBlockBinding");
		}
		static void glad_gl_load_GL_VERSION_3_2( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_3_2) return;
		    glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) load(userptr, "glClientWaitSync");
		    glad_glDeleteSync = (PFNGLDELETESYNCPROC) load(userptr, "glDeleteSync");
		    glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glDrawElementsBaseVertex");
		    glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) load(userptr, "glDrawElementsInstancedBaseVertex");
		    glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) load(userptr, "glDrawRangeElementsBaseVertex");
		    glad_glFenceSync = (PFNGLFENCESYNCPROC) load(userptr, "glFenceSync");
		    glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, "glFramebufferTexture");
		    glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) load(userptr, "glGetBufferParameteri64v");
		    glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) load(userptr, "glGetInteger64i_v");
		    glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC) load(userptr, "glGetInteger64v");
		    glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, "glGetMultisamplefv");
		    glad_glGetSynciv = (PFNGLGETSYNCIVPROC) load(userptr, "glGetSynciv");
		    glad_glIsSync = (PFNGLISSYNCPROC) load(userptr, "glIsSync");
		    glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glMultiDrawElementsBaseVertex");
		    glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, "glProvokingVertex");
		    glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC) load(userptr, "glSampleMaski");
		    glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) load(userptr, "glTexImage2DMultisample");
		    glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) load(userptr, "glTexImage3DMultisample");
		    glad_glWaitSync = (PFNGLWAITSYNCPROC) load(userptr, "glWaitSync");
		}
		static void glad_gl_load_GL_VERSION_3_3( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_3_3) return;
		    glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) load(userptr, "glBindFragDataLocationIndexed");
		    glad_glBindSampler = (PFNGLBINDSAMPLERPROC) load(userptr, "glBindSampler");
		    glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) load(userptr, "glDeleteSamplers");
		    glad_glGenSamplers = (PFNGLGENSAMPLERSPROC) load(userptr, "glGenSamplers");
		    glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC) load(userptr, "glGetFragDataIndex");
		    glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) load(userptr, "glGetQueryObjecti64v");
		    glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) load(userptr, "glGetQueryObjectui64v");
		    glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) load(userptr, "glGetSamplerParameterIiv");
		    glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) load(userptr, "glGetSamplerParameterIuiv");
		    glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) load(userptr, "glGetSamplerParameterfv");
		    glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) load(userptr, "glGetSamplerParameteriv");
		    glad_glIsSampler = (PFNGLISSAMPLERPROC) load(userptr, "glIsSampler");
		    glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC) load(userptr, "glQueryCounter");
		    glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) load(userptr, "glSamplerParameterIiv");
		    glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) load(userptr, "glSamplerParameterIuiv");
		    glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) load(userptr, "glSamplerParameterf");
		    glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) load(userptr, "glSamplerParameterfv");
		    glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) load(userptr, "glSamplerParameteri");
		    glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) load(userptr, "glSamplerParameteriv");
		    glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC) load(userptr, "glVertexAttribDivisor");
		    glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC) load(userptr, "glVertexAttribP1ui");
		    glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC) load(userptr, "glVertexAttribP1uiv");
		    glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC) load(userptr, "glVertexAttribP2ui");
		    glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC) load(userptr, "glVertexAttribP2uiv");
		    glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC) load(userptr, "glVertexAttribP3ui");
		    glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC) load(userptr, "glVertexAttribP3uiv");
		    glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC) load(userptr, "glVertexAttribP4ui");
		    glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC) load(userptr, "glVertexAttribP4uiv");
		}
		static void glad_gl_load_GL_VERSION_4_0( GLADuserptrloadfunc load, void* userptr) {
		    if(!GLAD_GL_VERSION_4_0) return;
		    glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) load(userptr, "glBeginQueryIndexed");
		    glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) load(userptr, "glBindTransformFeedback");
		    glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, "glBlendEquationSeparatei");
		    glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, "glBlendEquationi");
		    glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, "glBlendFuncSeparatei");
		    glad_glBlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, "glBlendFunci");
		    glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, "glDeleteTransformFeedbacks");
		    glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) load(userptr, "glDrawArraysIndirect");
		    glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) load(userptr, "glDrawElementsIndirect");
		    glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, "glDrawTransformFeedback");
		    glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) load(userptr, "glDrawTransformFeedbackStream");
		    glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) load(userptr, "glEndQueryIndexed");
		    glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, "glGenTransformFeedbacks");
		    glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) load(userptr, "glGetActiveSubroutineName");
		    glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) load(userptr, "glGetActiveSubroutineUniformName");
		    glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) load(userptr, "glGetActiveSubroutineUniformiv");
		    glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) load(userptr, "glGetProgramStageiv");
		    glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) load(userptr, "glGetQueryIndexediv");
		    glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) load(userptr, "glGetSubroutineIndex");
		    glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) load(userptr, "glGetSubroutineUniformLocation");
		    glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) load(userptr, "glGetUniformSubroutineuiv");
		    glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC) load(userptr, "glGetUniformdv");
		    glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, "glIsTransformFeedback");
		    glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC) load(userptr, "glMinSampleShading");
		    glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) load(userptr, "glPatchParameterfv");
		    glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) load(userptr, "glPatchParameteri");
		    glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, "glPauseTransformFeedback");
		    glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, "glResumeTransformFeedback");
		    glad_glUniform1d = (PFNGLUNIFORM1DPROC) load(userptr, "glUniform1d");
		    glad_glUniform1dv = (PFNGLUNIFORM1DVPROC) load(userptr, "glUniform1dv");
		    glad_glUniform2d = (PFNGLUNIFORM2DPROC) load(userptr, "glUniform2d");
		    glad_glUniform2dv = (PFNGLUNIFORM2DVPROC) load(userptr, "glUniform2dv");
		    glad_glUniform3d = (PFNGLUNIFORM3DPROC) load(userptr, "glUniform3d");
		    glad_glUniform3dv = (PFNGLUNIFORM3DVPROC) load(userptr, "glUniform3dv");
		    glad_glUniform4d = (PFNGLUNIFORM4DPROC) load(userptr, "glUniform4d");
		    glad_glUniform4dv = (PFNGLUNIFORM4DVPROC) load(userptr, "glUniform4dv");
		    glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) load(userptr, "glUniformMatrix2dv");
		    glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) load(userptr, "glUniformMatrix2x3dv");
		    glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) load(userptr, "glUniformMatrix2x4dv");
		    glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) load(userptr, "glUniformMatrix3dv");
		    glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) load(userptr, "glUniformMatrix3x2dv");
		    glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) load(userptr, "glUniformMatrix3x4dv");
		    glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) load(userptr, "glUniformMatrix4dv");
		    glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) load(userptr, "glUniformMatrix4x2dv");
		    glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) load(userptr, "glUniformMatrix4x3dv");
		    glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) load(userptr, "glUniformSubroutinesuiv");
		}



		static void glad_gl_free_extensions(char **exts_i) {
		    if (exts_i != NULL) {
		        unsigned int index;
		        for(index = 0; exts_i[index]; index++) {
		            free((void *) (exts_i[index]));
		        }
		        free((void *)exts_i);
		        exts_i = NULL;
		    }
		}
		static int glad_gl_get_extensions( const char **out_exts, char ***out_exts_i) {
		#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
		    if (glad_glGetStringi != NULL && glad_glGetIntegerv != NULL) {
		        unsigned int index = 0;
		        unsigned int num_exts_i = 0;
		        char **exts_i = NULL;
		        glad_glGetIntegerv(GL_NUM_EXTENSIONS, (int*) &num_exts_i);
		        exts_i = (char **) malloc((num_exts_i + 1) * (sizeof *exts_i));
		        if (exts_i == NULL) {
		            return 0;
		        }
		        for(index = 0; index < num_exts_i; index++) {
		            const char *gl_str_tmp = (const char*) glad_glGetStringi(GL_EXTENSIONS, index);
		            size_t len = strlen(gl_str_tmp) + 1;

		            char *local_str = (char*) malloc(len * sizeof(char));
		            if(local_str == NULL) {
		                exts_i[index] = NULL;
		                glad_gl_free_extensions(exts_i);
		                return 0;
		            }

		            memcpy(local_str, gl_str_tmp, len * sizeof(char));
		            exts_i[index] = local_str;
		        }
		        exts_i[index] = NULL;

		        *out_exts_i = exts_i;

		        return 1;
		    }
		#else
		    GLAD_UNUSED(out_exts_i);
		#endif
		    if (glad_glGetString == NULL) {
		        return 0;
		    }
		    *out_exts = (const char *)glad_glGetString(GL_EXTENSIONS);
		    return 1;
		}
		static int glad_gl_has_extension(const char *exts, char **exts_i, const char *ext) {
		    if(exts_i) {
		        unsigned int index;
		        for(index = 0; exts_i[index]; index++) {
		            const char *e = exts_i[index];
		            if(strcmp(e, ext) == 0) {
		                return 1;
		            }
		        }
		    } else {
		        const char *extensions;
		        const char *loc;
		        const char *terminator;
		        extensions = exts;
		        if(extensions == NULL || ext == NULL) {
		            return 0;
		        }
		        while(1) {
		            loc = strstr(extensions, ext);
		            if(loc == NULL) {
		                return 0;
		            }
		            terminator = loc + strlen(ext);
		            if((loc == extensions || *(loc - 1) == ' ') &&
		                (*terminator == ' ' || *terminator == '\0')) {
		                return 1;
		            }
		            extensions = terminator;
		        }
		    }
		    return 0;
		}

		static GLADapiproc glad_gl_get_proc_from_userptr(void *userptr, const char* name) {
		    return (GLAD_GNUC_EXTENSION (GLADapiproc (*)(const char *name)) userptr)(name);
		}

		static int glad_gl_find_extensions_gl(void) {
		    const char *exts = NULL;
		    char **exts_i = NULL;
		    if (!glad_gl_get_extensions(&exts, &exts_i)) return 0;

		    GLAD_UNUSED(glad_gl_has_extension);

		    glad_gl_free_extensions(exts_i);

		    return 1;
		}

		static int glad_gl_find_core_gl(void) {
		    int i;
		    const char* version;
		    const char* prefixes[] = {
		        "OpenGL ES-CM ",
		        "OpenGL ES-CL ",
		        "OpenGL ES ",
		        "OpenGL SC ",
		        NULL
		    };
		    int major = 0;
		    int minor = 0;
		    version = (const char*) glad_glGetString(GL_VERSION);
		    if (!version) return 0;
		    for (i = 0;  prefixes[i];  i++) {
		        const size_t length = strlen(prefixes[i]);
		        if (strncmp(version, prefixes[i], length) == 0) {
		            version += length;
		            break;
		        }
		    }

		    GLAD_IMPL_UTIL_SSCANF(version, "%d.%d", &major, &minor);

		    GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
		    GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
		    GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
		    GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
		    GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
		    GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
		    GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
		    GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
		    GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
		    GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
		    GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
		    GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
		    GLAD_GL_VERSION_4_0 = (major == 4 && minor >= 0) || major > 4;

		    return GLAD_MAKE_VERSION(major, minor);
		}

		int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr) {
		    int version;

		    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
		    if(glad_glGetString == NULL) return 0;
		    version = glad_gl_find_core_gl();

		    glad_gl_load_GL_VERSION_1_0(load, userptr);
		    glad_gl_load_GL_VERSION_1_1(load, userptr);
		    glad_gl_load_GL_VERSION_1_2(load, userptr);
		    glad_gl_load_GL_VERSION_1_3(load, userptr);
		    glad_gl_load_GL_VERSION_1_4(load, userptr);
		    glad_gl_load_GL_VERSION_1_5(load, userptr);
		    glad_gl_load_GL_VERSION_2_0(load, userptr);
		    glad_gl_load_GL_VERSION_2_1(load, userptr);
		    glad_gl_load_GL_VERSION_3_0(load, userptr);
		    glad_gl_load_GL_VERSION_3_1(load, userptr);
		    glad_gl_load_GL_VERSION_3_2(load, userptr);
		    glad_gl_load_GL_VERSION_3_3(load, userptr);
		    glad_gl_load_GL_VERSION_4_0(load, userptr);

		    if (!glad_gl_find_extensions_gl()) return 0;



		    return version;
		}


		int gladLoadGL( GLADloadfunc load) {
		    return gladLoadGLUserPtr( glad_gl_get_proc_from_userptr, GLAD_GNUC_EXTENSION (void*) load);
		}



		 

		#ifdef GLAD_GL

		#ifndef GLAD_LOADER_LIBRARY_C_
		#define GLAD_LOADER_LIBRARY_C_

		#include <stddef.h>
		#include <stdlib.h>

		#if GLAD_PLATFORM_WIN32
		#include <windows.h>
		#else
		#include <dlfcn.h>
		#endif


		static void* glad_get_dlopen_handle(const char *lib_names[], int length) {
		    void *handle = NULL;
		    int i;

		    for (i = 0; i < length; ++i) {
		#if GLAD_PLATFORM_WIN32
		  #if GLAD_PLATFORM_UWP
		        size_t buffer_size = (strlen(lib_names[i]) + 1) * sizeof(WCHAR);
		        LPWSTR buffer = (LPWSTR) malloc(buffer_size);
		        if (buffer != NULL) {
		            int ret = MultiByteToWideChar(CP_ACP, 0, lib_names[i], -1, buffer, buffer_size);
		            if (ret != 0) {
		                handle = (void*) LoadPackagedLibrary(buffer, 0);
		            }
		            free((void*) buffer);
		        }
		  #else
		        handle = (void*) LoadLibraryA(lib_names[i]);
		  #endif
		#else
		        handle = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
		#endif
		        if (handle != NULL) {
		            return handle;
		        }
		    }

		    return NULL;
		}

		static void glad_close_dlopen_handle(void* handle) {
		    if (handle != NULL) {
		#if GLAD_PLATFORM_WIN32
		        FreeLibrary((HMODULE) handle);
		#else
		        dlclose(handle);
		#endif
		    }
		}

		static GLADapiproc glad_dlsym_handle(void* handle, const char *name) {
		    if (handle == NULL) {
		        return NULL;
		    }

		#if GLAD_PLATFORM_WIN32
		    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);
		#else
		    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);
		#endif
		}

		#endif /* GLAD_LOADER_LIBRARY_C_ */

		typedef void* (GLAD_API_PTR *GLADglprocaddrfunc)(const char*);
		struct _glad_gl_userptr {
		    void *handle;
		    GLADglprocaddrfunc gl_get_proc_address_ptr;
		};

		static GLADapiproc glad_gl_get_proc(void *vuserptr, const char *name) {
		    struct _glad_gl_userptr userptr = *(struct _glad_gl_userptr*) vuserptr;
		    GLADapiproc result = NULL;

		    if(userptr.gl_get_proc_address_ptr != NULL) {
		        result = GLAD_GNUC_EXTENSION (GLADapiproc) userptr.gl_get_proc_address_ptr(name);
		    }
		    if(result == NULL) {
		        result = glad_dlsym_handle(userptr.handle, name);
		    }

		    return result;
		}

		static void* _glad_GL_loader_handle = NULL;

		static void* glad_gl_dlopen_handle(void) {
		#if GLAD_PLATFORM_APPLE
		    static const char *NAMES[] = {
		        "../Frameworks/OpenGL.framework/OpenGL",
		        "/Library/Frameworks/OpenGL.framework/OpenGL",
		        "/System/Library/Frameworks/OpenGL.framework/OpenGL",
		        "/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL"
		    };
		#elif GLAD_PLATFORM_WIN32
		    static const char *NAMES[] = {"opengl32.dll"};
		#else
		    static const char *NAMES[] = {
		  #if defined(__CYGWIN__)
		        "libGL-1.so",
		  #endif
		        "libGL.so.1",
		        "libGL.so"
		    };
		#endif

		    if (_glad_GL_loader_handle == NULL) {
		        _glad_GL_loader_handle = glad_get_dlopen_handle(NAMES, sizeof(NAMES) / sizeof(NAMES[0]));
		    }

		    return _glad_GL_loader_handle;
		}

		static struct _glad_gl_userptr glad_gl_build_userptr(void *handle) {
		    struct _glad_gl_userptr userptr;

		    userptr.handle = handle;
		#if GLAD_PLATFORM_APPLE || defined(__HAIKU__)
		    userptr.gl_get_proc_address_ptr = NULL;
		#elif GLAD_PLATFORM_WIN32
		    userptr.gl_get_proc_address_ptr =
		        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "wglGetProcAddress");
		#else
		    userptr.gl_get_proc_address_ptr =
		        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "glXGetProcAddressARB");
		#endif

		    return userptr;
		}

		int gladLoaderLoadGL(void) {
		    int version = 0;
		    void *handle;
		    int did_load = 0;
		    struct _glad_gl_userptr userptr;

		    did_load = _glad_GL_loader_handle == NULL;
		    handle = glad_gl_dlopen_handle();
		    if (handle) {
		        userptr = glad_gl_build_userptr(handle);

		        version = gladLoadGLUserPtr(glad_gl_get_proc, &userptr);

		        if (did_load) {
		            gladLoaderUnloadGL();
		        }
		    }

		    return version;
		}



		void gladLoaderUnloadGL(void) {
		    if (_glad_GL_loader_handle != NULL) {
		        glad_close_dlopen_handle(_glad_GL_loader_handle);
		        _glad_GL_loader_handle = NULL;
		    }
		}

		#endif /* GLAD_GL */

		#ifdef __cplusplus
		}
		#endif

		#endif /* GLAD_GL_IMPLEMENTATION */

	/* muCOSA commit beab34d implementation */

	#ifndef MUCOSA_IMPLEMENTATION
		#define MUCOSA_IMPLEMENTATION

		#ifdef MUCOSA_IMPLEMENTATION

			/* muString commit 6678f59 implementation */

				#ifndef MUS_IMPLEMENTATION
					#define MUS_IMPLEMENTATION

					#ifdef MUS_IMPLEMENTATION

						/* muMemoryAllocator version 1.0.0 implementation */

							#ifndef MUMA_IMPLEMENTATION
								#define MUMA_IMPLEMENTATION

								#ifdef MUMA_IMPLEMENTATION

									/* muUtility version 1.0.0 implementation */

										#ifndef MUU_IMPLEMENTATION
											#define MUU_IMPLEMENTATION

											#ifdef MUU_IMPLEMENTATION
									
												// ...

											#endif /* MUU_IMPLEMENTATION */
										#endif

									#ifdef __cplusplus
										extern "C" {
									#endif

									#ifdef MUMA_NAMES
										MUDEF const char* muma_result_get_name(mumaResult result) {
											switch (result) {
												default: return "MUMA_UNKNOWN"; break;
												case MUMA_SUCCESS: return "MUMA_SUCCESS"; break;
												case MUMA_FAILED_TO_ALLOCATE: return "MUMA_FAILED_TO_ALLOCATE"; break;
												case MUMA_INVALID_INDEX: return "MUMA_INVALID_INDEX"; break;
												case MUMA_INVALID_SHIFT_AMOUNT: return "MUMA_INVALID_SHIFT_AMOUNT"; break;
												case MUMA_NOT_FOUND: return "MUMA_NOT_FOUND"; break;
											}
										}
									#endif

									#ifdef __cplusplus
										}
									#endif

								#endif /* MUMA_IMPLEMENTATION */
							#endif

						/* muMultithreading version 1.0.0 implementation (only if thread safe) */
						// CHANGES:
						// * Removed muma implementation inclusion because this library already has it.
						// * Added alt MU_LOCK definitions for non-thread safe code.

						#ifdef MU_THREADSAFE

							#ifndef MUM_IMPLEMENTATION
								#define MUM_IMPLEMENTATION

								#ifdef MUM_IMPLEMENTATION

									#ifdef __cplusplus
									extern "C" { // }
									#endif

									/* Shared functions */

										/* Names */

											#ifdef MUM_NAMES
												MUDEF const char* mum_result_get_name(mumResult result) {
													switch (result) {
														default: return "MUM_UNKNOWN"; break;
														case MUM_SUCCESS: return "MUM_SUCCESS"; break;
														case MUM_MUMA_SUCCESS: return "MUM_MUMA_SUCCESS"; break;
														case MUM_MUMA_FAILED_TO_ALLOCATE: return "MUM_MUMA_FAILED_TO_ALLOCATE"; break;
														case MUM_MUMA_INVALID_INDEX: return "MUM_MUMA_INVALID_INDEX"; break;
														case MUM_MUMA_INVALID_SHIFT_AMOUNT: return "MUM_MUMA_INVALID_SHIFT_AMOUNT"; break;
														case MUM_MUMA_NOT_FOUND: return "MUM_MUMA_NOT_FOUND"; break;
														case MUM_ALLOCATION_FAILED: return "MUM_ALLOCATION_FAILED"; break;
														case MUM_ALREADY_INITIALIZED: return "MUM_ALREADY_INITIALIZED"; break;
														case MUM_ALREADY_TERMINATED: return "MUM_ALREADY_TERMINATED"; break;
														case MUM_NOT_YET_INITIALIZED: return "MUM_NOT_YET_INITIALIZED"; break;
														case MUM_CREATE_CALL_FAILED: return "MUM_CREATE_CALL_FAILED"; break;
														case MUM_DESTROY_CALL_FAILED: return "MUM_DESTROY_CALL_FAILED"; break;
														case MUM_WAIT_CALL_FAILED: return "MUM_WAIT_CALL_FAILED"; break;
														case MUM_LOCK_CALL_FAILED: return "MUM_LOCK_CALL_FAILED"; break;
														case MUM_UNLOCK_CALL_FAILED: return "MUM_UNLOCK_CALL_FAILED"; break;
														case MUM_GET_RETURN_VALUE_CALL_FAILED: return "MUM_GET_RETURN_VALUE_CALL_FAILED"; break;
														case MUM_INVALID_ID: return "MUM_INVALID_ID"; break;
														case MUM_THREAD_TIMED_OUT: return "MUM_THREAD_TIMED_OUT"; break;
														case MUM_PREVIOUS_THREAD_CLOSED_BEFORE_LOCK: return "MUM_PREVIOUS_THREAD_CLOSED_BEFORE_LOCK"; break;
													}
												}
											#endif

										/* Get result */

											mumResult muma_result_to_mum_result(mumaResult res) {
												switch (res) {
													default: case MUMA_SUCCESS: return MUM_MUMA_SUCCESS; break;
													case MUMA_FAILED_TO_ALLOCATE: return MUM_MUMA_FAILED_TO_ALLOCATE; break;
													case MUMA_INVALID_INDEX: return MUM_MUMA_INVALID_INDEX; break;
													case MUMA_INVALID_SHIFT_AMOUNT: return MUM_MUMA_INVALID_SHIFT_AMOUNT; break;
													case MUMA_NOT_FOUND: return MUM_MUMA_NOT_FOUND; break;
												}
											}

									/* Unix */

									#ifdef MU_UNIX

										#include <pthread.h>

										/* Useful things */

											// These two functions are essentially stolen from:
											// https://github.com/stepancheg/no-mutex-c

											static inline muBool mum_atomic_compare_exchange(int* ptr, int compare, int exchange) {
												return __atomic_compare_exchange_n(ptr, &compare, exchange, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
											}

											static inline void mum_atomic_store(int* ptr, int value) {
												if (value) {}
												__atomic_store_n(ptr, 0, __ATOMIC_SEQ_CST);
											}

											#ifdef MU_THREADSAFE

												#define MU_LOCK pthread_mutex_t lock; muBool lock_active;

												#define MU_LOCK_CREATE(lock, lock_active) \
													if (pthread_mutex_init(&lock, 0) == 0) { \
														lock_active = MU_TRUE; \
													} else { \
														lock_active = MU_FALSE; \
													}

												#define MU_LOCK_DESTROY(lock, lock_active) \
													if (lock_active) { \
														if (pthread_mutex_destroy(&lock) == 0) { \
															lock_active = MU_FALSE; \
														} \
													}

												#define MU_LOCK_LOCK(lock, lock_active) \
													if (lock_active) { \
														pthread_mutex_lock(&lock); \
													}

												#define MU_LOCK_UNLOCK(lock, lock_active) \
													if (lock_active) { \
														pthread_mutex_unlock(&lock); \
													}

											#else

												#define MU_LOCK
												#define MU_LOCK_CREATE(lock, active)
												#define MU_LOCK_DESTROY(lock, active)
												#define MU_LOCK_LOCK(lock, active)
												#define MU_LOCK_UNLOCK(lock, active)

											#endif

										/* Arrays */

											/* Thread */

												struct mu_unix_thread {
													muBool active;
													pthread_t handle;
													void* ret;

													MU_LOCK
												};
												typedef struct mu_unix_thread mu_unix_thread;

												MU_HRARRAY_DEFAULT_FUNC(mu_unix_thread)

											/* Mutex */

												struct mu_unix_mutex {
													muBool active;
													pthread_mutex_t handle;

													MU_LOCK
												};
												typedef struct mu_unix_mutex mu_unix_mutex;

												MU_HRARRAY_DEFAULT_FUNC(mu_unix_mutex)

											/* Spinlock */

												struct mu_unix_spinlock {
													muBool active;
													int locked;

													MU_LOCK
												};
												typedef struct mu_unix_spinlock mu_unix_spinlock;

												MU_HRARRAY_DEFAULT_FUNC(mu_unix_spinlock)

										/* Initiation / Termination */

											/* Setup */

												struct mumContext {
													mu_unix_thread_array threads;
													#define MUM_GTHREADS mum_global_context->threads
													mu_unix_mutex_array mutexes;
													#define MUM_GMUTEXES mum_global_context->mutexes
													mu_unix_spinlock_array spinlocks;
													#define MUM_GSPINLOCKS mum_global_context->spinlocks
												};

											/* API-level */

												mumContext* mum_global_context = MU_NULL_PTR;

												MUDEF void mum_init(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)

													MU_ASSERT(mum_global_context == MU_NULL_PTR, result, MUM_ALREADY_INITIALIZED, return;)

													mum_global_context = (mumContext*)mu_malloc(sizeof(mumContext));
													MU_ASSERT(mum_global_context != 0, result, MUM_ALLOCATION_FAILED, return;)

													MUM_GTHREADS = MU_ZERO_STRUCT(mu_unix_thread_array);
													MUM_GMUTEXES = MU_ZERO_STRUCT(mu_unix_mutex_array);
													MUM_GSPINLOCKS = MU_ZERO_STRUCT(mu_unix_spinlock_array);
												}

												MUDEF void mum_term(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)

													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_ALREADY_TERMINATED, return;)

													for (size_m i = 0; i < MUM_GTHREADS.length; i++) {
														mu_thread_destroy(0, i);
													}
													mu_unix_thread_destroy(0, &MUM_GTHREADS);

													for (size_m i = 0; i < MUM_GMUTEXES.length; i++) {
														mu_mutex_destroy(0, i);
													}
													mu_unix_mutex_destroy(0, &MUM_GMUTEXES);

													for (size_m i = 0; i < MUM_GSPINLOCKS.length; i++) {
														mu_spinlock_destroy(0, i);
													}
													mu_unix_spinlock_destroy(0, &MUM_GSPINLOCKS);

													mu_free(mum_global_context);
													mum_global_context = MU_NULL_PTR;
												}

										/* Threads */

											/* API-level */

												MUDEF muThread mu_thread_create(mumResult* result, void (*start)(void* args), void* args) {
													MU_SET_RESULT(result, MUM_SUCCESS)

													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_NOT_YET_INITIALIZED, return MU_NONE;)

													size_m thread = MU_NONE;
													mumaResult muma_res = MUMA_SUCCESS;
													mu_unix_thread_find_push(&muma_res, &MUM_GTHREADS, MU_ZERO_STRUCT(mu_unix_thread), &thread);
													MU_ASSERT(muma_res == MUMA_SUCCESS && thread != MU_NONE, result, muma_result_to_mum_result(muma_res), 
														return MU_NONE;
													)

													mu_unix_thread_hold_element(0, &MUM_GTHREADS, thread);
													void* (*func)(void*);
													mu_memcpy(&func, &start, sizeof(void*));
													if (pthread_create(&MUM_GTHREADS.data[thread].handle, 0, func, args) != 0) {
														MU_RELEASE(MUM_GTHREADS, thread, mu_unix_thread_)
														MU_SET_RESULT(result, MUM_CREATE_CALL_FAILED)
														return MU_NONE;
													}

													MUM_GTHREADS.data[thread].active = MU_TRUE;
													MU_RELEASE(MUM_GTHREADS, thread, mu_unix_thread_)
													return thread;
												}

												MUDEF muThread mu_thread_destroy(mumResult* result, muThread thread) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return thread;)
													MU_HOLD(result, thread, MUM_GTHREADS, mum_global_context, MUM_, return thread;, mu_unix_thread_)

													MU_ASSERT(pthread_cancel(MUM_GTHREADS.data[thread].handle) == 0, result, MUM_DESTROY_CALL_FAILED, 
														MU_RELEASE(MUM_GTHREADS, thread, mu_unix_thread_) return thread;
													)
													MUM_GTHREADS.data[thread].active = MU_FALSE;

													MU_RELEASE(MUM_GTHREADS, thread, mu_unix_thread_)
													return MU_NONE;
												}

												MUDEF void mu_thread_exit(void* ret) {
													pthread_exit(ret);
												}

												MUDEF void mu_thread_wait(mumResult* result, muThread thread) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, thread, MUM_GTHREADS, mum_global_context, MUM_, return;, mu_unix_thread_)

													MU_ASSERT(pthread_join(MUM_GTHREADS.data[thread].handle, &MUM_GTHREADS.data[thread].ret) == 0, result, MUM_WAIT_CALL_FAILED,
														MU_RELEASE(MUM_GTHREADS, thread, mu_unix_thread_) return;
													)
													MU_RELEASE(MUM_GTHREADS, thread, mu_unix_thread_)
												}

												MUDEF void* mu_thread_get_return_value(mumResult* result, muThread thread) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return MU_NULL_PTR;)
													MU_HOLD(result, thread, MUM_GTHREADS, mum_global_context, MUM_, return MU_NULL_PTR;, mu_unix_thread_)

													void* ret = MUM_GTHREADS.data[thread].ret;
													MU_RELEASE(MUM_GTHREADS, thread, mu_unix_thread_)
													return ret;
												}

										/* Mutexes */

											/* API-level */

												MUDEF muMutex mu_mutex_create(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)
													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_NOT_YET_INITIALIZED, return MU_NONE;)

													size_m mutex = MU_NONE;
													mumaResult muma_res = MUMA_SUCCESS;
													mu_unix_mutex_find_push(&muma_res, &MUM_GMUTEXES, MU_ZERO_STRUCT(mu_unix_mutex), &mutex);
													MU_ASSERT(muma_res == MUMA_SUCCESS && mutex != MU_NONE, result, muma_result_to_mum_result(muma_res),
														return MU_NONE;
													)

													mu_unix_mutex_hold_element(0, &MUM_GMUTEXES, mutex);
													if (pthread_mutex_init(&MUM_GMUTEXES.data[mutex].handle, 0) != 0) {
														MU_RELEASE(MUM_GMUTEXES, mutex, mu_unix_mutex_)
														MU_SET_RESULT(result, MUM_CREATE_CALL_FAILED)
														return MU_NONE;
													}

													MUM_GMUTEXES.data[mutex].active = MU_TRUE;
													MU_RELEASE(MUM_GMUTEXES, mutex, mu_unix_mutex_)
													return mutex;
												}

												MUDEF muMutex mu_mutex_destroy(mumResult* result, muMutex mutex) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return mutex;)
													MU_HOLD(result, mutex, MUM_GMUTEXES, mum_global_context, MUM_, return mutex;, mu_unix_mutex_)

													MU_ASSERT(pthread_mutex_destroy(&MUM_GMUTEXES.data[mutex].handle) == 0, result, MUM_DESTROY_CALL_FAILED, 
														MU_RELEASE(MUM_GMUTEXES, mutex, mu_unix_mutex_) return mutex;
													)
													MUM_GMUTEXES.data[mutex].active = MU_FALSE;
													MU_RELEASE(MUM_GMUTEXES, mutex, mu_unix_mutex_)
													return MU_NONE;
												}

												// This poses an odd structural challenge. If we make both the lock & unlock
												// function hold the mutex, you reach a deadlock pretty easily, ie:

												// * Thread 1 locks mutex, quickly holding and releasing it.
												// * Thread 2 attempts to lock mutex, holding it and waiting for it to be unlocked,
												// * Thread 1 is done, and attempts to unlock the mutex, so it tries to hold it,
												// but it's still being held by thread 2 who is attempting to lock it, so you reach
												// a deadlock.

												// This can be solved by:
												// A) Making the 'lock mutex' function release the function early, allowing it to
												// wait to lock it without holding it during that wait time.
												// B) Make the 'unlock mutex' function not hold/release the mutex.

												// I've chosen A because the only way it *doesn't* work well is if the user deletes
												// a mutex while a thread is running with it locked AND another one is waiting on
												// it, which is already a horrible situation to be in. Pretty sure deleting a mutex
												// with a thread having it locked is already undefined behavior anyway.

												// Note that this same logic applies to the other locks.

												MUDEF void mu_mutex_lock(mumResult* result, muMutex mutex) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, mutex, MUM_GMUTEXES, mum_global_context, MUM_, return;, mu_unix_mutex_)

													MU_RELEASE(MUM_GMUTEXES, mutex, mu_unix_mutex_)
													MU_ASSERT(pthread_mutex_lock(&MUM_GMUTEXES.data[mutex].handle) == 0, result, MUM_LOCK_CALL_FAILED, 
														return;
													)
												}

												MUDEF void mu_mutex_unlock(mumResult* result, muMutex mutex) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, mutex, MUM_GMUTEXES, mum_global_context, MUM_, return;, mu_unix_mutex_)

													MU_ASSERT(pthread_mutex_unlock(&MUM_GMUTEXES.data[mutex].handle) == 0, result, MUM_UNLOCK_CALL_FAILED, 
														MU_RELEASE(MUM_GMUTEXES, mutex, mu_unix_mutex_) return;
													)
													MU_RELEASE(MUM_GMUTEXES, mutex, mu_unix_mutex_)
												}

										/* Spinlocks */

											/* API-level */

												MUDEF muSpinlock mu_spinlock_create(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)
													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_NOT_YET_INITIALIZED, return MU_NONE;)

													size_m spinlock = MU_NONE;
													mumaResult muma_res = MUMA_SUCCESS;
													mu_unix_spinlock_find_push(&muma_res, &MUM_GSPINLOCKS, MU_ZERO_STRUCT(mu_unix_spinlock), &spinlock);
													MU_ASSERT(muma_res == MUMA_SUCCESS && spinlock != MU_NONE, result, muma_result_to_mum_result(muma_res),
														return MU_NONE;
													)

													mu_unix_spinlock_hold_element(0, &MUM_GSPINLOCKS, spinlock);
													MUM_GSPINLOCKS.data[spinlock].locked = 0;

													MUM_GSPINLOCKS.data[spinlock].active = MU_TRUE;
													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_unix_spinlock_)
													return spinlock;
												}

												MUDEF muSpinlock mu_spinlock_destroy(mumResult* result, muSpinlock spinlock) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return spinlock;)
													MU_HOLD(result, spinlock, MUM_GSPINLOCKS, mum_global_context, MUM_, return spinlock;, mu_unix_spinlock_)

													MUM_GSPINLOCKS.data[spinlock].locked = 0;
													MUM_GSPINLOCKS.data[spinlock].active = MU_FALSE;
													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_unix_spinlock_)
													return MU_NONE;
												}

												MUDEF void mu_spinlock_lock(mumResult* result, muSpinlock spinlock) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, spinlock, MUM_GSPINLOCKS, mum_global_context, MUM_, return;, mu_unix_spinlock_)

													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_unix_spinlock_)
													// Note that this is a bit less safe than mutexes, but there's little I can do
													// in this position.
													while (!mum_atomic_compare_exchange(&MUM_GSPINLOCKS.data[spinlock].locked, 0, 1)) {}
												}

												MUDEF void mu_spinlock_unlock(mumResult* result, muSpinlock spinlock) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, spinlock, MUM_GSPINLOCKS, mum_global_context, MUM_, return;, mu_unix_spinlock_)

													mum_atomic_store(&MUM_GSPINLOCKS.data[spinlock].locked, 0);
													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_unix_spinlock_)
												}

									#endif /* MU_UNIX */

									#ifdef MU_WIN32

										#include <windows.h>

										/* Useful things */

											static inline muBool mum_atomic_compare_exchange(LONG volatile* ptr, LONG compare, LONG exchange) {
												return InterlockedCompareExchange(ptr, exchange, compare) != exchange;
											}

											// Kind of a hack
											static inline void mum_atomic_store(LONG volatile* ptr, long value) {
												if (value == 0) {
													_interlockedbittestandreset(ptr, 0);
												} else {
													_interlockedbittestandset(ptr, 0);
												}
											}

											#ifdef MU_THREADSAFE

												#define MU_LOCK HANDLE lock; muBool lock_active;

												#define MU_LOCK_CREATE(lock, lock_active) \
													lock = CreateMutex(0, MU_FALSE, 0); \
													if (lock != 0) { \
														lock_active = MU_TRUE; \
													} else { \
														lock_active = MU_FALSE; \
													}

												#define MU_LOCK_DESTROY(lock, lock_active) \
													if (lock_active) { \
														if (CloseHandle(lock) != 0) { \
															lock_active = MU_FALSE; \
														} \
													}

												#define MU_LOCK_LOCK(lock, lock_active) \
													if (lock_active) { \
														WaitForSingleObject(lock, INFINITE); \
													}

												#define MU_LOCK_UNLOCK(lock, lock_active) \
													if (lock_active) { \
														ReleaseMutex(lock); \
													}

											#else

												#define MU_LOCK
												#define MU_LOCK_CREATE(lock, active)
												#define MU_LOCK_DESTROY(lock, active)
												#define MU_LOCK_LOCK(lock, active)
												#define MU_LOCK_UNLOCK(lock, active)

											#endif

										/* Arrays */

											/* Thread */

												struct mu_win32_thread {
													muBool active;
													HANDLE handle;

													MU_LOCK
												};
												typedef struct mu_win32_thread mu_win32_thread;

												MU_HRARRAY_DEFAULT_FUNC(mu_win32_thread)

											/* Mutex */

												struct mu_win32_mutex {
													muBool active;
													HANDLE handle;

													MU_LOCK
												};
												typedef struct mu_win32_mutex mu_win32_mutex;

												MU_HRARRAY_DEFAULT_FUNC(mu_win32_mutex)

											/* Spinlock */

												struct mu_win32_spinlock {
													muBool active;
													LONG volatile locked;

													MU_LOCK
												};
												typedef struct mu_win32_spinlock mu_win32_spinlock;

												MU_HRARRAY_DEFAULT_FUNC(mu_win32_spinlock)

										/* Initiation / Termination */

											/* Setup */

												struct mumContext {
													mu_win32_thread_array threads;
													#define MUM_GTHREADS mum_global_context->threads
													mu_win32_mutex_array mutexes;
													#define MUM_GMUTEXES mum_global_context->mutexes
													mu_win32_spinlock_array spinlocks;
													#define MUM_GSPINLOCKS mum_global_context->spinlocks
												};

											/* API-level */

												mumContext* mum_global_context = MU_NULL_PTR;

												MUDEF void mum_init(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)

													MU_ASSERT(mum_global_context == MU_NULL_PTR, result, MUM_ALREADY_INITIALIZED, return;)

													mum_global_context = (mumContext*)mu_malloc(sizeof(mumContext));
													MU_ASSERT(mum_global_context != 0, result, MUM_ALLOCATION_FAILED, return;)

													MUM_GTHREADS = MU_ZERO_STRUCT(mu_win32_thread_array);
													MUM_GMUTEXES = MU_ZERO_STRUCT(mu_win32_mutex_array);
													MUM_GSPINLOCKS = MU_ZERO_STRUCT(mu_win32_spinlock_array);
												}

												MUDEF void mum_term(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)

													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_ALREADY_TERMINATED, return;)

													for (size_m i = 0; i < MUM_GTHREADS.length; i++) {
														mu_thread_destroy(0, i);
													}
													mu_win32_thread_destroy(0, &MUM_GTHREADS);

													for (size_m i = 0; i < MUM_GMUTEXES.length; i++) {
														mu_mutex_destroy(0, i);
													}
													mu_win32_mutex_destroy(0, &MUM_GMUTEXES);

													for (size_m i = 0; i < MUM_GSPINLOCKS.length; i++) {
														mu_spinlock_destroy(0, i);
													}
													mu_win32_spinlock_destroy(0, &MUM_GSPINLOCKS);

													mu_free(mum_global_context);
													mum_global_context = MU_NULL_PTR;
												}

										/* Threads */

											/* API-level */

												MUDEF muThread mu_thread_create(mumResult* result, void (*start)(void* args), void* args) {
													MU_SET_RESULT(result, MUM_SUCCESS)

													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_NOT_YET_INITIALIZED, return MU_NONE;)

													size_m thread = MU_NONE;
													mumaResult muma_res = MUMA_SUCCESS;
													mu_win32_thread_find_push(&muma_res, &MUM_GTHREADS, MU_ZERO_STRUCT(mu_win32_thread), &thread);
													MU_ASSERT(muma_res == MUMA_SUCCESS && thread != MU_NONE, result, muma_result_to_mum_result(muma_res), 
														return MU_NONE;
													)

													mu_win32_thread_hold_element(0, &MUM_GTHREADS, thread);
													LPTHREAD_START_ROUTINE lp_start;
													mu_memcpy(&lp_start, &start, sizeof(void*));
													DWORD id;
													MUM_GTHREADS.data[thread].handle = CreateThread(0, 0, lp_start, args, 0, &id);
													if (MUM_GTHREADS.data[thread].handle == 0) {
														MU_RELEASE(MUM_GTHREADS, thread, mu_win32_thread_);
														MU_SET_RESULT(result, MUM_CREATE_CALL_FAILED)
														return MU_NONE;
													}

													MUM_GTHREADS.data[thread].active = MU_TRUE;
													MU_RELEASE(MUM_GTHREADS, thread, mu_win32_thread_)
													return thread;
												}

												MUDEF muThread mu_thread_destroy(mumResult* result, muThread thread) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return thread;)
													MU_HOLD(result, thread, MUM_GTHREADS, mum_global_context, MUM_, return thread;, mu_win32_thread_)

													MU_ASSERT(CloseHandle(MUM_GTHREADS.data[thread].handle) == 0, result, MUM_DESTROY_CALL_FAILED, 
														MU_RELEASE(MUM_GTHREADS, thread, mu_win32_thread_) return thread;
													)
													MUM_GTHREADS.data[thread].active = MU_FALSE;

													MU_RELEASE(MUM_GTHREADS, thread, mu_win32_thread_)
													return MU_NONE;
												}

												MUDEF void mu_thread_exit(void* ret) {
													DWORD d;
													mu_memcpy(&d, &ret, sizeof(DWORD));
													ExitThread(d);
												}

												MUDEF void mu_thread_wait(mumResult* result, muThread thread) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, thread, MUM_GTHREADS, mum_global_context, MUM_, return;, mu_win32_thread_)

													DWORD wait_result = WaitForSingleObject(MUM_GTHREADS.data[thread].handle, INFINITE);

													switch (wait_result) {
														case WAIT_TIMEOUT: {
															MU_SET_RESULT(result, MUM_THREAD_TIMED_OUT)
														} break;

														case WAIT_FAILED: {
															MU_SET_RESULT(result, MUM_WAIT_CALL_FAILED)
														} break;
													}

													MU_RELEASE(MUM_GTHREADS, thread, mu_win32_thread_)
												}

												MUDEF void* mu_thread_get_return_value(mumResult* result, muThread thread) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return MU_NULL_PTR;)
													MU_HOLD(result, thread, MUM_GTHREADS, mum_global_context, MUM_, return MU_NULL_PTR;, mu_win32_thread_)

													DWORD exit_code = 0;
													MU_ASSERT(GetExitCodeThread(MUM_GTHREADS.data[thread].handle, &exit_code) != 0, result, MUM_GET_RETURN_VALUE_CALL_FAILED, 
														MU_RELEASE(MUM_GTHREADS, thread, mu_win32_thread_) return MU_NULL_PTR;
													)

													void* p;
													mu_memcpy(&p, &exit_code, sizeof(DWORD));

													MU_RELEASE(MUM_GTHREADS, thread, mu_win32_thread_)
													return p;
												}

										/* Mutexes */

											/* API-level */

												MUDEF muMutex mu_mutex_create(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)
													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_NOT_YET_INITIALIZED, return MU_NONE;)

													size_m mutex = MU_NONE;
													mumaResult muma_res = MUMA_SUCCESS;
													mu_win32_mutex_find_push(&muma_res, &MUM_GMUTEXES, MU_ZERO_STRUCT(mu_win32_mutex), &mutex);
													MU_ASSERT(muma_res == MUMA_SUCCESS && mutex != MU_NONE, result, muma_result_to_mum_result(muma_res),
														return MU_NONE;
													)

													mu_win32_mutex_hold_element(0, &MUM_GMUTEXES, mutex);
													MUM_GMUTEXES.data[mutex].handle = CreateMutex(0, MU_FALSE, 0);
													if (MUM_GMUTEXES.data[mutex].handle == 0) {
														MU_RELEASE(MUM_GMUTEXES, mutex, mu_win32_mutex_)
														MU_SET_RESULT(result, MUM_CREATE_CALL_FAILED)
														return MU_NONE;
													}

													MUM_GMUTEXES.data[mutex].active = MU_TRUE;
													MU_RELEASE(MUM_GMUTEXES, mutex, mu_win32_mutex_)
													return mutex;
												}

												MUDEF muMutex mu_mutex_destroy(mumResult* result, muMutex mutex) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return mutex;)
													MU_HOLD(result, mutex, MUM_GMUTEXES, mum_global_context, MUM_, return mutex;, mu_win32_mutex_)

													MU_ASSERT(CloseHandle(MUM_GMUTEXES.data[mutex].handle) == 0, result, MUM_DESTROY_CALL_FAILED, 
														MU_RELEASE(MUM_GMUTEXES, mutex, mu_win32_mutex_) return mutex;
													)
													MUM_GMUTEXES.data[mutex].active = MU_FALSE;
													MU_RELEASE(MUM_GMUTEXES, mutex, mu_win32_mutex_)
													return MU_NONE;
												}

												MUDEF void mu_mutex_lock(mumResult* result, muMutex mutex) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, mutex, MUM_GMUTEXES, mum_global_context, MUM_, return;, mu_win32_mutex_)

													MU_RELEASE(MUM_GMUTEXES, mutex, mu_win32_mutex_)
													DWORD wait_result = WaitForSingleObject(MUM_GMUTEXES.data[mutex].handle, INFINITE);

													switch (wait_result) {
														// The mutex has most likely been closed. This should pretty much never happen with
														// the way mum is set up, but if it has, that's really bad. Most likely, rather mum
														// is not working as intended at all, or the user has modified things that they
														// shouldn't.
														case WAIT_FAILED: {
															MU_SET_RESULT(result, MUM_INVALID_ID)
														} break;

														// The thread holding the mutex has died. This can be due to a few things:
														// * The thread crashed or otherwise imploded in on itself.
														// * I forgot to put an unlock call on an error return case.
														// * The user has fiddled around with values they shouldn't.
														// Either way, this is REALLY, REALLY bad, and will lead to sporadic random bugs &
														// crashes.
														// Note: we still have ownership due to this, but ehhhhh.
														// https://devblogs.microsoft.com/oldnewthing/20050912-14/?p=34253
														// (Raymond Chen is awesome btw)
														case WAIT_ABANDONED: {
															MU_SET_RESULT(result, MUM_PREVIOUS_THREAD_CLOSED_BEFORE_LOCK)
														} break;
													}
												}

												MUDEF void mu_mutex_unlock(mumResult* result, muMutex mutex) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, mutex, MUM_GMUTEXES, mum_global_context, MUM_, return;, mu_win32_mutex_)

													MU_ASSERT(ReleaseMutex(MUM_GMUTEXES.data[mutex].handle), result, MUM_UNLOCK_CALL_FAILED, 
														MU_RELEASE(MUM_GMUTEXES, mutex, mu_win32_mutex_) return;
													)
													MU_RELEASE(MUM_GMUTEXES, mutex, mu_win32_mutex_)
												}

										/* Spinlocks */

											/* API-level */

												MUDEF muSpinlock mu_spinlock_create(mumResult* result) {
													MU_SET_RESULT(result, MUM_SUCCESS)
													MU_ASSERT(mum_global_context != MU_NULL_PTR, result, MUM_NOT_YET_INITIALIZED, return MU_NONE;)

													size_m spinlock = MU_NONE;
													mumaResult muma_res = MUMA_SUCCESS;
													mu_win32_spinlock_find_push(&muma_res, &MUM_GSPINLOCKS, MU_ZERO_STRUCT(mu_win32_spinlock), &spinlock);
													MU_ASSERT(muma_res == MUMA_SUCCESS && spinlock != MU_NONE, result, muma_result_to_mum_result(muma_res),
														return MU_NONE;
													)

													mu_win32_spinlock_hold_element(0, &MUM_GSPINLOCKS, spinlock);
													MUM_GSPINLOCKS.data[spinlock].locked = 0;

													MUM_GSPINLOCKS.data[spinlock].active = MU_TRUE;
													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_win32_spinlock_)
													return spinlock;
												}

												MUDEF muSpinlock mu_spinlock_destroy(mumResult* result, muSpinlock spinlock) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return spinlock;)
													MU_HOLD(result, spinlock, MUM_GSPINLOCKS, mum_global_context, MUM_, return spinlock;, mu_win32_spinlock_)

													MUM_GSPINLOCKS.data[spinlock].locked = 0;
													MUM_GSPINLOCKS.data[spinlock].active = MU_FALSE;
													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_win32_spinlock_)
													return MU_NONE;
												}

												MUDEF void mu_spinlock_lock(mumResult* result, muSpinlock spinlock) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, spinlock, MUM_GSPINLOCKS, mum_global_context, MUM_, return;, mu_win32_spinlock_)

													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_win32_spinlock_)
													while (!mum_atomic_compare_exchange(&MUM_GSPINLOCKS.data[spinlock].locked, 0, 1)) {}
												}

												MUDEF void mu_spinlock_unlock(mumResult* result, muSpinlock spinlock) {
													MU_SAFEFUNC(result, MUM_, mum_global_context, return;)
													MU_HOLD(result, spinlock, MUM_GSPINLOCKS, mum_global_context, MUM_, return;, mu_win32_spinlock_)

													mum_atomic_store(&MUM_GSPINLOCKS.data[spinlock].locked, 0);
													MU_RELEASE(MUM_GSPINLOCKS, spinlock, mu_win32_spinlock_)
												}

									#endif /* MU_WIN32 */

									#ifdef __cplusplus
									}
									#endif

								#endif /* MUM_IMPLEMENTATION */
							#endif

						#else

							#define MU_LOCK
							#define MU_LOCK_CREATE(...)
							#define MU_LOCK_DESTROY(...)
							#define MU_LOCK_LOCK(...)
							#define MU_LOCK_UNLOCK(...)

						#endif

						#ifdef __cplusplus
						extern "C" { // }
						#endif

						/* Result conversion */

							musResult muma_result_to_mus_result(mumaResult res) {
								switch (res) {
									default: case MUMA_SUCCESS: return MUS_MUMA_SUCCESS; break;
									case MUMA_FAILED_TO_ALLOCATE: return MUS_MUMA_FAILED_TO_ALLOCATE; break;
									case MUMA_INVALID_INDEX: return MUS_MUMA_INVALID_INDEX; break;
									case MUMA_INVALID_SHIFT_AMOUNT: return MUS_MUMA_INVALID_SHIFT_AMOUNT; break;
									case MUMA_NOT_FOUND: return MUS_MUMA_NOT_FOUND; break;
								}
							}

						/* Functions */

							/* Names */

								#ifdef MUS_NAMES
									MUDEF const char* mus_result_get_name(musResult result) {
										switch (result) {
											default: return "MUS_UNKNOWN"; break;
											case MUS_SUCCESS: return "MUS_SUCCESS"; break;
											case MUS_ALREADY_INITIALIZED: return "MUS_ALREADY_INITIALIZED"; break;
											case MUS_ALLOCATION_FAILED: return "MUS_ALLOCATION_FAILED"; break;
											case MUS_ALREADY_TERMINATED: return "MUS_ALREADY_TERMINATED"; break;
											case MUS_NOT_YET_INITIALIZED: return "MUS_NOT_YET_INITIALIZED"; break;
											case MUS_UNKNOWN_CHARACTER_ENCODING: return "MUS_UNKNOWN_CHARACTER_ENCODING"; break;
											case MUS_CHARACTER_CANNOT_BE_ENCODED: return "MUS_CHARACTER_CANNOT_BE_ENCODED"; break;
											case MUS_INVALID_CHARACTER_ENCODING: return "MUS_INVALID_CHARACTER_ENCODING"; break;
											case MUS_INVALID_CODE_POINT_SIZE: return "MUS_INVALID_CODE_POINT_SIZE"; break;
											case MUS_INVALID_DATA_SIZE: return "MUS_INVALID_DATA_SIZE"; break;
											case MUS_INVALID_DATA_POINTER: return "MUS_INVALID_DATA_POINTER"; break;
											case MUS_INVALID_OFFSET: return "MUS_INVALID_OFFSET"; break;
											case MUS_INVALID_ID: return "MUS_INVALID_ID"; break;
											case MUS_INVALID_DATA: return "MUS_INVALID_DATA"; break;
											case MUS_INSUFFICIENT_DATA_SIZE: return "MUS_INSUFFICIENT_DATA_SIZE"; break;
											case MUS_NONMATCHING_CHARACTER_ENCODING: return "MUS_NONMATCHING_CHARACTER_ENCODING"; break;
											case MUS_MUMA_FAILED_TO_ALLOCATE: return "MUS_MUMA_FAILED_TO_ALLOCATE"; break;
											case MUS_MUMA_INVALID_INDEX: return "MUS_MUMA_INVALID_INDEX"; break;
											case MUS_MUMA_INVALID_SHIFT_AMOUNT: return "MUS_MUMA_INVALID_SHIFT_AMOUNT"; break;
											case MUS_MUMA_NOT_FOUND: return "MUS_MUMA_NOT_FOUND"; break;
										}
									}
								#endif

							/* Structs */

								muBool mu_bstring_comp(muByte b0, muByte b1) {
									return b0 == b1;
								}

								mu_dynamic_array_declaration(mus_byte_string, muByte, mus_bstring_, mu_bstring_comp)

								struct mus_string {
									muBool active;

									muCharacterEncoding encoding;
									mus_byte_string bytes;
									size_m code_point_length;

									MU_LOCK
								};
								typedef struct mus_string mus_string;

								MU_HRARRAY_DEFAULT_FUNC(mus_string)

							/* Initiation / Termination */

								struct musContext {
									mus_string_array strings;
									#define MUS_GSTRINGS mus_global_context->strings
								};

								musContext* mus_global_context = MU_NULL_PTR;

								MUDEF void mus_init(musResult* result) {
									MU_SET_RESULT(result, MUS_SUCCESS)

									MU_ASSERT(mus_global_context == MU_NULL_PTR, result, MUS_ALREADY_INITIALIZED, return;)

									mus_global_context = (musContext*)mu_malloc(sizeof(musContext));
									MU_ASSERT(mus_global_context != 0, result, MUS_ALLOCATION_FAILED, return;)

									MUS_GSTRINGS = MU_ZERO_STRUCT(mus_string_array);
								}

								MUDEF void mus_term(musResult* result) {
									MU_SET_RESULT(result, MUS_SUCCESS)
									MU_ASSERT(mus_global_context != MU_NULL_PTR, result, MUS_ALREADY_TERMINATED, return;)

									for (size_m i = 0; i < MUS_GSTRINGS.length; i++) {
										mu_string_destroy(0, i);
									}
									mus_string_destroy(0, &MUS_GSTRINGS);

									mu_free(mus_global_context);
									mus_global_context = MU_NULL_PTR;
								}

							/* String functions */

								/* Creation/Destruction */

									MUDEF muString mu_string_create(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return MU_NONE;)
										mumaResult muma_res = MUMA_SUCCESS;
										musResult res = MUS_SUCCESS;
										
										MU_ASSERT(mu_character_encoding_verify_raw_string(&res, encoding, data, data_size) == MU_TRUE, result, MUS_INVALID_CHARACTER_ENCODING, return MU_NONE;)
										MU_ASSERT(res == MUS_SUCCESS, result, res, return MU_NONE;)

										mus_string s_string = MU_ZERO_STRUCT(mus_string);
										s_string.active = MU_TRUE;

										s_string.encoding = encoding;
										s_string.code_point_length = mu_character_encoding_get_raw_string_code_point_length(&res, encoding, data, data_size);
										MU_ASSERT(res == MUS_SUCCESS, result, res, return MU_NONE;)
										
										s_string.bytes = mus_bstring_create(&muma_res, data_size);
										MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), return MU_NONE;)
										mu_memcpy(s_string.bytes.data, data, data_size);

										size_m string = MU_NONE;
										mus_string_find_push(&muma_res, &MUS_GSTRINGS, MU_ZERO_STRUCT(mus_string), &string);
										MU_ASSERT(muma_res == MUMA_SUCCESS && string != MU_NONE, result, muma_result_to_mus_result(muma_res), 
											mus_bstring_destroy(0, s_string.bytes);
										)

										mus_string_hold_element(0, &MUS_GSTRINGS, string);
										MUS_GSTRINGS.data[string] = s_string;
										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return string;
									}

									MUDEF muString mu_string_destroy(musResult* result, muString string) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return string;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return string;, mus_string_)
										mumaResult muma_res = MUMA_SUCCESS;

										mus_bstring_destroy(&muma_res, MUS_GSTRINGS.data[string].bytes);
										MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return string;)
										MUS_GSTRINGS.data[string].active = MU_FALSE;

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return MU_NONE;
									}

									MUDEF muString mu_string_duplicate(musResult* result, muString string) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return MU_NONE;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return MU_NONE;, mus_string_)
										musResult mus_res = MUS_SUCCESS;

										muString dupe = mu_string_create(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											MUS_GSTRINGS.data[string].bytes.data,
											MUS_GSTRINGS.data[string].bytes.length
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return MU_NONE;)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return dupe;
									}

								/* Data */

									MUDEF muByte* mu_string_get_raw_data(musResult* result, muString string, size_m* size) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return MU_NULL_PTR;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return MU_NULL_PTR;, mus_string_)

										muByte* data = MUS_GSTRINGS.data[string].bytes.data;
										MU_SET_RESULT(size, MUS_GSTRINGS.data[string].bytes.length)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return data;
									}

								/* Character encoding */

									MUDEF muCharacterEncoding mu_string_get_character_encoding(musResult* result, muString string) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return MU_UNKNOWN_CHARACTER_ENCODING;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return MU_UNKNOWN_CHARACTER_ENCODING;, mus_string_)

										muCharacterEncoding encoding = MUS_GSTRINGS.data[string].encoding;

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return encoding;
									}

									MUDEF void mu_string_convert_character_encoding(musResult* result, muString string, muCharacterEncoding desired_encoding) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return;, mus_string_)
										musResult mus_res = MUS_SUCCESS;
										mumaResult muma_res = MUMA_SUCCESS;

										size_m new_size = mu_raw_string_get_character_encoding_conversion_size(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											MUS_GSTRINGS.data[string].bytes.data,
											MUS_GSTRINGS.data[string].bytes.length,
											desired_encoding
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)
										if (MUS_GSTRINGS.data[string].encoding == desired_encoding) {
											return;
										}

										mus_byte_string new_bytes = mus_bstring_create(&muma_res, new_size);
										MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										mu_raw_string_convert_character_encoding(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											MUS_GSTRINGS.data[string].bytes.data,
											MUS_GSTRINGS.data[string].bytes.length,
											desired_encoding,
											new_bytes.data,
											new_bytes.length
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, mus_bstring_destroy(0, new_bytes); MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										size_m new_code_point_length = mu_character_encoding_get_raw_string_code_point_length(&mus_res,
											desired_encoding, new_bytes.data, new_bytes.length
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, mus_bstring_destroy(0, new_bytes); MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										mus_bstring_destroy(0, MUS_GSTRINGS.data[string].bytes);
										MUS_GSTRINGS.data[string].bytes = new_bytes;
										MUS_GSTRINGS.data[string].encoding = desired_encoding;
										MUS_GSTRINGS.data[string].code_point_length = new_code_point_length;

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
									}

								/* Code point */

									MUDEF size_m mu_string_get_code_point_length(musResult* result, muString string) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return 0;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return 0;, mus_string_)

										size_m code_point_length = MUS_GSTRINGS.data[string].code_point_length;

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return code_point_length;
									}

									MUDEF size_m mu_string_get_code_point_offset(musResult* result, muString string, size_m offset, size_m index) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return 0;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return 0;, mus_string_)
										musResult mus_res = MUS_SUCCESS;

										size_m ret_offset = mu_character_encoding_get_raw_string_code_point_offset(&mus_res,
											MUS_GSTRINGS.data[string].encoding,
											MUS_GSTRINGS.data[string].bytes.data,
											MUS_GSTRINGS.data[string].bytes.length,
											offset, index
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return 0;)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return ret_offset;
									}

									MUDEF muCodePoint mu_string_get_code_point(musResult* result, muString string, size_m offset) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return 0;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return 0;, mus_string_)
										musResult mus_res = MUS_SUCCESS;

										MU_ASSERT(offset < MUS_GSTRINGS.data[string].bytes.length, result, MUS_INVALID_OFFSET, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return 0;)

										muCodePoint cp = mu_character_encoding_get_code_point(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											&MUS_GSTRINGS.data[string].bytes.data[offset],
											MUS_GSTRINGS.data[string].bytes.length-offset
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return 0;)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
										return cp;
									}

									MUDEF void mu_string_set_code_point(musResult* result, muString string, muCodePoint code_point, size_m offset) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return;, mus_string_)
										musResult mus_res = MUS_SUCCESS;
										mumaResult muma_res = MUMA_SUCCESS;

										MU_ASSERT(offset < MUS_GSTRINGS.data[string].bytes.length, result, MUS_INVALID_OFFSET, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										// Get sizes of current code point and the code point to be set

										muCodePoint prev_cp = mu_character_encoding_get_code_point(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											&MUS_GSTRINGS.data[string].bytes.data[offset],
											MUS_GSTRINGS.data[string].bytes.length-offset
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										size_m prev_cp_size = mu_character_encoding_get_code_point_size(&mus_res, MUS_GSTRINGS.data[string].encoding, prev_cp);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)
										size_m cp_size = mu_character_encoding_get_code_point_size(&mus_res, MUS_GSTRINGS.data[string].encoding, code_point);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										// Compare sizes and shift data accordingly

										if (prev_cp_size > cp_size) {
											MUS_GSTRINGS.data[string].bytes = mus_bstring_lshift(&muma_res, 
												MUS_GSTRINGS.data[string].bytes,
												offset + prev_cp_size,
												prev_cp_size - cp_size
											);
											MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)
										} else if (prev_cp_size < cp_size) {
											MUS_GSTRINGS.data[string].bytes = mus_bstring_rshift(&muma_res,
												MUS_GSTRINGS.data[string].bytes,
												offset + prev_cp_size,
												cp_size - prev_cp_size
											);
											MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)
										}

										// Set code point

										mu_character_encoding_set_code_point(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											code_point,
											&MUS_GSTRINGS.data[string].bytes.data[offset],
											MUS_GSTRINGS.data[string].bytes.length-offset
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
									}

								/* Insert */

									MUDEF void mu_string_insert_raw_string(musResult* result, muString string, muCharacterEncoding encoding, muByte* data, size_m data_size, size_m offset) {
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)
										MU_SAFEFUNC(result, MUS_, mus_global_context, return;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return;, mus_string_)

										mumaResult muma_res = MUMA_SUCCESS;
										musResult mus_res = MUS_SUCCESS;

										MU_ASSERT(encoding == MUS_GSTRINGS.data[string].encoding, result, MUS_NONMATCHING_CHARACTER_ENCODING, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										size_m first_offset = mu_character_encoding_get_raw_string_code_point_offset(&mus_res, encoding, data, data_size, 0, 0);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										MUS_GSTRINGS.data[string].bytes = mus_bstring_multiinsert(&muma_res, 
											MUS_GSTRINGS.data[string].bytes, offset,
											&data[first_offset], data_size-first_offset
										);
										MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
									}

									MUDEF void mu_string_insert_integer(musResult* result, muString string, int64_m i, size_m offset) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return;, mus_string_)

										mumaResult muma_res = MUMA_SUCCESS;
										musResult mus_res = MUS_SUCCESS;

										size_m int_size = mu_raw_string_get_integer_conversion_size(&mus_res, MUS_GSTRINGS.data[string].encoding, i);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										MUS_GSTRINGS.data[string].bytes = mus_bstring_rshift(&muma_res,
											MUS_GSTRINGS.data[string].bytes, offset, int_size
										);
										MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										mu_raw_string_convert_to_integer(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											&MUS_GSTRINGS.data[string].bytes.data[offset],
											MUS_GSTRINGS.data[string].bytes.length-offset,
											i
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res,
											MUS_GSTRINGS.data[string].bytes = mus_bstring_lshift(0, MUS_GSTRINGS.data[string].bytes, offset+int_size, int_size);
											MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
											return;
										)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
									}

									MUDEF void mu_string_insert_float(musResult* result, muString string, float d, size_m decimal_places, size_m offset) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return;, mus_string_)

										mumaResult muma_res = MUMA_SUCCESS;
										musResult mus_res = MUS_SUCCESS;

										size_m int_size = mu_raw_string_get_float_conversion_size(&mus_res, MUS_GSTRINGS.data[string].encoding, d, decimal_places);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										MUS_GSTRINGS.data[string].bytes = mus_bstring_rshift(&muma_res,
											MUS_GSTRINGS.data[string].bytes, offset, int_size
										);
										MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										mu_raw_string_convert_to_float(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											&MUS_GSTRINGS.data[string].bytes.data[offset],
											MUS_GSTRINGS.data[string].bytes.length-offset,
											d, decimal_places
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res,
											MUS_GSTRINGS.data[string].bytes = mus_bstring_lshift(0, MUS_GSTRINGS.data[string].bytes, offset+int_size, int_size);
											MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
											return;
										)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
									}

									MUDEF void mu_string_insert_double(musResult* result, muString string, double d, size_m decimal_places, size_m offset) {
										MU_SAFEFUNC(result, MUS_, mus_global_context, return;)
										MU_HOLD(result, string, MUS_GSTRINGS, mus_global_context, MUS_, return;, mus_string_)

										mumaResult muma_res = MUMA_SUCCESS;
										musResult mus_res = MUS_SUCCESS;

										size_m int_size = mu_raw_string_get_double_conversion_size(&mus_res, MUS_GSTRINGS.data[string].encoding, d, decimal_places);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										MUS_GSTRINGS.data[string].bytes = mus_bstring_rshift(&muma_res,
											MUS_GSTRINGS.data[string].bytes, offset, int_size
										);
										MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_mus_result(muma_res), MU_RELEASE(MUS_GSTRINGS, string, mus_string_) return;)

										mu_raw_string_convert_to_double(&mus_res, 
											MUS_GSTRINGS.data[string].encoding,
											&MUS_GSTRINGS.data[string].bytes.data[offset],
											MUS_GSTRINGS.data[string].bytes.length-offset,
											d, decimal_places
										);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res,
											MUS_GSTRINGS.data[string].bytes = mus_bstring_lshift(0, MUS_GSTRINGS.data[string].bytes, offset+int_size, int_size);
											MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
											return;
										)

										MU_RELEASE(MUS_GSTRINGS, string, mus_string_)
									}

							/* Raw string functions */

								/* Conversion */

									MUDEF size_m mu_raw_string_get_character_encoding_conversion_size(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, muCharacterEncoding desired_encoding) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)
										musResult res = MUS_SUCCESS;

										size_m i = mu_character_encoding_get_raw_string_code_point_offset(&res, encoding, data, data_size, 0, 0);
										MU_ASSERT(res == MUS_SUCCESS, result, res, return 0;)

										size_m output_size = 0;

										for (; i < data_size;) {
											muCodePoint cp = mu_character_encoding_get_code_point(&res, encoding, &data[i], data_size-i);
											MU_ASSERT(res == MUS_SUCCESS, result, res, return 0;)

											size_m cp_size = mu_character_encoding_get_code_point_size(&res, desired_encoding, cp);
											MU_ASSERT(res == MUS_SUCCESS, result, res, return 0;)
											output_size += cp_size;

											cp_size = mu_character_encoding_get_code_point_size(&res, encoding, cp);
											MU_ASSERT(res == MUS_SUCCESS, result, res, return 0;)

											i += cp_size;
										}

										return output_size;
									}

									MUDEF void mu_raw_string_convert_character_encoding(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, muCharacterEncoding output_encoding, muByte* output_data, size_m output_data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(output_data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)
										MU_ASSERT(output_data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)
										musResult res = MUS_SUCCESS;

										size_m input_i = mu_character_encoding_get_raw_string_code_point_offset(&res, encoding, data, data_size, 0, 0);
										MU_ASSERT(res == MUS_SUCCESS, result, res, return;)

										size_m output_i = 0;

										for (; input_i < data_size;) {
											muCodePoint input_cp = mu_character_encoding_get_code_point(&res, encoding, &data[input_i], data_size-input_i);
											MU_ASSERT(res == MUS_SUCCESS, result, res, return;)

											size_m input_cp_size = mu_character_encoding_get_code_point_size(&res, encoding, input_cp);
											MU_ASSERT(res == MUS_SUCCESS, result, res, return;)

											size_m output_cp_size = mu_character_encoding_get_code_point_size(&res, output_encoding, input_cp);
											MU_ASSERT(res == MUS_SUCCESS, result, res, return;)

											input_i += input_cp_size;
											MU_ASSERT((output_data_size - output_i) >= output_cp_size, result, MUS_INSUFFICIENT_DATA_SIZE, return;)

											mu_character_encoding_set_code_point(&res, output_encoding, input_cp, &output_data[output_i], output_data_size-output_i);
											MU_ASSERT(res == MUS_SUCCESS, result, res, return;)
											output_i += output_cp_size;
										}
									}

								/* Integer/Float/Double conversion */

									// For these functions, ASCII/UTF-8 is assumed. As of the time of writing this,
									// these are the only encoding formats supported by muString, and their
									// implementation for the characters concerned (0-9 and .) are the same, storing 1
									// byte per character.

									#define MUS_MAX_FLOAT_DECIMAL_POINTS 7
									#define MUS_MAX_DOUBLE_DECIMAL_POINTS 16

									MUDEF size_m mu_raw_string_get_integer_conversion_size(musResult* result, muCharacterEncoding encoding, int64_m i) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										if (encoding) {}

										uint8_m add = 0;
										uint64_m ui;
										if (i >= 0) {
											ui = (uint64_m)i;
										} else {
											add = 1;
											ui = (uint64_m)((int64_m)(-i));
										}

										// https://stackoverflow.com/a/14564888
										uint8_m digits = ((uint8_m)(mu_log10((double)ui))) + 1;
										return (size_m)(digits + add);
									}

									MUDEF void mu_raw_string_convert_to_integer(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, int64_m i) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)

										musResult mus_res = MUS_SUCCESS;
										size_m isize = mu_raw_string_get_integer_conversion_size(&mus_res, encoding, i);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, return;)
										MU_ASSERT(data_size >= isize, result, MUS_INSUFFICIENT_DATA_SIZE, return;)

										uint8_m neg = 0;
										if (i < 0) {
											neg = 1;
										}

										// https://stackoverflow.com/a/14564888
										for (int8_m isizemod = isize-1; isizemod >= 0; isizemod -= 1, i /= 10) {
											if (i < 0) {
												data[isizemod] = ((-i) % 10) + 48;
											} else {
												data[isizemod] = (i % 10) + 48;
											}
										}

										if (neg > 0) {
											data[0] = 45;
										}
									}

									MUDEF int64_m mu_raw_string_get_integer(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)
										if (encoding) {}

										size_m beg_i = 0;
										if (data[0] == 45) {
											beg_i = 1;
										}

										int64_m ret = 0;
										for (size_m i = data_size; i != beg_i;) {
											i -= 1;
											int64_m bef_ret = ret;

											MU_ASSERT(data[i] >= 48 && data[i] <= 57, result, MUS_INVALID_DATA, return 0;)
											ret += mu_pow(10, (data_size-i)-1) * (data[i]-48);
											if (ret < bef_ret) {
												MU_SET_RESULT(result, MUS_OVERFLOW)
												return 0;
											}
										}

										if (beg_i == 1) {
											return -ret;
										}
										return ret;
									}

									MUDEF size_m mu_raw_string_get_float_conversion_size(musResult* result, muCharacterEncoding encoding, float d, size_m decimal_places) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										if (encoding) {}
										if (decimal_places > MUS_MAX_FLOAT_DECIMAL_POINTS) {
											decimal_places = MUS_MAX_FLOAT_DECIMAL_POINTS;
										}

										uint8_m add = 0;
										float ud;
										if (d >= 0.f) {
											ud = d;
										} else {
											add = 1;
											ud = -d;
										}

										uint8_m digits = ((uint8_m)(mu_log10((double)ud))) + 1;
										if (decimal_places == 0) {
											return (size_m)(digits + add);
										}
										return ((size_m)(digits + add)) + decimal_places + 1;
									}

									void mus_write_double_int_only(size_m intsize, double floored_d, muByte* data) {
										uint8_m neg = 0;
										if (floored_d < 0.f) {
											neg = 1;
										}

										size_m count = 0;

										for (int64_m isizemod = intsize-1; isizemod >= 0; isizemod -= 1, count += 1) {
											double i = floored_d / mu_pow(10.f, count);
											if (i < 0) {
												data[isizemod] = (muByte)mu_fmod(-i, 10.f) + 48;
											} else {
												data[isizemod] = (muByte)mu_fmod(i, 10.f) + 48;
											}
										}

										if (neg > 0) {
											data[0] = 45;
										}
									}

									MUDEF void mu_raw_string_convert_to_float(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, float d, size_m decimal_places) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)
										if (decimal_places > MUS_MAX_FLOAT_DECIMAL_POINTS) {
											decimal_places = MUS_MAX_FLOAT_DECIMAL_POINTS;
										}

										musResult mus_res = MUS_SUCCESS;
										size_m dsize = mu_raw_string_get_float_conversion_size(&mus_res, encoding, d, decimal_places);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, return;)
										MU_ASSERT(data_size >= dsize, result, MUS_INSUFFICIENT_DATA_SIZE, return;)

										size_m intsize = (dsize - decimal_places);
										if (decimal_places != 0) {
											intsize -= 1;
										}

										// Write int digits

										double floored_d;
										if (d >= 0.f) {
											floored_d = mu_floor((double)d);
										} else {
											floored_d = -mu_floor((double)-d);
										}

										mus_write_double_int_only(intsize, floored_d, data);

										// Write decimal digits

										if (decimal_places > 0) {
											data[intsize] = 46;

											if (d < 0.f) { d = -d; }
											if (floored_d < 0.f) { floored_d = -floored_d; }

											double d_decimals = (double)(d)-floored_d;
											if (d_decimals != 0.f) {
												d_decimals = (((double)(d_decimals)) * (mu_pow(10.f, (double)(decimal_places))));
											} else {
												d_decimals = (((double)(floored_d)) * (mu_pow(10.f, (double)(decimal_places))));
											}

											mus_write_double_int_only(decimal_places, d_decimals, &data[intsize+1]);
										}
									}

									MUDEF float mu_raw_string_get_float(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0.f;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0.f;)
										if (encoding) {}

										size_m beg_i = 0;
										if (data[0] == 45) {
											beg_i = 1;
										}

										size_m decimal = MU_NONE;
										for (size_m i = 0; i < data_size; i++) {
											if (data[i] == 46) {
												decimal = i;
												break;
											}
										}
										MU_ASSERT(decimal != MU_NONE, result, MUS_INVALID_DATA, return 0.f;)

										float ret = 0.f;
										for (size_m i = beg_i; i < data_size; i++) {
											if (i == decimal) {
												continue;
											}
											MU_ASSERT(data[i] >= 48 && data[i] <= 57, result, MUS_INVALID_DATA, return 0;)

											if (i < decimal) {
												ret += (float)(mu_pow(10.f, (decimal-i)-1) * (double)(data[i]-48));
											} else {
												ret += (float)(mu_pow(10.f, -(double)((i-decimal))) * (double)(data[i]-48));
											}
										}

										if (beg_i == 1) {
											return -ret;
										}
										return ret;
									}

									MUDEF size_m mu_raw_string_get_double_conversion_size(musResult* result, muCharacterEncoding encoding, double d, size_m decimal_places) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										if (encoding) {}
										if (decimal_places > MUS_MAX_DOUBLE_DECIMAL_POINTS) {
											decimal_places = MUS_MAX_DOUBLE_DECIMAL_POINTS;
										}

										uint8_m add = 0;
										double ud;
										if (d >= 0.f) {
											ud = d;
										} else {
											add = 1;
											ud = -d;
										}

										uint8_m digits = ((uint8_m)(mu_log10(ud))) + 1;
										if (decimal_places == 0) {
											return (size_m)(digits + add);
										}
										return ((size_m)(digits + add)) + decimal_places + 1;
									}

									MUDEF void mu_raw_string_convert_to_double(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, double d, size_m decimal_places) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)
										if (decimal_places > MUS_MAX_DOUBLE_DECIMAL_POINTS) {
											decimal_places = MUS_MAX_DOUBLE_DECIMAL_POINTS;
										}

										musResult mus_res = MUS_SUCCESS;
										size_m dsize = mu_raw_string_get_double_conversion_size(&mus_res, encoding, d, decimal_places);
										MU_ASSERT(mus_res == MUS_SUCCESS, result, mus_res, return;)
										MU_ASSERT(data_size >= dsize, result, MUS_INSUFFICIENT_DATA_SIZE, return;)

										size_m intsize = (dsize - decimal_places);
										if (decimal_places != 0) {
											intsize -= 1;
										}

										// Write int digits

										double floored_d;
										if (d >= 0.f) {
											floored_d = mu_floor((double)d);
										} else {
											floored_d = -mu_floor((double)-d);
										}

										mus_write_double_int_only(intsize, floored_d, data);

										// Write decimal digits

										if (decimal_places > 0) {
											data[intsize] = 46;

											if (d < 0.f) { d = -d; }
											if (floored_d < 0.f) { floored_d = -floored_d; }

											double d_decimals = (double)(d)-floored_d;
											if (d_decimals != 0.f) {
												d_decimals = (((double)(d_decimals)) * (mu_pow(10.f, (double)(decimal_places))));
											} else {
												d_decimals = (((double)(floored_d)) * (mu_pow(10.f, (double)(decimal_places))));
											}

											mus_write_double_int_only(decimal_places, d_decimals, &data[intsize+1]);
										}
									}

									MUDEF double mu_raw_string_get_double(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0.f;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0.f;)
										if (encoding) {}

										size_m beg_i = 0;
										if (data[0] == 45) {
											beg_i = 1;
										}

										size_m decimal = MU_NONE;
										for (size_m i = 0; i < data_size; i++) {
											if (data[i] == 46) {
												decimal = i;
												break;
											}
										}
										MU_ASSERT(decimal != MU_NONE, result, MUS_INVALID_DATA, return 0.f;)

										double ret = 0.f;
										for (size_m i = beg_i; i < data_size; i++) {
											if (i == decimal) {
												continue;
											}
											MU_ASSERT(data[i] >= 48 && data[i] <= 57, result, MUS_INVALID_DATA, return 0;)

											if (i < decimal) {
												ret += mu_pow(10.f, (decimal-i)-1) * (double)(data[i]-48);
											} else {
												ret += mu_pow(10.f, -(double)((i-decimal))) * (double)(data[i]-48);
											}
										}

										if (beg_i == 1) {
											return -ret;
										}
										return ret;
									}

							/* Cross-encoding functions */

								MUDEF size_m mu_character_encoding_get_code_point_size(musResult* result, muCharacterEncoding encoding, muCodePoint code_point) {
									switch (encoding) { default: MU_SET_RESULT(result, MUS_UNKNOWN_CHARACTER_ENCODING) return 0; break;
										case MU_ASCII: return mu_ASCII_get_code_point_size(result, code_point); break;
										case MU_UTF8: return mu_UTF8_get_code_point_size(result, code_point); break;
									}
								}

								MUDEF muCodePoint mu_character_encoding_get_code_point(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size) {
									switch (encoding) { default: MU_SET_RESULT(result, MUS_UNKNOWN_CHARACTER_ENCODING) return 0; break;
										case MU_ASCII: return mu_ASCII_get_code_point(result, data, data_size); break;
										case MU_UTF8: return mu_UTF8_get_code_point(result, data, data_size); break;
									}
								}

								MUDEF void mu_character_encoding_set_code_point(musResult* result, muCharacterEncoding encoding, muCodePoint code_point, muByte* data, size_m data_size) {
									switch (encoding) { default: MU_SET_RESULT(result, MUS_UNKNOWN_CHARACTER_ENCODING) return; break;
										case MU_ASCII: mu_ASCII_set_code_point(result, code_point, data, data_size); break;
										case MU_UTF8: mu_UTF8_set_code_point(result, code_point, data, data_size); break;
									}
								}

								MUDEF muBool mu_character_encoding_verify_raw_string(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size) {
									switch (encoding) { default: MU_SET_RESULT(result, MUS_UNKNOWN_CHARACTER_ENCODING) return MU_FALSE; break;
										case MU_ASCII: return mu_ASCII_verify_raw_string(result, data, data_size); break;
										case MU_UTF8: return mu_UTF8_verify_raw_string(result, data, data_size); break;
									}
								}

								MUDEF size_m mu_character_encoding_get_raw_string_code_point_length(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size) {
									switch (encoding) { default: MU_SET_RESULT(result, MUS_UNKNOWN_CHARACTER_ENCODING) return 0; break;
										case MU_ASCII: return mu_ASCII_get_raw_string_code_point_length(result, data, data_size); break;
										case MU_UTF8: return mu_UTF8_get_raw_string_code_point_length(result, data, data_size); break;
									}
								}

								MUDEF size_m mu_character_encoding_get_raw_string_code_point_offset(musResult* result, muCharacterEncoding encoding, muByte* data, size_m data_size, size_m offset, size_m index) {
									switch (encoding) { default: MU_SET_RESULT(result, MUS_UNKNOWN_CHARACTER_ENCODING) return 0; break;
										case MU_ASCII: return mu_ASCII_get_raw_string_code_point_offset(result, data, data_size, offset, index); break;
										case MU_UTF8: return mu_UTF8_get_raw_string_code_point_offset(result, data, data_size, offset, index); break;
									}
								}

							/* Encoding-specific functions */

								/* ASCII */

									MUDEF size_m mu_ASCII_get_code_point_size(musResult* result, muCodePoint code_point) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(code_point <= 0x7F, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)

										return 1;
									}

									MUDEF muCodePoint mu_ASCII_get_code_point(musResult* result, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)
										MU_ASSERT(data[0] <= 0x7F, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)

										return data[0];
									}

									MUDEF void mu_ASCII_set_code_point(musResult* result, muCodePoint code_point, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)
										MU_ASSERT(code_point <= 0x7F, result, MUS_CHARACTER_CANNOT_BE_ENCODED, return;)

										data[0] = code_point;
									}

									MUDEF muBool mu_ASCII_verify_raw_string(musResult* result, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)

										for (size_m i = 0; i < data_size; i++) {
											if (data[i] > 0x7F) {
												return MU_FALSE;
											}
										}

										return MU_TRUE;
									}

									MUDEF size_m mu_ASCII_get_raw_string_code_point_length(musResult* result, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)

										return data_size;
									}

									MUDEF size_m mu_ASCII_get_raw_string_code_point_offset(musResult* result, muByte* data, size_m data_size, size_m offset, size_m index) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return offset;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return offset;)
										MU_ASSERT(offset+index < data_size, result, MUS_INVALID_OFFSET, return offset;)

										return offset+index;
									}

								/* UTF-8 */

									muByte mus_UTF8_get_code_point_size_from_byte(muByte byte) {
										// 00000000 <= n <= 01111111
										if (/*byte >= 0 && */byte <= 127) {
											return 1;
										// 11000000 <= n < 11100000
										} else if (byte >= 192 && byte < 224) {
											return 2;
										// 11100000 <= n < 11110000
										} else if (byte >= 224 && byte < 240) {
											return 3;
										// 11110000 <= n <= 11110111
										} else if (byte >= 240 && byte <= 247) {
											return 4;
										} else {
											// Value is 10xxxxxx or 11111xxx; invalid.
											return 0;
										}
									}

									MUDEF size_m mu_UTF8_get_code_point_size(musResult* result, muCodePoint code_point) {
										MU_SET_RESULT(result, MUS_SUCCESS)

										// Storable in 7 bits = 1 byte
										if (code_point < 128) {
											return 1;
										}
										// Storable in 11 bits = 2 bytes
										if (code_point < 2048) {
											return 2;
										}
										// Storable in 16 bits = 3 bytes
										if (code_point < 65536) {
											return 3;
										}
										// Storable in 21 bits = 4 bytes
										if (code_point < 2097152) {
											return 4;
										}
										// Anything larger cannot be stored.
										MU_SET_RESULT(result, MUS_CHARACTER_CANNOT_BE_ENCODED)
										return 0;
									}

									MUDEF muCodePoint mu_UTF8_get_code_point(musResult* result, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)

										muByte code_point_size = mus_UTF8_get_code_point_size_from_byte(data[0]);
										MU_ASSERT(code_point_size != 0, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)

										for (size_m i = 1; i < code_point_size; i++) {
											// 10000000 <= n <= 10111111
											if (!(data[i] >= 128 && data[i] <= 191)) {
												MU_SET_RESULT(result, MUS_INVALID_CHARACTER_ENCODING)
												return 0;
											}
										}

										switch (code_point_size) { default: MU_SET_RESULT(result, MUS_INVALID_CHARACTER_ENCODING) return 0; break;
											case 1: {
												return data[0];
											} break;

											case 2: {
												MU_ASSERT(data_size >= 2, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)
												return
												// 110xxxxx
												(muCodePoint)(data[0] & 31) << 6 |
												// 10xxxxxx
												(muCodePoint)(data[1] & 63);
											} break;

											case 3: {
												MU_ASSERT(data_size >= 3, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)
												return
												// 1110xxxx
												(muCodePoint)(data[0] & 15) << 12 |
												// 10xxxxxx
												(muCodePoint)(data[1] & 63) << 6 |
												// 10xxxxxx
												(muCodePoint)(data[2] & 63);
											} break;

											case 4: {
												MU_ASSERT(data_size >= 4, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)
												return
												// 1110xxxx
												(muCodePoint)(data[0] & 7) << 18 |
												// 10xxxxxx
												(muCodePoint)(data[1] & 63) << 12 |
												// 10xxxxxx
												(muCodePoint)(data[2] & 63) << 6 |
												// 10xxxxxx
												(muCodePoint)(data[3] & 63);
											} break;
										}
									}

									MUDEF void mu_UTF8_set_code_point(musResult* result, muCodePoint code_point, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return;)

										musResult res = MUS_SUCCESS;
										size_m code_point_size = mu_UTF8_get_code_point_size(&res, code_point);
										MU_ASSERT(res == MUS_SUCCESS, result, res, return;)

										MU_ASSERT(code_point_size <= data_size, result, MUS_INVALID_DATA_SIZE, return;)

										switch (code_point_size) { default: MU_SET_RESULT(result, MUS_CHARACTER_CANNOT_BE_ENCODED) return; break;
											case 1: {
												data[0] = code_point;
											} break;

											// mask = Get what you want
											// add  = Add bits
											case 2: {
												// 110xxxxx                           mask    add
												data[0] = (muByte)(((code_point >> 6) & 31) | 192);
												// 10xxxxxx                      mask
												data[1] = (muByte)((code_point & 63) | 128);
											} break;

											case 3: {
												// 1110xxxx
												data[0] = (muByte)(((code_point >> 12) & 15) | 224);
												// 10xxxxxx
												data[1] = (muByte)(((code_point >> 6) & 63) | 128);
												// 10xxxxxx
												data[2] = (muByte)((code_point & 63) | 128);
											} break;

											case 4: {
												// 11110xxx
												data[0] = (muByte)(((code_point >> 18) & 7) | 240);
												// 10xxxxxx
												data[1] = (muByte)(((code_point >> 12) & 63) | 128);
												// 10xxxxxx
												data[2] = (muByte)(((code_point >> 6) & 63) | 128);
												// 10xxxxxx
												data[3] = (muByte)((code_point & 63) | 128);
											} break;
										}
									}

									MUDEF muBool mu_UTF8_verify_raw_string(musResult* result, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)

										musResult res = MUS_SUCCESS;
										size_m i = 0;
										// BOM
										if (data_size >= 3) {
											if (data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) {
												i = 3;
											}
										}

										for (; i < data_size;) {
											muByte code_point_size = mus_UTF8_get_code_point_size_from_byte(data[i]);
											if (code_point_size == 0) {
												return MU_FALSE;
											}
											if (!((i+code_point_size < data_size) || (i+code_point_size == data_size))) {
												return MU_FALSE;
											}

											mu_UTF8_get_code_point(&res, &data[i], data_size-i);
											if (res != MUS_SUCCESS) {
												return MU_FALSE;
											}

											i += code_point_size;
										}
										return MU_TRUE;
									}

									MUDEF size_m mu_UTF8_get_raw_string_code_point_length(musResult* result, muByte* data, size_m data_size) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)

										size_m i = 0;
										// BOM
										if (data_size >= 3) {
											if (data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) {
												i = 3;
											}
										}

										size_m code_point_length = 0;

										for (; i < data_size;) {
											muByte code_point_size = mus_UTF8_get_code_point_size_from_byte(data[i]);
											MU_ASSERT(code_point_size != 0, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)
											MU_ASSERT((i+code_point_size < data_size) || (i+code_point_size == data_size), result, MUS_INVALID_CHARACTER_ENCODING, return 0;)
											code_point_length += 1;

											i += code_point_size;
										}
										return code_point_length;
									}

									MUDEF size_m mu_UTF8_get_raw_string_code_point_offset(musResult* result, muByte* data, size_m data_size, size_m offset, size_m index) {
										MU_SET_RESULT(result, MUS_SUCCESS)
										MU_ASSERT(data != MU_NULL_PTR, result, MUS_INVALID_DATA_POINTER, return 0;)
										MU_ASSERT(data_size > 0, result, MUS_INVALID_DATA_SIZE, return 0;)

										size_m i = 0;
										if (offset == 0) {
											// BOM
											if (data_size >= 3) {
												if (data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) {
													i = 3;
												}
											}
										}

										size_m count_index = 0;

										for (; i < data_size && count_index != index;) {
											muByte code_point_size = mus_UTF8_get_code_point_size_from_byte(data[0]);
											MU_ASSERT(code_point_size != 0, result, MUS_INVALID_CHARACTER_ENCODING, return 0;)
											MU_ASSERT((i+code_point_size < data_size) || (i+code_point_size == data_size), result, MUS_INVALID_CHARACTER_ENCODING, return 0;)
											count_index += 1;

											i += code_point_size;
										}

										MU_ASSERT(count_index == index, result, MUS_INVALID_OFFSET, return 0;)
										return i;
									}

							/* Codepoint */

								/* Uppercase/Lowercase */

									// Last updated 16 September 2023, covers 0 -> 65533
									// https://en.wikipedia.org/wiki/List_of_Unicode_characters
									// https://www.ssec.wisc.edu/~tomw/java/unicode.html

									MUDEF muCodePoint mu_code_point_lowercase(musResult* result, muCharacterEncoding encoding, muCodePoint code_point) {
										if (encoding == MU_ASCII) {
											MU_ASSERT(code_point <= 0x7F, result, MUS_INVALID_CHARACTER_ENCODING, return code_point;)
											if (code_point >= 65 && code_point <= 90) {
												return code_point + 32;
											}
											return code_point;
										}

										if (
										// Latin alphabet
											(code_point >= 65 && code_point <= 90) ||
										// Latin-1 supplement
											(code_point >= 192 && code_point <= 222 && code_point != 215) ||
										// Greek and Coptic
											(code_point >= 913 && code_point <= 939) ||
										// Cyrillic
											(code_point >= 0x0410 && code_point <= 0x042F) ||
										// Halfwidth and fullwidth forms
											(code_point >= 65313 && code_point <= 65338)
										) {
											return code_point + 32;
										} else if (
										// Latin extended-a
											(
												(code_point >= 256 && code_point <= 310 && code_point % 2 == 0) || 
												(code_point >= 313 && code_point <= 327 && code_point % 2 != 0) ||
												(code_point >= 330 && code_point <= 376 && code_point % 2 == 0) ||
												(code_point >= 377 && code_point <= 381 && code_point % 2 != 0)
											) ||
										// Latin extended-b
											(
												(code_point >= 461 && code_point <= 475 && code_point % 2 != 0) ||
												(code_point >= 478 && code_point <= 494 && code_point % 2 == 0) ||
												(code_point >= 504 && code_point <= 542 && code_point % 2 == 0) ||
												(code_point >= 546 && code_point <= 562 && code_point % 2 == 0) ||
												(code_point >= 582 && code_point <= 590 && code_point % 2 == 0)
											) ||
										// Greek and Coptic
											(
												(code_point >= 984 && code_point <= 1006 && code_point % 2 == 0)
											) ||
										// Cyrillic
											(
												(code_point >= 0x0460 && code_point <= 0x0480 && code_point % 2 == 0) ||
												(code_point >= 0x048A && code_point <= 0x04BE && code_point % 2 == 0) ||
												(code_point >= 0x04C1 && code_point <= 0x04CD && code_point % 2 != 0) ||
												(code_point >= 0x04D0 && code_point <= 0x04FE && code_point % 2 == 0) ||
												// Cyrillic supplement
												(code_point >= 0x0500 && code_point <= 0x052E && code_point % 2 == 0)
											) ||
										// Latin extended additional
											(
												(code_point >= 7680 && code_point <= 7828 && code_point % 2 == 0) ||
												(code_point >= 7840 && code_point <= 7928 && code_point % 2 == 0)
											)
										) {
											return code_point + 1;
										} else if (
										// Cyrillic
											(
												(code_point >= 0x0400 && code_point <= 0x040F)
											)
										) {
											return code_point + 80;
										} else if (
										// Armenian
											(
												(code_point >= 0x0530 && code_point <= 0x0558)
											) ||
										// Georgian
											(
												(code_point >= 0x10A0 && code_point <= 0x10CF)
											)
										) {
											return code_point + 48;
										} else if (
										// Greek extended
											(
												(code_point >= 7944 && code_point <= 7951) || (code_point >= 7960 && code_point <= 7965) || (code_point >= 7976 && code_point <= 7983) || (code_point >= 7992 && code_point <= 7999) ||
												(code_point >= 8008 && code_point <= 8013) || (code_point >= 8025 && code_point <= 8031) || (code_point >= 8040 && code_point <= 8047) || (code_point >= 8072 && code_point <= 8079) ||
												(code_point >= 8088 && code_point <= 8095) || (code_point >= 8104 && code_point <= 8111) || (code_point >= 8120 && code_point <= 8124)
											)
										) {
											return code_point - 8;
										} else if (
										// Enclosed alphanumerics
											(
												(code_point >= 9398 && code_point <= 9423)
											)
										) {
											return code_point + 26;
										}
										switch (code_point) {
										default: break;
										// Odd Latin extended-b / IPA extensions
										case 386: case 388: case 391: case 395: case 401: case 408: case 416: case 418: case 420: case 423: case 428: case 431: 
										case 435: case 437: case 440: case 444: case 453: case 456: case 459: case 498: case 500: case 571: case 577: return code_point+1; break;
										case 384: return 579; break;
										case 385: return 595; break;
										case 390: return 596; break;
										case 393: return 598; break;
										case 394: return 599; break;
										case 398: return 600; break;
										case 399: return 601; break;
										case 400: return 603; break;
										case 403: return 608; break;
										case 404: return 611; break;
										case 406: return 617; break;
										case 407: return 616; break;
										case 412: return 623; break;
										case 413: return 626; break;
										case 425: return 643; break;
										case 430: return 648; break;
										case 433: return 650; break;
										case 434: return 641; break;
										case 439: return 658; break;
										case 452: return 454; break;
										case 455: return 457; break;
										case 458: return 460; break;
										case 497: return 499; break;
										case 544: return 414; break;
										case 573: return 410; break;
										case 579: return 384; break;
										case 580: return 649; break;
										case 581: return 652; break;

										// Odd greek and coptic
										case 880: case 882: case 886: case 1015: case 1018: return code_point+1; break;
										case 895: return 1011; break;
										case 904: case 905: case 906: return code_point+37; break;
										case 908: case 910: case 911: return code_point+64; break;
										case 975: return 983; break;
										case 1012: return 977; break;
										case 1017: return 1010; break;
										case 1021: case 1022: case 1023: return code_point-130; break;

										// Odd greek extended
										case 8136: case 8137: case 8138: case 8139: return code_point-86; break;
										case 8140: return 8131; break;
										case 8152: return 8144; break;
										case 8153: return 8145; break;
										case 8154: case 8155: return code_point-100; break;
										case 8168: return 8160; break;
										case 8169: return 8161; break;
										case 8170: return 8058; break;
										case 8171: return 8059; break;
										case 8172: return 8165; break;
										case 8184: case 8185: return code_point-128; break;
										case 8187: return 8061; break;
										}
										return code_point;
									}

									MUDEF muCodePoint mu_code_point_uppercase(musResult* result, muCharacterEncoding encoding, muCodePoint code_point) {
										if (encoding == MU_ASCII) {
											MU_ASSERT(code_point <= 0x7F, result, MUS_INVALID_CHARACTER_ENCODING, return code_point;)
											if (code_point >= 97 && code_point <= 122) {
												return code_point - 32;
											}
											return code_point;
										}

										if (
										// Latin alphabet
											(code_point >= 97 && code_point <= 122) ||
										// Latin-1 supplement
											(code_point >= 224 && code_point <= 255 && code_point != 247) ||
										// Greek and Coptic
											(code_point >= 945 && code_point <= 971) ||
										// Cyrillic
											(code_point >= (0x0410 + 32) && code_point <= (0x042F + 32)) ||
										// Halfwidth and fullwidth forms
											(code_point >= (65313 + 32) && code_point <= (65338 + 32))
										) {
											return code_point - 32;
										} else if (
										// Latin extended-a
											(
												(code_point >= 257 && code_point <= 311 && code_point % 2 != 0) || 
												(code_point >= 312 && code_point <= 328 && code_point % 2 == 0) ||
												(code_point >= 329 && code_point <= 375 && code_point % 2 != 0) ||
												(code_point >= 378 && code_point <= 382 && code_point % 2 == 0)
											) ||
										// Latin extended-b
											(
												(code_point >= 462 && code_point <= 476 && code_point % 2 == 0) ||
												(code_point >= 479 && code_point <= 495 && code_point % 2 != 0) ||
												(code_point >= 505 && code_point <= 543 && code_point % 2 != 0) ||
												(code_point >= 547 && code_point <= 563 && code_point % 2 != 0) ||
												(code_point >= 583 && code_point <= 591 && code_point % 2 != 0)
											) ||
										// Greek and Coptic
											(
												(code_point >= 985 && code_point <= 1007 && code_point % 2 != 0)
											) ||
										// Cyrillic
											(
												(code_point >= 0x0461 && code_point <= 0x0481 && code_point % 2 != 0) ||
												(code_point >= 0x048B && code_point <= 0x04BF && code_point % 2 != 0) ||
												(code_point >= 0x04C2 && code_point <= 0x04CE && code_point % 2 == 0) ||
												(code_point >= 0x04D1 && code_point <= 0x04FF && code_point % 2 != 0) ||
												// Cyrillic supplement
												(code_point >= 0x0501 && code_point <= 0x052F && code_point % 2 != 0)
											) ||
										// Latin extended additional
											(
												(code_point >= 7681 && code_point <= 7829 && code_point % 2 != 0) ||
												(code_point >= 7841 && code_point <= 7929 && code_point % 2 != 0)
											)
										) {
											return code_point - 1;
										} else if (
										// Cyrillic
											(
												(code_point >= (0x0400+80) && code_point <= (0x040F+80))
											)
										) {
											return code_point - 80;
										} else if (
										// Armenian
											(
												(code_point >= (0x0530+48) && code_point <= (0x0558+48))
											) ||
										// Georgian
											(
												(code_point >= (0x10A0+48) && code_point <= (0x10CF+48))
											)
										) {
											return code_point - 48;
										} else if (
										// Greek extended
											(
												(code_point >= (7944-8) && code_point <= (7951-8)) || (code_point >= (7960-8) && code_point <= (7965-8)) || (code_point >= (7976-8) && code_point <= (7983-8)) || (code_point >= (7992-8) && code_point <= (7999-8)) ||
												(code_point >= (8008-8) && code_point <= (8013-8)) || (code_point >= (8025-8) && code_point <= (8031-8)) || (code_point >= (8040-8) && code_point <= (8047-8)) || (code_point >= (8072-8) && code_point <= (8079-8)) ||
												(code_point >= (8088-8) && code_point <= (8095-8)) || (code_point >= (8104-8) && code_point <= (8111-8)) || (code_point >= (8120-8) && code_point <= (8124-8))
											)
										) {
											return code_point + 8;
										} else if (
										// Enclosed alphanumerics
											(
												(code_point >= (9398+26) && code_point <= (9423+26))
											)
										) {
											return code_point - 26;
										}
										switch (code_point) {
										default: break;
										// Odd Latin extended-b / IPA extensions
										case 387: case 389: case 392: case 396: case 402: case 409: case 417: case 419: case 421: case 424: case 429: case 432: 
										case 436: case 438: case 441: case 445: case 453: case 456: case 459: case 498: case 501: case 572: case 578: return code_point-1; break;
										case 579: return 384; break;
										case 595: return 385; break;
										case 596: return 390; break;
										case 598: return 393; break;
										case 599: return 394; break;
										case 600: return 398; break;
										case 601: return 399; break;
										case 603: return 400; break;
										case 608: return 403; break;
										case 611: return 404; break;
										case 617: return 406; break;
										case 616: return 407; break;
										case 623: return 412; break;
										case 626: return 413; break;
										case 643: return 425; break;
										case 648: return 430; break;
										case 650: return 433; break;
										case 641: return 434; break;
										case 658: return 439; break;
										case 454: return 452; break;
										case 457: return 455; break;
										case 460: return 458; break;
										case 499: return 497; break;
										case 414: return 544; break;
										case 410: return 573; break;
										case 384: return 579; break;
										case 649: return 580; break;
										case 652: return 581; break;

										// Odd Greek and Coptic
										case 881: case 883: case 887: case 1016: case 1019: return code_point-1; break;
										case 1011: return 895; break;
										case 941: case 942: case 943: return code_point-37; break;
										case 972: case 974: case 975: return code_point-64; break;
										case 983: return 975; break;
										case 977: return 1012; break;
										case 1010: return 1017; break;
										case 891: case 892: case 893: return code_point+130; break;

										// Odd Greek extended
										case 8050: case 8051: case 8052: case 8053: return code_point+86; break;
										case 8131: return 8140; break;
										case 8144: return 8152; break;
										case 8145: return 8153; break;
										case 8054: case 8055: return code_point+100; break;
										case 8160: return 8168; break;
										case 8161: return 8169; break;
										case 8058: return 8170; break;
										case 8059: return 8171; break;
										case 8165: return 8172; break;
										case 8056: case 8057: return code_point+128; break;
										case 8061: return 8187; break;
										}
										return code_point;
									}

						#ifdef __cplusplus
						}
						#endif

					#endif /* MUS_IMPLEMENTATION */
				#endif

			#ifdef __cplusplus
			extern "C" { // }
			#endif

			/* Macro handling */

				#ifdef MUCOSA_OPENGL
					#define MUCOSA_OPENGL_CALL(...) __VA_ARGS__
				#else
					#define MUCOSA_OPENGL_CALL(...)
				#endif

				#if defined(MUCOSA_VULKAN) && !defined(MUCOSA_NO_INCLUDE_VULKAN)
					#ifndef MUCOSA_VULKAN_INCLUDE_PATH
						#pragma message("[MUCOSA] If MUCOSA_VULKAN is defined and MUCOSA_NO_INCLUDE_VULKAN is not defined, then the include path for Vulkan is expected to be defined in the macro MUCOSA_VULKAN_INCLUDE_PATH; acting as if MUCOSA_VULKAN was not defined from this point on")
						#undef MUCOSA_VULKAN
					#endif
				#endif

			/* Shared functions */

				muCOSAResult muma_result_to_muCOSA_result(mumaResult result) {
					switch (result) {
						default: case MUMA_SUCCESS: return MUCOSA_MUMA_SUCCESS; break;
						case MUMA_FAILED_TO_ALLOCATE: return MUCOSA_MUMA_FAILED_TO_ALLOCATE; break;
						case MUMA_INVALID_INDEX: return MUCOSA_MUMA_INVALID_INDEX; break;
						case MUMA_INVALID_SHIFT_AMOUNT: return MUCOSA_MUMA_INVALID_SHIFT_AMOUNT; break;
						case MUMA_NOT_FOUND: return MUCOSA_MUMA_NOT_FOUND; break;
					}
				}

				muCOSAResult muCOSA_verify_pixel_format(muPixelFormat pf) {
					if (pf.samples != 1 && pf.samples != 2 && pf.samples != 4 && pf.samples != 8 && pf.samples != 16) {
						return MUCOSA_INVALID_SAMPLE_COUNT;
					}
					return MUCOSA_SUCCESS;
				}

				muCOSAResult muCOSA_verify_window_create_info(muWindowCreateInfo ci) {
					if (ci.minimized && ci.maximized) {
						return MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS;
					}
					if (ci.min_width > ci.max_width || ci.min_height > ci.max_height) {
						return MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS;
					}
					return muCOSA_verify_pixel_format(ci.pixel_format);
				}

			/* X11 implementation */

			#ifdef MUCOSA_X11
				#define MUCOSA_X11_CALL(...) __VA_ARGS__

				#include <X11/Xlib.h> // Includes <X11/X.h>
				#include <X11/Xutil.h> // Must be included AFTER <X11/Xlib.h>
				#include <X11/XKBlib.h> // For XkbKeycodeToKeysym
				#ifndef MUCOSA_NO_LOCALE_MOD
					#include <X11/Xlocale.h> // For XSetLocaleModifiers
				#endif

				#include <time.h>
				#include <pthread.h>
				#include <unistd.h> // For nanosleep (and sleep as a backup because Linux is Linux)

				/* OpenGL */

				#ifdef MUCOSA_OPENGL
					#ifndef MUCOSA_NO_INCLUDE_OPENGL
						// There's gotta be a better way to do this lmao
						#ifndef glClearColor
							#include <GL/gl.h>
						#endif
					#endif

					#include <GL/glx.h>

					struct muCOSA_X11_gl_attributes {
						GLint att[25];
					};
					typedef struct muCOSA_X11_gl_attributes muCOSA_X11_gl_attributes;

					muCOSA_X11_gl_attributes muCOSA_X11_get_gl_attributes(muPixelFormat pf) {
						muCOSA_X11_gl_attributes a = MU_ZERO_STRUCT(muCOSA_X11_gl_attributes);
						a.att[0] = GLX_X_RENDERABLE; a.att[1] = True;
						a.att[2] = GLX_DRAWABLE_TYPE; a.att[3] = GLX_WINDOW_BIT;
						a.att[4] = GLX_RENDER_TYPE; a.att[5] = GLX_RGBA_BIT;
						a.att[6] = GLX_X_VISUAL_TYPE; a.att[7] = GLX_TRUE_COLOR; // ?
						a.att[8] = GLX_RED_SIZE; a.att[9] = pf.red_bits;
						a.att[10] = GLX_GREEN_SIZE; a.att[11] = pf.green_bits;
						a.att[12] = GLX_BLUE_SIZE; a.att[13] = pf.blue_bits;
						a.att[14] = GLX_ALPHA_SIZE; a.att[15] = pf.alpha_bits;
						a.att[16] = GLX_DEPTH_SIZE; a.att[17] = pf.depth_bits;
						a.att[18] = GLX_STENCIL_SIZE; a.att[19] = pf.stencil_bits;
						a.att[20] = GLX_DOUBLEBUFFER; a.att[21] = True;
						a.att[22] = GLX_SAMPLES; a.att[23] = pf.samples;
						a.att[24] = None;
						return a;
					}

					// Note: per-window
					// https://apoorvaj.io/creating-a-modern-opengl-context/
					muCOSAResult muCOSA_X11_init_opengl(Display* display, GLXContext* context, muGraphicsAPI api, GLXFBConfig fbc) {
						GLXContext (*glXCreateContextAttribsARB)(Display*, GLXFBConfig, GLXContext, Bool, const int*) = 
							(GLXContext (*)(Display*, GLXFBConfig, GLXContext, Bool, const int*))glXGetProcAddress((const GLubyte*)"glXCreateContextAttribsARB");
						if (!glXCreateContextAttribsARB) {
							return MUCOSA_FAILED_CREATE_OPENGL_CONTEXT;
						}

						int opengl_attributes[] = {
							GLX_CONTEXT_MAJOR_VERSION_ARB, 3,
							GLX_CONTEXT_MINOR_VERSION_ARB, 3,
							GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
							None
						};

						switch (api) {
							default: return MUCOSA_UNKNOWN_GRAPHICS_API; break;
							case MU_OPENGL_1_0:   { opengl_attributes[1] = 1; opengl_attributes[3] = 0; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_1_1:   { opengl_attributes[1] = 1; opengl_attributes[3] = 1; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_1_2:   { opengl_attributes[1] = 1; opengl_attributes[3] = 2; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							// No idea what to do here lmao
							case MU_OPENGL_1_2_1: { opengl_attributes[1] = 1; opengl_attributes[3] = 2; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_1_3:   { opengl_attributes[1] = 1; opengl_attributes[3] = 3; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_1_4:   { opengl_attributes[1] = 1; opengl_attributes[3] = 4; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_1_5:   { opengl_attributes[1] = 1; opengl_attributes[3] = 5; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_2_0:   { opengl_attributes[1] = 2; opengl_attributes[3] = 0; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_2_1:   { opengl_attributes[1] = 2; opengl_attributes[3] = 1; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_3_0:   { opengl_attributes[1] = 3; opengl_attributes[3] = 0; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_3_1:   { opengl_attributes[1] = 3; opengl_attributes[3] = 1; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
							case MU_OPENGL_3_2_CORE:          { opengl_attributes[1] = 3; opengl_attributes[3] = 2; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_3_2_COMPATIBILITY: { opengl_attributes[1] = 3; opengl_attributes[3] = 2; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_3_3_CORE:          { opengl_attributes[1] = 3; opengl_attributes[3] = 3; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_3_3_COMPATIBILITY: { opengl_attributes[1] = 3; opengl_attributes[3] = 3; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_0_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 0; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_0_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 0; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_1_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 1; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_1_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 1; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_2_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 2; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_2_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 2; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_3_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 3; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_3_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 3; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_4_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 4; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_4_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 4; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_5_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 5; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_5_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 5; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_6_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 6; opengl_attributes[5] = GLX_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
							case MU_OPENGL_4_6_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 6; opengl_attributes[5] = GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
						}

						*context = glXCreateContextAttribsARB(display, fbc, MU_NULL, MU_TRUE, opengl_attributes);
						if (!*context) {
							return MUCOSA_FAILED_CREATE_OPENGL_CONTEXT;
						}

						return MUCOSA_SUCCESS;
					}

				#endif /* MUCOSA_OPENGL */

				/* Structs */

					struct muCOSA_X11_input {
						muButtonState keyboard_key_states[MU_KEYBOARD_KEY_LAST-MU_KEYBOARD_KEY_FIRST+1];
						muState keyboard_state_states[MU_KEYBOARD_STATE_LAST-MU_KEYBOARD_STATE_FIRST+1];
						muButtonState mouse_button_states[MU_MOUSE_BUTTON_LAST-MU_MOUSE_BUTTON_FIRST+1];
					};
					typedef struct muCOSA_X11_input muCOSA_X11_input;

					struct muCOSA_X11_input_context {
						muBool active;
						XIM im;
						XIC ic;
					};
					typedef struct muCOSA_X11_input_context muCOSA_X11_input_context;

					struct muCOSA_X11Window {
						muBool active;

						muBool closed;
						muBool visible;
						muBool resizable;

						Display* display;
						Window parent_window;
						Window window;

						MU_LOCK

						Atom delete_atom;

						muGraphicsAPI api;
						MUCOSA_OPENGL_CALL(
							GLXContext gl_context;
						)

						uint32_m min_width; uint32_m min_height;
						uint32_m max_width; uint32_m max_height;
						XSizeHints* size_hints;

						muCursorStyle cursor_style;
						Cursor cursor;
						int32_m scroll_level;

						muCOSA_X11_input input;
						muCOSA_X11_input_context ic;
						void (*text_input_callback)(muWindow window, muByte* input);

						int32_m x;
						int32_m y;
						muBool minimized;
						muBool maximized;

						void (*dimensions_callback)(muWindow window, uint32_m width, uint32_m height);
						void (*position_callback)(muWindow window, int32_m x, int32_m y);
						void (*focus_callback)(muWindow window, muBool focused);
						void (*maximize_callback)(muWindow window, muBool maximized);
						void (*minimize_callback)(muWindow window, muBool minimized);

						void (*keyboard_key_callback)(muWindow window, muKeyboardKey keyboard_key, muButtonState state);
						void (*keyboard_state_callback)(muWindow window, muKeyboardState keyboard_state, muState state);

						void (*cursor_position_callback)(muWindow window, int32_m x, int32_m y);
						void (*mouse_button_callback)(muWindow window, muMouseButton mouse_button, muButtonState state);
						void (*scroll_callback)(muWindow window, int32_m scroll_level_add);

					};
					typedef struct muCOSA_X11Window muCOSA_X11Window;

					MU_HRARRAY_DEFAULT_FUNC(muCOSA_X11Window)

					struct muCOSA_X11Context {
						double original_time;

						muCOSA_X11Window_array windows;

						// @TODO Threadsafe here (?)
						pthread_t clipboard_thread;
						muBool clipboard_thread_exists;
						muBool clipboard_thread_running;
						muByte* clipboard_text;
						size_m clipboard_size;
					};
					typedef struct muCOSA_X11Context muCOSA_X11Context;

					double muCOSA_X11_inner_get_time(void);
					muCOSA_X11Context muCOSA_X11Context_init(void) {
						muCOSA_X11Context context = MU_ZERO_STRUCT(muCOSA_X11Context);
						context.original_time = muCOSA_X11_inner_get_time();
						context.clipboard_thread_exists = MU_FALSE;
						context.clipboard_thread_running = MU_FALSE;
						context.clipboard_text = 0;
						context.clipboard_size = 0;
						return context;
					}

				/* Useful funcs */

					/* Input context */
						// https://gist.github.com/Determinant/19bbecb6db35312861f6cf9f54fdd3a5
						// https://forums.gentoo.org/viewtopic-t-757913-start-0.html
						// https://www.cl.cam.ac.uk/~mgk25/ucs/keysym2ucs.c
						// http://www1.kokusaika.jp/advisory/org/en/x_im.html
						// https://gist.github.com/baines/5a49f1334281b2685af5dcae81a6fa8a
						// https://www.x.org/releases/X11R7.6/doc/libX11/specs/libX11/libX11.html#Input_Methods
						// https://github.com/wez/wezterm/issues/250
						// https://handmade.network/forums/articles/t/2834-tutorial_a_tour_through_xlib_and_related_technologies

						void muCOSA_X11_set_ic_locale(void) {
							#ifndef MUCOSA_NO_LOCALE_MOD
								mu_setlocale(LC_CTYPE, "");
								XSetLocaleModifiers("");
							#endif
						}

						void muCOSA_X11_set_ic_cursor_pos(muCOSA_X11Window* p_win, int32_m x, int32_m y) {
							XPoint point = { (short)x, (short)y };
							XVaNestedList ic_val = XVaCreateNestedList(0, XNSpotLocation, &point, NULL);
							XSetICValues(p_win->ic.ic, XNPreeditAttributes, ic_val, NULL);
							XFree(ic_val);
						}

						// https://handmade.network/forums/articles/t/2834-tutorial_a_tour_through_xlib_and_related_technologies
						muCOSA_X11_input_context muCOSA_X11_create_input_context(muCOSAResult* result, muCOSA_X11Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							muCOSA_X11_input_context ret = MU_ZERO_STRUCT(muCOSA_X11_input_context);
							ret.im = XOpenIM(p_win->display, 0, 0, 0);
							if (!ret.im) {
								MU_SET_RESULT(result, MUCOSA_FAILED_CREATE_INPUT_METHOD)
								return MU_ZERO_STRUCT(muCOSA_X11_input_context);
							}

							XIMStyles* styles = 0;
							if (XGetIMValues(ret.im, XNQueryInputStyle, &styles, NULL) || !styles) {
								MU_SET_RESULT(result, MUCOSA_FAILED_GET_INPUT_STYLES)
								XCloseIM(ret.im);
								return MU_ZERO_STRUCT(muCOSA_X11_input_context);
							}

							XIMStyle best_style = 0;
							for (size_m i = 0; i < styles->count_styles; i++) {
								if (styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing)) {
									best_style = styles->supported_styles[i];
									break;
								}
							}
							XFree(styles);

							if (!best_style) {
								MU_SET_RESULT(result, MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE)
								XCloseIM(ret.im);
								return MU_ZERO_STRUCT(muCOSA_X11_input_context);
							}

							ret.ic = XCreateIC(ret.im,
								XNInputStyle, best_style, 
								XNClientWindow, p_win->window,
							NULL);
							if (!ret.ic) {
								MU_SET_RESULT(result, MUCOSA_FAILED_CREATE_INPUT_CONTEXT)
								XCloseIM(ret.im);
								return MU_ZERO_STRUCT(muCOSA_X11_input_context);
							}

							XSetICFocus(ret.ic);
							ret.active = MU_TRUE;
							return ret;
						}

						muCOSA_X11_input_context muCOSA_X11_close_input_context(muCOSA_X11Window* p_win) {
							muCOSA_X11_input_context ret = p_win->ic;
							XDestroyIC(ret.ic);
							XCloseIM(ret.im);
							ret.active = MU_FALSE;
							return ret;
						}

						// @TODO Find an alternative to XGrabKeyboard that has less reported side effects.
						// Maybe calling XGrabKey?
						void muCOSA_X11_get_keyboard_focus(muCOSA_X11Window* p_win) {
							XGrabKeyboard(p_win->display, p_win->window, True, GrabModeAsync, GrabModeAsync, CurrentTime);
						}

						void muCOSA_X11_let_keyboard_focus(muCOSA_X11Window* p_win) {
							XUngrabKeyboard(p_win->display, CurrentTime);
						}

						void muCOSA_X11_handle_text_input_event(muCOSA_X11Window* p_win, XKeyEvent* p_kev, muWindow window) {
							// 24 should be enough for UTF-8
							char utf8_buf[24]; mu_memset(utf8_buf, 0, sizeof(utf8_buf));
							Status status = 0;
							KeySym ksym;
							size_m n = Xutf8LookupString(p_win->ic.ic, p_kev, utf8_buf, sizeof(utf8_buf)-1, &ksym, &status);

							if (status == XBufferOverflow) {
								// :P
								return;
							}

							if (n && p_win->text_input_callback) {
								p_win->text_input_callback(window, (muByte*)utf8_buf);
							}
						}

					/* Keyboard key input */

						// https://www.cl.cam.ac.uk/~mgk25/ucs/keysymdef.h
							#define MUCOSA_X11_XK_VoidSymbol 0xffffff
							#define MUCOSA_X11_XK_BackSpace 0xff08
							#define MUCOSA_X11_XK_Tab 0xff09
							#define MUCOSA_X11_XK_Clear 0xff0b
							#define MUCOSA_X11_XK_Return 0xff0d
							#define MUCOSA_X11_XK_Pause 0xff13
							#define MUCOSA_X11_XK_Escape 0xff1b
							#define MUCOSA_X11_XK_Mode_switch 0xff7e
							#define MUCOSA_X11_XK_space 0x0020
							#define MUCOSA_X11_XK_Prior 0xff55
							#define MUCOSA_X11_XK_Next 0xff56
							#define MUCOSA_X11_XK_End 0xff57
							#define MUCOSA_X11_XK_Home 0xff50
							#define MUCOSA_X11_XK_Left 0xff51
							#define MUCOSA_X11_XK_Up 0xff52
							#define MUCOSA_X11_XK_Right 0xff53
							#define MUCOSA_X11_XK_Down 0xff54
							#define MUCOSA_X11_XK_Select 0xff60
							#define MUCOSA_X11_XK_Print 0xff61
							#define MUCOSA_X11_XK_Execute 0xff62
							#define MUCOSA_X11_XK_Insert 0xff63
							#define MUCOSA_X11_XK_Delete 0xffff
							#define MUCOSA_X11_XK_Help 0xff6a
							#define MUCOSA_X11_XK_0 0x0030
							#define MUCOSA_X11_XK_1 0x0031
							#define MUCOSA_X11_XK_2 0x0032
							#define MUCOSA_X11_XK_3 0x0033
							#define MUCOSA_X11_XK_4 0x0034
							#define MUCOSA_X11_XK_5 0x0035
							#define MUCOSA_X11_XK_6 0x0036
							#define MUCOSA_X11_XK_7 0x0037
							#define MUCOSA_X11_XK_8 0x0038
							#define MUCOSA_X11_XK_9 0x0039
							#define MUCOSA_X11_XK_a 0x0061
							#define MUCOSA_X11_XK_b 0x0062
							#define MUCOSA_X11_XK_c 0x0063
							#define MUCOSA_X11_XK_d 0x0064
							#define MUCOSA_X11_XK_e 0x0065
							#define MUCOSA_X11_XK_f 0x0066
							#define MUCOSA_X11_XK_g 0x0067
							#define MUCOSA_X11_XK_h 0x0068
							#define MUCOSA_X11_XK_i 0x0069
							#define MUCOSA_X11_XK_j 0x006a
							#define MUCOSA_X11_XK_k 0x006b
							#define MUCOSA_X11_XK_l 0x006c
							#define MUCOSA_X11_XK_m 0x006d
							#define MUCOSA_X11_XK_n 0x006e
							#define MUCOSA_X11_XK_o 0x006f
							#define MUCOSA_X11_XK_p 0x0070
							#define MUCOSA_X11_XK_q 0x0071
							#define MUCOSA_X11_XK_r 0x0072
							#define MUCOSA_X11_XK_s 0x0073
							#define MUCOSA_X11_XK_t 0x0074
							#define MUCOSA_X11_XK_u 0x0075
							#define MUCOSA_X11_XK_v 0x0076
							#define MUCOSA_X11_XK_w 0x0077
							#define MUCOSA_X11_XK_x 0x0078
							#define MUCOSA_X11_XK_y 0x0079
							#define MUCOSA_X11_XK_z 0x007a
							#define MUCOSA_X11_XK_Super_L 0xffeb
							#define MUCOSA_X11_XK_Super_R 0xffec
							#define MUCOSA_X11_XK_KP_0 0xffb0
							#define MUCOSA_X11_XK_KP_1 0xffb1
							#define MUCOSA_X11_XK_KP_2 0xffb2
							#define MUCOSA_X11_XK_KP_3 0xffb3
							#define MUCOSA_X11_XK_KP_4 0xffb4
							#define MUCOSA_X11_XK_KP_5 0xffb5
							#define MUCOSA_X11_XK_KP_6 0xffb6
							#define MUCOSA_X11_XK_KP_7 0xffb7
							#define MUCOSA_X11_XK_KP_8 0xffb8
							#define MUCOSA_X11_XK_KP_9 0xffb9
							#define MUCOSA_X11_XK_KP_Multiply 0xffaa
							#define MUCOSA_X11_XK_KP_Add 0xffab
							#define MUCOSA_X11_XK_KP_Separator 0xffac
							#define MUCOSA_X11_XK_KP_Subtract 0xffad
							#define MUCOSA_X11_XK_KP_Decimal 0xffae
							#define MUCOSA_X11_XK_KP_Divide 0xffaf
							#define MUCOSA_X11_XK_F1 0xffbe
							#define MUCOSA_X11_XK_F2 0xffbf
							#define MUCOSA_X11_XK_F3 0xffc0
							#define MUCOSA_X11_XK_F4 0xffc1
							#define MUCOSA_X11_XK_F5 0xffc2
							#define MUCOSA_X11_XK_F6 0xffc3
							#define MUCOSA_X11_XK_F7 0xffc4
							#define MUCOSA_X11_XK_F8 0xffc5
							#define MUCOSA_X11_XK_F9 0xffc6
							#define MUCOSA_X11_XK_F10 0xffc7
							#define MUCOSA_X11_XK_F11 0xffc8
							#define MUCOSA_X11_XK_F12 0xffc9
							#define MUCOSA_X11_XK_F13 0xffca
							#define MUCOSA_X11_XK_F14 0xffcb
							#define MUCOSA_X11_XK_F15 0xffcc
							#define MUCOSA_X11_XK_F16 0xffcd
							#define MUCOSA_X11_XK_F17 0xffce
							#define MUCOSA_X11_XK_F18 0xffcf
							#define MUCOSA_X11_XK_F19 0xffd0
							#define MUCOSA_X11_XK_F20 0xffd1
							#define MUCOSA_X11_XK_F21 0xffd2
							#define MUCOSA_X11_XK_F22 0xffd3
							#define MUCOSA_X11_XK_F23 0xffd4
							#define MUCOSA_X11_XK_F24 0xffd5
							#define MUCOSA_X11_XK_Num_Lock 0xff7f
							#define MUCOSA_X11_XK_Scroll_Lock 0xff14
							#define MUCOSA_X11_XK_Shift_L 0xffe1
							#define MUCOSA_X11_XK_Shift_R 0xffe2
							#define MUCOSA_X11_XK_Control_L 0xffe3
							#define MUCOSA_X11_XK_Control_R 0xffe4
							#define MUCOSA_X11_XK_Menu 0xff67
							#define MUCOSA_X11_XK_3270_Attn 0xfd0e
							#define MUCOSA_X11_XK_3270_CursorSelect 0xfd1c
							#define MUCOSA_X11_XK_3270_ExSelect 0xfd1b
							#define MUCOSA_X11_XK_3270_EraseEOF 0xfd06
							#define MUCOSA_X11_XK_3270_Play 0xfd16
							#define MUCOSA_X11_XK_3270_PA1 0xfd0a

						int muCOSA_X11_keyboard_key_get_XK_key(muKeyboardKey key) {
							switch (key) {
								default: return MUCOSA_X11_XK_VoidSymbol; break;
								case MU_KEYBOARD_KEY_BACKSPACE: return MUCOSA_X11_XK_BackSpace; break;
								case MU_KEYBOARD_KEY_TAB: return MUCOSA_X11_XK_Tab; break;
								case MU_KEYBOARD_KEY_CLEAR: return MUCOSA_X11_XK_Clear; break;
								case MU_KEYBOARD_KEY_RETURN: return MUCOSA_X11_XK_Return; break;
								case MU_KEYBOARD_KEY_PAUSE: return MUCOSA_X11_XK_Pause; break;
								case MU_KEYBOARD_KEY_ESCAPE: return MUCOSA_X11_XK_Escape; break;
								case MU_KEYBOARD_KEY_MODECHANGE: return MUCOSA_X11_XK_Mode_switch; break;
								case MU_KEYBOARD_KEY_SPACE: return MUCOSA_X11_XK_space; break;
								case MU_KEYBOARD_KEY_PRIOR: return MUCOSA_X11_XK_Prior; break;
								case MU_KEYBOARD_KEY_NEXT: return MUCOSA_X11_XK_Next; break;
								case MU_KEYBOARD_KEY_END: return MUCOSA_X11_XK_End; break;
								case MU_KEYBOARD_KEY_HOME: return MUCOSA_X11_XK_Home; break;
								case MU_KEYBOARD_KEY_LEFT: return MUCOSA_X11_XK_Left; break;
								case MU_KEYBOARD_KEY_UP: return MUCOSA_X11_XK_Up; break;
								case MU_KEYBOARD_KEY_RIGHT: return MUCOSA_X11_XK_Right; break;
								case MU_KEYBOARD_KEY_DOWN: return MUCOSA_X11_XK_Down; break;
								case MU_KEYBOARD_KEY_SELECT: return MUCOSA_X11_XK_Select; break;
								case MU_KEYBOARD_KEY_PRINT: return MUCOSA_X11_XK_Print; break;
								case MU_KEYBOARD_KEY_EXECUTE: return MUCOSA_X11_XK_Execute; break;
								case MU_KEYBOARD_KEY_INSERT: return MUCOSA_X11_XK_Insert; break;
								case MU_KEYBOARD_KEY_DELETE: return MUCOSA_X11_XK_Delete; break;
								case MU_KEYBOARD_KEY_HELP: return MUCOSA_X11_XK_Help; break;
								case MU_KEYBOARD_KEY_0: return MUCOSA_X11_XK_0; break;
								case MU_KEYBOARD_KEY_1: return MUCOSA_X11_XK_1; break;
								case MU_KEYBOARD_KEY_2: return MUCOSA_X11_XK_2; break;
								case MU_KEYBOARD_KEY_3: return MUCOSA_X11_XK_3; break;
								case MU_KEYBOARD_KEY_4: return MUCOSA_X11_XK_4; break;
								case MU_KEYBOARD_KEY_5: return MUCOSA_X11_XK_5; break;
								case MU_KEYBOARD_KEY_6: return MUCOSA_X11_XK_6; break;
								case MU_KEYBOARD_KEY_7: return MUCOSA_X11_XK_7; break;
								case MU_KEYBOARD_KEY_8: return MUCOSA_X11_XK_8; break;
								case MU_KEYBOARD_KEY_9: return MUCOSA_X11_XK_9; break;
								case MU_KEYBOARD_KEY_A: return MUCOSA_X11_XK_a; break;
								case MU_KEYBOARD_KEY_B: return MUCOSA_X11_XK_b; break;
								case MU_KEYBOARD_KEY_C: return MUCOSA_X11_XK_c; break;
								case MU_KEYBOARD_KEY_D: return MUCOSA_X11_XK_d; break;
								case MU_KEYBOARD_KEY_E: return MUCOSA_X11_XK_e; break;
								case MU_KEYBOARD_KEY_F: return MUCOSA_X11_XK_f; break;
								case MU_KEYBOARD_KEY_G: return MUCOSA_X11_XK_g; break;
								case MU_KEYBOARD_KEY_H: return MUCOSA_X11_XK_h; break;
								case MU_KEYBOARD_KEY_I: return MUCOSA_X11_XK_i; break;
								case MU_KEYBOARD_KEY_J: return MUCOSA_X11_XK_j; break;
								case MU_KEYBOARD_KEY_K: return MUCOSA_X11_XK_k; break;
								case MU_KEYBOARD_KEY_L: return MUCOSA_X11_XK_l; break;
								case MU_KEYBOARD_KEY_M: return MUCOSA_X11_XK_m; break;
								case MU_KEYBOARD_KEY_N: return MUCOSA_X11_XK_n; break;
								case MU_KEYBOARD_KEY_O: return MUCOSA_X11_XK_o; break;
								case MU_KEYBOARD_KEY_P: return MUCOSA_X11_XK_p; break;
								case MU_KEYBOARD_KEY_Q: return MUCOSA_X11_XK_q; break;
								case MU_KEYBOARD_KEY_R: return MUCOSA_X11_XK_r; break;
								case MU_KEYBOARD_KEY_S: return MUCOSA_X11_XK_s; break;
								case MU_KEYBOARD_KEY_T: return MUCOSA_X11_XK_t; break;
								case MU_KEYBOARD_KEY_U: return MUCOSA_X11_XK_u; break;
								case MU_KEYBOARD_KEY_V: return MUCOSA_X11_XK_v; break;
								case MU_KEYBOARD_KEY_W: return MUCOSA_X11_XK_w; break;
								case MU_KEYBOARD_KEY_X: return MUCOSA_X11_XK_x; break;
								case MU_KEYBOARD_KEY_Y: return MUCOSA_X11_XK_y; break;
								case MU_KEYBOARD_KEY_Z: return MUCOSA_X11_XK_z; break;
								case MU_KEYBOARD_KEY_LEFT_WINDOWS: return MUCOSA_X11_XK_Super_L; break;
								case MU_KEYBOARD_KEY_RIGHT_WINDOWS: return MUCOSA_X11_XK_Super_R; break;
								case MU_KEYBOARD_KEY_NUMPAD_0: return MUCOSA_X11_XK_KP_0; break;
								case MU_KEYBOARD_KEY_NUMPAD_1: return MUCOSA_X11_XK_KP_1; break;
								case MU_KEYBOARD_KEY_NUMPAD_2: return MUCOSA_X11_XK_KP_2; break;
								case MU_KEYBOARD_KEY_NUMPAD_3: return MUCOSA_X11_XK_KP_3; break;
								case MU_KEYBOARD_KEY_NUMPAD_4: return MUCOSA_X11_XK_KP_4; break;
								case MU_KEYBOARD_KEY_NUMPAD_5: return MUCOSA_X11_XK_KP_5; break;
								case MU_KEYBOARD_KEY_NUMPAD_6: return MUCOSA_X11_XK_KP_6; break;
								case MU_KEYBOARD_KEY_NUMPAD_7: return MUCOSA_X11_XK_KP_7; break;
								case MU_KEYBOARD_KEY_NUMPAD_8: return MUCOSA_X11_XK_KP_8; break;
								case MU_KEYBOARD_KEY_NUMPAD_9: return MUCOSA_X11_XK_KP_9; break;
								case MU_KEYBOARD_KEY_MULTIPLY: return MUCOSA_X11_XK_KP_Multiply; break;
								case MU_KEYBOARD_KEY_ADD: return MUCOSA_X11_XK_KP_Add; break;
								case MU_KEYBOARD_KEY_SEPARATOR: return MUCOSA_X11_XK_KP_Separator; break;
								case MU_KEYBOARD_KEY_SUBTRACT: return MUCOSA_X11_XK_KP_Subtract; break;
								case MU_KEYBOARD_KEY_DECIMAL: return MUCOSA_X11_XK_KP_Decimal; break;
								case MU_KEYBOARD_KEY_DIVIDE: return MUCOSA_X11_XK_KP_Divide; break;
								case MU_KEYBOARD_KEY_F1: return MUCOSA_X11_XK_F1; break;
								case MU_KEYBOARD_KEY_F2: return MUCOSA_X11_XK_F2; break;
								case MU_KEYBOARD_KEY_F3: return MUCOSA_X11_XK_F3; break;
								case MU_KEYBOARD_KEY_F4: return MUCOSA_X11_XK_F4; break;
								case MU_KEYBOARD_KEY_F5: return MUCOSA_X11_XK_F5; break;
								case MU_KEYBOARD_KEY_F6: return MUCOSA_X11_XK_F6; break;
								case MU_KEYBOARD_KEY_F7: return MUCOSA_X11_XK_F7; break;
								case MU_KEYBOARD_KEY_F8: return MUCOSA_X11_XK_F8; break;
								case MU_KEYBOARD_KEY_F9: return MUCOSA_X11_XK_F9; break;
								case MU_KEYBOARD_KEY_F10: return MUCOSA_X11_XK_F10;break;
								case MU_KEYBOARD_KEY_F11: return MUCOSA_X11_XK_F11;break;
								case MU_KEYBOARD_KEY_F12: return MUCOSA_X11_XK_F12; break;
								case MU_KEYBOARD_KEY_F13: return MUCOSA_X11_XK_F13; break;
								case MU_KEYBOARD_KEY_F14: return MUCOSA_X11_XK_F14; break;
								case MU_KEYBOARD_KEY_F15: return MUCOSA_X11_XK_F15; break;
								case MU_KEYBOARD_KEY_F16: return MUCOSA_X11_XK_F16; break;
								case MU_KEYBOARD_KEY_F17: return MUCOSA_X11_XK_F17; break;
								case MU_KEYBOARD_KEY_F18: return MUCOSA_X11_XK_F18; break;
								case MU_KEYBOARD_KEY_F19: return MUCOSA_X11_XK_F19; break;
								case MU_KEYBOARD_KEY_F20: return MUCOSA_X11_XK_F20; break;
								case MU_KEYBOARD_KEY_F21: return MUCOSA_X11_XK_F21; break;
								case MU_KEYBOARD_KEY_F22: return MUCOSA_X11_XK_F22; break;
								case MU_KEYBOARD_KEY_F23: return MUCOSA_X11_XK_F23; break;
								case MU_KEYBOARD_KEY_F24: return MUCOSA_X11_XK_F24; break;
								case MU_KEYBOARD_KEY_NUMLOCK: return MUCOSA_X11_XK_Num_Lock; break;
								case MU_KEYBOARD_KEY_SCROLL: return MUCOSA_X11_XK_Scroll_Lock; break;
								case MU_KEYBOARD_KEY_LEFT_SHIFT: return MUCOSA_X11_XK_Shift_L; break;
								case MU_KEYBOARD_KEY_RIGHT_SHIFT: return MUCOSA_X11_XK_Shift_R; break;
								case MU_KEYBOARD_KEY_LEFT_CONTROL: return MUCOSA_X11_XK_Control_L; break;
								case MU_KEYBOARD_KEY_RIGHT_CONTROL: return MUCOSA_X11_XK_Control_R; break;
								case MU_KEYBOARD_KEY_LEFT_MENU: return MUCOSA_X11_XK_Menu; break;
								case MU_KEYBOARD_KEY_RIGHT_MENU: return MUCOSA_X11_XK_Menu; break;
								case MU_KEYBOARD_KEY_ATTN: return MUCOSA_X11_XK_3270_Attn; break;
								case MU_KEYBOARD_KEY_CRSEL: return MUCOSA_X11_XK_3270_CursorSelect; break;
								case MU_KEYBOARD_KEY_EXSEL: return MUCOSA_X11_XK_3270_ExSelect; break;
								case MU_KEYBOARD_KEY_EREOF: return MUCOSA_X11_XK_3270_EraseEOF; break;
								case MU_KEYBOARD_KEY_PLAY: return MUCOSA_X11_XK_3270_Play; break;
								case MU_KEYBOARD_KEY_PA1: return MUCOSA_X11_XK_3270_PA1; break;
							}
						}

						muKeyboardKey muCOSA_X11_XK_key_to_keyboard_key(int key) {
							switch (key) {
								default: return MU_KEYBOARD_KEY_UNKNOWN; break;
								case MUCOSA_X11_XK_BackSpace: return MU_KEYBOARD_KEY_BACKSPACE; break;
								case MUCOSA_X11_XK_Tab: return MU_KEYBOARD_KEY_TAB; break;
								case MUCOSA_X11_XK_Clear: return MU_KEYBOARD_KEY_CLEAR; break;
								case MUCOSA_X11_XK_Return: return MU_KEYBOARD_KEY_RETURN; break;
								case MUCOSA_X11_XK_Menu: return MU_KEYBOARD_KEY_LEFT_MENU; break;
								case MUCOSA_X11_XK_Pause: return MU_KEYBOARD_KEY_PAUSE; break;
								case MUCOSA_X11_XK_Escape: return MU_KEYBOARD_KEY_ESCAPE; break;
								case MUCOSA_X11_XK_Mode_switch: return MU_KEYBOARD_KEY_MODECHANGE; break;
								case MUCOSA_X11_XK_space: return MU_KEYBOARD_KEY_SPACE; break;
								case MUCOSA_X11_XK_Prior: return MU_KEYBOARD_KEY_PRIOR; break;
								case MUCOSA_X11_XK_Next: return MU_KEYBOARD_KEY_NEXT; break;
								case MUCOSA_X11_XK_End: return MU_KEYBOARD_KEY_END; break;
								case MUCOSA_X11_XK_Home: return MU_KEYBOARD_KEY_HOME; break;
								case MUCOSA_X11_XK_Left: return MU_KEYBOARD_KEY_LEFT; break;
								case MUCOSA_X11_XK_Up: return MU_KEYBOARD_KEY_UP; break;
								case MUCOSA_X11_XK_Right: return MU_KEYBOARD_KEY_RIGHT; break;
								case MUCOSA_X11_XK_Down: return MU_KEYBOARD_KEY_DOWN; break;
								case MUCOSA_X11_XK_Select: return MU_KEYBOARD_KEY_SELECT; break;
								case MUCOSA_X11_XK_Print: return MU_KEYBOARD_KEY_PRINT; break;
								case MUCOSA_X11_XK_Execute: return MU_KEYBOARD_KEY_EXECUTE; break;
								case MUCOSA_X11_XK_Insert: return MU_KEYBOARD_KEY_INSERT; break;
								case MUCOSA_X11_XK_Delete: return MU_KEYBOARD_KEY_DELETE; break;
								case MUCOSA_X11_XK_Help: return MU_KEYBOARD_KEY_HELP; break;
								case MUCOSA_X11_XK_0: return MU_KEYBOARD_KEY_0; break;
								case MUCOSA_X11_XK_1: return MU_KEYBOARD_KEY_1; break;
								case MUCOSA_X11_XK_2: return MU_KEYBOARD_KEY_2; break;
								case MUCOSA_X11_XK_3: return MU_KEYBOARD_KEY_3; break;
								case MUCOSA_X11_XK_4: return MU_KEYBOARD_KEY_4; break;
								case MUCOSA_X11_XK_5: return MU_KEYBOARD_KEY_5; break;
								case MUCOSA_X11_XK_6: return MU_KEYBOARD_KEY_6; break;
								case MUCOSA_X11_XK_7: return MU_KEYBOARD_KEY_7; break;
								case MUCOSA_X11_XK_8: return MU_KEYBOARD_KEY_8; break;
								case MUCOSA_X11_XK_9: return MU_KEYBOARD_KEY_9; break;
								case MUCOSA_X11_XK_a: return MU_KEYBOARD_KEY_A; break;
								case MUCOSA_X11_XK_b: return MU_KEYBOARD_KEY_B; break;
								case MUCOSA_X11_XK_c: return MU_KEYBOARD_KEY_C; break;
								case MUCOSA_X11_XK_d: return MU_KEYBOARD_KEY_D; break;
								case MUCOSA_X11_XK_e: return MU_KEYBOARD_KEY_E; break;
								case MUCOSA_X11_XK_f: return MU_KEYBOARD_KEY_F; break;
								case MUCOSA_X11_XK_g: return MU_KEYBOARD_KEY_G; break;
								case MUCOSA_X11_XK_h: return MU_KEYBOARD_KEY_H; break;
								case MUCOSA_X11_XK_i: return MU_KEYBOARD_KEY_I; break;
								case MUCOSA_X11_XK_j: return MU_KEYBOARD_KEY_J; break;
								case MUCOSA_X11_XK_k: return MU_KEYBOARD_KEY_K; break;
								case MUCOSA_X11_XK_l: return MU_KEYBOARD_KEY_L; break;
								case MUCOSA_X11_XK_m: return MU_KEYBOARD_KEY_M; break;
								case MUCOSA_X11_XK_n: return MU_KEYBOARD_KEY_N; break;
								case MUCOSA_X11_XK_o: return MU_KEYBOARD_KEY_O; break;
								case MUCOSA_X11_XK_p: return MU_KEYBOARD_KEY_P; break;
								case MUCOSA_X11_XK_q: return MU_KEYBOARD_KEY_Q; break;
								case MUCOSA_X11_XK_r: return MU_KEYBOARD_KEY_R; break;
								case MUCOSA_X11_XK_s: return MU_KEYBOARD_KEY_S; break;
								case MUCOSA_X11_XK_t: return MU_KEYBOARD_KEY_T; break;
								case MUCOSA_X11_XK_u: return MU_KEYBOARD_KEY_U; break;
								case MUCOSA_X11_XK_v: return MU_KEYBOARD_KEY_V; break;
								case MUCOSA_X11_XK_w: return MU_KEYBOARD_KEY_W; break;
								case MUCOSA_X11_XK_x: return MU_KEYBOARD_KEY_X; break;
								case MUCOSA_X11_XK_y: return MU_KEYBOARD_KEY_Y; break;
								case MUCOSA_X11_XK_z: return MU_KEYBOARD_KEY_Z; break;
								case MUCOSA_X11_XK_Super_L: return MU_KEYBOARD_KEY_LEFT_WINDOWS; break;
								case MUCOSA_X11_XK_Super_R: return MU_KEYBOARD_KEY_RIGHT_WINDOWS; break;
								case MUCOSA_X11_XK_KP_0: return MU_KEYBOARD_KEY_NUMPAD_0; break;
								case MUCOSA_X11_XK_KP_1: return MU_KEYBOARD_KEY_NUMPAD_1; break;
								case MUCOSA_X11_XK_KP_2: return MU_KEYBOARD_KEY_NUMPAD_2; break;
								case MUCOSA_X11_XK_KP_3: return MU_KEYBOARD_KEY_NUMPAD_3; break;
								case MUCOSA_X11_XK_KP_4: return MU_KEYBOARD_KEY_NUMPAD_4; break;
								case MUCOSA_X11_XK_KP_5: return MU_KEYBOARD_KEY_NUMPAD_5; break;
								case MUCOSA_X11_XK_KP_6: return MU_KEYBOARD_KEY_NUMPAD_6; break;
								case MUCOSA_X11_XK_KP_7: return MU_KEYBOARD_KEY_NUMPAD_7; break;
								case MUCOSA_X11_XK_KP_8: return MU_KEYBOARD_KEY_NUMPAD_8; break;
								case MUCOSA_X11_XK_KP_9: return MU_KEYBOARD_KEY_NUMPAD_9; break;
								case MUCOSA_X11_XK_KP_Multiply: return MU_KEYBOARD_KEY_MULTIPLY; break;
								case MUCOSA_X11_XK_KP_Add: return MU_KEYBOARD_KEY_ADD; break;
								case MUCOSA_X11_XK_KP_Separator: return MU_KEYBOARD_KEY_SEPARATOR; break;
								case MUCOSA_X11_XK_KP_Subtract: return MU_KEYBOARD_KEY_SUBTRACT; break;
								case MUCOSA_X11_XK_KP_Decimal: return MU_KEYBOARD_KEY_DECIMAL; break;
								case MUCOSA_X11_XK_KP_Divide: return MU_KEYBOARD_KEY_DIVIDE; break;
								case MUCOSA_X11_XK_F1: return MU_KEYBOARD_KEY_F1; break;
								case MUCOSA_X11_XK_F2: return MU_KEYBOARD_KEY_F2; break;
								case MUCOSA_X11_XK_F3: return MU_KEYBOARD_KEY_F3; break;
								case MUCOSA_X11_XK_F4: return MU_KEYBOARD_KEY_F4; break;
								case MUCOSA_X11_XK_F5: return MU_KEYBOARD_KEY_F5; break;
								case MUCOSA_X11_XK_F6: return MU_KEYBOARD_KEY_F6; break;
								case MUCOSA_X11_XK_F7: return MU_KEYBOARD_KEY_F7; break;
								case MUCOSA_X11_XK_F8: return MU_KEYBOARD_KEY_F8; break;
								case MUCOSA_X11_XK_F9: return MU_KEYBOARD_KEY_F9; break;
								case MUCOSA_X11_XK_F10: return MU_KEYBOARD_KEY_F10; break;
								case MUCOSA_X11_XK_F11: return MU_KEYBOARD_KEY_F11; break;
								case MUCOSA_X11_XK_F12: return MU_KEYBOARD_KEY_F12; break;
								case MUCOSA_X11_XK_F13: return MU_KEYBOARD_KEY_F13; break;
								case MUCOSA_X11_XK_F14: return MU_KEYBOARD_KEY_F14; break;
								case MUCOSA_X11_XK_F15: return MU_KEYBOARD_KEY_F15; break;
								case MUCOSA_X11_XK_F16: return MU_KEYBOARD_KEY_F16; break;
								case MUCOSA_X11_XK_F17: return MU_KEYBOARD_KEY_F17; break;
								case MUCOSA_X11_XK_F18: return MU_KEYBOARD_KEY_F18; break;
								case MUCOSA_X11_XK_F19: return MU_KEYBOARD_KEY_F19; break;
								case MUCOSA_X11_XK_F20: return MU_KEYBOARD_KEY_F20; break;
								case MUCOSA_X11_XK_F21: return MU_KEYBOARD_KEY_F21; break;
								case MUCOSA_X11_XK_F22: return MU_KEYBOARD_KEY_F22; break;
								case MUCOSA_X11_XK_F23: return MU_KEYBOARD_KEY_F23; break;
								case MUCOSA_X11_XK_F24: return MU_KEYBOARD_KEY_F24; break;
								case MUCOSA_X11_XK_Num_Lock: return MU_KEYBOARD_KEY_NUMLOCK; break;
								case MUCOSA_X11_XK_Scroll_Lock: return MU_KEYBOARD_KEY_SCROLL; break;
								case MUCOSA_X11_XK_Shift_L: return MU_KEYBOARD_KEY_LEFT_SHIFT; break;
								case MUCOSA_X11_XK_Shift_R: return MU_KEYBOARD_KEY_RIGHT_SHIFT; break;
								case MUCOSA_X11_XK_Control_L: return MU_KEYBOARD_KEY_LEFT_CONTROL; break;
								case MUCOSA_X11_XK_Control_R: return MU_KEYBOARD_KEY_RIGHT_CONTROL; break;
								case MUCOSA_X11_XK_3270_Attn: return MU_KEYBOARD_KEY_ATTN; break;
								case MUCOSA_X11_XK_3270_CursorSelect: return MU_KEYBOARD_KEY_CRSEL; break;
								case MUCOSA_X11_XK_3270_ExSelect: return MU_KEYBOARD_KEY_EXSEL; break;
								case MUCOSA_X11_XK_3270_EraseEOF: return MU_KEYBOARD_KEY_EREOF; break;
								case MUCOSA_X11_XK_3270_Play: return MU_KEYBOARD_KEY_PLAY; break;
								case MUCOSA_X11_XK_3270_PA1: return MU_KEYBOARD_KEY_PA1; break;
							}
						}

						void muCOSA_X11_keyboard_key_handle_event(muCOSA_X11Context* c, muWindow window, muCOSA_X11Window* p_win, XKeyEvent* p_kev, unsigned int keycode, muByte down) {
							muKeyboardKey key = muCOSA_X11_XK_key_to_keyboard_key(XkbKeycodeToKeysym(p_win->display, keycode, 0, 0));
							if (key != MU_KEYBOARD_KEY_UNKNOWN) {
								p_win->input.keyboard_key_states[key-MU_KEYBOARD_KEY_FIRST] = down;

								if (p_win->keyboard_key_callback != MU_NULL_PTR) {
									muCOSA_X11Window_release_element(0, &c->windows, window);
									p_win->keyboard_key_callback(window, key, p_win->input.keyboard_key_states[key-MU_KEYBOARD_KEY_FIRST]);
									muCOSA_X11Window_hold_element(0, &c->windows, window);
								}
							}

							if (c->windows.data[window].ic.active && c->windows.data[window].text_input_callback) {
								muCOSA_X11_handle_text_input_event(p_win, p_kev, window);
							}
						}

					/* Cursor */

						// https://tronche.com/gui/x/xlib/appendix/b/
						int muCOSA_X11_cursor_get_style(muCursorStyle style) {
							switch (style) {
								default: return 2; break;
								case MU_CURSOR_STYLE_IBEAM: return 152; break;
								case MU_CURSOR_STYLE_WAIT: case MU_CURSOR_STYLE_WAIT_ARROW: return 150; break;
								case MU_CURSOR_STYLE_CROSSHAIR: return 34; break;
								case MU_CURSOR_STYLE_HAND: return 58; break;
								case MU_CURSOR_STYLE_SIZE_EAST_WEST: return 108; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_SOUTH: return 116; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_EAST_SOUTH_WEST: case MU_CURSOR_STYLE_SIZE_NORTH_WEST_SOUTH_EAST: return 120; break;
								case MU_CURSOR_STYLE_SIZE_ALL: return 52; break;
								case MU_CURSOR_STYLE_NO: return 0; break;
							}
						}

						void muCOSA_X11_cursor_handle_event(muCOSA_X11Context* c, muWindow window, muCOSA_X11Window* p_win, int button, muByte down) {
							// down = true -> button being pressed down
							// down = false -> button being released
							switch (button) {
								default: break;

								case Button1: {
									p_win->input.mouse_button_states[MU_MOUSE_BUTTON_LEFT-MU_MOUSE_BUTTON_FIRST] = down;
									if (p_win->mouse_button_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->mouse_button_callback(window, MU_MOUSE_BUTTON_LEFT, down);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;

								case Button2: {
									p_win->input.mouse_button_states[MU_MOUSE_BUTTON_MIDDLE-MU_MOUSE_BUTTON_FIRST] = down;
									if (p_win->mouse_button_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->mouse_button_callback(window, MU_MOUSE_BUTTON_MIDDLE, down);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;

								case Button3: {
									p_win->input.mouse_button_states[MU_MOUSE_BUTTON_RIGHT-MU_MOUSE_BUTTON_FIRST] = down;
									if (p_win->mouse_button_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->mouse_button_callback(window, MU_MOUSE_BUTTON_RIGHT, down);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;

								// Not 100% sure if 120 is the appropriate value here for matching with window's WM_MOUSEWHEEL.

								/* Scroll wheel up */
								case Button4: {
									if (!down) {
										p_win->scroll_level += 120;
									}
									if (p_win->scroll_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->scroll_callback(window, 120);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;

								/* Scroll wheel down */
								case Button5: {
									if (!down) {
										p_win->scroll_level -= 120;
									}
									if (p_win->scroll_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->scroll_callback(window, -120);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;
							}
						}

						void muCOSA_X11_cursor_handle_motion_event(muCOSA_X11Context* c, muWindow window, muCOSA_X11Window* p_win, XMotionEvent motion_event) {
							if (p_win->cursor_position_callback != MU_NULL_PTR) {
								muCOSA_X11Window_release_element(0, &c->windows, window);
								p_win->cursor_position_callback(window, (int32_m)motion_event.x, (int32_m)motion_event.y);
								muCOSA_X11Window_hold_element(0, &c->windows, window);
							}
						}

					/* Window */

						// https://www.linuxquestions.org/questions/programming-9/how-to-read-the-state-by-using-_net_wm_state-in-xlib-836879/
						Atom muCOSA_X11Window_get_atom_plural(muCOSA_X11Window* p_win, const char** names, size_m namelen) {
							Atom wm_state = XInternAtom(p_win->display, "_NET_WM_STATE", MU_TRUE);
							if (wm_state == None) {
								return None;
							}
							Atom type;
							int format;
							unsigned long n_item = 0, bytes_after;
							unsigned char* properties = 0;
							XGetWindowProperty(
								p_win->display, p_win->window,
								wm_state, 0, (~0L), False, AnyPropertyType,
								&type, &format, &n_item, &bytes_after, &properties
							);

							for (size_m i = 0; i < n_item; i++) {
								Atom prop = ((Atom*)properties)[0];
								char* prop_name = XGetAtomName(p_win->display, prop);
								if (prop_name != 0) {
									for (size_m i = 0; i < namelen; i++) {
										if (mu_strcmp(prop_name, names[i]) == 0) {
											XFree(properties);
											return prop;
										}
									}
								}
							}

							if (properties != 0) {
								XFree(properties);
							}
							return None;
						}

						Atom muCOSA_X11Window_get_atom(muCOSA_X11Window* p_win, const char* name) {
							const char* names[1] = { name };
							return muCOSA_X11Window_get_atom_plural(p_win, names, 1);
						}

						// https://stackoverflow.com/questions/36188154/get-x11-window-caption-height
						void muCOSA_X11_inner_window_get_extents(Display* display, Window window, long* left, long* right, long* top, long* bottom) {
							MU_SET_RESULT(left, 0) MU_SET_RESULT(right, 0) MU_SET_RESULT(top, 0) MU_SET_RESULT(bottom, 0)

							Atom a = XInternAtom(display, "_NET_FRAME_EXTENTS", True);
							if (a == None) {
								return;
							}
							Atom t;
							int f;
							unsigned long _n, b;
							unsigned char* data = 0;
							int r = XGetWindowProperty(display, window, 
								a, 0, 4, False, AnyPropertyType, 
								&t, &f, &_n, &b, &data
							);

							if (r == Success && _n == 4 && b == 0) {
								long* extents = (long*)data;
								MU_SET_RESULT(left, extents[0])
								MU_SET_RESULT(right, extents[1])
								MU_SET_RESULT(top, extents[2])
								MU_SET_RESULT(bottom, extents[3])
							}
						}

						void muCOSA_X11Window_get_extents(muCOSA_X11Window* p_win, long* left, long* right, long* top, long* bottom) {
							muCOSA_X11_inner_window_get_extents(p_win->display, p_win->window, left, right, top, bottom);
						}

						void muCOSA_X11Window_update_min_max_dim(muCOSA_X11Window* p_win) {
							*p_win->size_hints = MU_ZERO_STRUCT(XSizeHints);
							p_win->size_hints->flags = PMinSize | PMaxSize;
							p_win->size_hints->min_width = p_win->min_width;
							p_win->size_hints->min_height = p_win->min_height;
							p_win->size_hints->max_width = p_win->min_width;
							p_win->size_hints->max_height = p_win->min_height;
							XSetWMNormalHints(p_win->display, p_win->window, p_win->size_hints);
						}

						void muCOSA_X11_inner_window_get_position(Display* display, Window window, Window par, int* x, int* y) {
							// https://stackoverflow.com/questions/3806872/window-position-in-xlib
							int rx, ry;
							Window child;
							XTranslateCoordinates(display, window, par, 0, 0, &rx, &ry, &child);

							MU_SET_RESULT(x, rx)
							MU_SET_RESULT(y, ry)
						}

						void muCOSA_X11_inner_window_set_position(muCOSA_X11Window* p_win, int x, int y) {
							// https://stackoverflow.com/questions/3806872/window-position-in-xlib
							XWindowAttributes xwa = MU_ZERO_STRUCT(XWindowAttributes);
							XGetWindowAttributes(p_win->display, p_win->window, &xwa);

							XMoveWindow(p_win->display, p_win->window, (x-xwa.x), (y-xwa.y));
						}

						muBool muCOSA_X11_inner_get_maximized(muCOSA_X11Window* p_win) {
							static const char* names[2] = { "_NET_WM_STATE_MAXIMIZED_VERT", "_NET_WM_STATE_MAXIMIZED_HORZ" };
							if (muCOSA_X11Window_get_atom_plural(p_win, names, 2) != None) {
								return MU_TRUE;
							}
							return MU_FALSE;
						}

						void muCOSA_X11_inner_set_maximized(muCOSA_X11Window* p_win, muBool maximized) {
							// https://forum.juce.com/t/how-to-maximize-not-fullscreen/28346
							XClientMessageEvent ev = MU_ZERO_STRUCT(XClientMessageEvent); ev.type = ClientMessage; ev.window = p_win->window;
							ev.message_type = XInternAtom(p_win->display, "_NET_WM_STATE", False);
							ev.format = 32;
							ev.data.l[0] = maximized;
							ev.data.l[1] = XInternAtom(p_win->display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
							ev.data.l[2] = XInternAtom(p_win->display, "_NET_WM_STATE_MAXIMIZED_HORZ", False);
							ev.data.l[3] = 1; ev.data.l[4] = 0;
							XSendEvent(p_win->display, p_win->parent_window,
								False, SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev
							);
							XFlush(p_win->display);
						}

						muBool muCOSA_X11_inner_get_minimized(muCOSA_X11Window* p_win) {
							if (muCOSA_X11Window_get_atom(p_win, "_NET_WM_STATE_HIDDEN") != None) {
								return MU_TRUE;
							}
							return MU_FALSE;
						}

						void muCOSA_X11_inner_set_minimized(muCOSA_X11Window* p_win, muBool minimized) {
							XClientMessageEvent ev = MU_ZERO_STRUCT(XClientMessageEvent); ev.type = ClientMessage; ev.window = p_win->window;
							if (minimized) {
								ev.message_type = XInternAtom(p_win->display, "WM_CHANGE_STATE", False);
								ev.format = 32;
								ev.data.l[0] = IconicState;
							} else {
								ev.message_type = XInternAtom(p_win->display, "_NET_ACTIVE_WINDOW", False);
								ev.format = 32;
								ev.data.l[0] = 1;
								ev.data.l[1] = CurrentTime;
								ev.data.l[2] = ev.data.l[3] = ev.data.l[4] = 0;
							}
							XSendEvent(p_win->display, p_win->parent_window,
								False, SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev
							);
							XFlush(p_win->display);
						}

					/* Event */

						muCOSAResult muCOSA_X11Window_handle_event(muCOSA_X11Context* c, muWindow window, muCOSA_X11Window* p_win, XEvent event) {
							switch (event.type) {
								default: return MUCOSA_SUCCESS; break;

								/* Refreshing keyboard mapping */
								case KeymapNotify: {
									XRefreshKeyboardMapping(&event.xmapping);
								} break;

								/* Closing the window */
								case ClientMessage: {
									if (event.xclient.data.l[0] == (long int)p_win->delete_atom) {
										XUnmapWindow(p_win->display, p_win->window);
										p_win->closed = MU_TRUE;
									}
								} break;

								/* Mouse button press */
								case ButtonPress: {
									muCOSA_X11_cursor_handle_event(c, window, p_win, event.xbutton.button, MU_TRUE);
								} break;
								/* Mouse button release */
								case ButtonRelease: {
									muCOSA_X11_cursor_handle_event(c, window, p_win, event.xbutton.button, MU_FALSE);
								} break;
								/* Mouse button movement */
								case MotionNotify: {
									muCOSA_X11_cursor_handle_motion_event(c, window, p_win, event.xmotion);
								} break;

								/* Keyboard key press */
								case KeyPress: {
									muCOSA_X11_keyboard_key_handle_event(c, window, p_win, &event.xkey, event.xkey.keycode, MU_TRUE);
								} break;
								/* Keyboard key release */
								case KeyRelease: {
									muCOSA_X11_keyboard_key_handle_event(c, window, p_win, &event.xkey, event.xkey.keycode, MU_FALSE);
								} break;

								/* Dimension changing */
								case Expose: {
									XWindowAttributes attribs;
									XGetWindowAttributes(p_win->display, p_win->window, &attribs);
									if (p_win->dimensions_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->dimensions_callback(window, (uint32_m)attribs.width, (uint32_m)attribs.height);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;

								/* Position changing */
								case ConfigureNotify: {
									if (p_win->x != event.xconfigure.x || p_win->y != event.xconfigure.y) {
										p_win->x = (int32_m)event.xconfigure.x;
										p_win->y = (int32_m)event.xconfigure.y;
										if (p_win->position_callback != MU_NULL_PTR) {
											muCOSA_X11Window_release_element(0, &c->windows, window);
											p_win->position_callback(window, p_win->x, p_win->y);
											muCOSA_X11Window_hold_element(0, &c->windows, window);
										}
									}
								} break;

								/* Focusing in/out */
								// @TODO Fix FocusIn/FocusOut getting called when window is being dragged
								case FocusIn: {
									if (p_win->ic.active) {
										XSetICFocus(p_win->ic.ic);
									}
									if (p_win->focus_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->focus_callback(window, MU_TRUE);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;
								case FocusOut: {
									if (p_win->ic.active) {
										XUnsetICFocus(p_win->ic.ic);
									}
									if (p_win->focus_callback != MU_NULL_PTR) {
										muCOSA_X11Window_release_element(0, &c->windows, window);
										p_win->focus_callback(window, MU_FALSE);
										muCOSA_X11Window_hold_element(0, &c->windows, window);
									}
								} break;
							}

							return MUCOSA_SUCCESS;
						}

						void muCOSA_X11Window_handle_focus_input_flushing(muCOSA_X11Window* p_win) {
							Window focused_window;
							int revert_to;
							XGetInputFocus(p_win->display, &focused_window, &revert_to);

							if (focused_window != p_win->window) {
								p_win->input = MU_ZERO_STRUCT(muCOSA_X11_input);
							}
						}

						void muCOSA_X11Window_handle_min_max_events(muCOSA_X11Context* c, muWindow window, muCOSA_X11Window* p_win) {
							muBool maximized = muCOSA_X11_inner_get_maximized(p_win);
							if (p_win->maximized != maximized) {
								p_win->maximized = maximized;
								if (p_win->maximize_callback != MU_NULL_PTR) {
									muCOSA_X11Window_release_element(0, &c->windows, window);
									p_win->maximize_callback(window, maximized);
									muCOSA_X11Window_hold_element(0, &c->windows, window);
								}
							}

							muBool minimized = muCOSA_X11_inner_get_minimized(p_win);
							if (p_win->minimized != minimized) {
								p_win->minimized = minimized;
								if (p_win->minimize_callback != MU_NULL_PTR) {
									muCOSA_X11Window_release_element(0, &c->windows, window);
									p_win->minimize_callback(window, minimized);
									muCOSA_X11Window_hold_element(0, &c->windows, window);
								}
							}
						}

					/* Keyboard state input */

						void muCOSA_X11_check_state_input(muCOSA_X11Context* c, muWindow window, muCOSA_X11Window* p_win, unsigned int n, const char* name, muKeyboardState state) {
							muBool check = (n & (XInternAtom(p_win->display, name, False) - 1)) != 0;
							if (check != p_win->input.keyboard_state_states[state-MU_KEYBOARD_STATE_FIRST]) {
								p_win->input.keyboard_state_states[state-MU_KEYBOARD_STATE_FIRST] = check;

								if (p_win->keyboard_state_callback != MU_NULL_PTR) {
									muCOSA_X11Window_release_element(0, &c->windows, window);
									p_win->keyboard_state_callback(window, state, check);
									muCOSA_X11Window_hold_element(0, &c->windows, window);
								}
							}
						}

						void muCOSA_X11_handle_state_input(muCOSA_X11Context* c, muWindow window, muCOSA_X11Window* p_win) {
							// http://levonp.blogspot.com/2010/08/retrieving-caps-lock-info-using-xlib.html
							unsigned int n;
							XkbGetIndicatorState(p_win->display, XkbUseCoreKbd, &n);

							muCOSA_X11_check_state_input(c, window, p_win, n, "Caps Lock", MU_KEYBOARD_STATE_CAPS_LOCK);
							muCOSA_X11_check_state_input(c, window, p_win, n, "Num Lock", MU_KEYBOARD_STATE_NUM_LOCK);
							// Been having issues with this... being triggered by Caps Lock and Num Lock
							// sometimes... :L
							muCOSA_X11_check_state_input(c, window, p_win, n, "Scroll Lock", MU_KEYBOARD_STATE_SCROLL_LOCK);
						}

					/* Time */

						// https://stackoverflow.com/questions/3756323/how-to-get-the-current-time-in-milliseconds-from-c-in-linux
						double muCOSA_X11_inner_get_time(void) {
							struct timespec spec;
							clock_gettime(CLOCK_REALTIME, &spec);
							return (double)((double)(spec.tv_sec) + ((double)(spec.tv_nsec) / (double)(1.0e9)));
						}

					/* Clipboard */

						// NOTE: only meant to be called by thread
						void* muCOSA_X11_inner_clipboard_set(void* p) {
							muCOSA_X11Context* c = (muCOSA_X11Context*)p;
							Display* d = XOpenDisplay(NULL);
							Window w = XCreateSimpleWindow(d, RootWindow(d, DefaultScreen(d)), -10, -10, 1, 1, 0, 0, 0);

							Atom utf8 = XInternAtom(d, "UTF8_STRING", False);
							XSetSelectionOwner(d, XInternAtom(d, "CLIPBOARD", False), w, CurrentTime);

							XEvent ev;
							muBool got_event = MU_FALSE;
							while (!got_event && c->clipboard_thread_running) {
								while (!XPending(d)) {
									if (!c->clipboard_thread_running) {
										XCloseDisplay(d);
										return 0;
									}
								}
								XNextEvent(d, &ev);
								switch (ev.type) {
									default: break;

									/* Ownership loss */
									case SelectionClear: {
										got_event = MU_TRUE;
									} break;

									/* Clipboard request */
									case SelectionRequest: {
										XSelectionRequestEvent* sev = (XSelectionRequestEvent*)&ev.xselectionrequest;

										if (sev->target != utf8 || sev->property == None) {
											// "Can't give it to you, mate, I only got UTF-8."
											char* an = XGetAtomName(d, sev->target);
											if (an) {
												XFree(an);
											}

											XSelectionEvent ssev = MU_ZERO_STRUCT(XSelectionEvent);
											ssev.type = SelectionNotify;
											ssev.requestor = sev->requestor;
											ssev.selection = sev->selection;
											ssev.target = sev->target;
											ssev.property = None;
											ssev.time = sev->time;
											XSendEvent(d, sev->requestor, True, NoEventMask, (XEvent*)&ssev);
										} else {
											// "Right, here ya go."
											char* an = XGetAtomName(d, sev->property);
											if (an) {
												XFree(an);
											}
											XChangeProperty(d, sev->requestor, sev->property, utf8, 8, PropModeReplace,
												(unsigned char*)c->clipboard_text, c->clipboard_size
											);

											XSelectionEvent ssev = MU_ZERO_STRUCT(XSelectionEvent);
											ssev.type = SelectionNotify;
											ssev.requestor = sev->requestor;
											ssev.selection = sev->selection;
											ssev.target = sev->target;
											ssev.property = sev->property;
											ssev.time = sev->time;
											XSendEvent(d, sev->requestor, True, NoEventMask, (XEvent*)&ssev);
										}
									} break;
								}
							}

							XCloseDisplay(d);
							c->clipboard_thread_running = MU_FALSE;
							return 0;
						}

				/* Functions */

					/* Is supported */

						muBool muCOSA_X11_is_supported(void) {
							return MU_TRUE;
						}

					/* Initiation / Termination */

						void muCOSA_X11_init(muCOSAResult* result, muCOSA_X11Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							muCOSA_X11_set_ic_locale();
							c->windows = MU_ZERO_STRUCT(muCOSA_X11Window_array);
						}

						muWindow muCOSA_X11_window_destroy(muCOSAResult* result, muCOSA_X11Context* c, muWindow window);
						void muCOSA_X11_term(muCOSAResult* result, muCOSA_X11Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							for (size_m i = 0; i < c->windows.length; i++) {
								muCOSA_X11_window_destroy(0, c, i);
							}

							if (c->clipboard_thread_running) {
								c->clipboard_thread_running = MU_FALSE;
								MU_ASSERT(pthread_join(c->clipboard_thread, NULL) == 0, result, MUCOSA_FAILED_JOIN_THREAD, return;)
							}
							if (c->clipboard_text) {
								mu_free(c->clipboard_text);
								c->clipboard_text = 0;
							}
						}

					/* Window */

						/* Creation / Destruction */

							muWindow muCOSA_X11_window_create(muCOSAResult* result, muCOSA_X11Context* c,
								muGraphicsAPI api, muBool (*load_functions)(void),
								muByte* name, uint16_m width, uint16_m height,
								muWindowCreateInfo create_info
							) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								mumaResult muma_res = MUMA_SUCCESS;
								muCOSAResult mu_res = MUCOSA_SUCCESS;

								mu_res = muCOSA_verify_window_create_info(create_info);
								MU_ASSERT(mu_res == MUCOSA_SUCCESS, result, mu_res, return MU_NONE;)

								size_m win = MU_NONE;
								muCOSA_X11Window_find_push(&muma_res, &c->windows, MU_ZERO_STRUCT(muCOSA_X11Window), &win);
								if (muma_res != MUMA_SUCCESS) {
									MU_SET_RESULT(result, muma_result_to_muCOSA_result(muma_res))
									return MU_NONE;
								}
								muCOSA_X11Window_hold_element(&muma_res, &c->windows, win);
								MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_muCOSA_result(muma_res), return MU_NONE;)

								c->windows.data[win].size_hints = XAllocSizeHints();
								MU_ASSERT(c->windows.data[win].size_hints != 0, result, MUCOSA_ALLOCATION_FAILED,
									MU_RELEASE(c->windows, win, muCOSA_X11Window_) return MU_NONE;)

								c->windows.data[win].active = MU_FALSE;

								/* Create display */

								c->windows.data[win].display = XOpenDisplay(MU_NULL_PTR);
								MU_ASSERT(c->windows.data[win].display != NULL, result, MUCOSA_FAILED_CONNECTION_TO_SERVER, 
									// Note: OK to just release here, since it's still marked as inactive
									XFree(c->windows.data[win].size_hints);
									MU_RELEASE(c->windows, win, muCOSA_X11Window_) return MU_NONE;)

								/*
								The XCloseDisplay function closes the connection to the X server for the
								display specified in the Display structure and destroys all windows,
								resource IDs (Window, Font, Pixmap, Colormap, Cursor, and GContext), or
								other resources that the client has created on this display, unless the
								close-down mode of the resource has been changed (see XSetCloseDownMode).
								Therefore, these windows, resource IDs, and other resources should never be
								referenced again or an error will be generated. Before exiting, you should
								call XCloseDisplay explicitly so that any pending errors are reported as
								XCloseDisplay performs a final XSync operation. 
								*/
								// https://www.x.org/releases/X11R7.5/doc/man/man3/XOpenDisplay.3.html

								// In other words, just call XCloseDisplay, and everything will be OK.

								/* Create window */

								c->windows.data[win].parent_window = DefaultRootWindow(c->windows.data[win].display);

								MUCOSA_OPENGL_CALL(
									muCOSA_X11_gl_attributes gl_att = MU_ZERO_STRUCT(muCOSA_X11_gl_attributes); if (gl_att.att[2]) {}
									GLXFBConfig* fbcs = 0;
									GLXFBConfig fbc;
									int fbc_count = 0;
								)
								XVisualInfo* vi = 0;
								if (api >= MUCOSA_OPENGL_FIRST && api <= MUCOSA_OPENGL_LAST) {
									MUCOSA_OPENGL_CALL(
										gl_att = muCOSA_X11_get_gl_attributes(create_info.pixel_format);
										fbcs = glXChooseFBConfig(
											c->windows.data[win].display, 
											DefaultScreen(c->windows.data[win].display),
											gl_att.att, &fbc_count
										);
										if (fbcs == 0) {
											MU_SET_RESULT(result, MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER)
										} else {
											// @TODO Choose best format
											fbc = fbcs[0];
											XFree(fbcs);

											vi = glXGetVisualFromFBConfig(c->windows.data[win].display, fbc);
											if (vi == 0) {
												MU_SET_RESULT(result, MUCOSA_FAILED_USE_PIXEL_FORMAT)
											}
										}
									)
								}

								// This probably isn't being done right :L
								int depth = 8*3;
								Visual* v = 0;
								unsigned long valuemask = CWEventMask;
								XSetWindowAttributes win_attribs = MU_ZERO_STRUCT(XSetWindowAttributes);
								win_attribs.event_mask = ExposureMask | StructureNotifyMask
								| KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask
								| PointerMotionMask | FocusChangeMask
								;
								if (vi != 0) {
									depth = vi->depth;
									v = vi->visual;

									win_attribs.colormap = XCreateColormap(
										c->windows.data[win].display, c->windows.data[win].parent_window,
										vi->visual, AllocNone
									);
									valuemask |= CWColormap;
								}

								// @TODO Figure out how to tell if this worked or not
								c->windows.data[win].window = XCreateWindow(c->windows.data[win].display,
									c->windows.data[win].parent_window,
									0, 0,
									(unsigned int)width, (unsigned int)height,
									0, // (Border width)
									// (Bits per pixel / "depth")
									depth,
									InputOutput,
									v,
									valuemask, &win_attribs
								);

								XFree(vi);

								/* Create cursor */

								c->windows.data[win].cursor_style = create_info.cursor_style;
								c->windows.data[win].cursor = XCreateFontCursor(c->windows.data[win].display, muCOSA_X11_cursor_get_style(c->windows.data[win].cursor_style));
								XDefineCursor(c->windows.data[win].display, c->windows.data[win].window, c->windows.data[win].cursor);

								/* API initialization */

								if (api >= MUCOSA_OPENGL_FIRST && api <= MUCOSA_OPENGL_LAST) {
									MUCOSA_OPENGL_CALL(
										mu_res = muCOSA_X11_init_opengl(
											c->windows.data[win].display, &c->windows.data[win].gl_context,
											api, fbc
										);
										MU_ASSERT(mu_res == MUCOSA_SUCCESS, result, mu_res, 
											XCloseDisplay(c->windows.data[win].display); MU_RELEASE(c->windows, win, muCOSA_X11Window_) return MU_NONE;)
									)
								} else if (api != MU_NO_GRAPHICS_API) {
									MU_SET_RESULT(result, MUCOSA_UNKNOWN_GRAPHICS_API)
									XFree(c->windows.data[win].size_hints);
									XCloseDisplay(c->windows.data[win].display);
									MU_RELEASE(c->windows, win, muCOSA_X11Window_)
									return MU_NONE;
								}

								/* API loading */

								if (api >= MUCOSA_OPENGL_FIRST && api <= MUCOSA_OPENGL_LAST) {
									MUCOSA_OPENGL_CALL(
										glXMakeCurrent(c->windows.data[win].display, c->windows.data[win].window, c->windows.data[win].gl_context);
									)
								}

								if (load_functions != MU_NULL_PTR) {
									MU_ASSERT(load_functions() == MU_TRUE, result, MUCOSA_FAILED_LOAD_FUNCTIONS, 
										if (api >= MUCOSA_OPENGL_FIRST && api <= MUCOSA_OPENGL_LAST) {
											MUCOSA_OPENGL_CALL(glXDestroyContext(c->windows.data[win].display, c->windows.data[win].gl_context);)
										}
										XFree(c->windows.data[win].size_hints);
										XCloseDisplay(c->windows.data[win].display); MU_RELEASE(c->windows, win, muCOSA_X11Window_) return MU_NONE;)
								}

								/* Name */

								XChangeProperty(
									c->windows.data[win].display, c->windows.data[win].window,
									XInternAtom(c->windows.data[win].display, "_NET_WM_NAME", MU_FALSE),
									XInternAtom(c->windows.data[win].display, "UTF8_STRING", MU_FALSE),
									8, PropModeReplace, (unsigned char*)name, mu_strlen((const char*)name) // <--- strlen or actual UTF-8 char count?
								);

								/* Delete message */

								c->windows.data[win].delete_atom = XInternAtom(c->windows.data[win].display, "WM_DELETE_WINDOW", MU_FALSE);
								XSetWMProtocols(c->windows.data[win].display, c->windows.data[win].window, &c->windows.data[win].delete_atom, 1);

								/* Size hints */

								*c->windows.data[win].size_hints = MU_ZERO_STRUCT(XSizeHints);
								c->windows.data[win].size_hints->flags = PPosition | PMinSize | PMaxSize;
								c->windows.data[win].size_hints->x = create_info.x;
								c->windows.data[win].size_hints->y = create_info.y;
								c->windows.data[win].size_hints->min_width = create_info.min_width;
								c->windows.data[win].size_hints->min_height = create_info.min_height;
								c->windows.data[win].size_hints->max_width = create_info.max_width;
								c->windows.data[win].size_hints->max_height = create_info.max_height;
								if (!create_info.resizable) {
									c->windows.data[win].size_hints->min_width = width;
									c->windows.data[win].size_hints->min_height = height;
									c->windows.data[win].size_hints->max_width = width;
									c->windows.data[win].size_hints->max_height = height;
								}
								XSetWMNormalHints(c->windows.data[win].display, c->windows.data[win].window, c->windows.data[win].size_hints);

								/* Map */

								if (create_info.visible) {
									XMapWindow(c->windows.data[win].display, c->windows.data[win].window);
								}
								XSync(c->windows.data[win].display, False);

								muCOSA_X11_inner_set_maximized(&c->windows.data[win], create_info.maximized);
								muCOSA_X11_inner_set_minimized(&c->windows.data[win], create_info.minimized);

								/* Position correctly */

								for (size_m i = 0; i < 10; i++) {
									muCOSA_X11_inner_window_set_position(&c->windows.data[win], (int)create_info.x, (int)create_info.y);
								}

								/* G i v e */

								c->windows.data[win].active = MU_TRUE;
								c->windows.data[win].api = api;
								c->windows.data[win].closed = MU_FALSE;
								c->windows.data[win].visible = create_info.visible;
								c->windows.data[win].resizable = create_info.resizable;
								c->windows.data[win].min_width = create_info.min_width;
								c->windows.data[win].min_height = create_info.min_height;
								c->windows.data[win].max_width = create_info.max_width;
								c->windows.data[win].max_height = create_info.max_height;
								c->windows.data[win].scroll_level = 0;
								c->windows.data[win].input = MU_ZERO_STRUCT(muCOSA_X11_input);
								c->windows.data[win].ic = MU_ZERO_STRUCT(muCOSA_X11_input_context);
								c->windows.data[win].text_input_callback = 0;
								c->windows.data[win].dimensions_callback = create_info.dimensions_callback;
								c->windows.data[win].position_callback = create_info.position_callback;
								c->windows.data[win].focus_callback = create_info.focus_callback;
								c->windows.data[win].maximize_callback = create_info.maximize_callback;
								c->windows.data[win].minimize_callback = create_info.minimize_callback;
								c->windows.data[win].keyboard_key_callback = create_info.keyboard_key_callback;
								c->windows.data[win].keyboard_state_callback = create_info.keyboard_state_callback;
								c->windows.data[win].cursor_position_callback = create_info.cursor_position_callback;
								c->windows.data[win].mouse_button_callback = create_info.mouse_button_callback;
								c->windows.data[win].scroll_callback = create_info.scroll_callback;
								c->windows.data[win].x = create_info.x;
								c->windows.data[win].y = create_info.y;
								c->windows.data[win].minimized = create_info.minimized;
								c->windows.data[win].maximized = create_info.maximized;
								MU_RELEASE(c->windows, win, muCOSA_X11Window_)
								return win;
							}

							muWindow muCOSA_X11_window_destroy(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return window;, muCOSA_X11Window_)

								if (c->windows.data[window].api >= MUCOSA_OPENGL_FIRST && c->windows.data[window].api <= MUCOSA_OPENGL_LAST) {
									MUCOSA_OPENGL_CALL(
										glXDestroyContext(c->windows.data[window].display, c->windows.data[window].gl_context);
									)
								}

								XFree(c->windows.data[window].size_hints);

								XSync(c->windows.data[window].display, False);
								XCloseDisplay(c->windows.data[window].display);

								c->windows.data[window].active = MU_FALSE;
								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
								return MU_NONE;
							}

						/* Main loop */

							muBool muCOSA_X11_window_get_closed(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_TRUE;, muCOSA_X11Window_)

								muBool closed = c->windows.data[window].closed;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
								return closed;
							}

							void muCOSA_X11_window_close(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								XUnmapWindow(c->windows.data[window].display, c->windows.data[window].window);
								c->windows.data[window].closed = MU_TRUE;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_update(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)
								muCOSAResult mu_res = MUCOSA_SUCCESS;

								while (XPending(c->windows.data[window].display)) {
									XEvent event;
									XNextEvent(c->windows.data[window].display, &event);

									if (!XFilterEvent(&event, None)) {
										mu_res = muCOSA_X11Window_handle_event(c, window, &c->windows.data[window], event);
										MU_ASSERT(mu_res == MUCOSA_SUCCESS, result, mu_res, MU_RELEASE(c->windows, window, muCOSA_X11Window_) return;)
									}
								}

								muCOSA_X11_handle_state_input(c, window, &c->windows.data[window]);
								muCOSA_X11Window_handle_focus_input_flushing(&c->windows.data[window]);
								muCOSA_X11Window_handle_min_max_events(c, window, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_swap_buffers(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								if (c->windows.data[window].api >= MUCOSA_OPENGL_FIRST && c->windows.data[window].api <= MUCOSA_OPENGL_LAST) {
									MUCOSA_OPENGL_CALL(
										glXSwapBuffers(c->windows.data[window].display, c->windows.data[window].window);
									)
								}

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

						/* Get / Set */

							muBool muCOSA_X11_window_get_focused(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_X11Window_)

								Window focused;
								int revert_to;
								XGetInputFocus(c->windows.data[window].display, &focused, &revert_to);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return focused == c->windows.data[window].window;
							}

							void muCOSA_X11_window_focus(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								if (muCOSA_X11Window_get_atom(&c->windows.data[window], "_NET_WM_STATE_HIDDEN") != None) {
									// https://stackoverflow.com/questions/30192347/how-to-restore-a-window-with-xlib
									XClientMessageEvent ev = MU_ZERO_STRUCT(XClientMessageEvent); ev.type = ClientMessage; ev.window = c->windows.data[window].window;
									ev.message_type = XInternAtom(c->windows.data[window].display, "_NET_ACTIVE_WINDOW", True);
									MU_ASSERT(ev.message_type != None, result, MUCOSA_UNSUPPORTED_FEATURE, MU_RELEASE(c->windows, window, muCOSA_X11Window_) return;)

									ev.format = 32;
									ev.data.l[0] = 1; ev.data.l[1] = CurrentTime;
									ev.data.l[2] = ev.data.l[3] = ev.data.l[4] = 0;
									XSendEvent(c->windows.data[window].display, c->windows.data[window].parent_window, False, 
										SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*)&ev
									);
									XFlush(c->windows.data[window].display);
								}

								// Try blocking for a bit to register the deminimization
								// This is a hack and a half
								double time_beg = muCOSA_X11_inner_get_time();
								while (muCOSA_X11_inner_get_minimized(&c->windows.data[window]) && 
									(muCOSA_X11_inner_get_time()-time_beg) < .001f) {

								}

								if (muCOSA_X11_inner_get_minimized(&c->windows.data[window]) || !c->windows.data[window].visible) {
									MU_SET_RESULT(result, MUCOSA_INVALID_WINDOW_STATE)
									MU_RELEASE(c->windows, window, muCOSA_X11Window_)
									return;
								}

								XSetInputFocus(c->windows.data[window].display, c->windows.data[window].window, RevertToPointerRoot, CurrentTime);
								XRaiseWindow(c->windows.data[window].display, c->windows.data[window].window);

								void (*focus_callback)(muWindow window, muBool focused) = c->windows.data[window].focus_callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								if (focus_callback != MU_NULL_PTR && callback) {
									focus_callback(window, MU_TRUE);
								}
							}

							muBool muCOSA_X11_window_get_visible(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_X11Window_)

								muBool visible = c->windows.data[window].visible;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return visible;
							}

							void muCOSA_X11_window_set_visible(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muBool visible) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								if (visible && !c->windows.data[window].visible) {
									XMapWindow(c->windows.data[window].display, c->windows.data[window].window);
									c->windows.data[window].input = MU_ZERO_STRUCT(muCOSA_X11_input);
								} else if (!visible && c->windows.data[window].visible) {
									XUnmapWindow(c->windows.data[window].display, c->windows.data[window].window);
									c->windows.data[window].input = MU_ZERO_STRUCT(muCOSA_X11_input);
								}

								c->windows.data[window].visible = visible;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_get_position(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int32_m* x, int32_m* y) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								int rx = 0, ry = 0;
								muCOSA_X11_inner_window_get_position(c->windows.data[window].display, c->windows.data[window].window, c->windows.data[window].parent_window, &rx, &ry);

								MU_SET_RESULT(x, rx) MU_SET_RESULT(y, ry)

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_position(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int32_m x, int32_m y, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								muCOSA_X11_inner_window_set_position(&c->windows.data[window], x, y);
								c->windows.data[window].x = x;
								c->windows.data[window].y = y;
								void (*position_callback)(muWindow window, int32_m x, int32_m y) = c->windows.data[window].position_callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								if (position_callback != MU_NULL_PTR && callback) {
									position_callback(window, x, y);
								}
							}

							void muCOSA_X11_window_get_dimensions(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, uint32_m* width, uint32_m* height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								XWindowAttributes xwa = MU_ZERO_STRUCT(XWindowAttributes);
								XGetWindowAttributes(c->windows.data[window].display, c->windows.data[window].window, &xwa);

								MU_SET_RESULT(width, xwa.width) MU_SET_RESULT(height, xwa.height)

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_dimensions(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, uint32_m width, uint32_m height, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								MU_ASSERT(c->windows.data[window].resizable, result, MUCOSA_WINDOW_NON_RESIZABLE, 
									MU_RELEASE(c->windows, window, muCOSA_X11Window_) return;
								)
								MU_ASSERT(width >= c->windows.data[window].min_width && width <= c->windows.data[window].max_width &&
									height >= c->windows.data[window].min_height && height <= c->windows.data[window].max_height,
									result, MUCOSA_INVALID_DIMENSIONS, MU_RELEASE(c->windows, window, muCOSA_X11Window_) return;
								)

								XResizeWindow(c->windows.data[window].display, c->windows.data[window].window, width, height);
								void (*dimensions_callback)(muWindow window, uint32_m width, uint32_m height) = c->windows.data[window].dimensions_callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								if (dimensions_callback != MU_NULL_PTR && callback) {
									dimensions_callback(window, width, height);
								}
							}

							muBool muCOSA_X11_window_get_maximized(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_X11Window_)

								muBool maximized = muCOSA_X11_inner_get_maximized(&c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return maximized;
							}

							void muCOSA_X11_window_set_maximized(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muBool maximized, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								muCOSA_X11_inner_set_maximized(&c->windows.data[window], maximized);

								void (*maximize_callback)(muWindow window, muBool maximized) = c->windows.data[window].maximize_callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								if (maximize_callback != MU_NULL_PTR && callback) {
									maximize_callback(window, maximized);
								}
							}

							muBool muCOSA_X11_window_get_minimized(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_X11Window_)

								muBool minimized = muCOSA_X11_inner_get_minimized(&c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return minimized;
							}

							void muCOSA_X11_window_set_minimized(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muBool minimized, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								muCOSA_X11_inner_set_minimized(&c->windows.data[window], minimized);

								void (*minimize_callback)(muWindow window, muBool minimized) = c->windows.data[window].minimize_callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								if (minimize_callback != MU_NULL_PTR && callback) {
									minimize_callback(window, minimized);
								}
							}

							void muCOSA_X11_window_get_minimum_dimensions(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, uint32_m* min_width, uint32_m* min_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								MU_SET_RESULT(min_width, c->windows.data[window].min_width)
								MU_SET_RESULT(min_height, c->windows.data[window].min_height)

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_minimum_dimensions(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, uint32_m min_width, uint32_m min_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].min_width = min_width;
								c->windows.data[window].min_height = min_height;
								muCOSA_X11Window_update_min_max_dim(&c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_get_maximum_dimensions(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, uint32_m* max_width, uint32_m* max_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								MU_SET_RESULT(max_width, c->windows.data[window].max_width)
								MU_SET_RESULT(max_height, c->windows.data[window].max_height)

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_maximum_dimensions(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, uint32_m max_width, uint32_m max_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].max_width = max_width;
								c->windows.data[window].max_height = max_height;
								muCOSA_X11Window_update_min_max_dim(&c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_get_cursor_position(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int32_m* x, int32_m* y) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								// https://stackoverflow.com/questions/3585871/how-can-i-get-the-current-mouse-pointer-position-co-ordinates-in-x
								int screen_count = XScreenCount(c->windows.data[window].display);

								Bool oresult = False;
								int root_x, root_y;
								for (int i = 0; i < screen_count; i++) {
									Window root_window = XRootWindow(c->windows.data[window].display, i);

									Window window_ret, window_chi;
									int win_x, win_y;
									unsigned int mask_return;
									oresult = XQueryPointer(c->windows.data[window].display, root_window, 
										&window_ret, &window_chi, &root_x, &root_y, &win_x, &win_y, &mask_return
									);
									// "window_ret" is the window the cursor is located in
									// "root_x" and "root_y" are cursor pos relative to "window_ret"
									// "win_x" and "win_y" are cursor pos relative to "root_window" (which I'm pretty sure is the whole display)

									if (oresult == True) {
										int wx, wy;
										muCOSA_X11_inner_window_get_position(c->windows.data[window].display, c->windows.data[window].window, c->windows.data[window].parent_window, &wx, &wy);

										// I really don't get how this works, lol...
										MU_SET_RESULT(x, win_x - wx)
										MU_SET_RESULT(y, win_y - wy)

										MU_RELEASE(c->windows, window, muCOSA_X11Window_)
										return;
									}
								}

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								MU_SET_RESULT(result, MUCOSA_NONEXISTENT_DEVICE)
							}

							void muCOSA_X11_window_set_cursor_position(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int32_m x, int32_m y, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								if (callback) {}
								XWarpPointer(c->windows.data[window].display, c->windows.data[window].window, c->windows.data[window].window, 0, 0, 0, 0, x, y);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							muCursorStyle muCOSA_X11_window_get_cursor_style(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_CURSOR_STYLE_UNKNOWN;, muCOSA_X11Window_)

								muCursorStyle style = c->windows.data[window].cursor_style;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return style;
							}

							void muCOSA_X11_window_set_cursor_style(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muCursorStyle style) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								XUndefineCursor(c->windows.data[window].display, c->windows.data[window].window);
								XFreeCursor(c->windows.data[window].display, c->windows.data[window].cursor);

								c->windows.data[window].cursor_style = style;
								c->windows.data[window].cursor = XCreateFontCursor(c->windows.data[window].display, muCOSA_X11_cursor_get_style(c->windows.data[window].cursor_style));
								XDefineCursor(c->windows.data[window].display, c->windows.data[window].window, c->windows.data[window].cursor);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							int32_m muCOSA_X11_window_get_scroll_level(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_X11Window_)

								int32_m scroll_level = c->windows.data[window].scroll_level;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return scroll_level;
							}

							void muCOSA_X11_window_set_scroll_level(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int32_m scroll_level, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								int32_m old_scroll = c->windows.data[window].scroll_level;
								c->windows.data[window].scroll_level = scroll_level;
								void (*scroll_callback)(muWindow window, int32_m scroll_level_add) = c->windows.data[window].scroll_callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								if (scroll_level != old_scroll && scroll_callback != MU_NULL_PTR && callback) {
									scroll_callback(window, scroll_level-old_scroll);
								}
							}

						/* Get / Let */

							void muCOSA_X11_window_get_text_input_focus(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int32_m text_cursor_x, int32_m text_cursor_y, void (*callback)(muWindow window, muByte* input)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								MU_ASSERT(!c->windows.data[window].ic.active, result, MUCOSA_ALREADY_ACTIVE,
									MU_RELEASE(c->windows, window, muCOSA_X11Window_) return;)

								muCOSAResult res = MUCOSA_SUCCESS;
								c->windows.data[window].ic = muCOSA_X11_create_input_context(&res, &c->windows.data[window]);
								if (res != MUCOSA_SUCCESS) {
									MU_SET_RESULT(result, res)
									c->windows.data[window].ic = MU_ZERO_STRUCT(muCOSA_X11_input_context);
									MU_RELEASE(c->windows, window, muCOSA_X11Window_)
									return;
								}
								muCOSA_X11_set_ic_cursor_pos(&c->windows.data[window], text_cursor_x, text_cursor_y);
								c->windows.data[window].text_input_callback = callback;

								// Not necessary to call and usually has weird side effects...
								// muCOSA_X11_get_keyboard_focus(&c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_update_text_cursor(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int32_m x, int32_m y) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								if (c->windows.data[window].ic.active) {
									muCOSA_X11_set_ic_cursor_pos(&c->windows.data[window], x, y);
								}

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_let_text_input_focus(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								MU_ASSERT(c->windows.data[window].ic.active, result, MUCOSA_ALREADY_INACTIVE,
									MU_RELEASE(c->windows, window, muCOSA_X11Window_) return;)

								c->windows.data[window].ic = muCOSA_X11_close_input_context(&c->windows.data[window]);
								c->windows.data[window].text_input_callback = 0;

								//muCOSA_X11_let_keyboard_focus(&c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

						/* Get */

							void muCOSA_X11_window_get_frame_extents(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, uint32_m* left, uint32_m* right, uint32_m* top, uint32_m* bottom) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								long l_left=0, l_right=0, l_top=0, l_bottom=0;
								muCOSA_X11Window_get_extents(&c->windows.data[window], &l_left, &l_right, &l_top, &l_bottom);
								MU_SET_RESULT(left, (uint32_m)l_left)
								MU_SET_RESULT(right, (uint32_m)l_right)
								MU_SET_RESULT(top, (uint32_m)l_top)
								MU_SET_RESULT(bottom, (uint32_m)l_bottom)

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							muButtonState muCOSA_X11_window_get_keyboard_key_state(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muKeyboardKey key) {
								MU_ASSERT(key >= MU_KEYBOARD_KEY_FIRST && key <= MU_KEYBOARD_KEY_LAST, result, MUCOSA_UNKNOWN_KEYBOARD_KEY, return 0;)

								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_X11Window_)

								muButtonState state = c->windows.data[window].input.keyboard_key_states[key-MU_KEYBOARD_KEY_FIRST];

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return state;
							}

							muState muCOSA_X11_window_get_keyboard_state_state(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muKeyboardState state) {
								MU_ASSERT(state >= MU_KEYBOARD_STATE_FIRST && state <= MU_KEYBOARD_STATE_LAST, result, MUCOSA_UNKNOWN_KEYBOARD_STATE, return 0;)

								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_X11Window_)

								muState ret_state = c->windows.data[window].input.keyboard_state_states[state-MU_KEYBOARD_STATE_FIRST];

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return ret_state;
							}

							muButtonState muCOSA_X11_window_get_mouse_button_state(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muMouseButton button) {
								MU_ASSERT(button >= MU_MOUSE_BUTTON_FIRST && button <= MU_MOUSE_BUTTON_LAST, result, MUCOSA_UNKNOWN_MOUSE_BUTTON, return 0;)

								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_X11Window_)

								muButtonState state = c->windows.data[window].input.mouse_button_states[button-MU_MOUSE_BUTTON_FIRST];

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)

								return state;
							}

						/* Set */

							void muCOSA_X11_window_set_title(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muByte* title) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								XChangeProperty(c->windows.data[window].display, c->windows.data[window].window,
									XInternAtom(c->windows.data[window].display, "_NET_WM_NAME", False),
									XInternAtom(c->windows.data[window].display, "UTF8_STRING", False),
									8, PropModeReplace, (unsigned char*)title, (int)mu_strlen((const char*)title)
								);

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_dimensions_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, uint32_m width, uint32_m height)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].dimensions_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_position_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, int32_m x, int32_m y)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].position_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_focus_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, muBool focused)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].focus_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_maximize_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, muBool maximized)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].maximize_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_minimize_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, muBool minimized)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].minimize_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_keyboard_key_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, muKeyboardKey keyboard_key, muButtonState state)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].keyboard_key_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_keyboard_state_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, muKeyboardState keyboard_state, muState state)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].keyboard_state_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

							void muCOSA_X11_window_set_mouse_button_callback(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void (*callback)(muWindow window, muMouseButton mouse_button, muButtonState state)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								c->windows.data[window].mouse_button_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							}

					/* Time */

						double muCOSA_X11_time_get(muCOSAResult* result, muCOSA_X11Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							return muCOSA_X11_inner_get_time() - c->original_time;
						}

						void muCOSA_X11_time_set(muCOSAResult* result, muCOSA_X11Context* c, double time) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							c->original_time = c->original_time + (muCOSA_X11_inner_get_time() - c->original_time) - time;
						}

						void muCOSA_X11_sleep(muCOSAResult* result, muCOSA_X11Context* c, double time) {
							if (c) {}
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							MU_ASSERT(time >= 0.f, result, MUCOSA_INVALID_TIME, return;)

							// https://stackoverflow.com/a/1157217

							struct timespec ts;
							ts.tv_sec = (time_t)time;
							ts.tv_nsec = (long)(time * (double)1e+9);

							mu_fflush(mu_stdout);
							int n = nanosleep(&ts, NULL);

							// Dunno about you guys, but nanosleep literally just doesn't work on my
							// system. Literally, it always returns -1, I have never gotten it to work.
							if (n != 0) {
								sleep((unsigned)time);
							}
						}

					/* Clipboard */

						// https://www.uninformativ.de/blog/postings/2017-04-02/0/POSTING-en.html
						muByte* muCOSA_X11_clipboard_get(muCOSAResult* result, muCOSA_X11Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							Display* d = 0;
							Window w;

							for (size_m i = 0; i < c->windows.length; i++) {
								if (c->windows.data[i].active) {
									d = c->windows.data[i].display;
									w = c->windows.data[i].window;
								}
							}

							muBool created = MU_FALSE;
							if (d == 0) {
								created = MU_TRUE;
								d = XOpenDisplay(NULL);
								w = XCreateSimpleWindow(d, RootWindow(d, DefaultScreen(d)), -10, -10, 1, 1, 0, 0, 0);
							}

							Atom sel = XInternAtom(d, "CLIPBOARD", False);
							Window owner = XGetSelectionOwner(d, sel);
							if (owner == None) {
								return 0;
							}

							// ?
							Atom p = XInternAtom(d, "PENGUIN", False);
							XConvertSelection(d, sel, XInternAtom(d, "UTF8_STRING", False), p, w, CurrentTime);

							XEvent ev;
							muBool got_notify = MU_FALSE;
							muByte* data = 0;
							while (!got_notify) {
								XNextEvent(d, &ev);
								switch (ev.type) {
									default: break;

									case SelectionNotify: {
										got_notify = MU_TRUE;
										XSelectionEvent* sev = (XSelectionEvent*)&ev.xselection;
										if (sev->property == None) {
											return 0;
										} else {
											Atom type;
											int di;
											unsigned long dul, size;
											unsigned char* prop_ret = 0;
											XGetWindowProperty(d, w, p, 0, 0, False, AnyPropertyType, &type, &di, &dul, &size, &prop_ret);
											XFree(prop_ret);

											if (type == XInternAtom(d, "INCR", False)) {
												MU_SET_RESULT(result, MUCOSA_OVERSIZED_CLIPBOARD)
												return 0;
											}
											if (size == 0) {
												return 0;
											}

											Atom da;
											XGetWindowProperty(d, w, p, 0, size, False, AnyPropertyType, &da, &di, &dul, &dul, &prop_ret);
											XDeleteProperty(d, w, p);
											data = (muByte*)prop_ret;
										}
									} break;
								}
							}

							if (created) {
								XCloseDisplay(d);
							}
							return data;
						}

						void muCOSA_X11_clipboard_set(muCOSAResult* result, muCOSA_X11Context* c, muByte* text, size_m text_size) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							if (c->clipboard_thread_running) {
								c->clipboard_thread_running = MU_FALSE;
								MU_ASSERT(pthread_join(c->clipboard_thread, NULL) == 0, result, MUCOSA_FAILED_JOIN_THREAD, return;)
								if (c->clipboard_text) {
									mu_free(c->clipboard_text);
								}
							}

							c->clipboard_text = 0;
							if (text_size > 0) {
								c->clipboard_text = (muByte*)mu_malloc(text_size);
								MU_ASSERT(c->clipboard_text != 0, result, MUCOSA_ALLOCATION_FAILED, return;)
							}
							c->clipboard_size = text_size;
							mu_memcpy(c->clipboard_text, text, text_size);

							c->clipboard_thread_running = MU_TRUE;
							MU_ASSERT(pthread_create(&c->clipboard_thread, NULL, muCOSA_X11_inner_clipboard_set, (void*)c) == 0,
								result, MUCOSA_FAILED_CREATE_THREAD, return;)
						}

					/* OS functions */

						void* muCOSA_X11_os_get_window_handle(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, muWindowHandle handle) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_NULL_PTR;, muCOSA_X11Window_)

							void* ret = MU_NULL_PTR;
							switch (handle) {
								default: MU_SET_RESULT(result, MUCOSA_UNKNOWN_WINDOW_HANDLE) break;
								case MU_X11_DISPLAY: ret = &c->windows.data[window].display; break;
								case MU_X11_WINDOW: ret = &c->windows.data[window].window; break;
								case MU_X11_PARENT_WINDOW: ret = &c->windows.data[window].parent_window; break;
							}

							MU_RELEASE(c->windows, window, muCOSA_X11Window_)

							return ret;
						}

					/* OpenGL */

						void muCOSA_X11_opengl_bind_window(muCOSAResult* result, muCOSA_X11Context* c, muWindow window) {
							#ifndef MUCOSA_OPENGL
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
								return;
							#endif
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

							if (c->windows.data[window].api >= MUCOSA_OPENGL_FIRST && c->windows.data[window].api <= MUCOSA_OPENGL_LAST) {
								MUCOSA_OPENGL_CALL(
									glXMakeCurrent(c->windows.data[window].display, c->windows.data[window].window, c->windows.data[window].gl_context);
								)
							}

							MU_RELEASE(c->windows, window, muCOSA_X11Window_)
						}

						void* muCOSA_X11_opengl_get_function_address(const muByte* name) {
							MUCOSA_OPENGL_CALL(
								void(*addr)() = glXGetProcAddress((const GLubyte*)name);
								void* ret = 0;
								mu_memcpy(&ret, &addr, sizeof(void*));
								return ret;
							)
							if (name) {}
							return 0;
						}

						void muCOSA_X11_opengl_window_swap_interval(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, int interval) {
							#ifndef MUCOSA_OPENGL
								if (window) {} if (interval) {} if (c) {}
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
							#else
								void* ptr = muCOSA_X11_opengl_get_function_address((const muByte*)"glXSwapIntervalEXT");
								MU_ASSERT(ptr != 0, result, MUCOSA_UNSUPPORTED_OPENGL_FEATURE, return;)
								GLXDrawable drawable = glXGetCurrentDrawable();

								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								if (drawable) {
									PFNGLXSWAPINTERVALEXTPROC proc = 0;
									mu_memcpy(&proc, &ptr, sizeof(void*));
									proc(c->windows.data[window].display, drawable, interval);
								} else {
									MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_OPENGL_FEATURE)
								}

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							#endif
						}

					/* Vulkan */

						const char** muCOSA_X11_vulkan_get_surface_instance_extensions(muCOSAResult* result, size_m* count) {
							#ifndef MUCOSA_VULKAN
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
								if (count) {}
								return 0;
							#else
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								static const char* exts[] = { "VK_KHR_surface", "VK_KHR_xlib_surface" };
								MU_SET_RESULT(count, 2)
								return (const char**)exts;
							#endif
						}

						void muCOSA_X11_vulkan_create_window_surface(muCOSAResult* result, muCOSA_X11Context* c, muWindow window, void* vk_result, void* instance, void* allocator, void* surface) {
							#ifndef MUCOSA_VULKAN
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
								if (c) {} if (window) {} if (vk_result) {} if (instance) {} if (allocator) {} if (surface) {}
							#else
								MU_SET_RESULT(result, MUCOSA_SUCCESS)

								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_X11Window_)

								VkXlibSurfaceCreateInfoKHR create_info = MU_ZERO_STRUCT(VkXlibSurfaceCreateInfoKHR);
								create_info.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
								create_info.dpy = c->windows.data[window].display;
								create_info.window = c->windows.data[window].window;

								VkInstance r_instance = VK_NULL_HANDLE;
								if (instance != 0) {
									r_instance = *((VkInstance*)instance);
								}

								VkResult vkres = vkCreateXlibSurfaceKHR(r_instance, &create_info, (const VkAllocationCallbacks*)allocator, (VkSurfaceKHR*)surface);
								if (vk_result != MU_NULL_PTR) {
									*((VkResult*)vk_result) = vkres;
								}

								MU_RELEASE(c->windows, window, muCOSA_X11Window_)
							#endif
						}

			#else
				#define MUCOSA_X11_CALL(...)
			#endif  /* MUCOSA_X11 */

			/* Win32 implementation */

			#ifdef MUCOSA_WIN32
				#define MUCOSA_WIN32_CALL(...) __VA_ARGS__

				#include <windows.h> // For all of the stuff that can't be included directly (CURSE YOU BILL)
				#include <WinDef.h> // For basic types
				#include <winuser.h> // For virtually everything window related (requires linkage with user32.lib I think)
				#include <imm.h> // For IMM usage (requires linkage with imm32.lib)
				#include <sysinfoapi.h> // For GetSystemTimeAsFileTime
				#include <synchapi.h> // For Sleep
				#include <stringapiset.h> // For Win32 string conversion functions
				#include <winbase.h> // For global memory functions

				/* Misc useful functions */

					EXTERN_C IMAGE_DOS_HEADER __ImageBase;
					HINSTANCE muCOSA_innerWin32_get_hinstance(void) {
						return ((HINSTANCE)&__ImageBase);
					}

				/* OpenGL */

				#ifdef MUCOSA_OPENGL

					#ifndef MUCOSA_NO_INCLUDE_OPENGL
						#ifndef glClearColor
							#include <gl/gl.h>
							#include <gl/glu.h>
						#endif
					#endif

					#include <wingdi.h>

					typedef HGLRC WINAPI wglCreateContextAttribsARB_type(HDC hdc, HGLRC hShareContext, const int* attribList);
					typedef BOOL WINAPI wglChoosePixelFormatARB_type(HDC hdc, const int* piAttribIList, const FLOAT* pfAttribFList, UINT nMaxFormats, int* piFormats, UINT* nNumFormats);

					struct muCOSA_Win32WGL_SwapInterval {
						MU_LOCK
						BOOL (*wglSwapIntervalEXT)(int interval);
					};
					typedef struct muCOSA_Win32WGL_SwapInterval muCOSA_Win32WGL_SwapInterval;

					struct muCOSA_Win32WGL {
						MU_LOCK
						wglCreateContextAttribsARB_type* wglCreateContextAttribsARB;
						wglChoosePixelFormatARB_type* wglChoosePixelFormatARB;
						muCOSA_Win32WGL_SwapInterval si;
					};
					typedef struct muCOSA_Win32WGL muCOSA_Win32WGL;

					muCOSA_Win32WGL muCOSA_Win32WGL_init(void) {
						muCOSA_Win32WGL wwgl = MU_ZERO_STRUCT(muCOSA_Win32WGL);
						MU_LOCK_CREATE(wwgl.lock, wwgl.lock_active)
						MU_LOCK_CREATE(wwgl.si.lock, wwgl.si.lock_active)
						return wwgl;
					}
					void muCOSA_Win32WGL_term(muCOSA_Win32WGL wwgl) {
						if (wwgl.si.wglSwapIntervalEXT) {}
						MU_LOCK_DESTROY(wwgl.lock, wwgl.lock_active)
						MU_LOCK_DESTROY(wwgl.si.lock, wwgl.si.lock_active)
					}

					/* WGL tokens */
						// @TODO Remove the ones we're not using

						// https://registry.khronos.org/OpenGL/extensions/ARB/WGL_ARB_create_context.txt

						#define WGL_CONTEXT_MAJOR_VERSION_ARB             0x2091
						#define WGL_CONTEXT_MINOR_VERSION_ARB             0x2092
						#define WGL_CONTEXT_LAYER_PLANE_ARB               0x2093
						#define WGL_CONTEXT_FLAGS_ARB                     0x2094
						#define WGL_CONTEXT_PROFILE_MASK_ARB              0x9126

						#define WGL_CONTEXT_DEBUG_BIT_ARB                 0x0001
						#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB    0x0002

						#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB          0x00000001
						#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002

						#define ERROR_INVALID_VERSION_ARB                 0x2095
						#define ERROR_INVALID_PROFILE_ARB                 0x2096

						// https://registry.khronos.org/OpenGL/extensions/ARB/WGL_ARB_pixel_format.txt

						#define WGL_NUMBER_PIXEL_FORMATS_ARB    0x2000
						#define WGL_DRAW_TO_WINDOW_ARB          0x2001
						#define WGL_DRAW_TO_BITMAP_ARB          0x2002
						#define WGL_ACCELERATION_ARB            0x2003
						#define WGL_NEED_PALETTE_ARB            0x2004
						#define WGL_NEED_SYSTEM_PALETTE_ARB     0x2005
						#define WGL_SWAP_LAYER_BUFFERS_ARB      0x2006
						#define WGL_SWAP_METHOD_ARB             0x2007
						#define WGL_NUMBER_OVERLAYS_ARB         0x2008
						#define WGL_NUMBER_UNDERLAYS_ARB        0x2009
						#define WGL_TRANSPARENT_ARB             0x200A
						#define WGL_TRANSPARENT_RED_VALUE_ARB   0x2037
						#define WGL_TRANSPARENT_GREEN_VALUE_ARB 0x2038
						#define WGL_TRANSPARENT_BLUE_VALUE_ARB  0x2039
						#define WGL_TRANSPARENT_ALPHA_VALUE_ARB 0x203A
						#define WGL_TRANSPARENT_INDEX_VALUE_ARB 0x203B
						#define WGL_SHARE_DEPTH_ARB             0x200C
						#define WGL_SHARE_STENCIL_ARB           0x200D
						#define WGL_SHARE_ACCUM_ARB             0x200E
						#define WGL_SUPPORT_GDI_ARB             0x200F
						#define WGL_SUPPORT_OPENGL_ARB          0x2010
						#define WGL_DOUBLE_BUFFER_ARB           0x2011
						#define WGL_STEREO_ARB                  0x2012
						#define WGL_PIXEL_TYPE_ARB              0x2013
						#define WGL_COLOR_BITS_ARB              0x2014
						#define WGL_RED_BITS_ARB                0x2015
						#define WGL_RED_SHIFT_ARB               0x2016
						#define WGL_GREEN_BITS_ARB              0x2017
						#define WGL_GREEN_SHIFT_ARB             0x2018
						#define WGL_BLUE_BITS_ARB               0x2019
						#define WGL_BLUE_SHIFT_ARB              0x201A
						#define WGL_ALPHA_BITS_ARB              0x201B
						#define WGL_ALPHA_SHIFT_ARB             0x201C
						#define WGL_ACCUM_BITS_ARB              0x201D
						#define WGL_ACCUM_RED_BITS_ARB          0x201E
						#define WGL_ACCUM_GREEN_BITS_ARB        0x201F
						#define WGL_ACCUM_BLUE_BITS_ARB         0x2020
						#define WGL_ACCUM_ALPHA_BITS_ARB        0x2021
						#define WGL_DEPTH_BITS_ARB              0x2022
						#define WGL_STENCIL_BITS_ARB            0x2023
						#define WGL_AUX_BUFFERS_ARB             0x2024

						#define WGL_NO_ACCELERATION_ARB         0x2025
						#define WGL_GENERIC_ACCELERATION_ARB    0x2026
						#define WGL_FULL_ACCELERATION_ARB       0x2027

						#define WGL_SWAP_EXCHANGE_ARB           0x2028
						#define WGL_SWAP_COPY_ARB               0x2029
						#define WGL_SWAP_UNDEFINED_ARB          0x202A

						#define WGL_TYPE_RGBA_ARB               0x202B
						#define WGL_TYPE_COLORINDEX_ARB         0x202C

						// https://nehe.gamedev.net/tutorial/fullscreen_antialiasing/16008/

						#define WGL_SAMPLE_BUFFERS_ARB  0x2041
						#define WGL_SAMPLES_ARB     0x2042

					/* Functions */

						// https://gist.github.com/nickrolfe/1127313ed1dbf80254b614a721b3ee9c

						muCOSAResult muCOSA_Win32_init_opengl_extensions(muCOSA_Win32WGL* p_wgl) {
							WNDCLASSA wclass = MU_ZERO_STRUCT(WNDCLASSA);
							wclass.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
							wclass.lpfnWndProc = DefWindowProcA;
							wclass.hInstance = muCOSA_innerWin32_get_hinstance();
							wclass.lpszClassName = "Dummy WGL window class";

							if (!RegisterClassA(&wclass)) {
								return MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS;
							}

							HWND win = CreateWindowExA(
								0, wclass.lpszClassName, "Dummy WGL window",
								0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 0,
								0, wclass.hInstance, 0
							);
							if (!win) {
								UnregisterClassA(wclass.lpszClassName, wclass.hInstance);
								return MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW;
							}

							HDC dc = GetDC(win);

							// Note: this pixel format NEEDS to be chosen to make this function work. In
							// particular, the call to wglCreateContext fails if we don't. The choice of
							// which pixel format is arbitrary.

							PIXELFORMATDESCRIPTOR format = MU_ZERO_STRUCT(PIXELFORMATDESCRIPTOR);
							format.nSize = sizeof(PIXELFORMATDESCRIPTOR);
							format.nVersion = 1;
							format.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
							format.iPixelType = PFD_TYPE_RGBA;
							format.cColorBits = 32;
							format.cAlphaBits = 8;
							format.cDepthBits = 24;
							format.cStencilBits = 8;
							format.iLayerType = PFD_MAIN_PLANE;

							// Doing no error checking here in case the ATTEMPT of setting one allows
							// wglCreateContext to pass...
							int pixel_format = ChoosePixelFormat(dc, &format);
							SetPixelFormat(dc, pixel_format, &format);

							HGLRC context = wglCreateContext(dc);
							if (!context) {
								ReleaseDC(win, dc);
								DestroyWindow(win);
								UnregisterClassA(wclass.lpszClassName, wclass.hInstance);
								return MUCOSA_FAILED_CREATE_OPENGL_CONTEXT;
							}
							if (!wglMakeCurrent(dc, context)) {
								wglDeleteContext(context);
								ReleaseDC(win, dc);
								DestroyWindow(win);
								UnregisterClassA(wclass.lpszClassName, wclass.hInstance);
								return MUCOSA_FAILED_LOAD_OPENGL_CONTEXT;
							}

							PROC wglCreateContextAttribsARB_proc = wglGetProcAddress("wglCreateContextAttribsARB");
							mu_memcpy(&p_wgl->wglCreateContextAttribsARB, &wglCreateContextAttribsARB_proc, sizeof(PROC));
							PROC wglChoosePixelFormatARB_proc = wglGetProcAddress("wglChoosePixelFormatARB");
							mu_memcpy(&p_wgl->wglChoosePixelFormatARB, &wglChoosePixelFormatARB_proc, sizeof(PROC));

							wglMakeCurrent(dc, 0);
							wglDeleteContext(context);
							ReleaseDC(win, dc);
							DestroyWindow(win);
							UnregisterClassA(wclass.lpszClassName, wclass.hInstance);

							if (p_wgl->wglCreateContextAttribsARB == 0 || p_wgl->wglChoosePixelFormatARB == 0) {
								return MUCOSA_UNSUPPORTED_OPENGL_FEATURE;
							}

							return MUCOSA_SUCCESS;
						}

						muCOSAResult muCOSA_Win32_create_opengl_context(HDC dc, muCOSA_Win32WGL* p_wgl, muPixelFormat pf, HGLRC* p_context, muGraphicsAPI api) {
							int pixel_format_attributes[] = {
								WGL_DRAW_TO_WINDOW_ARB, MU_TRUE,
								WGL_SUPPORT_OPENGL_ARB, MU_TRUE,
								WGL_DOUBLE_BUFFER_ARB,  MU_TRUE,
								WGL_SAMPLE_BUFFERS_ARB, MU_TRUE, // ?
								WGL_ACCELERATION_ARB,   WGL_FULL_ACCELERATION_ARB, // ?
								WGL_PIXEL_TYPE_ARB,     WGL_TYPE_RGBA_ARB,
								WGL_RED_BITS_ARB,       pf.red_bits,
								WGL_GREEN_BITS_ARB,     pf.green_bits,
								WGL_BLUE_BITS_ARB,      pf.blue_bits,
								WGL_ALPHA_BITS_ARB,     pf.alpha_bits,
								WGL_DEPTH_BITS_ARB,     pf.depth_bits,
								WGL_STENCIL_BITS_ARB,   pf.stencil_bits,
								WGL_SAMPLES_ARB,        pf.samples,
								0
							};

							int pixel_format;
							UINT format_count;
							p_wgl->wglChoosePixelFormatARB(dc, pixel_format_attributes, 0, 1, &pixel_format, &format_count);
							if (!format_count) {
								return MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT;
							}

							PIXELFORMATDESCRIPTOR format;
							if (DescribePixelFormat(dc, pixel_format, sizeof(PIXELFORMATDESCRIPTOR), &format) == 0) {
								return MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT;
							}

							if (!SetPixelFormat(dc, pixel_format, &format)) {
								return MUCOSA_FAILED_SET_PIXEL_FORMAT;
							}

							int opengl_attributes[] = {
								WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
								WGL_CONTEXT_MINOR_VERSION_ARB, 3,
								WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
								0
							};

							switch (api) {
								default: return MUCOSA_UNKNOWN_GRAPHICS_API; break;
								case MU_OPENGL_1_0:   { opengl_attributes[1] = 1; opengl_attributes[3] = 0; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_1_1:   { opengl_attributes[1] = 1; opengl_attributes[3] = 1; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_1_2:   { opengl_attributes[1] = 1; opengl_attributes[3] = 2; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								// No idea what to do here lmao
								case MU_OPENGL_1_2_1: { opengl_attributes[1] = 1; opengl_attributes[3] = 2; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_1_3:   { opengl_attributes[1] = 1; opengl_attributes[3] = 3; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_1_4:   { opengl_attributes[1] = 1; opengl_attributes[3] = 4; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_1_5:   { opengl_attributes[1] = 1; opengl_attributes[3] = 5; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_2_0:   { opengl_attributes[1] = 2; opengl_attributes[3] = 0; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_2_1:   { opengl_attributes[1] = 2; opengl_attributes[3] = 1; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_3_0:   { opengl_attributes[1] = 3; opengl_attributes[3] = 0; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_3_1:   { opengl_attributes[1] = 3; opengl_attributes[3] = 1; opengl_attributes[4] = 0; opengl_attributes[5] = 0; } break;
								case MU_OPENGL_3_2_CORE:          { opengl_attributes[1] = 3; opengl_attributes[3] = 2; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_3_2_COMPATIBILITY: { opengl_attributes[1] = 3; opengl_attributes[3] = 2; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_3_3_CORE:          { opengl_attributes[1] = 3; opengl_attributes[3] = 3; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_3_3_COMPATIBILITY: { opengl_attributes[1] = 3; opengl_attributes[3] = 3; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_0_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 0; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_0_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 0; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_1_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 1; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_1_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 1; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_2_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 2; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_2_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 2; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_3_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 3; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_3_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 3; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_4_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 4; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_4_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 4; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_5_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 5; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_5_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 5; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_6_CORE:          { opengl_attributes[1] = 4; opengl_attributes[3] = 6; opengl_attributes[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; } break;
								case MU_OPENGL_4_6_COMPATIBILITY: { opengl_attributes[1] = 4; opengl_attributes[3] = 6; opengl_attributes[5] = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB; } break;
							}

							*p_context = p_wgl->wglCreateContextAttribsARB(dc, 0, opengl_attributes);
							if (!*p_context) {
								return MUCOSA_FAILED_CREATE_OPENGL_CONTEXT;
							}
							if (!wglMakeCurrent(dc, *p_context)) {
								return MUCOSA_FAILED_LOAD_OPENGL_CONTEXT;
							}

							return MUCOSA_SUCCESS;
						}

				#endif

				/* Structs */

					struct muCOSA_Win32Input {
						muButtonState keyboard_key_states[MU_KEYBOARD_KEY_LAST-MU_KEYBOARD_KEY_FIRST+1];
						muState keyboard_state_states[MU_KEYBOARD_STATE_LAST-MU_KEYBOARD_STATE_FIRST+1];
						muButtonState mouse_button_states[MU_MOUSE_BUTTON_LAST-MU_MOUSE_BUTTON_FIRST+1];
					};
					typedef struct muCOSA_Win32Input muCOSA_Win32Input;

					struct muCOSA_Win32Window {
						muBool active;
						MU_LOCK

						wchar_t wclass_name[2];
						HWND hwnd;
						HINSTANCE hinstance;
						HDC dc;

						muGraphicsAPI api;
						MUCOSA_OPENGL_CALL(
							HGLRC glrc;
						)

						muCOSA_Win32Input input;
						void (*text_input_callback)(muWindow window, muByte* input);
						int32_m text_cursor_x;
						int32_m text_cursor_y;

						muBool closed;
						muBool visible;
						muBool maximized;
						muBool minimized;

						uint32_m min_width;
						uint32_m min_height;
						uint32_m max_width;
						uint32_m max_height;

						muCursorStyle cursor_style;
						HCURSOR cursor;
						int32_m scroll_level;
						int32_m cx, cy;

						void (*dimensions_callback)(muWindow window, uint32_m width, uint32_m height);
						void (*position_callback)(muWindow window, int32_m x, int32_m y);
						void (*focus_callback)(muWindow window, muBool focused);
						void (*maximize_callback)(muWindow window, muBool maximized);
						void (*minimize_callback)(muWindow window, muBool minimized);

						void (*keyboard_key_callback)(muWindow window, muKeyboardKey keyboard_key, muButtonState state);
						void (*keyboard_state_callback)(muWindow window, muKeyboardState keyboard_state, muState state);

						void (*cursor_position_callback)(muWindow window, int32_m x, int32_m y);
						void (*mouse_button_callback)(muWindow window, muMouseButton mouse_button, muButtonState state);
						void (*scroll_callback)(muWindow window, int32_m scroll_level_add);
					};
					typedef struct muCOSA_Win32Window muCOSA_Win32Window;

					MU_HRARRAY_DEFAULT_FUNC(muCOSA_Win32Window)

					struct muCOSA_Win32Time {
						MU_LOCK
						double orig_time;
					};
					typedef struct muCOSA_Win32Time muCOSA_Win32Time;

					double muCOSA_innerWin32_get_current_time(void);
					muCOSA_Win32Time muCOSA_Win32Time_init(void) {
						muCOSA_Win32Time time = MU_ZERO_STRUCT(muCOSA_Win32Time);

						MU_LOCK_CREATE(time.lock, time.lock_active)

						time.orig_time = muCOSA_innerWin32_get_current_time();

						return time;
					}

					void muCOSA_Win32Time_term(muCOSA_Win32Time time) {
						if (time.orig_time) {}
						MU_LOCK_DESTROY(time.lock, time.lock_active)
					}

					struct muCOSA_Win32Context {
						muCOSA_Win32Window_array windows;

						MUCOSA_OPENGL_CALL(muCOSA_Win32WGL wgl;)

						muCOSA_Win32Time time;
					};
					typedef struct muCOSA_Win32Context muCOSA_Win32Context;

					muCOSA_Win32Context* muCOSA_Win32Context_get(void);

					muCOSA_Win32Context muCOSA_Win32Context_init(void) {
						muCOSA_Win32Context context = MU_ZERO_STRUCT(muCOSA_Win32Context);
						return context;
					}

				/* Inner functions */

					/* Strings cuz Microsoft sucks */

						wchar_t* muCOSA_innerWin32_utf8_to_wchar(muByte* str) {
							// Note: we can use -1 here, since it's expected for it to be null-terminated.
							int len = MultiByteToWideChar(CP_UTF8, 0, (const char*)str, -1, NULL, 0);
							if (len == 0) {
								return 0;
							}

							wchar_t* wstr = (wchar_t*)mu_malloc(len * sizeof(wchar_t));
							if (wstr == 0) {
								return 0;
							}

							if (MultiByteToWideChar(CP_UTF8, 0, (const char*)str, -1, (LPWSTR)wstr, len) == 0) {
								mu_free(wstr);
								return 0;
							}

							return wstr;
						}

						muByte* muCOSA_innerWin32_wchar_to_utf8(wchar_t* wstr) {
							// Note: we don't need length here, either. This function is only intended to
							// be called with null-terminated wchar_t strings; for example, in the
							// clipboard get function, the format "CF_UNICODETEXT" is specified, and,
							// according to the docs: "A null character signals the end of the data."
							int len = WideCharToMultiByte(CP_UTF8, 0, wstr, -1, NULL, 0, NULL, NULL);
							if (len == 0) {
								return 0;
							}

							muByte* str = (muByte*)mu_malloc(len);
							if (str == 0) {
								return 0;
							}

							if (WideCharToMultiByte(CP_UTF8, 0, wstr, -1, (LPSTR)str, len, NULL, NULL) == 0) {
								mu_free(str);
								return 0;
							}

							return str;
						}

					/* Input handling */

						void muCOSA_innerWin32_possible_input_flushing(muCOSA_Win32Window* p_win) {
							if (GetFocus() != p_win->hwnd) {
								p_win->input = MU_ZERO_STRUCT(muCOSA_Win32Input);
							}
						}

						/* Keyboard key */

							// https://stackoverflow.com/questions/15966642/how-do-you-tell-lshift-apart-from-rshift-in-wm-keydown-events
							// RIP Bill Gates, he would've loved this API
							WPARAM muCOSA_innerWin32_map_left_right_keys(WPARAM vk, LPARAM lParam) {
								UINT scancode = (lParam & 0x00ff0000) >> 16;
								int extended  = (lParam & 0x01000000) != 0;

								switch (vk) {
									default: return vk; break;
									case VK_SHIFT: return MapVirtualKey(scancode, MAPVK_VSC_TO_VK_EX); break;
									case VK_CONTROL: return extended ? VK_RCONTROL : VK_LCONTROL; break;
									case VK_MENU: return extended ? VK_RMENU : VK_LMENU; break;
								}
							}

							muKeyboardKey muCOSA_Win32_key_to_keyboard_key(int key) {
								switch (key) {
									default: return MU_KEYBOARD_KEY_UNKNOWN; break;
									case VK_BACK: return MU_KEYBOARD_KEY_BACKSPACE; break;
									case VK_TAB: return MU_KEYBOARD_KEY_TAB; break;
									case VK_CLEAR: return MU_KEYBOARD_KEY_CLEAR; break;
									case VK_RETURN: return MU_KEYBOARD_KEY_RETURN; break;
									case VK_PAUSE: return MU_KEYBOARD_KEY_PAUSE; break;
									case VK_ESCAPE: return MU_KEYBOARD_KEY_ESCAPE; break;
									case VK_MODECHANGE: return MU_KEYBOARD_KEY_MODECHANGE; break;
									case VK_SPACE: return MU_KEYBOARD_KEY_SPACE; break;
									case VK_PRIOR: return MU_KEYBOARD_KEY_PRIOR; break;
									case VK_NEXT: return MU_KEYBOARD_KEY_NEXT; break;
									case VK_END: return MU_KEYBOARD_KEY_END; break;
									case VK_HOME: return MU_KEYBOARD_KEY_HOME; break;
									case VK_LEFT: return MU_KEYBOARD_KEY_LEFT; break;
									case VK_UP: return MU_KEYBOARD_KEY_UP; break;
									case VK_RIGHT: return MU_KEYBOARD_KEY_RIGHT; break;
									case VK_DOWN: return MU_KEYBOARD_KEY_DOWN; break;
									case VK_SELECT: return MU_KEYBOARD_KEY_SELECT; break;
									case VK_PRINT: return MU_KEYBOARD_KEY_PRINT; break;
									case VK_EXECUTE: return MU_KEYBOARD_KEY_EXECUTE; break;
									case VK_INSERT: return MU_KEYBOARD_KEY_INSERT; break;
									case VK_DELETE: return MU_KEYBOARD_KEY_DELETE; break;
									case VK_HELP: return MU_KEYBOARD_KEY_HELP; break;
									case 0x30: return MU_KEYBOARD_KEY_0; break;
									case 0x31: return MU_KEYBOARD_KEY_1; break;
									case 0x32: return MU_KEYBOARD_KEY_2; break;
									case 0x33: return MU_KEYBOARD_KEY_3; break;
									case 0x34: return MU_KEYBOARD_KEY_4; break;
									case 0x35: return MU_KEYBOARD_KEY_5; break;
									case 0x36: return MU_KEYBOARD_KEY_6; break;
									case 0x37: return MU_KEYBOARD_KEY_7; break;
									case 0x38: return MU_KEYBOARD_KEY_8; break;
									case 0x39: return MU_KEYBOARD_KEY_9; break;
									case 0x41: return MU_KEYBOARD_KEY_A; break;
									case 0x42: return MU_KEYBOARD_KEY_B; break;
									case 0x43: return MU_KEYBOARD_KEY_C; break;
									case 0x44: return MU_KEYBOARD_KEY_D; break;
									case 0x45: return MU_KEYBOARD_KEY_E; break;
									case 0x46: return MU_KEYBOARD_KEY_F; break;
									case 0x47: return MU_KEYBOARD_KEY_G; break;
									case 0x48: return MU_KEYBOARD_KEY_H; break;
									case 0x49: return MU_KEYBOARD_KEY_I; break;
									case 0x4A: return MU_KEYBOARD_KEY_J; break;
									case 0x4B: return MU_KEYBOARD_KEY_K; break;
									case 0x4C: return MU_KEYBOARD_KEY_L; break;
									case 0x4D: return MU_KEYBOARD_KEY_M; break;
									case 0x4E: return MU_KEYBOARD_KEY_N; break;
									case 0x4F: return MU_KEYBOARD_KEY_O; break;
									case 0x50: return MU_KEYBOARD_KEY_P; break;
									case 0x51: return MU_KEYBOARD_KEY_Q; break;
									case 0x52: return MU_KEYBOARD_KEY_R; break;
									case 0x53: return MU_KEYBOARD_KEY_S; break;
									case 0x54: return MU_KEYBOARD_KEY_T; break;
									case 0x55: return MU_KEYBOARD_KEY_U; break;
									case 0x56: return MU_KEYBOARD_KEY_V; break;
									case 0x57: return MU_KEYBOARD_KEY_W; break;
									case 0x58: return MU_KEYBOARD_KEY_X; break;
									case 0x59: return MU_KEYBOARD_KEY_Y; break;
									case 0x5A: return MU_KEYBOARD_KEY_Z; break;
									case VK_LWIN: return MU_KEYBOARD_KEY_LEFT_WINDOWS; break;
									case VK_RWIN: return MU_KEYBOARD_KEY_RIGHT_WINDOWS; break;
									case VK_NUMPAD0: return MU_KEYBOARD_KEY_NUMPAD_0; break;
									case VK_NUMPAD1: return MU_KEYBOARD_KEY_NUMPAD_1; break;
									case VK_NUMPAD2: return MU_KEYBOARD_KEY_NUMPAD_2; break;
									case VK_NUMPAD3: return MU_KEYBOARD_KEY_NUMPAD_3; break;
									case VK_NUMPAD4: return MU_KEYBOARD_KEY_NUMPAD_4; break;
									case VK_NUMPAD5: return MU_KEYBOARD_KEY_NUMPAD_5; break;
									case VK_NUMPAD6: return MU_KEYBOARD_KEY_NUMPAD_6; break;
									case VK_NUMPAD7: return MU_KEYBOARD_KEY_NUMPAD_7; break;
									case VK_NUMPAD8: return MU_KEYBOARD_KEY_NUMPAD_8; break;
									case VK_NUMPAD9: return MU_KEYBOARD_KEY_NUMPAD_9; break;
									case VK_MULTIPLY: return MU_KEYBOARD_KEY_MULTIPLY; break;
									case VK_ADD: return MU_KEYBOARD_KEY_ADD; break;
									case VK_SEPARATOR: return MU_KEYBOARD_KEY_SEPARATOR; break;
									case VK_SUBTRACT: return MU_KEYBOARD_KEY_SUBTRACT; break;
									case VK_DECIMAL: return MU_KEYBOARD_KEY_DECIMAL; break;
									case VK_DIVIDE: return MU_KEYBOARD_KEY_DIVIDE; break;
									case VK_F1: return MU_KEYBOARD_KEY_F1; break;
									case VK_F2: return MU_KEYBOARD_KEY_F2; break;
									case VK_F3: return MU_KEYBOARD_KEY_F3; break;
									case VK_F4: return MU_KEYBOARD_KEY_F4; break;
									case VK_F5: return MU_KEYBOARD_KEY_F5; break;
									case VK_F6: return MU_KEYBOARD_KEY_F6; break;
									case VK_F7: return MU_KEYBOARD_KEY_F7; break;
									case VK_F8: return MU_KEYBOARD_KEY_F8; break;
									case VK_F9: return MU_KEYBOARD_KEY_F9; break;
									case VK_F10: return MU_KEYBOARD_KEY_F10; break;
									case VK_F11: return MU_KEYBOARD_KEY_F11; break;
									case VK_F12: return MU_KEYBOARD_KEY_F12; break;
									case VK_F13: return MU_KEYBOARD_KEY_F13; break;
									case VK_F14: return MU_KEYBOARD_KEY_F14; break;
									case VK_F15: return MU_KEYBOARD_KEY_F15; break;
									case VK_F16: return MU_KEYBOARD_KEY_F16; break;
									case VK_F17: return MU_KEYBOARD_KEY_F17; break;
									case VK_F18: return MU_KEYBOARD_KEY_F18; break;
									case VK_F19: return MU_KEYBOARD_KEY_F19; break;
									case VK_F20: return MU_KEYBOARD_KEY_F20; break;
									case VK_F21: return MU_KEYBOARD_KEY_F21; break;
									case VK_F22: return MU_KEYBOARD_KEY_F22; break;
									case VK_F23: return MU_KEYBOARD_KEY_F23; break;
									case VK_F24: return MU_KEYBOARD_KEY_F24; break;
									case VK_NUMLOCK: return MU_KEYBOARD_KEY_NUMLOCK; break;
									case VK_SCROLL: return MU_KEYBOARD_KEY_SCROLL; break;
									case VK_LSHIFT: return MU_KEYBOARD_KEY_LEFT_SHIFT; break;
									case VK_RSHIFT: return MU_KEYBOARD_KEY_RIGHT_SHIFT; break;
									case VK_LCONTROL: return MU_KEYBOARD_KEY_LEFT_CONTROL; break;
									case VK_RCONTROL: return MU_KEYBOARD_KEY_RIGHT_CONTROL; break;
									case VK_LMENU: return MU_KEYBOARD_KEY_LEFT_MENU; break;
									case VK_RMENU: return MU_KEYBOARD_KEY_RIGHT_MENU; break;
									case VK_ATTN: return MU_KEYBOARD_KEY_ATTN; break;
									case VK_CRSEL: return MU_KEYBOARD_KEY_CRSEL; break;
									case VK_EXSEL: return MU_KEYBOARD_KEY_EXSEL; break;
									case VK_EREOF: return MU_KEYBOARD_KEY_EREOF; break;
									case VK_PLAY: return MU_KEYBOARD_KEY_PLAY; break;
									case VK_PA1: return MU_KEYBOARD_KEY_PA1; break;
								}
							}

						/* Keyboard state */

							int muCOSA_innerWin32_keyboard_state_get_win32(muKeyboardState state) {
								switch (state) {
									default: return VK_NONAME; break;
									case MU_KEYBOARD_STATE_CAPS_LOCK: return VK_CAPITAL; break;
									case MU_KEYBOARD_STATE_SCROLL_LOCK: return VK_SCROLL; break;
									case MU_KEYBOARD_STATE_NUM_LOCK: return VK_NUMLOCK; break;
								}
							}

							void muCOSA_innerWin32_update_state(muCOSA_Win32Context* c, muWindow win, muCOSA_Win32Window* p_win) {
								for (size_m i = MU_KEYBOARD_STATE_FIRST; i <= MU_KEYBOARD_STATE_LAST; i++) {
									muState state = MU_OFF;
									if ((GetKeyState(muCOSA_innerWin32_keyboard_state_get_win32(i)) & 0x0001) != 0) {
										state = MU_ON;
									}

									if (p_win->input.keyboard_state_states[i] != state) {
										p_win->input.keyboard_state_states[i] = state;
										if (p_win->keyboard_state_callback != 0) {
											muCOSAResult result;
											MU_RELEASE(c->windows, win, muCOSA_Win32Window_)
											p_win->keyboard_state_callback(win, i, state);
											MU_HOLD((&result), win, c->windows, 0, MUCOSA_, return;, muCOSA_Win32Window_)
										}
									}
								}
							}

						/* Cursor */

							void* muCOSA_innerWin32_cursor_to_win_cursor(muCursorStyle style) {
								switch (style) {
									default: case MU_CURSOR_STYLE_ARROW: return IDC_ARROW; break;
									case MU_CURSOR_STYLE_IBEAM: return IDC_IBEAM; break;
									case MU_CURSOR_STYLE_WAIT: return IDC_WAIT; break;
									case MU_CURSOR_STYLE_WAIT_ARROW: return IDC_APPSTARTING; break;
									case MU_CURSOR_STYLE_CROSSHAIR: return IDC_CROSS; break;
									case MU_CURSOR_STYLE_HAND: return IDC_HAND; break;
									case MU_CURSOR_STYLE_SIZE_EAST_WEST: return IDC_SIZEWE; break;
									case MU_CURSOR_STYLE_SIZE_NORTH_SOUTH: return IDC_SIZENS; break;
									case MU_CURSOR_STYLE_SIZE_NORTH_EAST_SOUTH_WEST: return IDC_SIZENESW; break;
									case MU_CURSOR_STYLE_SIZE_NORTH_WEST_SOUTH_EAST: return IDC_SIZENWSE; break;
									case MU_CURSOR_STYLE_SIZE_ALL: return IDC_SIZEALL; break;
									case MU_CURSOR_STYLE_NO: return IDC_NO; break;
								}
							}

							void muCOSA_innerWin32_window_get_cursor_position(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m* x, int32_m* y);
							void muCOSA_innerWin32_handle_cursor_position(muCOSA_Win32Context* c, muWindow win, muCOSA_Win32Window* p_win) {
								muCOSAResult result = MUCOSA_SUCCESS;

								int32_m cx=0, cy=0;
								muCOSA_innerWin32_window_get_cursor_position(&result, p_win, &cx, &cy);

								if (result == MUCOSA_SUCCESS && (cx != p_win->cx || cy != p_win->cy)) {
									p_win->cx = cx;
									p_win->cy = cy;

									if (p_win->cursor_position_callback != 0) {
										MU_RELEASE(c->windows, win, muCOSA_Win32Window_)
										p_win->cursor_position_callback(win, p_win->cx, p_win->cy);
										MU_HOLD((&result), win, c->windows, 0, MUCOSA_, return;, muCOSA_Win32Window_)
									}
								}
							}

							void muCOSA_innerWin32_window_get_dimensions(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m* width, uint32_m* height);
							void muCOSA_innerWin32_window_set_cursor_style(muCOSAResult* result, muCOSA_Win32Window* p_win, muCursorStyle style);
							// This doesn't work... :L
							void muCOSA_innerWin32_update_cursor_style(muCOSA_Win32Window* p_win) {
								muCOSAResult result = MUCOSA_SUCCESS;
								return;

								int32_m cx=0,cy=0;
								muCOSA_innerWin32_window_get_cursor_position(&result, p_win, &cx, &cy);
								if (result != MUCOSA_SUCCESS) {
									return;
								}
								uint32_m ucx=cx, ucy=cy;

								uint32_m ww=0,wh=0;
								muCOSA_innerWin32_window_get_dimensions(&result, p_win, &ww, &wh);
								if (result != MUCOSA_SUCCESS) {
									return;
								}

								if (p_win->cursor == NULL) {
									if (ucx < ww && ucy < wh && cx > 0 && cy > 0) {
										muCOSA_innerWin32_window_set_cursor_style(0, p_win, p_win->cursor_style);
									}
								} else {
									if (ucx >= ww || ucy >= wh || cx <= 0 || cy <= 0) {
										DestroyCursor(p_win->cursor);
										p_win->cursor = NULL;
									}
								}
							}

					/* Procedure handling */

						muWindow muCOSA_innerWin32_find_window_by_hwnd(HWND hwnd) {
							muCOSA_Win32Context* c = muCOSA_Win32Context_get();
							if (c == 0) {
								return MU_NONE;
							}
							for (size_m i = 0; i < c->windows.length; i++) {
								if (c->windows.data[i].active && c->windows.data[i].hwnd == hwnd) {
									return i;
								}
							}
							return MU_NONE;
						}

						struct muCOSA_innerWin32_msginfo {
							UINT uMsg;
							WPARAM wParam;
							LPARAM lParam;

							muCOSA_Win32Window* p_win;
							muCOSA_Win32Context* c;
							muWindow id_window;
						};
						typedef struct muCOSA_innerWin32_msginfo muCOSA_innerWin32_msginfo;

						LRESULT CALLBACK muCOSA_innerWin32_handle_quit(muCOSA_innerWin32_msginfo msg) {
							PostQuitMessage(0);
							msg.p_win->closed = MU_TRUE;
							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_size(muCOSA_innerWin32_msginfo msg) {
							muCOSAResult result = MUCOSA_SUCCESS;

							if (msg.p_win->dimensions_callback != 0) {
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->dimensions_callback(msg.id_window, (int)LOWORD(msg.lParam), (int)HIWORD(msg.lParam));
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							if (msg.wParam == SIZE_MAXIMIZED && msg.p_win->maximize_callback != 0) {
								msg.p_win->maximized = MU_TRUE;
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->maximize_callback(msg.id_window, MU_TRUE);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							// ?
							} else if (msg.p_win->maximized
								&& msg.wParam != SIZE_MAXIMIZED && msg.wParam != SIZE_MAXHIDE && msg.wParam != SIZE_MAXSHOW
								&& msg.p_win->maximize_callback != 0) {
								msg.p_win->maximized = MU_FALSE;
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->maximize_callback(msg.id_window, MU_FALSE);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							if (msg.wParam == SIZE_MINIMIZED && msg.p_win->minimize_callback != 0) {
								msg.p_win->minimized = MU_TRUE;
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->minimize_callback(msg.id_window, MU_TRUE);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							// ?
							} else if (msg.p_win->minimized
								&& msg.wParam != SIZE_MINIMIZED && msg.wParam != SIZE_MAXHIDE && msg.wParam != SIZE_MAXSHOW
								&& msg.p_win->minimize_callback != 0) {
								msg.p_win->minimized = MU_FALSE;
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->minimize_callback(msg.id_window, MU_FALSE);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							PostMessage(msg.p_win->hwnd, WM_PAINT, 0, 0);
							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_key(muCOSA_innerWin32_msginfo msg, muButtonState state) {
							muCOSAResult result = MUCOSA_SUCCESS;

							msg.wParam = muCOSA_innerWin32_map_left_right_keys(msg.wParam, msg.lParam);
							muKeyboardKey key = muCOSA_Win32_key_to_keyboard_key(msg.wParam);
							if (key == MU_KEYBOARD_KEY_UNKNOWN) {
								return 0;
							}

							msg.p_win->input.keyboard_key_states[key-MU_KEYBOARD_KEY_FIRST] = state;

							if (msg.p_win->keyboard_key_callback != MU_NULL_PTR) {
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->keyboard_key_callback(msg.id_window, key, state);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_move(muCOSA_innerWin32_msginfo msg) {
							muCOSAResult result = MUCOSA_SUCCESS;

							if (msg.p_win->position_callback != 0) {
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								// https://www.autohotkey.com/boards/viewtopic.php?t=27857
								// BILL GATES... MY LOVE... YOU MAKE NO MISTAKES IN YOUR FLAWLESS,
								// IMPECCABLE API. HOW COULD AN API GET BETTER IF THE DOCUMENTATION FOR IT
								// IS UNIVERSALLY UNDERSTOOD AS BEING COMPLETELY WORTHLESS? I'D LET YOU
								// FORCE UPDATE A MILLION TIMES FOR YOUR PERFECT API... Oh, Bill...
								msg.p_win->position_callback(msg.id_window,
									(int32_m)( msg.lParam      & 0x8000 ? - ((~msg.lParam    )&0x7FFF)+1 :  msg.lParam     &0x7FFF),
									(int32_m)((msg.lParam>>16) & 0x8000 ? - ((~msg.lParam>>16)&0x7FFF)+1 : (msg.lParam>>16)&0x7FFF)
								);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_focus(muCOSA_innerWin32_msginfo msg, muBool focus) {
							muCOSAResult result = MUCOSA_SUCCESS;

							if (msg.p_win->focus_callback != 0) {
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->focus_callback(msg.id_window, focus);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_minmax_info(muCOSA_innerWin32_msginfo msg) {
							LPMINMAXINFO lp = (LPMINMAXINFO)msg.lParam;
							// No idea why 16 and 39 need to be added here. It can't be broder stuff like
							// the titlebar, because the border width is almost never 16 whole pixels in
							// Windows. :|
							lp->ptMinTrackSize.x = msg.p_win->min_width + 16;
							lp->ptMinTrackSize.y = msg.p_win->min_height + 39;
							lp->ptMaxTrackSize.x = msg.p_win->max_width + 16;
							lp->ptMaxTrackSize.y = msg.p_win->max_height + 39;

							return 0;
						}

						// Note: button and state must be valid, this func doesn't perform checks
						LRESULT CALLBACK muCOSA_innerWin32_handle_mouse_button(muCOSA_innerWin32_msginfo msg, muMouseButton button, muButtonState state) {
							muCOSAResult result = MUCOSA_SUCCESS;

							msg.p_win->input.mouse_button_states[button-MU_MOUSE_BUTTON_FIRST] = state;

							if (msg.p_win->mouse_button_callback != MU_NULL_PTR) {
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->mouse_button_callback(msg.id_window, button, state);
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_set_cursor(muCOSA_innerWin32_msginfo msg) {
							if (LOWORD(msg.lParam) == HTCLIENT && msg.p_win->cursor_style != MU_CURSOR_STYLE_DEFAULT) {
								DestroyCursor(msg.p_win->cursor);
								msg.p_win->cursor = LoadCursor(0, (LPCSTR)muCOSA_innerWin32_cursor_to_win_cursor(msg.p_win->cursor_style));
								SetCursor(msg.p_win->cursor);
								return TRUE;
							}

							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_mouse_wheel(muCOSA_innerWin32_msginfo msg) {
							muCOSAResult result = MUCOSA_SUCCESS;
							msg.p_win->scroll_level += GET_WHEEL_DELTA_WPARAM(msg.wParam);

							if (msg.p_win->scroll_callback != 0) {
								MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)
								msg.p_win->scroll_callback(msg.id_window, GET_WHEEL_DELTA_WPARAM(msg.wParam));
								MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)
							}

							return 0;
						}

						// This code assumes that wParam is the Unicode codepoint for the character, which
						// I'm pretty sure it is.
						LRESULT CALLBACK muCOSA_innerWin32_handle_wmchar(muCOSA_innerWin32_msginfo msg) {
							if (msg.p_win->text_input_callback == 0) {
								return DefWindowProcW(msg.p_win->hwnd, msg.uMsg, msg.wParam, msg.lParam);
							}

							musResult mus_res = MUS_SUCCESS;
							muCOSAResult result = MUCOSA_SUCCESS;
							muCodePoint codepoint = (muCodePoint)msg.wParam;

							size_m codepoint_size = mu_UTF8_get_code_point_size(&mus_res, codepoint);
							if (codepoint_size == 0 || mus_res != MUS_SUCCESS) {
								// :L
								return 0;
							}
							codepoint_size += 1; // For \0

							muByte buf[6]; mu_memset(buf, 0, sizeof(buf));
							size_m bufsize = sizeof(buf);
							muByte* input = 0;

							if (codepoint_size > sizeof(buf)) {
								input = (muByte*)mu_malloc(codepoint_size);
								bufsize = codepoint_size;
								if (input == 0) {
									return 0;
								}
							} else {
								input = buf;
							}

							input[codepoint_size-1] = 0;

							mu_character_encoding_set_code_point(&mus_res, MU_UTF8, codepoint, buf, bufsize);
							if (mus_res != MUS_SUCCESS) {
								// :L
								return 0;
							}

							MU_RELEASE(msg.c->windows, msg.id_window, muCOSA_Win32Window_)

							msg.p_win->text_input_callback(msg.id_window, input);
							if (input != buf) {
								mu_free(input);
							}

							MU_HOLD((&result), msg.id_window, msg.c->windows, 0, MUCOSA_, return 0;, muCOSA_Win32Window_)

							return 0;
						}

						LRESULT CALLBACK muCOSA_innerWin32_handle_umsg(muCOSA_innerWin32_msginfo msg) {
							switch (msg.uMsg) {
								default: return DefWindowProcW(msg.p_win->hwnd, msg.uMsg, msg.wParam, msg.lParam); break;
								case WM_DESTROY: return muCOSA_innerWin32_handle_quit(msg); break;

								case WM_SIZE: return muCOSA_innerWin32_handle_size(msg); break;

								case WM_KEYDOWN: return muCOSA_innerWin32_handle_key(msg, MU_BUTTON_STATE_HELD); break;
								case WM_KEYUP: return muCOSA_innerWin32_handle_key(msg, MU_BUTTON_STATE_RELEASED); break;

								case WM_MOVE: return muCOSA_innerWin32_handle_move(msg); break;

								case WM_SETFOCUS: return muCOSA_innerWin32_handle_focus(msg, MU_TRUE); break;
								case WM_KILLFOCUS: return muCOSA_innerWin32_handle_focus(msg, MU_FALSE); break;

								case WM_GETMINMAXINFO: return muCOSA_innerWin32_handle_minmax_info(msg); break;

								case WM_LBUTTONDOWN: return muCOSA_innerWin32_handle_mouse_button(msg, MU_MOUSE_BUTTON_LEFT, MU_BUTTON_STATE_HELD); break;
								case WM_RBUTTONDOWN: return muCOSA_innerWin32_handle_mouse_button(msg, MU_MOUSE_BUTTON_RIGHT, MU_BUTTON_STATE_HELD); break;
								case WM_LBUTTONUP: return muCOSA_innerWin32_handle_mouse_button(msg, MU_MOUSE_BUTTON_LEFT, MU_BUTTON_STATE_RELEASED); break;
								case WM_RBUTTONUP: return muCOSA_innerWin32_handle_mouse_button(msg, MU_MOUSE_BUTTON_RIGHT, MU_BUTTON_STATE_RELEASED); break;

								case WM_SETCURSOR: return muCOSA_innerWin32_handle_set_cursor(msg); break;

								case WM_MOUSEWHEEL: return muCOSA_innerWin32_handle_mouse_wheel(msg); break;

								case WM_CHAR: return muCOSA_innerWin32_handle_wmchar(msg); break;
							}
						}

						LRESULT CALLBACK muCOSA_innerWin32_proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
							muCOSA_Win32Context* c = muCOSA_Win32Context_get();
							if (c == 0) {
								return DefWindowProcW(hwnd, uMsg, wParam, lParam);
							}
							muWindow win = muCOSA_innerWin32_find_window_by_hwnd(hwnd);
							if (win == MU_NONE) {
								return DefWindowProcW(hwnd, uMsg, wParam, lParam);
							}
							// Hack city.
							// Actually, don't have to do this here, should already be being held because
							// it SHOULD (from my understanding) be triggered while we're dispatching
							// messages within the update window func.
							//muCOSAResult result = MUCOSA_SUCCESS;
							//MU_HOLD((&result), win, c->windows, 0, MUCOSA_, return DefWindowProcW(hwnd, uMsg, wParam, lParam);, muCOSA_Win32Window_)

							muCOSA_innerWin32_msginfo msginfo = MU_ZERO_STRUCT(muCOSA_innerWin32_msginfo);
							msginfo.uMsg = uMsg;
							msginfo.wParam = wParam;
							msginfo.lParam = lParam;
							msginfo.p_win = &c->windows.data[win];
							msginfo.c = c;
							msginfo.id_window = win;
							LRESULT ret = muCOSA_innerWin32_handle_umsg(msginfo);

							//MU_RELEASE(c->windows, win, muCOSA_Win32Window_)
							return ret;
						}

					/* Window */

						WNDCLASSEXW muCOSA_innerWin32_window_get_class(muCOSAResult* result,
							wchar_t* wname, wchar_t* wclass_name
						) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							WNDCLASSEXW wclass = MU_ZERO_STRUCT(WNDCLASSEXW);
							wclass.cbSize = sizeof(WNDCLASSEXW);
							wclass.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
							wclass.lpfnWndProc = muCOSA_innerWin32_proc;
							wclass.hInstance = muCOSA_innerWin32_get_hinstance();
							wclass.lpszMenuName = wname;
							wclass.lpszClassName = wclass_name;

							return wclass;
						}

						void muCOSA_innerWin32_window_get_frame_extents(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m* l, uint32_m* r, uint32_m* t, uint32_m* b);
						HWND muCOSA_innerWin32_window_create(
							uint16_m width, uint16_m height, muWindowCreateInfo ci,
							WNDCLASSEXW wclass, muCOSA_Win32Window* p_win
						) {
							DWORD style = WS_OVERLAPPEDWINDOW;
							if (!ci.resizable) {
								style = WS_OVERLAPPED | WS_MINIMIZEBOX | WS_SYSMENU;
							}

							RECT r = MU_ZERO_STRUCT(RECT);
							r.left = r.top = 0;
							r.right = (LONG)width;
							r.bottom = (LONG)height;
							AdjustWindowRect(&r, style, FALSE);

							uint32_m l=0, t=0;
							muCOSA_innerWin32_window_get_frame_extents(0, p_win, &l, 0, &t, 0);

							return CreateWindowExW(
								0,
								wclass.lpszClassName, wclass.lpszMenuName,
								style,
								(int)(ci.x - l),
								(int)(ci.y - t),
								r.right-r.left, r.bottom-r.top, // (Dimensions)
								NULL, NULL,
								wclass.hInstance,
								NULL
							);
						}

					/* Get / Set */

						muBool muCOSA_innerWin32_window_get_focused(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							return GetFocus() == p_win->hwnd;
						}

						muBool muCOSA_innerWin32_window_get_minimized(muCOSAResult* result, muCOSA_Win32Window* p_win);
						void muCOSA_innerWin32_window_set_minimized(muCOSAResult* result, muCOSA_Win32Window* p_win, muBool minimized);
						void muCOSA_innerWin32_window_focus(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							// Attempt to restore the window if it is minimized.
							if (muCOSA_innerWin32_window_get_minimized(0, p_win)) {
								muCOSA_innerWin32_window_set_minimized(0, p_win, MU_FALSE);
							}

							// https://stackoverflow.com/questions/71437203/proper-way-of-activating-a-window-using-winapi
							// This can be made more consistent with the automation API, but I don't want
							// to touch that with a 51!-foot pole.
							SetForegroundWindow(p_win->hwnd);
							if (GetForegroundWindow() != p_win->hwnd) {
								SwitchToThisWindow(p_win->hwnd, MU_TRUE);
								Sleep(2); // I would kiss Bill Gates on the mouth if I ever met him.
								SetForegroundWindow(p_win->hwnd);
							}
						}

						muBool muCOSA_innerWin32_window_get_visible(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							return p_win->visible;
						}

						void muCOSA_innerWin32_window_set_visible(muCOSAResult* result, muCOSA_Win32Window* p_win, muBool visible) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							if (!visible && p_win->visible) {
								ShowWindow(p_win->hwnd, SW_HIDE);
							} else if (visible && !p_win->visible) {
								ShowWindow(p_win->hwnd, SW_NORMAL);
							}

							p_win->visible = visible;
						}

						void muCOSA_innerWin32_window_get_position(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m* x, int32_m* y) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							RECT rect = MU_ZERO_STRUCT(RECT);
							if (GetWindowRect(p_win->hwnd, &rect) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return;
							}

							muCOSAResult res = MUCOSA_SUCCESS;
							uint32_m l=0, t=0;
							muCOSA_innerWin32_window_get_frame_extents(&res, p_win, &l, 0, &t, 0);
							MU_ASSERT(res == MUCOSA_SUCCESS, result, res, return;)

							MU_SET_RESULT(x, (int32_m)rect.left + (int32_m)l)
							MU_SET_RESULT(y, (int32_m)rect.top + (int32_m)t)
						}

						void muCOSA_innerWin32_window_set_position(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m x, int32_m y) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							uint32_m xborder=0, yborder=0;
							muCOSA_innerWin32_window_get_frame_extents(0, p_win, &xborder, 0, &yborder, 0);

							x -= (int32_m)xborder;
							y -= (int32_m)yborder;

							if (SetWindowPos(p_win->hwnd, HWND_TOP, x, y, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_SET_WINDOW_INFO)
							}
						}

						void muCOSA_innerWin32_window_get_dimensions(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m* width, uint32_m* height) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							RECT rect = MU_ZERO_STRUCT(RECT);
							if (GetClientRect(p_win->hwnd, &rect) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return;
							}

							MU_SET_RESULT(width, (uint32_m)(rect.right - rect.left))
							MU_SET_RESULT(height, (uint32_m)(rect.bottom - rect.top))
						}

						void muCOSA_innerWin32_window_set_dimensions(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m width, uint32_m height) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							WINDOWINFO wi = MU_ZERO_STRUCT(WINDOWINFO);
							if (GetWindowInfo(p_win->hwnd, &wi) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return;
							}

							RECT rect = MU_ZERO_STRUCT(RECT);
							rect.right = width;
							rect.bottom = height;
							if (AdjustWindowRect(&rect, wi.dwStyle, FALSE) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_SET_WINDOW_INFO)
								return;
							}

							if (SetWindowPos(
									p_win->hwnd, HWND_TOP, 0, 0, rect.right-rect.left, rect.bottom-rect.top, 
									SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE
								) == 0
							) {
								MU_SET_RESULT(result, MUCOSA_FAILED_SET_WINDOW_INFO)
							}
						}

						muBool muCOSA_innerWin32_window_get_maximized(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							WINDOWPLACEMENT wp = MU_ZERO_STRUCT(WINDOWPLACEMENT);
							wp.length = sizeof(WINDOWPLACEMENT);
							if (GetWindowPlacement(p_win->hwnd, &wp) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return MU_FALSE;
							}

							return wp.showCmd == SW_MAXIMIZE;
						}

						void muCOSA_innerWin32_window_set_maximized(muCOSAResult* result, muCOSA_Win32Window* p_win, muBool maximized) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							muCOSAResult res = MUCOSA_SUCCESS;
							muBool b_maximized = muCOSA_innerWin32_window_get_maximized(&res, p_win);
							MU_ASSERT(res == MUCOSA_SUCCESS, result, res, return;)

							if (b_maximized == maximized) {
								return;
							}

							if (maximized) {
								ShowWindow(p_win->hwnd, SW_MAXIMIZE);
							} else {
								ShowWindow(p_win->hwnd, SW_NORMAL);
							}
						}

						muBool muCOSA_innerWin32_window_get_minimized(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							return IsIconic(p_win->hwnd);
						}

						void muCOSA_innerWin32_window_set_minimized(muCOSAResult* result, muCOSA_Win32Window* p_win, muBool minimized) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							muCOSAResult res = MUCOSA_SUCCESS;
							muBool b_minimized = muCOSA_innerWin32_window_get_minimized(&res, p_win);
							MU_ASSERT(res == MUCOSA_SUCCESS, result, res, return;)

							if (b_minimized == minimized) {
								return;
							}

							if (minimized) {
								ShowWindow(p_win->hwnd, SW_MINIMIZE);
							} else {
								if (OpenIcon(p_win->hwnd) == 0) {
									MU_SET_RESULT(result, MUCOSA_FAILED_SET_WINDOW_INFO)
								}
							}
						}

						void muCOSA_innerWin32_window_get_minimum_dimensions(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m* min_width, uint32_m* min_height) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_SET_RESULT(min_width, p_win->min_width)
							MU_SET_RESULT(min_height, p_win->min_height)
						}

						void muCOSA_innerWin32_window_set_minimum_dimensions(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m min_width, uint32_m min_height) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							p_win->min_width = min_width;
							p_win->min_height = min_height;
						}

						void muCOSA_innerWin32_window_get_maximum_dimensions(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m* max_width, uint32_m* max_height) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_SET_RESULT(max_width, p_win->max_width)
							MU_SET_RESULT(max_height, p_win->max_height)
						}

						void muCOSA_innerWin32_window_set_maximum_dimensions(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m max_width, uint32_m max_height) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							p_win->max_width = max_width;
							p_win->max_height = max_height;
						}

						void muCOSA_innerWin32_window_get_cursor_position(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m* x, int32_m* y) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							POINT p = MU_ZERO_STRUCT(POINT);
							if (GetCursorPos(&p) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return;
							}

							int32_m wx=0, wy=0;
							muCOSAResult res = MUCOSA_SUCCESS;
							muCOSA_innerWin32_window_get_position(&res, p_win, &wx, &wy);
							MU_ASSERT(res == MUCOSA_SUCCESS, result, res, return;)

							MU_SET_RESULT(x, p.x-wx)
							MU_SET_RESULT(y, p.y-wy)
						}

						void muCOSA_innerWin32_window_set_cursor_position(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m x, int32_m y) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							int32_m wx=0, wy=0;
							muCOSAResult res = MUCOSA_SUCCESS;
							muCOSA_innerWin32_window_get_position(&res, p_win, &wx, &wy);
							MU_ASSERT(res == MUCOSA_SUCCESS, result, res, return;)

							if (SetCursorPos(wx+x, wy+y) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_SET_WINDOW_INFO)
							}
						}

						muCursorStyle muCOSA_innerWin32_window_get_cursor_style(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							return p_win->cursor_style;
						}

						void muCOSA_innerWin32_window_set_cursor_style(muCOSAResult* result, muCOSA_Win32Window* p_win, muCursorStyle style) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							p_win->cursor_style = style;
							if (p_win->cursor != NULL) {
								DestroyCursor(p_win->cursor);
							}
							p_win->cursor = LoadCursor(0, (LPCSTR)muCOSA_innerWin32_cursor_to_win_cursor(style));
							SetCursor(p_win->cursor);
						}

						int32_m muCOSA_innerWin32_window_get_scroll_level(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							return p_win->scroll_level;
						}

						void muCOSA_innerWin32_window_set_scroll_level(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m scroll_level) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							p_win->scroll_level = scroll_level;
						}

					/* Get / Let */

						// https://chromium.googlesource.com/chromium/chromium/+/8da845c82ec64ba85c8222e61c249244a492bebd/chrome/browser/ime_input.cc
						// Chromium my beloved

						void muCOSA_innerWin32_window_update_text_cursor(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m x, int32_m y) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							if (p_win->text_input_callback == 0) {
								return;
							}

							HIMC imm = ImmGetContext(p_win->hwnd);

							COMPOSITIONFORM cf = MU_ZERO_STRUCT(COMPOSITIONFORM);
							cf.dwStyle = CFS_FORCE_POSITION;

							cf.ptCurrentPos.x = x;
							cf.ptCurrentPos.y = y;
							ImmSetCompositionWindow(imm, &cf);

							if (ImmReleaseContext(p_win->hwnd, imm) == 0) {
								
							}
						}

						void muCOSA_innerWin32_window_get_text_input_focus(muCOSAResult* result, muCOSA_Win32Window* p_win, int32_m text_cursor_x, int32_m text_cursor_y, void (*callback)(muWindow window, muByte* input)) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							if (ImmAssociateContextEx(p_win->hwnd, NULL, IACE_DEFAULT) == FALSE) {
								MU_SET_RESULT(result, MUCOSA_FAILED_GET_IMM_CONTEXT)
								return;
							}

							muCOSA_innerWin32_window_update_text_cursor(0, p_win, text_cursor_x, text_cursor_y);

							p_win->text_input_callback = callback;
						}

						void muCOSA_innerWin32_window_let_text_input_focus(muCOSAResult* result, muCOSA_Win32Window* p_win) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							p_win->text_input_callback = 0;

							if (ImmAssociateContextEx(p_win->hwnd, NULL, 0) == FALSE) {
								MU_SET_RESULT(result, MUCOSA_FAILED_GET_IMM_CONTEXT)
								return;
							}
						}

					/* Get */

						void muCOSA_innerWin32_window_get_def_frame_extents(uint32_m* l, uint32_m* r, uint32_m* t, uint32_m* b) {
							MU_SET_RESULT(l, (uint32_m)GetSystemMetrics(SM_CXSIZEFRAME))
							MU_SET_RESULT(r, (uint32_m)GetSystemMetrics(SM_CXSIZEFRAME))
							MU_SET_RESULT(t, (uint32_m)(GetSystemMetrics(SM_CYFRAME) + GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(92)))
							MU_SET_RESULT(b, (uint32_m)GetSystemMetrics(SM_CXSIZEFRAME))
						}

						// I LOVE YOU BILL GATES!!!!
						void muCOSA_innerWin32_window_get_frame_extents(muCOSAResult* result, muCOSA_Win32Window* p_win, uint32_m* l, uint32_m* r, uint32_m* t, uint32_m* b) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							// (Fallback)
							muCOSA_innerWin32_window_get_def_frame_extents(l, r, t, b);

							RECT wrect, crect;
							if (GetWindowRect(p_win->hwnd, &wrect) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return;
							}
							if (GetClientRect(p_win->hwnd, &crect) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return;
							}
							MapWindowPoints(p_win->hwnd, NULL, (LPPOINT)&crect, 2);

							MU_SET_RESULT(l, (uint32_m)(crect.left-wrect.left))
							MU_SET_RESULT(r, (uint32_m)(wrect.right-crect.right))
							MU_SET_RESULT(t, (uint32_m)(crect.top-wrect.top))
							MU_SET_RESULT(b, (uint32_m)(wrect.bottom-crect.bottom))

							/*LONG styles = GetWindowLongA(p_win->hwnd, GWL_STYLE);
							LONG exstyles = GetWindowLongA(p_win->hwnd, GWL_EXSTYLE);

							RECT rect;
							if (AdjustWindowRectEx(&rect, styles, FALSE, exstyles) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_QUERY_WINDOW_INFO)
								return;
							}

							MU_SET_RESULT(l, rect.left)
							MU_SET_RESULT(r, rect.right)
							MU_SET_RESULT(t, rect.top)
							MU_SET_RESULT(b, rect.bottom)*/
						}

						muButtonState muCOSA_innerWin32_window_get_keyboard_key_state(muCOSAResult* result, muCOSA_Win32Window* p_win, muKeyboardKey key) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_ASSERT(key >= MU_KEYBOARD_KEY_FIRST && key <= MU_KEYBOARD_KEY_LAST, result, MUCOSA_UNKNOWN_KEYBOARD_KEY, return 0;)

							return p_win->input.keyboard_key_states[key-MU_KEYBOARD_KEY_FIRST];
						}

						muState muCOSA_innerWin32_window_get_keyboard_state_state(muCOSAResult* result, muCOSA_Win32Window* p_win, muKeyboardState state) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_ASSERT(state >= MU_KEYBOARD_STATE_FIRST && state <= MU_KEYBOARD_STATE_LAST, result, MUCOSA_UNKNOWN_KEYBOARD_STATE, return 0;)

							return (GetKeyState(muCOSA_innerWin32_keyboard_state_get_win32(state)) & 0x0001) != 0;
							if (p_win) {}
						}

						muButtonState muCOSA_innerWin32_window_get_mouse_button_state(muCOSAResult* result, muCOSA_Win32Window* p_win, muMouseButton button) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_ASSERT(button >= MU_MOUSE_BUTTON_FIRST && button <= MU_MOUSE_BUTTON_LAST, result, MUCOSA_UNKNOWN_MOUSE_BUTTON, return 0;)

							return p_win->input.mouse_button_states[button-MU_MOUSE_BUTTON_FIRST];
						}

					/* Set */

						void muCOSA_innerWin32_window_set_title(muCOSAResult* result, muCOSA_Win32Window* p_win, muByte* title) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							wchar_t* wtitle = muCOSA_innerWin32_utf8_to_wchar(title);
							MU_ASSERT(wtitle != 0, result, MUCOSA_ALLOCATION_FAILED, return;)

							if (SetWindowTextW(p_win->hwnd, wtitle) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_SET_WINDOW_INFO)
							}

							mu_free(wtitle);
						}

				/* Time */

					// https://stackoverflow.com/questions/1695288/getting-the-current-time-in-milliseconds-from-the-system-clock-in-windows
					double muCOSA_innerWin32_get_current_time(void) {
						FILETIME file_time;
						GetSystemTimeAsFileTime(&file_time);
						LONGLONG ll_now = (LONGLONG)file_time.dwLowDateTime + ((LONGLONG)(file_time.dwHighDateTime) << 32LL);
						return (double)ll_now / (double)1.0e7;
					}

				/* Functions */

					/* Is supported */

						muBool muCOSA_Win32_is_supported(void) {
							return MU_TRUE;
						}

					/* Initiation / Termination */

						void muCOSA_Win32_init(muCOSAResult* result, muCOSA_Win32Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							MUCOSA_OPENGL_CALL(
								c->wgl = muCOSA_Win32WGL_init();
							)

							c->time = muCOSA_Win32Time_init();
						}

						muWindow muCOSA_Win32_window_destroy(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window);
						void muCOSA_Win32_term(muCOSAResult* result, muCOSA_Win32Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							for (size_m i = 0; i < c->windows.length; i++) {
								muCOSA_Win32_window_destroy(0, c, i);
							}

							MUCOSA_OPENGL_CALL(
								muCOSA_Win32WGL_term(c->wgl);
							)

							muCOSA_Win32Time_term(c->time);
						}

					/* Window */

						/* Creation / Destruction */

							muWindow muCOSA_Win32_window_create(muCOSAResult* result, muCOSA_Win32Context* c,
								muGraphicsAPI api, muBool (*load_functions)(void),
								muByte* name, uint16_m width, uint16_m height,
								muWindowCreateInfo create_info
							) {
								if (api) {} if (load_functions) {}

								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								mumaResult muma_res = MUMA_SUCCESS;
								muCOSAResult mu_res = MUCOSA_SUCCESS;

								mu_res = muCOSA_verify_window_create_info(create_info);
								MU_ASSERT(mu_res == MUCOSA_SUCCESS, result, mu_res, return MU_NONE;)

								size_m win = MU_NONE;
								muCOSA_Win32Window_find_push(&muma_res, &c->windows, MU_ZERO_STRUCT(muCOSA_Win32Window), &win);
								if (muma_res != MUMA_SUCCESS) {
									MU_SET_RESULT(result, muma_result_to_muCOSA_result(muma_res))
									return MU_NONE;
								}
								muCOSA_Win32Window_hold_element(&muma_res, &c->windows, win);
								MU_ASSERT(muma_res == MUMA_SUCCESS, result, muma_result_to_muCOSA_result(muma_res), return MU_NONE;)

								c->windows.data[win] = MU_ZERO_STRUCT(muCOSA_Win32Window);
								c->windows.data[win].active = MU_FALSE;

								/* Create */

								wchar_t* wname = muCOSA_innerWin32_utf8_to_wchar(name);
								MU_ASSERT(wname != 0, result, MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR, 
									MU_RELEASE(c->windows, win, muCOSA_Win32Window_) return MU_NONE;
								)

								c->windows.data[win].hinstance = muCOSA_innerWin32_get_hinstance();

								// This might be a bad idea... :)
								c->windows.data[win].wclass_name[0] = (wchar_t)'!' + (wchar_t)win;
								c->windows.data[win].wclass_name[1] = (wchar_t)'\0';

								WNDCLASSEXW wclass = muCOSA_innerWin32_window_get_class(&mu_res, wname, c->windows.data[win].wclass_name);
								MU_ASSERT(mu_res == MUCOSA_SUCCESS, result, mu_res, 
									mu_free(wname);
									MU_RELEASE(c->windows, win, muCOSA_Win32Window_) return MU_NONE;
								)

								if (!RegisterClassExW(&wclass)) {
									mu_free(wname);
									MU_SET_RESULT(result, MUCOSA_FAILED_REGISTER_WINDOW_CLASS)
									MU_RELEASE(c->windows, win, muCOSA_Win32Window_)
									return MU_NONE;
								}

								c->windows.data[win].hwnd = muCOSA_innerWin32_window_create(
									width, height, create_info, wclass, &c->windows.data[win]
								);

								mu_free(wname);

								MU_ASSERT(c->windows.data[win].hwnd != NULL, result, MUCOSA_FAILED_CREATE_WINDOW,
									UnregisterClassW(c->windows.data[win].wclass_name, c->windows.data[win].hinstance);
									MU_RELEASE(c->windows, win, muCOSA_Win32Window_) return MU_NONE;
								);

								c->windows.data[win].dc = GetDC(c->windows.data[win].hwnd);

								/* Handle API */

								c->windows.data[win].api = api;

								MUCOSA_OPENGL_CALL(
								if (api >= MUCOSA_OPENGL_FIRST && api <= MUCOSA_OPENGL_LAST) {
									MU_LOCK_LOCK(c->wgl.lock, c->wgl.lock_active)

									if (c->wgl.wglCreateContextAttribsARB == 0) {
										mu_res = muCOSA_Win32_init_opengl_extensions(&c->wgl);
										MU_ASSERT(mu_res == MUCOSA_SUCCESS, result, mu_res,
											ReleaseDC(c->windows.data[win].hwnd, c->windows.data[win].dc);
											DestroyWindow(c->windows.data[win].hwnd);
											UnregisterClassW(c->windows.data[win].wclass_name, c->windows.data[win].hinstance);
											MU_LOCK_UNLOCK(c->wgl.lock, c->wgl.lock_active)
											MU_RELEASE(c->windows, win, muCOSA_Win32Window_) return MU_NONE;
										)
									}

									mu_res = muCOSA_Win32_create_opengl_context(
										c->windows.data[win].dc, &c->wgl, create_info.pixel_format, &c->windows.data[win].glrc, api
									);
									MU_ASSERT(mu_res == MUCOSA_SUCCESS, result, mu_res,
										ReleaseDC(c->windows.data[win].hwnd, c->windows.data[win].dc);
										DestroyWindow(c->windows.data[win].hwnd);
										UnregisterClassW(c->windows.data[win].wclass_name, c->windows.data[win].hinstance);
										MU_LOCK_UNLOCK(c->wgl.lock, c->wgl.lock_active)
										MU_RELEASE(c->windows, win, muCOSA_Win32Window_) return MU_NONE;
									)

									MU_LOCK_UNLOCK(c->wgl.lock, c->wgl.lock_active)
								}
								)

								if (load_functions != MU_NULL_PTR) {
									MU_ASSERT(load_functions() == MU_TRUE, result, MUCOSA_FAILED_LOAD_FUNCTIONS, 
										MUCOSA_OPENGL_CALL(
											if (api >= MUCOSA_OPENGL_FIRST && api <= MUCOSA_OPENGL_LAST) {
												wglDeleteContext(c->windows.data[win].glrc);
											}
										)

										ReleaseDC(c->windows.data[win].hwnd, c->windows.data[win].dc);
										DestroyWindow(c->windows.data[win].hwnd);
										UnregisterClassW(c->windows.data[win].wclass_name, c->windows.data[win].hinstance);
									)
								}

								/* Cursor */

								c->windows.data[win].cursor_style = create_info.cursor_style;
								c->windows.data[win].cursor = LoadCursor(0, (LPCSTR)muCOSA_innerWin32_cursor_to_win_cursor(create_info.cursor_style));
								SetCursor(c->windows.data[win].cursor);

								/* Show window */

								c->windows.data[win].visible = create_info.visible;

								if (c->windows.data[win].visible) {
									if (create_info.maximized) {
										ShowWindow(c->windows.data[win].hwnd, SW_MAXIMIZE);
									} else if (create_info.minimized) {
										ShowWindow(c->windows.data[win].hwnd, SW_MINIMIZE);
									} else {
										ShowWindow(c->windows.data[win].hwnd, SW_NORMAL);
									}
								} else {
									ShowWindow(c->windows.data[win].hwnd, SW_HIDE);
								}

								/* Auto-disable IME */

								if (ImmAssociateContextEx(c->windows.data[win].hwnd, NULL, 0) == FALSE) {
									// ？
								}

								/* R e t u r n */

								c->windows.data[win].closed = MU_FALSE;
								c->windows.data[win].maximized = create_info.maximized;
								c->windows.data[win].minimized = create_info.minimized;
								c->windows.data[win].dimensions_callback = create_info.dimensions_callback;
								c->windows.data[win].position_callback = create_info.position_callback;
								c->windows.data[win].focus_callback = create_info.focus_callback;
								c->windows.data[win].maximize_callback = create_info.maximize_callback;
								c->windows.data[win].minimize_callback = create_info.minimize_callback;
								c->windows.data[win].keyboard_key_callback = create_info.keyboard_key_callback;
								c->windows.data[win].keyboard_state_callback = create_info.keyboard_state_callback;
								c->windows.data[win].cursor_position_callback = create_info.cursor_position_callback;
								c->windows.data[win].mouse_button_callback = create_info.mouse_button_callback;
								c->windows.data[win].scroll_callback = create_info.scroll_callback;
								c->windows.data[win].min_width = create_info.min_width;
								c->windows.data[win].min_height = create_info.min_height;
								c->windows.data[win].max_width = create_info.max_width;
								c->windows.data[win].max_height = create_info.max_height;

								c->windows.data[win].active = MU_TRUE;
								MU_RELEASE(c->windows, win, muCOSA_Win32Window_)
								return win;
							}

							muWindow muCOSA_Win32_window_destroy(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return window;, muCOSA_Win32Window_)

								MUCOSA_OPENGL_CALL(
									if (c->windows.data[window].api >= MUCOSA_OPENGL_FIRST && c->windows.data[window].api <= MUCOSA_OPENGL_LAST) {
										wglDeleteContext(c->windows.data[window].glrc);
									}
								)

								ReleaseDC(c->windows.data[window].hwnd, c->windows.data[window].dc);
								DestroyWindow(c->windows.data[window].hwnd);
								UnregisterClassW(c->windows.data[window].wclass_name, c->windows.data[window].hinstance);

								c->windows.data[window].active = MU_FALSE;
								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
								return MU_NONE;
							}

						/* Main loop */

							muBool muCOSA_Win32_window_get_closed(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_TRUE;, muCOSA_Win32Window_)

								muBool closed = c->windows.data[window].closed;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
								return closed;
							}

							void muCOSA_Win32_window_close(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSAResult res = MUCOSA_SUCCESS;
								muCOSA_innerWin32_window_set_visible(&res, &c->windows.data[window], MU_FALSE);
								MU_ASSERT(res == MUCOSA_SUCCESS, result, res, MU_RELEASE(c->windows, window, muCOSA_Win32Window_) return;)

								c->windows.data[window].closed = MU_TRUE;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_update(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								MSG msg = MU_ZERO_STRUCT(MSG);
								while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE)) {
									TranslateMessage(&msg);
									DispatchMessage(&msg);
								}

								muCOSA_innerWin32_update_state(c, window, &c->windows.data[window]);
								muCOSA_innerWin32_possible_input_flushing(&c->windows.data[window]);

								muCOSA_innerWin32_handle_cursor_position(c, window, &c->windows.data[window]);
								muCOSA_innerWin32_update_cursor_style(&c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_swap_buffers(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								MUCOSA_OPENGL_CALL(
									if (c->windows.data[window].api >= MUCOSA_OPENGL_FIRST && c->windows.data[window].api <= MUCOSA_OPENGL_LAST) {
										SwapBuffers(c->windows.data[window].dc);
									}
								)

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

						/* Get / Set */

							muBool muCOSA_Win32_window_get_focused(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_Win32Window_)

								muBool ret = muCOSA_innerWin32_window_get_focused(result, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return ret;
							}

							void muCOSA_Win32_window_focus(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_focus(result, &c->windows.data[window]);
								if (callback) {}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							muBool muCOSA_Win32_window_get_visible(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_Win32Window_)

								muBool ret = muCOSA_innerWin32_window_get_visible(result, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return ret;
							}

							void muCOSA_Win32_window_set_visible(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muBool visible) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_visible(result, &c->windows.data[window], visible);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_get_position(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int32_m* x, int32_m* y) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_get_position(result, &c->windows.data[window], x, y);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_position(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int32_m x, int32_m y, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_position(result, &c->windows.data[window], x, y);
								if (callback) {}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_get_dimensions(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, uint32_m* width, uint32_m* height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_get_dimensions(result, &c->windows.data[window], width, height);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_dimensions(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, uint32_m width, uint32_m height, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_dimensions(result, &c->windows.data[window], width, height);
								if (callback) {}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							muBool muCOSA_Win32_window_get_maximized(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_Win32Window_)

								muBool ret = muCOSA_innerWin32_window_get_maximized(result, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return ret;
							}

							void muCOSA_Win32_window_set_maximized(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muBool maximized, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_maximized(result, &c->windows.data[window], maximized);
								if (callback) {}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							muBool muCOSA_Win32_window_get_minimized(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_FALSE;, muCOSA_Win32Window_)

								muBool ret = muCOSA_innerWin32_window_get_minimized(result, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return ret;
							}

							void muCOSA_Win32_window_set_minimized(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muBool minimized, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_minimized(result, &c->windows.data[window], minimized);
								if (callback) {}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_get_minimum_dimensions(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, uint32_m* min_width, uint32_m* min_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_get_minimum_dimensions(result, &c->windows.data[window], min_width, min_height);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_minimum_dimensions(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, uint32_m min_width, uint32_m min_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_minimum_dimensions(result, &c->windows.data[window], min_width, min_height);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_get_maximum_dimensions(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, uint32_m* max_width, uint32_m* max_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_get_maximum_dimensions(result, &c->windows.data[window], max_width, max_height);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_maximum_dimensions(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, uint32_m max_width, uint32_m max_height) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_maximum_dimensions(result, &c->windows.data[window], max_width, max_height);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_get_cursor_position(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int32_m* x, int32_m* y) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_get_cursor_position(result, &c->windows.data[window], x, y);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_cursor_position(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int32_m x, int32_m y, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_cursor_position(result, &c->windows.data[window], x, y);
								if (callback) {}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							muCursorStyle muCOSA_Win32_window_get_cursor_style(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return MU_CURSOR_STYLE_UNKNOWN;, muCOSA_Win32Window_)

								muCursorStyle style = muCOSA_innerWin32_window_get_cursor_style(result, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return style;
							}

							void muCOSA_Win32_window_set_cursor_style(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muCursorStyle style) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_cursor_style(result, &c->windows.data[window], style);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							int32_m muCOSA_Win32_window_get_scroll_level(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_Win32Window_)

								int32_m level = muCOSA_innerWin32_window_get_scroll_level(result, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return level;
							}

							void muCOSA_Win32_window_set_scroll_level(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int32_m scroll_level, muBool callback) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_scroll_level(result, &c->windows.data[window], scroll_level);
								if (callback) {}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

						/* Get / Let */

							void muCOSA_Win32_window_get_text_input_focus(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int32_m text_cursor_x, int32_m text_cursor_y, void (*callback)(muWindow window, muByte* input)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_get_text_input_focus(result, &c->windows.data[window], text_cursor_x, text_cursor_y, callback);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_update_text_cursor(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int32_m x, int32_m y) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_update_text_cursor(result, &c->windows.data[window], x, y);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_let_text_input_focus(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_let_text_input_focus(result, &c->windows.data[window]);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

						/* Get */

							void muCOSA_Win32_window_get_frame_extents(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, uint32_m* left, uint32_m* right, uint32_m* top, uint32_m* bottom) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_get_frame_extents(result, &c->windows.data[window], left, right, top, bottom);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							muButtonState muCOSA_Win32_window_get_keyboard_key_state(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muKeyboardKey key) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_Win32Window_)

								muButtonState ret = muCOSA_innerWin32_window_get_keyboard_key_state(result, &c->windows.data[window], key);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return ret;
							}

							muState muCOSA_Win32_window_get_keyboard_state_state(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muKeyboardState state) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_Win32Window_)

								muState ret = muCOSA_innerWin32_window_get_keyboard_state_state(result, &c->windows.data[window], state);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return ret;
							}

							muButtonState muCOSA_Win32_window_get_mouse_button_state(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muMouseButton button) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_Win32Window_)

								muButtonState ret = muCOSA_innerWin32_window_get_mouse_button_state(result, &c->windows.data[window], button);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

								return ret;
							}

						/* Set */

							void muCOSA_Win32_window_set_title(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muByte* title) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								muCOSA_innerWin32_window_set_title(result, &c->windows.data[window], title);

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_dimensions_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, uint32_m width, uint32_m height)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].dimensions_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_position_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, int32_m x, int32_m y)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].position_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_focus_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, muBool focused)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].focus_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_maximize_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, muBool maximized)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].maximize_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_minimize_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, muBool minimized)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].minimize_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_keyboard_key_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, muKeyboardKey keyboard_key, muButtonState state)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].keyboard_key_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_keyboard_state_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, muKeyboardState keyboard_state, muState state)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].keyboard_state_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_cursor_position_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, int32_m x, int32_m y)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].cursor_position_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_mouse_button_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, muMouseButton mouse_button, muButtonState state)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].mouse_button_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

							void muCOSA_Win32_window_set_scroll_callback(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void (*callback)(muWindow window, int32_m scroll_level_add)) {
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								c->windows.data[window].scroll_callback = callback;

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							}

					/* Time */

						double muCOSA_Win32_time_get(muCOSAResult* result, muCOSA_Win32Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							MU_LOCK_LOCK(c->time.lock, c->time.lock_active)
							double time = c->time.orig_time;
							MU_LOCK_UNLOCK(c->time.lock, c->time.lock_active)

							return muCOSA_innerWin32_get_current_time() - time;
						}

						void muCOSA_Win32_time_set(muCOSAResult* result, muCOSA_Win32Context* c, double time) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							MU_LOCK_LOCK(c->time.lock, c->time.lock_active)
							c->time.orig_time = muCOSA_innerWin32_get_current_time() + time;
							MU_LOCK_UNLOCK(c->time.lock, c->time.lock_active)
						}

						void muCOSA_Win32_sleep(muCOSAResult* result, muCOSA_Win32Context* c, double time) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							Sleep((DWORD)((double)time*(double)1000.f));
							if (c) {}
						}

					/* Clipboard */

						// https://stackoverflow.com/questions/14762456/getclipboarddatacf-text

						muByte* muCOSA_Win32_clipboard_get(muCOSAResult* result, muCOSA_Win32Context* c) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							if (OpenClipboard(NULL) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_HOLD_CLIPBOARD)
								return 0;
							}

							HANDLE data = GetClipboardData(CF_UNICODETEXT);
							if (data == 0) {
								// I'm pretty sure this can happen if no clipboard is available, so I'm not
								// throwing an error here.
								CloseClipboard();
								return 0;
							}

							wchar_t* wdata = (wchar_t*)GlobalLock(data);
							if (wdata == NULL) {
								MU_SET_RESULT(result, MUCOSA_FAILED_GLOBAL_LOCK)
								CloseClipboard();
								return 0;
							}

							muByte* utf8_data = muCOSA_innerWin32_wchar_to_utf8(wdata);
							if (utf8_data == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8)
								GlobalUnlock(data);
								CloseClipboard();
								return 0;
							}

							return utf8_data;
							if (c) {}
						}

						// https://stackoverflow.com/questions/1264137/how-to-copy-string-to-clipboard-in-c

						void muCOSA_Win32_clipboard_set(muCOSAResult* result, muCOSA_Win32Context* c, muByte* text, size_m text_size) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)

							int wlen = MultiByteToWideChar(CP_UTF8, 0, (const char*)text, text_size, NULL, 0);
							if (wlen == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR)
								return;
							}

							HGLOBAL g_mem = GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wlen * sizeof(wchar_t));
							MU_ASSERT(g_mem != NULL, result, MUCOSA_FAILED_GLOBAL_ALLOCATION, return;)

							LPVOID p_mem = GlobalLock(g_mem);
							if (p_mem == NULL) {
								MU_SET_RESULT(result, MUCOSA_FAILED_GLOBAL_LOCK)
								GlobalFree(g_mem);
								return;
							}

							if (MultiByteToWideChar(CP_UTF8, 0, (const char*)text, text_size, (LPWSTR)p_mem, wlen) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR)
								GlobalUnlock(g_mem);
								GlobalFree(g_mem);
								return;
							}

							GlobalUnlock(g_mem);

							if (OpenClipboard(NULL) == 0) {
								MU_SET_RESULT(result, MUCOSA_FAILED_HOLD_CLIPBOARD)
								GlobalFree(g_mem);
								return;
							}

							if (EmptyClipboard() == 0) {
								// I'm going to assume that this can occur if the clipboard was already
								// empty, so I don't wanna throw an error here. But if that's not the case,
								// this could cause a bad memory leak. :L
							}

							// Is CF_UNICODETEXT right here? Pretty sure it is...
							if (SetClipboardData(CF_UNICODETEXT, g_mem) == NULL) {
								MU_SET_RESULT(result, MUCOSA_FAILED_SET_CLIPBOARD)
								GlobalFree(g_mem);
								CloseClipboard();
								return;
							}

							CloseClipboard();

							return;
							if (c) {}
						}

					/* OS functions */

						void* muCOSA_Win32_os_get_window_handle(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, muWindowHandle handle) {
							MU_SET_RESULT(result, MUCOSA_SUCCESS)
							MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return 0;, muCOSA_Win32Window_)

							void* p = 0;
							switch (handle) {
								default: MU_SET_RESULT(result, MUCOSA_UNKNOWN_WINDOW_HANDLE) break;
								case MU_WINDOWS_HWND: p = (void*)c->windows.data[window].hwnd; break;
							}

							MU_RELEASE(c->windows, window, muCOSA_Win32Window_)

							return p;
						}

					/* OpenGL */

						void muCOSA_Win32_opengl_bind_window(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window) {
							#ifndef MUCOSA_OPENGL
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
								return;
								if (c) {} if (window) {}
							#else
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								if (c->windows.data[window].api >= MUCOSA_OPENGL_FIRST && c->windows.data[window].api <= MUCOSA_OPENGL_LAST) {
									if (wglMakeCurrent(c->windows.data[window].dc, c->windows.data[window].glrc) != TRUE) {
										MU_SET_RESULT(result, MUCOSA_FAILED_LOAD_OPENGL_CONTEXT)
										MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
										return;
									}
								}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							#endif
						}

						// https://stackoverflow.com/questions/76638441/how-to-init-glad-without-the-glfw-loader-using-windows-headers
						void* muCOSA_Win32_opengl_get_function_address(const muByte* name) {
							MUCOSA_OPENGL_CALL(
								PROC p = (PROC)wglGetProcAddress((LPCSTR)name);

								if (p == 0 || (p == (PROC)0x1) || (p == (PROC)0x2) || (p == (PROC)0x3) || (p == (PROC)-1)) {
									HMODULE module = LoadLibraryA("opengl32.dll");
									p = (PROC)GetProcAddress(module, (LPCSTR)name);
								}

								void* vptr = 0;
								mu_memcpy(&vptr, &p, sizeof(void*));
								return vptr;
							)
							if (name) {}
							return 0;
						}

						void muCOSA_Win32_opengl_window_swap_interval(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, int interval) {
							#ifndef MUCOSA_OPENGL
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
								return;
								if (c) {} if (window) {} if (interval) {}
							#else
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								MU_LOCK_LOCK(c->wgl.si.lock, c->wgl.si.lock_active)

								// Check if extension "wglGetExtensionsStringEXT" is present
								if (c->wgl.si.wglSwapIntervalEXT == 0) {
									void* vptr = muCOSA_Win32_opengl_get_function_address((muByte*)"wglGetExtensionsStringEXT");

									if (vptr == 0) {
										MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_OPENGL_FEATURE)
										MU_LOCK_UNLOCK(c->wgl.si.lock, c->wgl.si.lock_active)
										MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
										return;
									}

									vptr = muCOSA_Win32_opengl_get_function_address((muByte*)"wglSwapIntervalEXT");
									mu_memcpy(&c->wgl.si.wglSwapIntervalEXT, &vptr, sizeof(void*));
								}

								if (c->wgl.si.wglSwapIntervalEXT == 0) {
									MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_OPENGL_FEATURE)
									MU_LOCK_UNLOCK(c->wgl.si.lock, c->wgl.si.lock_active)
									MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
									return;
								}

								c->wgl.si.wglSwapIntervalEXT(interval);

								MU_LOCK_UNLOCK(c->wgl.si.lock, c->wgl.si.lock_active)

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							#endif
						}

					/* Vulkan */

						#if defined(MUCOSA_VULKAN) && !defined(MUCOSA_NO_INCLUDE_VULKAN)
							#include MUCOSA_VULKAN_INCLUDE_PATH
						#endif

						const char** muCOSA_Win32_vulkan_get_surface_instance_extensions(muCOSAResult* result, size_m* count) {
							#ifndef MUCOSA_VULKAN
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
								return 0;
								if (count) {}
							#else
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								static const char* exts[] = { "VK_KHR_surface", "VK_KHR_win32_surface" };
								MU_SET_RESULT(count, 2)
								return (const char**)exts;
							#endif
						}

						void muCOSA_Win32_vulkan_create_window_surface(muCOSAResult* result, muCOSA_Win32Context* c, muWindow window, void* vk_result, void* instance, void* allocator, void* surface) {
							#ifndef MUCOSA_VULKAN
								MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_GRAPHICS_API)
								return;
								if (c) {} if (window) {} if (vk_result) {} if (instance) {} if (allocator) {} if (surface) {}
							#else
								MU_SET_RESULT(result, MUCOSA_SUCCESS)
								MU_HOLD(result, window, c->windows, muCOSA_global_context, MUCOSA_, return;, muCOSA_Win32Window_)

								VkWin32SurfaceCreateInfoKHR ci = MU_ZERO_STRUCT(VkWin32SurfaceCreateInfoKHR);
								ci.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
								ci.hinstance = c->windows.data[window].hinstance;
								ci.hwnd = c->windows.data[window].hwnd;

								VkInstance r_instance = VK_NULL_HANDLE;
								if (instance != 0) {
									r_instance = *((VkInstance*)instance);
								}

								VkResult vkres = vkCreateWin32SurfaceKHR(r_instance, &ci, (const VkAllocationCallbacks*)allocator, (VkSurfaceKHR*)surface);
								if (vk_result != 0) {
									*((VkResult*)vk_result) = vkres;
								}

								MU_RELEASE(c->windows, window, muCOSA_Win32Window_)
							#endif
						}
			#else
				#define MUCOSA_WIN32_CALL(...)
			#endif /* MUCOSA_WIN32 */

			/* API-level functions */

				/* Names */

					#ifdef MUCOSA_NAMES
						MUDEF const char* muCOSA_result_get_name(muCOSAResult result) {
							switch (result) {
								default: return "MUCOSA_UNKNOWN"; break;
								case MUCOSA_SUCCESS: return "MUCOSA_SUCCESS"; break;
								case MUCOSA_ALREADY_INITIALIZED: return "MUCOSA_ALREADY_INITIALIZED"; break;
								case MUCOSA_ALREADY_TERMINATED: return "MUCOSA_ALREADY_TERMINATED"; break;
								case MUCOSA_ALREADY_ACTIVE: return "MUCOSA_ALREADY_ACTIVE"; break;
								case MUCOSA_ALREADY_INACTIVE: return "MUCOSA_ALREADY_INACTIVE"; break;
								case MUCOSA_NOT_YET_INITIALIZED: return "MUCOSA_NOT_YET_INITIALIZED"; break;
								case MUCOSA_ALLOCATION_FAILED: return "MUCOSA_ALLOCATION_FAILED"; break;
								case MUCOSA_UNKNOWN_WINDOW_SYSTEM: return "MUCOSA_UNKNOWN_WINDOW_SYSTEM"; break;
								case MUCOSA_UNKNOWN_GRAPHICS_API: return "MUCOSA_UNKNOWN_GRAPHICS_API"; break;
								case MUCOSA_UNKNOWN_KEYBOARD_KEY: return "MUCOSA_UNKNOWN_KEYBOARD_KEY"; break;
								case MUCOSA_UNKNOWN_KEYBOARD_STATE: return "MUCOSA_UNKNOWN_KEYBOARD_STATE"; break;
								case MUCOSA_UNKNOWN_MOUSE_BUTTON: return "MUCOSA_UNKNOWN_MOUSE_BUTTON"; break;
								case MUCOSA_UNKNOWN_WINDOW_HANDLE: return "MUCOSA_UNKNOWN_WINDOW_HANDLE"; break;
								case MUCOSA_UNSUPPORTED_WINDOW_SYSTEM: return "MUCOSA_UNSUPPORTED_WINDOW_SYSTEM"; break;
								case MUCOSA_UNSUPPORTED_FEATURE: return "MUCOSA_UNSUPPORTED_FEATURE"; break;
								case MUCOSA_UNSUPPORTED_OPENGL_FEATURE: return "MUCOSA_UNSUPPORTED_OPENGL_FEATURE"; break;
								case MUCOSA_UNSUPPORTED_GRAPHICS_API: return "MUCOSA_UNSUPPORTED_GRAPHICS_API"; break;
								case MUCOSA_FAILED_CONNECTION_TO_SERVER: return "MUCOSA_FAILED_CONNECTION_TO_SERVER"; break;
								case MUCOSA_FAILED_CREATE_WINDOW: return "MUCOSA_FAILED_CREATE_WINDOW"; break;
								case MUCOSA_FAILED_LOAD_FUNCTIONS: return "MUCOSA_FAILED_LOAD_FUNCTIONS"; break;
								case MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER: return "MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER"; break;
								case MUCOSA_FAILED_CREATE_OPENGL_CONTEXT: return "MUCOSA_FAILED_CREATE_OPENGL_CONTEXT"; break;
								case MUCOSA_FAILED_LOAD_OPENGL_CONTEXT: return "MUCOSA_FAILED_LOAD_OPENGL_CONTEXT"; break;
								case MUCOSA_FAILED_USE_PIXEL_FORMAT: return "MUCOSA_FAILED_USE_PIXEL_FORMAT"; break;
								case MUCOSA_FAILED_JOIN_THREAD: return "MUCOSA_FAILED_JOIN_THREAD"; break;
								case MUCOSA_FAILED_CREATE_THREAD: return "MUCOSA_FAILED_CREATE_THREAD"; break;
								case MUCOSA_FAILED_CREATE_INPUT_METHOD: return "MUCOSA_FAILED_CREATE_INPUT_METHOD"; break;
								case MUCOSA_FAILED_GET_INPUT_STYLES: return "MUCOSA_FAILED_GET_INPUT_STYLES"; break;
								case MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE: return "MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE"; break;
								case MUCOSA_FAILED_CREATE_INPUT_CONTEXT: return "MUCOSA_FAILED_CREATE_INPUT_CONTEXT"; break;
								case MUCOSA_FAILED_REGISTER_WINDOW_CLASS: return "MUCOSA_FAILED_REGISTER_WINDOW_CLASS"; break;
								case MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR: return "MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR"; break;
								case MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8: return "MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8"; break;
								case MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS: return "MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS"; break;
								case MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW: return "MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW"; break;
								case MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT: return "MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT"; break;
								case MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT: return "MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT"; break;
								case MUCOSA_FAILED_SET_PIXEL_FORMAT: return "MUCOSA_FAILED_SET_PIXEL_FORMAT"; break;
								case MUCOSA_FAILED_QUERY_WINDOW_INFO: return "MUCOSA_FAILED_QUERY_WINDOW_INFO"; break;
								case MUCOSA_FAILED_SET_WINDOW_INFO: return "MUCOSA_FAILED_SET_WINDOW_INFO"; break;
								case MUCOSA_FAILED_GET_IMM_CONTEXT: return "MUCOSA_FAILED_GET_IMM_CONTEXT"; break;
								case MUCOSA_FAILED_LET_IMM_CONTEXT: return "MUCOSA_FAILED_LET_IMM_CONTEXT"; break;
								case MUCOSA_FAILED_GLOBAL_ALLOCATION: return "MUCOSA_FAILED_GLOBAL_ALLOCATION"; break;
								case MUCOSA_FAILED_GLOBAL_LOCK: return "MUCOSA_FAILED_GLOBAL_LOCK"; break;
								case MUCOSA_FAILED_HOLD_CLIPBOARD: return "MUCOSA_FAILED_HOLD_CLIPBOARD"; break;
								case MUCOSA_FAILED_SET_CLIPBOARD: return "MUCOSA_FAILED_SET_CLIPBOARD"; break;
								case MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS: return "MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS"; break;
								case MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS: return "MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS"; break;
								case MUCOSA_INVALID_ID: return "MUCOSA_INVALID_ID"; break;
								case MUCOSA_INVALID_SAMPLE_COUNT: return "MUCOSA_INVALID_SAMPLE_COUNT"; break;
								case MUCOSA_INVALID_DIMENSIONS: return "MUCOSA_INVALID_DIMENSIONS"; break;
								case MUCOSA_INVALID_POINTER: return "MUCOSA_INVALID_POINTER"; break;
								case MUCOSA_INVALID_WINDOW_STATE: return "MUCOSA_INVALID_WINDOW_STATE"; break;
								case MUCOSA_INVALID_TIME: return "MUCOSA_INVALID_TIME"; break;
								case MUCOSA_NONEXISTENT_DEVICE: return "MUCOSA_NONEXISTENT_DEVICE"; break;
								case MUCOSA_OVERSIZED_CLIPBOARD: return "MUCOSA_OVERSIZED_CLIPBOARD"; break;
								case MUCOSA_WINDOW_NON_RESIZABLE: return "MUCOSA_WINDOW_NON_RESIZABLE"; break;
								case MUCOSA_MUMA_SUCCESS: return "MUCOSA_MUMA_SUCCESS"; break;
								case MUCOSA_MUMA_FAILED_TO_ALLOCATE: return "MUCOSA_MUMA_FAILED_TO_ALLOCATE"; break;
								case MUCOSA_MUMA_INVALID_INDEX: return "MUCOSA_MUMA_INVALID_INDEX"; break;
								case MUCOSA_MUMA_INVALID_SHIFT_AMOUNT: return "MUCOSA_MUMA_INVALID_SHIFT_AMOUNT"; break;
								case MUCOSA_MUMA_NOT_FOUND: return "MUCOSA_MUMA_NOT_FOUND"; break;
							}
						}

						MUDEF const char* mu_window_system_get_name(muWindowSystem system) {
							switch (system) {
								default: return "MU_WINDOW_SYSTEM_UNKNOWN"; break;
								case MU_WINDOW_SYSTEM_AUTO: return "MU_WINDOW_SYSTEM_AUTO"; break;
								case MU_WINDOW_SYSTEM_X11: return "MU_WINDOW_SYSTEM_X11"; break;
								case MU_WINDOW_SYSTEM_WIN32: return "MU_WINDOW_SYSTEM_WIN32"; break;
							}
						}

						MUDEF const char* mu_window_system_get_nice_name(muWindowSystem system) {
							switch (system) {
								default: return "Unknown"; break;
								case MU_WINDOW_SYSTEM_AUTO: return "Auto"; break;
								case MU_WINDOW_SYSTEM_X11: return "X11"; break;
								case MU_WINDOW_SYSTEM_WIN32: return "Win32"; break;
							}
						}

						MUDEF const char* mu_window_handle_get_name(muWindowHandle handle) {
							switch (handle) {
								default: return "UNKNOWN"; break;
								case MU_WINDOWS_HWND: return "MU_WINDOWS_HWND"; break;
								case MU_X11_DISPLAY: return "MU_X11_DISPLAY"; break;
								case MU_X11_WINDOW: return "MU_X11_WINDOW"; break;
								case MU_X11_PARENT_WINDOW: return "MU_X11_PARENT_WINDOW"; break;
							}
						}

						MUDEF const char* mu_window_handle_get_nice_name(muWindowHandle handle) {
							switch (handle) {
								default: return "Unknown"; break;
								case MU_WINDOWS_HWND: return "HWND"; break;
								case MU_X11_DISPLAY: return "Display"; break;
								case MU_X11_WINDOW: return "Window"; break;
								case MU_X11_PARENT_WINDOW: return "Parent Window"; break;
							}
						}

						MUDEF const char* mu_graphics_api_get_name(muGraphicsAPI api) {
							switch (api) {
								default: return "UNKNOWN"; break;
								case MU_NO_GRAPHICS_API: return "MU_NO_GRAPHICS_API"; break;
								case MU_OPENGL_1_0: return "MU_OPENGL_1_0"; break;
								case MU_OPENGL_1_1: return "MU_OPENGL_1_1"; break;
								case MU_OPENGL_1_2: return "MU_OPENGL_1_2"; break;
								case MU_OPENGL_1_2_1: return "MU_OPENGL_1_2_1"; break;
								case MU_OPENGL_1_3: return "MU_OPENGL_1_3"; break;
								case MU_OPENGL_1_4: return "MU_OPENGL_1_4"; break;
								case MU_OPENGL_1_5: return "MU_OPENGL_1_5"; break;
								case MU_OPENGL_2_0: return "MU_OPENGL_2_0"; break;
								case MU_OPENGL_2_1: return "MU_OPENGL_2_1"; break;
								case MU_OPENGL_3_0: return "MU_OPENGL_3_0"; break;
								case MU_OPENGL_3_1: return "MU_OPENGL_3_1"; break;
								case MU_OPENGL_3_2_CORE:          return "MU_OPENGL_3_2_CORE"; break;
								case MU_OPENGL_3_2_COMPATIBILITY: return "MU_OPENGL_3_2_COMPATIBILITY"; break;
								case MU_OPENGL_3_3_CORE:          return "MU_OPENGL_3_3_CORE"; break;
								case MU_OPENGL_3_3_COMPATIBILITY: return "MU_OPENGL_3_3_COMPATIBILITY"; break;
								case MU_OPENGL_4_0_CORE:          return "MU_OPENGL_4_0_CORE"; break;
								case MU_OPENGL_4_0_COMPATIBILITY: return "MU_OPENGL_4_0_COMPATIBILITY"; break;
								case MU_OPENGL_4_1_CORE:          return "MU_OPENGL_4_1_CORE"; break;
								case MU_OPENGL_4_1_COMPATIBILITY: return "MU_OPENGL_4_1_COMPATIBILITY"; break;
								case MU_OPENGL_4_2_CORE:          return "MU_OPENGL_4_2_CORE"; break;
								case MU_OPENGL_4_2_COMPATIBILITY: return "MU_OPENGL_4_2_COMPATIBILITY"; break;
								case MU_OPENGL_4_3_CORE:          return "MU_OPENGL_4_3_CORE"; break;
								case MU_OPENGL_4_3_COMPATIBILITY: return "MU_OPENGL_4_3_COMPATIBILITY"; break;
								case MU_OPENGL_4_4_CORE:          return "MU_OPENGL_4_4_CORE"; break;
								case MU_OPENGL_4_4_COMPATIBILITY: return "MU_OPENGL_4_4_COMPATIBILITY"; break;
								case MU_OPENGL_4_5_CORE:          return "MU_OPENGL_4_5_CORE"; break;
								case MU_OPENGL_4_5_COMPATIBILITY: return "MU_OPENGL_4_5_COMPATIBILITY"; break;
								case MU_OPENGL_4_6_CORE:          return "MU_OPENGL_4_6_CORE"; break;
								case MU_OPENGL_4_6_COMPATIBILITY: return "MU_OPENGL_4_6_COMPATIBILITY"; break;
							}
						}

						MUDEF const char* mu_graphics_api_get_nice_name(muGraphicsAPI api) {
							switch (api) {
								default: return "Unknown"; break;
								case MU_NO_GRAPHICS_API: return "None"; break;
								case MU_OPENGL_1_0: return "OpenGL 1.0"; break;
								case MU_OPENGL_1_1: return "OpenGL 1.1"; break;
								case MU_OPENGL_1_2: return "OpenGL 1.2"; break;
								case MU_OPENGL_1_2_1: return "OpenGL 1.2.1"; break;
								case MU_OPENGL_1_3: return "OpenGL 1.3"; break;
								case MU_OPENGL_1_4: return "OpenGL 1.4"; break;
								case MU_OPENGL_1_5: return "OpenGL 1.5"; break;
								case MU_OPENGL_2_0: return "OpenGL 2.0"; break;
								case MU_OPENGL_2_1: return "OpenGL 2.1"; break;
								case MU_OPENGL_3_0: return "OpenGL 3.0"; break;
								case MU_OPENGL_3_1: return "OpenGL 3.1"; break;
								case MU_OPENGL_3_2_CORE:          return "OpenGL 3.2 Core"; break;
								case MU_OPENGL_3_2_COMPATIBILITY: return "OpenGL 3.2 Compatibility"; break;
								case MU_OPENGL_3_3_CORE:          return "OpenGL 3.3 Core"; break;
								case MU_OPENGL_3_3_COMPATIBILITY: return "OpenGL 3.3 Compatibility"; break;
								case MU_OPENGL_4_0_CORE:          return "OpenGL 4.0 Core"; break;
								case MU_OPENGL_4_0_COMPATIBILITY: return "OpenGL 4.0 Compatibility"; break;
								case MU_OPENGL_4_1_CORE:          return "OpenGL 4.1 Core"; break;
								case MU_OPENGL_4_1_COMPATIBILITY: return "OpenGL 4.1 Compatibility"; break;
								case MU_OPENGL_4_2_CORE:          return "OpenGL 4.2 Core"; break;
								case MU_OPENGL_4_2_COMPATIBILITY: return "OpenGL 4.2 Compatibility"; break;
								case MU_OPENGL_4_3_CORE:          return "OpenGL 4.3 Core"; break;
								case MU_OPENGL_4_3_COMPATIBILITY: return "OpenGL 4.3 Compatibility"; break;
								case MU_OPENGL_4_4_CORE:          return "OpenGL 4.4 Core"; break;
								case MU_OPENGL_4_4_COMPATIBILITY: return "OpenGL 4.4 Compatibility"; break;
								case MU_OPENGL_4_5_CORE:          return "OpenGL 4.5 Core"; break;
								case MU_OPENGL_4_5_COMPATIBILITY: return "OpenGL 4.5 Compatibility"; break;
								case MU_OPENGL_4_6_CORE:          return "OpenGL 4.6 Core"; break;
								case MU_OPENGL_4_6_COMPATIBILITY: return "OpenGL 4.6 Compatibility"; break;
							}
						}

						MUDEF const char* mu_cursor_style_get_name(muCursorStyle style) {
							switch (style) {
								default: return "MU_CURSOR_STYLE_UNKNOWN"; break;
								case MU_CURSOR_STYLE_DEFAULT: return "MU_CURSOR_STYLE_DEFAULT"; break;
								case MU_CURSOR_STYLE_ARROW: return "MU_CURSOR_STYLE_ARROW"; break;
								case MU_CURSOR_STYLE_IBEAM: return "MU_CURSOR_STYLE_IBEAM"; break;
								case MU_CURSOR_STYLE_WAIT: return "MU_CURSOR_STYLE_WAIT"; break;
								case MU_CURSOR_STYLE_WAIT_ARROW: return "MU_CURSOR_STYLE_WAIT_ARROW"; break;
								case MU_CURSOR_STYLE_CROSSHAIR: return "MU_CURSOR_STYLE_CROSSHAIR"; break;
								case MU_CURSOR_STYLE_HAND: return "MU_CURSOR_STYLE_HAND"; break;
								case MU_CURSOR_STYLE_SIZE_EAST_WEST: return "MU_CURSOR_STYLE_SIZE_EAST_WEST"; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_SOUTH: return "MU_CURSOR_STYLE_SIZE_NORTH_SOUTH"; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_EAST_SOUTH_WEST: return "MU_CURSOR_STYLE_SIZE_NORTH_EAST_SOUTH_WEST"; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_WEST_SOUTH_EAST: return "MU_CURSOR_STYLE_SIZE_NORTH_WEST_SOUTH_EAST"; break;
								case MU_CURSOR_STYLE_SIZE_ALL: return "MU_CURSOR_STYLE_SIZE_ALL"; break;
								case MU_CURSOR_STYLE_NO: return "MU_CURSOR_STYLE_NO"; break;
							}
						}

						MUDEF const char* mu_cursor_style_get_nice_name(muCursorStyle style) {
							switch (style) {
								default: return "Unknown"; break;
								case MU_CURSOR_STYLE_DEFAULT: return "Default"; break;
								case MU_CURSOR_STYLE_ARROW: return "Arrow"; break;
								case MU_CURSOR_STYLE_IBEAM: return "I-Beam"; break;
								case MU_CURSOR_STYLE_WAIT: return "Wait"; break;
								case MU_CURSOR_STYLE_WAIT_ARROW: return "Wait Arrow"; break;
								case MU_CURSOR_STYLE_CROSSHAIR: return "Crosshair"; break;
								case MU_CURSOR_STYLE_HAND: return "Hand"; break;
								case MU_CURSOR_STYLE_SIZE_EAST_WEST: return "Size East-West"; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_SOUTH: return "Size North-South"; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_EAST_SOUTH_WEST: return "Size North-East South-West"; break;
								case MU_CURSOR_STYLE_SIZE_NORTH_WEST_SOUTH_EAST: return "Size North-West South-East"; break;
								case MU_CURSOR_STYLE_SIZE_ALL: return "Size All"; break;
								case MU_CURSOR_STYLE_NO: return "No"; break;
							}
						}

						MUDEF const char* mu_keyboard_key_get_name(muKeyboardKey key) {
							switch (key) {
								default: return "MU_KEYBOARD_KEY_UNKNOWN"; break;
								case MU_KEYBOARD_KEY_BACKSPACE: return "MU_KEYBOARD_KEY_BACKSPACE"; break;
								case MU_KEYBOARD_KEY_TAB: return "MU_KEYBOARD_KEY_TAB"; break;
								case MU_KEYBOARD_KEY_CLEAR: return "MU_KEYBOARD_KEY_CLEAR"; break;
								case MU_KEYBOARD_KEY_RETURN: return "MU_KEYBOARD_KEY_RETURN"; break;
								case MU_KEYBOARD_KEY_PAUSE: return "MU_KEYBOARD_KEY_PAUSE"; break;
								case MU_KEYBOARD_KEY_ESCAPE: return "MU_KEYBOARD_KEY_ESCAPE"; break;
								case MU_KEYBOARD_KEY_MODECHANGE: return "MU_KEYBOARD_KEY_MODECHANGE"; break;
								case MU_KEYBOARD_KEY_SPACE: return "MU_KEYBOARD_KEY_SPACE"; break;
								case MU_KEYBOARD_KEY_PRIOR: return "MU_KEYBOARD_KEY_PRIOR"; break;
								case MU_KEYBOARD_KEY_NEXT: return "MU_KEYBOARD_KEY_NEXT"; break;
								case MU_KEYBOARD_KEY_END: return "MU_KEYBOARD_KEY_END"; break;
								case MU_KEYBOARD_KEY_HOME: return "MU_KEYBOARD_KEY_HOME"; break;
								case MU_KEYBOARD_KEY_LEFT: return "MU_KEYBOARD_KEY_LEFT"; break;
								case MU_KEYBOARD_KEY_UP: return "MU_KEYBOARD_KEY_UP"; break;
								case MU_KEYBOARD_KEY_RIGHT: return "MU_KEYBOARD_KEY_RIGHT"; break;
								case MU_KEYBOARD_KEY_DOWN: return "MU_KEYBOARD_KEY_DOWN"; break;
								case MU_KEYBOARD_KEY_SELECT: return "MU_KEYBOARD_KEY_SELECT"; break;
								case MU_KEYBOARD_KEY_PRINT: return "MU_KEYBOARD_KEY_PRINT"; break;
								case MU_KEYBOARD_KEY_EXECUTE: return "MU_KEYBOARD_KEY_EXECUTE"; break;
								case MU_KEYBOARD_KEY_INSERT: return "MU_KEYBOARD_KEY_INSERT"; break;
								case MU_KEYBOARD_KEY_DELETE: return "MU_KEYBOARD_KEY_DELETE"; break;
								case MU_KEYBOARD_KEY_HELP: return "MU_KEYBOARD_KEY_HELP"; break;
								case MU_KEYBOARD_KEY_0: return "MU_KEYBOARD_KEY_0"; break;
								case MU_KEYBOARD_KEY_1: return "MU_KEYBOARD_KEY_1"; break;
								case MU_KEYBOARD_KEY_2: return "MU_KEYBOARD_KEY_2"; break;
								case MU_KEYBOARD_KEY_3: return "MU_KEYBOARD_KEY_3"; break;
								case MU_KEYBOARD_KEY_4: return "MU_KEYBOARD_KEY_4"; break;
								case MU_KEYBOARD_KEY_5: return "MU_KEYBOARD_KEY_5"; break;
								case MU_KEYBOARD_KEY_6: return "MU_KEYBOARD_KEY_6"; break;
								case MU_KEYBOARD_KEY_7: return "MU_KEYBOARD_KEY_7"; break;
								case MU_KEYBOARD_KEY_8: return "MU_KEYBOARD_KEY_8"; break;
								case MU_KEYBOARD_KEY_9: return "MU_KEYBOARD_KEY_9"; break;
								case MU_KEYBOARD_KEY_A: return "MU_KEYBOARD_KEY_A"; break;
								case MU_KEYBOARD_KEY_B: return "MU_KEYBOARD_KEY_B"; break;
								case MU_KEYBOARD_KEY_C: return "MU_KEYBOARD_KEY_C"; break;
								case MU_KEYBOARD_KEY_D: return "MU_KEYBOARD_KEY_D"; break;
								case MU_KEYBOARD_KEY_E: return "MU_KEYBOARD_KEY_E"; break;
								case MU_KEYBOARD_KEY_F: return "MU_KEYBOARD_KEY_F"; break;
								case MU_KEYBOARD_KEY_G: return "MU_KEYBOARD_KEY_G"; break;
								case MU_KEYBOARD_KEY_H: return "MU_KEYBOARD_KEY_H"; break;
								case MU_KEYBOARD_KEY_I: return "MU_KEYBOARD_KEY_I"; break;
								case MU_KEYBOARD_KEY_J: return "MU_KEYBOARD_KEY_J"; break;
								case MU_KEYBOARD_KEY_K: return "MU_KEYBOARD_KEY_K"; break;
								case MU_KEYBOARD_KEY_L: return "MU_KEYBOARD_KEY_L"; break;
								case MU_KEYBOARD_KEY_M: return "MU_KEYBOARD_KEY_M"; break;
								case MU_KEYBOARD_KEY_N: return "MU_KEYBOARD_KEY_N"; break;
								case MU_KEYBOARD_KEY_O: return "MU_KEYBOARD_KEY_O"; break;
								case MU_KEYBOARD_KEY_P: return "MU_KEYBOARD_KEY_P"; break;
								case MU_KEYBOARD_KEY_Q: return "MU_KEYBOARD_KEY_Q"; break;
								case MU_KEYBOARD_KEY_R: return "MU_KEYBOARD_KEY_R"; break;
								case MU_KEYBOARD_KEY_S: return "MU_KEYBOARD_KEY_S"; break;
								case MU_KEYBOARD_KEY_T: return "MU_KEYBOARD_KEY_T"; break;
								case MU_KEYBOARD_KEY_U: return "MU_KEYBOARD_KEY_U"; break;
								case MU_KEYBOARD_KEY_V: return "MU_KEYBOARD_KEY_V"; break;
								case MU_KEYBOARD_KEY_W: return "MU_KEYBOARD_KEY_W"; break;
								case MU_KEYBOARD_KEY_X: return "MU_KEYBOARD_KEY_X"; break;
								case MU_KEYBOARD_KEY_Y: return "MU_KEYBOARD_KEY_Y"; break;
								case MU_KEYBOARD_KEY_Z: return "MU_KEYBOARD_KEY_Z"; break;
								case MU_KEYBOARD_KEY_LEFT_WINDOWS: return "MU_KEYBOARD_KEY_LEFT_WINDOWS"; break;
								case MU_KEYBOARD_KEY_RIGHT_WINDOWS: return "MU_KEYBOARD_KEY_RIGHT_WINDOWS"; break;
								case MU_KEYBOARD_KEY_NUMPAD_0: return "MU_KEYBOARD_KEY_NUMPAD_0"; break;
								case MU_KEYBOARD_KEY_NUMPAD_1: return "MU_KEYBOARD_KEY_NUMPAD_1"; break;
								case MU_KEYBOARD_KEY_NUMPAD_2: return "MU_KEYBOARD_KEY_NUMPAD_2"; break;
								case MU_KEYBOARD_KEY_NUMPAD_3: return "MU_KEYBOARD_KEY_NUMPAD_3"; break;
								case MU_KEYBOARD_KEY_NUMPAD_4: return "MU_KEYBOARD_KEY_NUMPAD_4"; break;
								case MU_KEYBOARD_KEY_NUMPAD_5: return "MU_KEYBOARD_KEY_NUMPAD_5"; break;
								case MU_KEYBOARD_KEY_NUMPAD_6: return "MU_KEYBOARD_KEY_NUMPAD_6"; break;
								case MU_KEYBOARD_KEY_NUMPAD_7: return "MU_KEYBOARD_KEY_NUMPAD_7"; break;
								case MU_KEYBOARD_KEY_NUMPAD_8: return "MU_KEYBOARD_KEY_NUMPAD_8"; break;
								case MU_KEYBOARD_KEY_NUMPAD_9: return "MU_KEYBOARD_KEY_NUMPAD_9"; break;
								case MU_KEYBOARD_KEY_MULTIPLY: return "MU_KEYBOARD_KEY_MULTIPLY"; break;
								case MU_KEYBOARD_KEY_ADD: return "MU_KEYBOARD_KEY_ADD"; break;
								case MU_KEYBOARD_KEY_SEPARATOR: return "MU_KEYBOARD_KEY_SEPARATOR"; break;
								case MU_KEYBOARD_KEY_SUBTRACT: return "MU_KEYBOARD_KEY_SUBTRACT"; break;
								case MU_KEYBOARD_KEY_DECIMAL: return "MU_KEYBOARD_KEY_DECIMAL"; break;
								case MU_KEYBOARD_KEY_DIVIDE: return "MU_KEYBOARD_KEY_DIVIDE"; break;
								case MU_KEYBOARD_KEY_F1: return "MU_KEYBOARD_KEY_F1"; break;
								case MU_KEYBOARD_KEY_F2: return "MU_KEYBOARD_KEY_F2"; break;
								case MU_KEYBOARD_KEY_F3: return "MU_KEYBOARD_KEY_F3"; break;
								case MU_KEYBOARD_KEY_F4: return "MU_KEYBOARD_KEY_F4"; break;
								case MU_KEYBOARD_KEY_F5: return "MU_KEYBOARD_KEY_F5"; break;
								case MU_KEYBOARD_KEY_F6: return "MU_KEYBOARD_KEY_F6"; break;
								case MU_KEYBOARD_KEY_F7: return "MU_KEYBOARD_KEY_F7"; break;
								case MU_KEYBOARD_KEY_F8: return "MU_KEYBOARD_KEY_F8"; break;
								case MU_KEYBOARD_KEY_F9: return "MU_KEYBOARD_KEY_F9"; break;
								case MU_KEYBOARD_KEY_F10: return "MU_KEYBOARD_KEY_F10"; break;
								case MU_KEYBOARD_KEY_F11: return "MU_KEYBOARD_KEY_F11"; break;
								case MU_KEYBOARD_KEY_F12: return "MU_KEYBOARD_KEY_F12"; break;
								case MU_KEYBOARD_KEY_F13: return "MU_KEYBOARD_KEY_F13"; break;
								case MU_KEYBOARD_KEY_F14: return "MU_KEYBOARD_KEY_F14"; break;
								case MU_KEYBOARD_KEY_F15: return "MU_KEYBOARD_KEY_F15"; break;
								case MU_KEYBOARD_KEY_F16: return "MU_KEYBOARD_KEY_F16"; break;
								case MU_KEYBOARD_KEY_F17: return "MU_KEYBOARD_KEY_F17"; break;
								case MU_KEYBOARD_KEY_F18: return "MU_KEYBOARD_KEY_F18"; break;
								case MU_KEYBOARD_KEY_F19: return "MU_KEYBOARD_KEY_F19"; break;
								case MU_KEYBOARD_KEY_F20: return "MU_KEYBOARD_KEY_F20"; break;
								case MU_KEYBOARD_KEY_F21: return "MU_KEYBOARD_KEY_F21"; break;
								case MU_KEYBOARD_KEY_F22: return "MU_KEYBOARD_KEY_F22"; break;
								case MU_KEYBOARD_KEY_F23: return "MU_KEYBOARD_KEY_F23"; break;
								case MU_KEYBOARD_KEY_F24: return "MU_KEYBOARD_KEY_F24"; break;
								case MU_KEYBOARD_KEY_NUMLOCK: return "MU_KEYBOARD_KEY_NUMLOCK"; break;
								case MU_KEYBOARD_KEY_SCROLL: return "MU_KEYBOARD_KEY_SCROLL"; break;
								case MU_KEYBOARD_KEY_LEFT_SHIFT: return "MU_KEYBOARD_KEY_LEFT_SHIFT"; break;
								case MU_KEYBOARD_KEY_RIGHT_SHIFT: return "MU_KEYBOARD_KEY_RIGHT_SHIFT"; break;
								case MU_KEYBOARD_KEY_LEFT_CONTROL: return "MU_KEYBOARD_KEY_LEFT_CONTROL"; break;
								case MU_KEYBOARD_KEY_RIGHT_CONTROL: return "MU_KEYBOARD_KEY_RIGHT_CONTROL"; break;
								case MU_KEYBOARD_KEY_LEFT_MENU: return "MU_KEYBOARD_KEY_LEFT_MENU"; break;
								case MU_KEYBOARD_KEY_RIGHT_MENU: return "MU_KEYBOARD_KEY_RIGHT_MENU"; break;
								case MU_KEYBOARD_KEY_ATTN: return "MU_KEYBOARD_KEY_ATTN"; break;
								case MU_KEYBOARD_KEY_CRSEL: return "MU_KEYBOARD_KEY_CRSEL"; break;
								case MU_KEYBOARD_KEY_EXSEL: return "MU_KEYBOARD_KEY_EXSEL"; break;
								case MU_KEYBOARD_KEY_EREOF: return "MU_KEYBOARD_KEY_EREOF"; break;
								case MU_KEYBOARD_KEY_PLAY: return "MU_KEYBOARD_KEY_PLAY"; break;
								case MU_KEYBOARD_KEY_PA1: return "MU_KEYBOARD_KEY_PA1"; break;
							}
						}

						MUDEF const char* mu_keyboard_key_get_nice_name(muKeyboardKey key) {
							switch (key) {
								default: return "Unknown"; break;
								case MU_KEYBOARD_KEY_BACKSPACE: return "Backspace"; break;
								case MU_KEYBOARD_KEY_TAB: return "Tab"; break;
								case MU_KEYBOARD_KEY_CLEAR: return "Clear"; break;
								case MU_KEYBOARD_KEY_RETURN: return "Return"; break;
								case MU_KEYBOARD_KEY_PAUSE: return "Pause"; break;
								case MU_KEYBOARD_KEY_ESCAPE: return "Escape"; break;
								case MU_KEYBOARD_KEY_MODECHANGE: return "Mode Change"; break;
								case MU_KEYBOARD_KEY_SPACE: return "Space"; break;
								case MU_KEYBOARD_KEY_PRIOR: return "Prior"; break;
								case MU_KEYBOARD_KEY_NEXT: return "Next"; break;
								case MU_KEYBOARD_KEY_END: return "End"; break;
								case MU_KEYBOARD_KEY_HOME: return "Home"; break;
								case MU_KEYBOARD_KEY_LEFT: return "Left"; break;
								case MU_KEYBOARD_KEY_UP: return "Up"; break;
								case MU_KEYBOARD_KEY_RIGHT: return "Right"; break;
								case MU_KEYBOARD_KEY_DOWN: return "Down"; break;
								case MU_KEYBOARD_KEY_SELECT: return "Select"; break;
								case MU_KEYBOARD_KEY_PRINT: return "Print"; break;
								case MU_KEYBOARD_KEY_EXECUTE: return "Execute"; break;
								case MU_KEYBOARD_KEY_INSERT: return "Insert"; break;
								case MU_KEYBOARD_KEY_DELETE: return "Delete"; break;
								case MU_KEYBOARD_KEY_HELP: return "Help"; break;
								case MU_KEYBOARD_KEY_0: return "0"; break;
								case MU_KEYBOARD_KEY_1: return "1"; break;
								case MU_KEYBOARD_KEY_2: return "2"; break;
								case MU_KEYBOARD_KEY_3: return "3"; break;
								case MU_KEYBOARD_KEY_4: return "4"; break;
								case MU_KEYBOARD_KEY_5: return "5"; break;
								case MU_KEYBOARD_KEY_6: return "6"; break;
								case MU_KEYBOARD_KEY_7: return "7"; break;
								case MU_KEYBOARD_KEY_8: return "8"; break;
								case MU_KEYBOARD_KEY_9: return "9"; break;
								case MU_KEYBOARD_KEY_A: return "A"; break;
								case MU_KEYBOARD_KEY_B: return "B"; break;
								case MU_KEYBOARD_KEY_C: return "C"; break;
								case MU_KEYBOARD_KEY_D: return "D"; break;
								case MU_KEYBOARD_KEY_E: return "E"; break;
								case MU_KEYBOARD_KEY_F: return "F"; break;
								case MU_KEYBOARD_KEY_G: return "G"; break;
								case MU_KEYBOARD_KEY_H: return "H"; break;
								case MU_KEYBOARD_KEY_I: return "I"; break;
								case MU_KEYBOARD_KEY_J: return "J"; break;
								case MU_KEYBOARD_KEY_K: return "K"; break;
								case MU_KEYBOARD_KEY_L: return "L"; break;
								case MU_KEYBOARD_KEY_M: return "M"; break;
								case MU_KEYBOARD_KEY_N: return "N"; break;
								case MU_KEYBOARD_KEY_O: return "O"; break;
								case MU_KEYBOARD_KEY_P: return "P"; break;
								case MU_KEYBOARD_KEY_Q: return "Q"; break;
								case MU_KEYBOARD_KEY_R: return "R"; break;
								case MU_KEYBOARD_KEY_S: return "S"; break;
								case MU_KEYBOARD_KEY_T: return "T"; break;
								case MU_KEYBOARD_KEY_U: return "U"; break;
								case MU_KEYBOARD_KEY_V: return "V"; break;
								case MU_KEYBOARD_KEY_W: return "W"; break;
								case MU_KEYBOARD_KEY_X: return "X"; break;
								case MU_KEYBOARD_KEY_Y: return "Y"; break;
								case MU_KEYBOARD_KEY_Z: return "Z"; break;
								case MU_KEYBOARD_KEY_LEFT_WINDOWS: return "Left Windows"; break;
								case MU_KEYBOARD_KEY_RIGHT_WINDOWS: return "Right Windows"; break;
								case MU_KEYBOARD_KEY_NUMPAD_0: return "Numpad 0"; break;
								case MU_KEYBOARD_KEY_NUMPAD_1: return "Numpad 1"; break;
								case MU_KEYBOARD_KEY_NUMPAD_2: return "Numpad 2"; break;
								case MU_KEYBOARD_KEY_NUMPAD_3: return "Numpad 3"; break;
								case MU_KEYBOARD_KEY_NUMPAD_4: return "Numpad 4"; break;
								case MU_KEYBOARD_KEY_NUMPAD_5: return "Numpad 5"; break;
								case MU_KEYBOARD_KEY_NUMPAD_6: return "Numpad 6"; break;
								case MU_KEYBOARD_KEY_NUMPAD_7: return "Numpad 7"; break;
								case MU_KEYBOARD_KEY_NUMPAD_8: return "Numpad 8"; break;
								case MU_KEYBOARD_KEY_NUMPAD_9: return "Numpad 9"; break;
								case MU_KEYBOARD_KEY_MULTIPLY: return "Multiply"; break;
								case MU_KEYBOARD_KEY_ADD: return "Add"; break;
								case MU_KEYBOARD_KEY_SEPARATOR: return "Separator"; break;
								case MU_KEYBOARD_KEY_SUBTRACT: return "Subtract"; break;
								case MU_KEYBOARD_KEY_DECIMAL: return "Decimal"; break;
								case MU_KEYBOARD_KEY_DIVIDE: return "Divide"; break;
								case MU_KEYBOARD_KEY_F1: return "F1"; break;
								case MU_KEYBOARD_KEY_F2: return "F2"; break;
								case MU_KEYBOARD_KEY_F3: return "F3"; break;
								case MU_KEYBOARD_KEY_F4: return "F4"; break;
								case MU_KEYBOARD_KEY_F5: return "F5"; break;
								case MU_KEYBOARD_KEY_F6: return "F6"; break;
								case MU_KEYBOARD_KEY_F7: return "F7"; break;
								case MU_KEYBOARD_KEY_F8: return "F8"; break;
								case MU_KEYBOARD_KEY_F9: return "F9"; break;
								case MU_KEYBOARD_KEY_F10: return "F10"; break;
								case MU_KEYBOARD_KEY_F11: return "F11"; break;
								case MU_KEYBOARD_KEY_F12: return "F12"; break;
								case MU_KEYBOARD_KEY_F13: return "F13"; break;
								case MU_KEYBOARD_KEY_F14: return "F14"; break;
								case MU_KEYBOARD_KEY_F15: return "F15"; break;
								case MU_KEYBOARD_KEY_F16: return "F16"; break;
								case MU_KEYBOARD_KEY_F17: return "F17"; break;
								case MU_KEYBOARD_KEY_F18: return "F18"; break;
								case MU_KEYBOARD_KEY_F19: return "F19"; break;
								case MU_KEYBOARD_KEY_F20: return "F20"; break;
								case MU_KEYBOARD_KEY_F21: return "F21"; break;
								case MU_KEYBOARD_KEY_F22: return "F22"; break;
								case MU_KEYBOARD_KEY_F23: return "F23"; break;
								case MU_KEYBOARD_KEY_F24: return "F24"; break;
								case MU_KEYBOARD_KEY_NUMLOCK: return "Num Lock"; break;
								case MU_KEYBOARD_KEY_SCROLL: return "Key Scroll"; break;
								case MU_KEYBOARD_KEY_LEFT_SHIFT: return "Left Shift"; break;
								case MU_KEYBOARD_KEY_RIGHT_SHIFT: return "Right Shift"; break;
								case MU_KEYBOARD_KEY_LEFT_CONTROL: return "Left Control"; break;
								case MU_KEYBOARD_KEY_RIGHT_CONTROL: return "Right Control"; break;
								case MU_KEYBOARD_KEY_LEFT_MENU: return "Left Menu"; break;
								case MU_KEYBOARD_KEY_RIGHT_MENU: return "Right Menu"; break;
								case MU_KEYBOARD_KEY_ATTN: return "Attention"; break;
								case MU_KEYBOARD_KEY_CRSEL: return "CrSel"; break;
								case MU_KEYBOARD_KEY_EXSEL: return "ExSel"; break;
								case MU_KEYBOARD_KEY_EREOF: return "Erase End Of File (EREOF)"; break;
								case MU_KEYBOARD_KEY_PLAY: return "Play"; break;
								case MU_KEYBOARD_KEY_PA1: return "PA1"; break;
							}
						}

						MUDEF const char* mu_keyboard_state_get_name(muKeyboardState state) {
							switch (state) {
								default: return "MU_KEYBOARD_STATE_UNKNOWN"; break;
								case MU_KEYBOARD_STATE_CAPS_LOCK: return "MU_KEYBOARD_STATE_CAPS_LOCK"; break;
								case MU_KEYBOARD_STATE_SCROLL_LOCK: return "MU_KEYBOARD_STATE_SCROLL_LOCK"; break;
								case MU_KEYBOARD_STATE_NUM_LOCK: return "MU_KEYBOARD_STATE_NUM_LOCK"; break;
							}
						}

						MUDEF const char* mu_keyboard_state_get_nice_name(muKeyboardState state) {
							switch (state) {
								default: return "Unknown"; break;
								case MU_KEYBOARD_STATE_CAPS_LOCK: return "Caps Lock"; break;
								case MU_KEYBOARD_STATE_SCROLL_LOCK: return "Scroll Lock"; break;
								case MU_KEYBOARD_STATE_NUM_LOCK: return "Num Lock"; break;
							}
						}

						MUDEF const char* mu_mouse_button_get_name(muMouseButton button) {
							switch (button) {
								default: return "MU_MOUSE_BUTTON_UNKNOWN"; break;
								case MU_MOUSE_BUTTON_LEFT: return "MU_MOUSE_BUTTON_LEFT"; break;
								case MU_MOUSE_BUTTON_RIGHT: return "MU_MOUSE_BUTTON_RIGHT"; break;
								case MU_MOUSE_BUTTON_MIDDLE: return "MU_MOUSE_BUTTON_MIDDLE"; break;
							}
						}

						MUDEF const char* mu_mouse_button_get_nice_name(muMouseButton button) {
							switch (button) {
								default: return "Unknown"; break;
								case MU_MOUSE_BUTTON_LEFT: return "Left"; break;
								case MU_MOUSE_BUTTON_RIGHT: return "Right"; break;
								case MU_MOUSE_BUTTON_MIDDLE: return "Middle"; break;
							}
						}
					#endif

				/* Initiation / Termination */

					struct muCOSAContext {
						muWindowSystem window_system;
						#define MUCOSA_GWINSYS muCOSA_global_context->window_system

						MUCOSA_X11_CALL(muCOSA_X11Context X11;)
						#define MUCOSA_GX11 muCOSA_global_context->X11

						MUCOSA_WIN32_CALL(muCOSA_Win32Context win32;)
						#define MUCOSA_GWIN32 muCOSA_global_context->win32
					};

					muCOSAContext* muCOSA_global_context = MU_NULL_PTR;

					MUCOSA_WIN32_CALL(
						muCOSA_Win32Context* muCOSA_Win32Context_get(void) {
							if (muCOSA_global_context == 0) {
								return 0;
							}
							return &MUCOSA_GWIN32;
						}
					)

					MUDEF void muCOSA_init(muCOSAResult* result, muWindowSystem window_system) {
						MU_SET_RESULT(result, MUCOSA_SUCCESS)

						MU_ASSERT(muCOSA_global_context == MU_NULL_PTR, result, MUCOSA_ALREADY_INITIALIZED, return;)

						muCOSA_global_context = (muCOSAContext*)mu_malloc(sizeof(muCOSAContext));
						MU_ASSERT(muCOSA_global_context != 0, result, MUCOSA_ALLOCATION_FAILED, return;)

						MUCOSA_X11_CALL(MUCOSA_GX11 = muCOSA_X11Context_init();)
						MUCOSA_WIN32_CALL(MUCOSA_GWIN32 = muCOSA_Win32Context_init();)

						if (window_system == MU_WINDOW_SYSTEM_AUTO) {
							MUCOSA_X11_CALL(
								if (muCOSA_X11_is_supported()) {
									window_system = MU_WINDOW_SYSTEM_X11;
								}
							)
							MUCOSA_WIN32_CALL(
								if (muCOSA_Win32_is_supported()) {
									window_system = MU_WINDOW_SYSTEM_WIN32;
								}
							)
						} else {
							switch (window_system) {
								default: MU_SET_RESULT(result, MUCOSA_UNKNOWN_WINDOW_SYSTEM) mu_free(muCOSA_global_context); return; break;
								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: MU_ASSERT(muCOSA_X11_is_supported(), result, MUCOSA_UNSUPPORTED_WINDOW_SYSTEM, mu_free(muCOSA_global_context); return;) break;)
								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: MU_ASSERT(muCOSA_Win32_is_supported(), result, MUCOSA_UNSUPPORTED_WINDOW_SYSTEM, mu_free(muCOSA_global_context); return;) break;)
							}
						}

						switch (window_system) {
							default: MU_SET_RESULT(result, MUCOSA_UNSUPPORTED_WINDOW_SYSTEM) mu_free(muCOSA_global_context); return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSAResult res = MUCOSA_SUCCESS;
								muCOSA_X11_init(&res, &MUCOSA_GX11);
								MU_ASSERT(res == MUCOSA_SUCCESS, result, res, mu_free(muCOSA_global_context); return;)
								MUCOSA_GWINSYS = MU_WINDOW_SYSTEM_X11;
								return;
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSAResult res = MUCOSA_SUCCESS;
								muCOSA_Win32_init(&res, &MUCOSA_GWIN32);
								MU_ASSERT(res == MUCOSA_SUCCESS, result, res, mu_free(muCOSA_global_context); return;)
								MUCOSA_GWINSYS = MU_WINDOW_SYSTEM_WIN32;
								return;
							} break;)
						}
					}

					MUDEF void muCOSA_term(muCOSAResult* result) {
						MU_SET_RESULT(result, MUCOSA_SUCCESS)
						MU_ASSERT(muCOSA_global_context != MU_NULL_PTR, result, MUCOSA_ALREADY_TERMINATED, return;)

						switch (MUCOSA_GWINSYS) {
							default: return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSAResult res = MUCOSA_SUCCESS;
								muCOSA_X11_term(&res, &MUCOSA_GX11);
								MU_ASSERT(res == MUCOSA_SUCCESS, result, res, return;)
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSAResult res = MUCOSA_SUCCESS;
								muCOSA_Win32_term(&res, &MUCOSA_GWIN32);
								MU_ASSERT(res == MUCOSA_SUCCESS, result, res, return;)
							} break;)
						}

						mu_free(muCOSA_global_context);
						muCOSA_global_context = MU_NULL_PTR;
					}

					MUDEF muWindowSystem muCOSA_get_current_window_system(muCOSAResult* result) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_WINDOW_SYSTEM_UNKNOWN;)

						return MUCOSA_GWINSYS;
					}

				/* Window */

					/* Creation / Destruction */

						MUDEF muWindowCreateInfo mu_window_default_create_info(void) {
							muWindowCreateInfo ci = MU_ZERO_STRUCT(muWindowCreateInfo);

							ci.pixel_format.red_bits = 8;
							ci.pixel_format.green_bits = 8;
							ci.pixel_format.blue_bits = 8;
							ci.pixel_format.alpha_bits = 0;
							ci.pixel_format.depth_bits = 0;
							ci.pixel_format.stencil_bits = 0;
							ci.pixel_format.samples = 1;

							ci.visible = MU_TRUE;
							ci.resizable = MU_TRUE;
							ci.minimized = MU_FALSE;
							ci.maximized = MU_FALSE;
							ci.x = 50;
							ci.y = 50;
							ci.min_width = 120; // ? Does it work on Windows?
							ci.min_height = 1; // ? Does it work on Windows?
							ci.max_width = 30720;
							ci.max_height = 17280;
							ci.cursor_style = MU_CURSOR_STYLE_DEFAULT;

							ci.dimensions_callback = MU_NULL_PTR;
							ci.position_callback = MU_NULL_PTR;
							ci.focus_callback = MU_NULL_PTR;
							ci.maximize_callback = MU_NULL_PTR;
							ci.minimize_callback = MU_NULL_PTR;

							ci.cursor_position_callback = MU_NULL_PTR;
							ci.keyboard_key_callback = MU_NULL_PTR;
							ci.keyboard_state_callback = MU_NULL_PTR;

							return ci;
						}

						MUDEF muWindow mu_window_create(muCOSAResult* result, 
							muGraphicsAPI api, muBool (*load_functions)(void),
							muByte* name, uint16_m width, uint16_m height,
							muWindowCreateInfo create_info
						) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_NONE;)

							MU_ASSERT(width >= create_info.min_width && width <= create_info.max_width &&
								height >= create_info.min_height && height <= create_info.max_height,
								result, MUCOSA_INVALID_DIMENSIONS, return MU_NONE;
							)

							switch (MUCOSA_GWINSYS) {
								default: return MU_NONE; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_create(result, &MUCOSA_GX11, api, load_functions, name, width, height, create_info);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_create(result, &MUCOSA_GWIN32, api, load_functions, name, width, height, create_info);
								} break;)
							}

							// To avoid unused parameter warnings
							if (api) {} if (load_functions) {} if (name) {} if (width) {} if (height) {} if (create_info.min_width) {}
						}

						MUDEF muWindow mu_window_destroy(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return window;)

							switch (MUCOSA_GWINSYS) {
								default: return window; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_destroy(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_destroy(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

					/* Main loop */

						MUDEF muBool mu_window_get_closed(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_TRUE;)

							switch (MUCOSA_GWINSYS) {
								default: return window; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_closed(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_closed(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_close(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_close(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_close(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_update(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_update(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_update(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_swap_buffers(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_swap_buffers(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_swap_buffers(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

					/* Get / Set */

						MUDEF muBool mu_window_get_focused(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_FALSE;)

							switch (MUCOSA_GWINSYS) {
								default: return MU_FALSE; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_focused(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_focused(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_focus(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_focus(result, &MUCOSA_GX11, window, MU_TRUE);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_focus(result, &MUCOSA_GWIN32, window, MU_TRUE);
								} break;)
							}

							if (window) {}
						}

						MUDEF muBool mu_window_get_visible(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_FALSE;)

							switch (MUCOSA_GWINSYS) {
								default: return MU_FALSE; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_visible(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_visible(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_set_visible(muCOSAResult* result, muWindow window, muBool visible) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_visible(result, &MUCOSA_GX11, window, visible);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_visible(result, &MUCOSA_GWIN32, window, visible);
								} break;)
							}

							if (window) {} if (visible) {}
						}

						MUDEF void mu_window_get_position(muCOSAResult* result, muWindow window, int32_m* x, int32_m* y) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_get_position(result, &MUCOSA_GX11, window, x, y);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_get_position(result, &MUCOSA_GWIN32, window, x, y);
								} break;)
							}

							if (window) {} if (x) {} if (y) {}
						}

						MUDEF void mu_window_set_position(muCOSAResult* result, muWindow window, int32_m x, int32_m y) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_position(result, &MUCOSA_GX11, window, x, y, MU_TRUE);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_position(result, &MUCOSA_GWIN32, window, x, y, MU_TRUE);
								} break;)
							}

							if (window) {} if (x) {} if (y) {}
						}

						MUDEF void mu_window_get_dimensions(muCOSAResult* result, muWindow window, uint32_m* width, uint32_m* height) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_get_dimensions(result, &MUCOSA_GX11, window, width, height);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_get_dimensions(result, &MUCOSA_GWIN32, window, width, height);
								} break;)
							}

							if (window) {} if (width) {} if (height) {}
						}

						MUDEF void mu_window_set_dimensions(muCOSAResult* result, muWindow window, uint32_m width, uint32_m height) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_dimensions(result, &MUCOSA_GX11, window, width, height, MU_TRUE);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_dimensions(result, &MUCOSA_GWIN32, window, width, height, MU_TRUE);
								} break;)
							}

							if (window) {} if (width) {} if (height) {}
						}

						MUDEF muBool mu_window_get_maximized(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_FALSE;)

							switch (MUCOSA_GWINSYS) {
								default: return MU_FALSE; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_maximized(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_maximized(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_set_maximized(muCOSAResult* result, muWindow window, muBool maximized) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_maximized(result, &MUCOSA_GX11, window, maximized, MU_TRUE);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_maximized(result, &MUCOSA_GWIN32, window, maximized, MU_TRUE);
								} break;)
							}

							if (window) {} if (maximized) {}
						}

						MUDEF muBool mu_window_get_minimized(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_FALSE;)

							switch (MUCOSA_GWINSYS) {
								default: return MU_FALSE; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_minimized(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_minimized(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_set_minimized(muCOSAResult* result, muWindow window, muBool minimized) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_minimized(result, &MUCOSA_GX11, window, minimized, MU_TRUE);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_minimized(result, &MUCOSA_GWIN32, window, minimized, MU_TRUE);
								} break;)
							}

							if (window) {} if (minimized) {}
						}

						MUDEF void mu_window_get_minimum_dimensions(muCOSAResult* result, muWindow window, uint32_m* min_width, uint32_m* min_height) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_get_minimum_dimensions(result, &MUCOSA_GX11, window, min_width, min_height);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_get_minimum_dimensions(result, &MUCOSA_GWIN32, window, min_width, min_height);
								} break;)
							}

							if (window) {} if (min_width) {} if (min_height) {}
						}

						MUDEF void mu_window_set_minimum_dimensions(muCOSAResult* result, muWindow window, uint32_m min_width, uint32_m min_height) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_minimum_dimensions(result, &MUCOSA_GX11, window, min_width, min_height);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_minimum_dimensions(result, &MUCOSA_GWIN32, window, min_width, min_height);
								} break;)
							}

							if (window) {} if (min_width) {} if (min_height) {}
						}

						MUDEF void mu_window_get_maximum_dimensions(muCOSAResult* result, muWindow window, uint32_m* max_width, uint32_m* max_height) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_get_maximum_dimensions(result, &MUCOSA_GX11, window, max_width, max_height);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_get_maximum_dimensions(result, &MUCOSA_GWIN32, window, max_width, max_height);
								} break;)
							}

							if (window) {} if (max_width) {} if (max_height) {}
						}

						MUDEF void mu_window_set_maximum_dimensions(muCOSAResult* result, muWindow window, uint32_m max_width, uint32_m max_height) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_maximum_dimensions(result, &MUCOSA_GX11, window, max_width, max_height);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_maximum_dimensions(result, &MUCOSA_GWIN32, window, max_width, max_height);
								} break;)
							}

							if (window) {} if (max_width) {} if (max_height) {}
						}

						MUDEF void mu_window_get_cursor_position(muCOSAResult* result, muWindow window, int32_m* x, int32_m* y) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_get_cursor_position(result, &MUCOSA_GX11, window, x, y);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_get_cursor_position(result, &MUCOSA_GWIN32, window, x, y);
								} break;)
							}

							if (window) {} if (x) {} if (y) {}
						}

						MUDEF void mu_window_set_cursor_position(muCOSAResult* result, muWindow window, int32_m x, int32_m y) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_cursor_position(result, &MUCOSA_GX11, window, x, y, MU_TRUE);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_cursor_position(result, &MUCOSA_GWIN32, window, x, y, MU_TRUE);
								} break;)
							}

							if (window) {} if (x) {} if (y) {}
						}

						MUDEF muCursorStyle mu_window_get_cursor_style(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_CURSOR_STYLE_UNKNOWN;)

							switch (MUCOSA_GWINSYS) {
								default: return MU_CURSOR_STYLE_UNKNOWN; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_cursor_style(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_cursor_style(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_set_cursor_style(muCOSAResult* result, muWindow window, muCursorStyle style) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_cursor_style(result, &MUCOSA_GX11, window, style);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_cursor_style(result, &MUCOSA_GWIN32, window, style);
								} break;)
							}

							if (window) {} if (style) {}
						}

						MUDEF int32_m mu_window_get_scroll_level(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return 0;)

							switch (MUCOSA_GWINSYS) {
								default: return 0; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_scroll_level(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_scroll_level(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

						MUDEF void mu_window_set_scroll_level(muCOSAResult* result, muWindow window, int32_m scroll_level) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_scroll_level(result, &MUCOSA_GX11, window, scroll_level, MU_TRUE);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_scroll_level(result, &MUCOSA_GWIN32, window, scroll_level, MU_TRUE);
								} break;)
							}

							if (window) {} if (scroll_level) {}
						}

					/* Get / Let */

						MUDEF void mu_window_get_text_input_focus(muCOSAResult* result, muWindow window, int32_m text_cursor_x, int32_m text_cursor_y, void (*callback)(muWindow window, muByte* input)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_get_text_input_focus(result, &MUCOSA_GX11, window, text_cursor_x, text_cursor_y, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_get_text_input_focus(result, &MUCOSA_GWIN32, window, text_cursor_x, text_cursor_y, callback);
								} break;)
							}

							if (window) {} if (text_cursor_x) {} if (text_cursor_y) {} if (callback) {}
						}

						MUDEF void mu_window_update_text_cursor(muCOSAResult* result, muWindow window, int32_m x, int32_m y) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_update_text_cursor(result, &MUCOSA_GX11, window, x, y);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_update_text_cursor(result, &MUCOSA_GWIN32, window, x, y);
								} break;)
							}

							if (window) {} if (x) {} if (y) {}
						}

						MUDEF void mu_window_let_text_input_focus(muCOSAResult* result, muWindow window) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_let_text_input_focus(result, &MUCOSA_GX11, window);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_let_text_input_focus(result, &MUCOSA_GWIN32, window);
								} break;)
							}

							if (window) {}
						}

					/* Get */

						MUDEF void mu_window_get_frame_extents(muCOSAResult* result, muWindow window, uint32_m* left, uint32_m* right, uint32_m* top, uint32_m* bottom) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_get_frame_extents(result, &MUCOSA_GX11, window, left, right, top, bottom);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_get_frame_extents(result, &MUCOSA_GWIN32, window, left, right, top, bottom);
								} break;)
							}

							if (window) {} if (left) {} if (right) {} if (top) {} if (bottom) {}
						}

						MUDEF muButtonState mu_window_get_keyboard_key_state(muCOSAResult* result, muWindow window, muKeyboardKey key) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return 0;)

							switch (MUCOSA_GWINSYS) {
								default: return 0; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_keyboard_key_state(result, &MUCOSA_GX11, window, key);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_keyboard_key_state(result, &MUCOSA_GWIN32, window, key);
								} break;)
							}

							if (window) {} if (key) {}
						}

						MUDEF muState mu_window_get_keyboard_state_state(muCOSAResult* result, muWindow window, muKeyboardState state) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return 0;)

							switch (MUCOSA_GWINSYS) {
								default: return 0; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_keyboard_state_state(result, &MUCOSA_GX11, window, state);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_keyboard_state_state(result, &MUCOSA_GWIN32, window, state);
								} break;)
							}

							if (window) {} if (state) {}
						}

						MUDEF muButtonState mu_window_get_mouse_button_state(muCOSAResult* result, muWindow window, muMouseButton button) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return 0;)

							switch (MUCOSA_GWINSYS) {
								default: return 0; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									return muCOSA_X11_window_get_mouse_button_state(result, &MUCOSA_GX11, window, button);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									return muCOSA_Win32_window_get_mouse_button_state(result, &MUCOSA_GWIN32, window, button);
								} break;)
							}

							if (window) {} if (button) {}
						}

					/* Set */

						MUDEF void mu_window_set_title(muCOSAResult* result, muWindow window, muByte* title) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							MU_ASSERT(title != 0, result, MUCOSA_INVALID_POINTER, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_title(result, &MUCOSA_GX11, window, title);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_title(result, &MUCOSA_GWIN32, window, title);
								} break;)
							}

							if (window) {} if (title) {}
						}

						MUDEF void mu_window_set_dimensions_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, uint32_m width, uint32_m height)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_dimensions_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_dimensions_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

						MUDEF void mu_window_set_position_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, int32_m x, int32_m y)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_position_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_position_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

						MUDEF void mu_window_set_focus_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muBool focused)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_focus_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_focus_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

						MUDEF void mu_window_set_maximize_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muBool maximized)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_maximize_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_maximize_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

						MUDEF void mu_window_set_minimize_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muBool minimized)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_minimize_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_minimize_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

						MUDEF void mu_window_set_keyboard_key_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muKeyboardKey keyboard_key, muButtonState state)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_keyboard_key_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_keyboard_key_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

						MUDEF void mu_window_set_keyboard_state_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muKeyboardState keyboard_state, muState state)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_keyboard_state_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_keyboard_state_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

						MUDEF void mu_window_set_mouse_button_callback(muCOSAResult* result, muWindow window, void (*callback)(muWindow window, muMouseButton mouse_button, muButtonState state)) {
							MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

							switch (MUCOSA_GWINSYS) {
								default: return; break;

								MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
									muCOSA_X11_window_set_mouse_button_callback(result, &MUCOSA_GX11, window, callback);
								} break;)

								MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
									muCOSA_Win32_window_set_mouse_button_callback(result, &MUCOSA_GWIN32, window, callback);
								} break;)
							}

							if (window) {} if (callback) {}
						}

				/* Time */

					MUDEF double mu_time_get(muCOSAResult* result) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return 0.f;)

						switch (MUCOSA_GWINSYS) {
							default: return 0.f; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								return muCOSA_X11_time_get(result, &MUCOSA_GX11);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								return muCOSA_Win32_time_get(result, &MUCOSA_GWIN32);
							} break;)
						}
					}

					MUDEF void mu_time_set(muCOSAResult* result, double time) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

						switch (MUCOSA_GWINSYS) {
							default: return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSA_X11_time_set(result, &MUCOSA_GX11, time);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSA_Win32_time_set(result, &MUCOSA_GWIN32, time);
							} break;)
						}

						if (time) {}
					}

					MUDEF void mu_sleep(muCOSAResult* result, double time) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

						switch (MUCOSA_GWINSYS) {
							default: return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSA_X11_sleep(result, &MUCOSA_GX11, time);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSA_Win32_sleep(result, &MUCOSA_GWIN32, time);
							} break;)
						}

						if (time) {}
					}

				/* Clipboard */

					MUDEF muByte* mu_clipboard_get(muCOSAResult* result) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return 0;)

						switch (MUCOSA_GWINSYS) {
							default: return 0; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								return muCOSA_X11_clipboard_get(result, &MUCOSA_GX11);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								return muCOSA_Win32_clipboard_get(result, &MUCOSA_GWIN32);
							} break;)
						}
					}

					MUDEF void mu_clipboard_set(muCOSAResult* result, muByte* text, size_m text_size) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

						switch (MUCOSA_GWINSYS) {
							default: return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSA_X11_clipboard_set(result, &MUCOSA_GX11, text, text_size);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSA_Win32_clipboard_set(result, &MUCOSA_GWIN32, text, text_size);
							} break;)
						}

						if (text) {} if (text_size) {}
					}

				/* OS functions */

					MUDEF void* mu_os_get_window_handle(muCOSAResult* result, muWindow window, muWindowHandle handle) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_NULL_PTR;)

						switch (MUCOSA_GWINSYS) {
							default: return MU_NULL_PTR; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								return muCOSA_X11_os_get_window_handle(result, &MUCOSA_GX11, window, handle);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								return muCOSA_Win32_os_get_window_handle(result, &MUCOSA_GWIN32, window, handle);
							} break;)
						}

						if (window) {} if (handle) {}
					}

				/* OpenGL */

					MUDEF void mu_opengl_bind_window(muCOSAResult* result, muWindow window) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

						switch (MUCOSA_GWINSYS) {
							default: return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSA_X11_opengl_bind_window(result, &MUCOSA_GX11, window);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSA_Win32_opengl_bind_window(result, &MUCOSA_GWIN32, window);
							} break;)
						}

						if (window) {}
					}

					MUDEF void* mu_opengl_get_function_address(const muByte* name) {
						if (muCOSA_global_context == 0) {
							return 0;
						}

						switch (MUCOSA_GWINSYS) {
							default: return 0; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								return muCOSA_X11_opengl_get_function_address(name);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								return muCOSA_Win32_opengl_get_function_address(name);
							} break;)
						}

						if (name) {}
					}

					MUDEF void mu_opengl_window_swap_interval(muCOSAResult* result, muWindow window, int interval) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

						switch (MUCOSA_GWINSYS) {
							default: return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSA_X11_opengl_window_swap_interval(result, &MUCOSA_GX11, window, interval);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSA_Win32_opengl_window_swap_interval(result, &MUCOSA_GWIN32, window, interval);
							} break;)
						}

						if (window) {} if (interval) {}
					}

				/* Vulkan */

					// Note: also not necessarily UTF-8
					MUDEF const char** mu_vulkan_get_surface_instance_extensions(muCOSAResult* result, size_m* count) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return MU_NULL_PTR;)

						switch (MUCOSA_GWINSYS) {
							default: return MU_NULL_PTR; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								return muCOSA_X11_vulkan_get_surface_instance_extensions(result, count);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								return muCOSA_Win32_vulkan_get_surface_instance_extensions(result, count);
							} break;)
						}

						if (count) {}
					}

					MUDEF void mu_vulkan_create_window_surface(muCOSAResult* result, muWindow window, void* vk_result, void* instance, void* allocator, void* surface) {
						MU_SAFEFUNC(result, MUCOSA_, muCOSA_global_context, return;)

						switch (MUCOSA_GWINSYS) {
							default: return; break;

							MUCOSA_X11_CALL(case MU_WINDOW_SYSTEM_X11: {
								muCOSA_X11_vulkan_create_window_surface(result, &MUCOSA_GX11, window, vk_result, instance, allocator, surface);
							} break;)

							MUCOSA_WIN32_CALL(case MU_WINDOW_SYSTEM_WIN32: {
								muCOSA_Win32_vulkan_create_window_surface(result, &MUCOSA_GWIN32, window, vk_result, instance, allocator, surface);
							} break;)
						}

						if (window) {} if (vk_result) {} if (instance) {} if (allocator) {} if (surface) {}
					}

			#ifdef __cplusplus
			}
			#endif

		#endif /* MUCOSA_IMPLEMENTATION */

	#endif /* MUCOSA IMP */

	#ifdef __cplusplus
	extern "C" { // }
	#endif

	/* Useful functions */

		mugResult muCOSA_result_to_mug_result(muCOSAResult result) {
			switch (result) {
				default: return MUG_MUCOSA_SUCCESS; break;
				case MUCOSA_SUCCESS: return MUG_MUCOSA_SUCCESS; break;
				case MUCOSA_ALREADY_INITIALIZED: return MUG_MUCOSA_ALREADY_INITIALIZED; break;
				case MUCOSA_ALREADY_TERMINATED: return MUG_MUCOSA_ALREADY_TERMINATED; break;
				case MUCOSA_ALREADY_ACTIVE: return MUG_MUCOSA_ALREADY_ACTIVE; break;
				case MUCOSA_ALREADY_INACTIVE: return MUG_MUCOSA_ALREADY_INACTIVE; break;
				case MUCOSA_NOT_YET_INITIALIZED: return MUG_MUCOSA_NOT_YET_INITIALIZED; break;
				case MUCOSA_ALLOCATION_FAILED: return MUG_MUCOSA_ALLOCATION_FAILED; break;
				case MUCOSA_UNKNOWN_WINDOW_SYSTEM: return MUG_MUCOSA_UNKNOWN_WINDOW_SYSTEM; break;
				case MUCOSA_UNKNOWN_GRAPHICS_API: return MUG_MUCOSA_UNKNOWN_GRAPHICS_API; break;
				case MUCOSA_UNKNOWN_KEYBOARD_KEY: return MUG_MUCOSA_UNKNOWN_KEYBOARD_KEY; break;
				case MUCOSA_UNKNOWN_KEYBOARD_STATE: return MUG_MUCOSA_UNKNOWN_KEYBOARD_STATE; break;
				case MUCOSA_UNKNOWN_MOUSE_BUTTON: return MUG_MUCOSA_UNKNOWN_MOUSE_BUTTON; break;
				case MUCOSA_UNKNOWN_WINDOW_HANDLE: return MUG_MUCOSA_UNKNOWN_WINDOW_HANDLE; break;
				case MUCOSA_UNSUPPORTED_WINDOW_SYSTEM: return MUG_MUCOSA_UNSUPPORTED_WINDOW_SYSTEM; break;
				case MUCOSA_UNSUPPORTED_FEATURE: return MUG_MUCOSA_UNSUPPORTED_FEATURE; break;
				case MUCOSA_UNSUPPORTED_OPENGL_FEATURE: return MUG_MUCOSA_UNSUPPORTED_OPENGL_FEATURE; break;
				case MUCOSA_UNSUPPORTED_GRAPHICS_API: return MUG_MUCOSA_UNSUPPORTED_GRAPHICS_API; break;
				case MUCOSA_FAILED_CONNECTION_TO_SERVER: return MUG_MUCOSA_FAILED_CONNECTION_TO_SERVER; break;
				case MUCOSA_FAILED_CREATE_WINDOW: return MUG_MUCOSA_FAILED_CREATE_WINDOW; break;
				case MUCOSA_FAILED_LOAD_FUNCTIONS: return MUG_MUCOSA_FAILED_LOAD_FUNCTIONS; break;
				case MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER: return MUG_MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER; break;
				case MUCOSA_FAILED_CREATE_OPENGL_CONTEXT: return MUG_MUCOSA_FAILED_CREATE_OPENGL_CONTEXT; break;
				case MUCOSA_FAILED_LOAD_OPENGL_CONTEXT: return MUG_MUCOSA_FAILED_LOAD_OPENGL_CONTEXT; break;
				case MUCOSA_FAILED_USE_PIXEL_FORMAT: return MUG_MUCOSA_FAILED_USE_PIXEL_FORMAT; break;
				case MUCOSA_FAILED_JOIN_THREAD: return MUG_MUCOSA_FAILED_JOIN_THREAD; break;
				case MUCOSA_FAILED_CREATE_THREAD: return MUG_MUCOSA_FAILED_CREATE_THREAD; break;
				case MUCOSA_FAILED_CREATE_INPUT_METHOD: return MUG_MUCOSA_FAILED_CREATE_INPUT_METHOD; break;
				case MUCOSA_FAILED_GET_INPUT_STYLES: return MUG_MUCOSA_FAILED_GET_INPUT_STYLES; break;
				case MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE: return MUG_MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE; break;
				case MUCOSA_FAILED_CREATE_INPUT_CONTEXT: return MUG_MUCOSA_FAILED_CREATE_INPUT_CONTEXT; break;
				case MUCOSA_FAILED_REGISTER_WINDOW_CLASS: return MUG_MUCOSA_FAILED_REGISTER_WINDOW_CLASS; break;
				case MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR: return MUG_MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR; break;
				case MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8: return MUG_MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8; break;
				case MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS: return MUG_MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS; break;
				case MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW: return MUG_MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW; break;
				case MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT: return MUG_MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT; break;
				case MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT: return MUG_MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT; break;
				case MUCOSA_FAILED_SET_PIXEL_FORMAT: return MUG_MUCOSA_FAILED_SET_PIXEL_FORMAT; break;
				case MUCOSA_FAILED_QUERY_WINDOW_INFO: return MUG_MUCOSA_FAILED_QUERY_WINDOW_INFO; break;
				case MUCOSA_FAILED_SET_WINDOW_INFO: return MUG_MUCOSA_FAILED_SET_WINDOW_INFO; break;
				case MUCOSA_FAILED_GET_IMM_CONTEXT: return MUG_MUCOSA_FAILED_GET_IMM_CONTEXT; break;
				case MUCOSA_FAILED_LET_IMM_CONTEXT: return MUG_MUCOSA_FAILED_LET_IMM_CONTEXT; break;
				case MUCOSA_FAILED_GLOBAL_ALLOCATION: return MUG_MUCOSA_FAILED_GLOBAL_ALLOCATION; break;
				case MUCOSA_FAILED_GLOBAL_LOCK: return MUG_MUCOSA_FAILED_GLOBAL_LOCK; break;
				case MUCOSA_FAILED_HOLD_CLIPBOARD: return MUG_MUCOSA_FAILED_HOLD_CLIPBOARD; break;
				case MUCOSA_FAILED_SET_CLIPBOARD: return MUG_MUCOSA_FAILED_SET_CLIPBOARD; break;
				case MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS: return MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS; break;
				case MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS: return MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS; break;
				case MUCOSA_INVALID_ID: return MUG_MUCOSA_INVALID_ID; break;
				case MUCOSA_INVALID_SAMPLE_COUNT: return MUG_MUCOSA_INVALID_SAMPLE_COUNT; break;
				case MUCOSA_INVALID_DIMENSIONS: return MUG_MUCOSA_INVALID_DIMENSIONS; break;
				case MUCOSA_INVALID_POINTER: return MUG_MUCOSA_INVALID_POINTER; break;
				case MUCOSA_INVALID_WINDOW_STATE: return MUG_MUCOSA_INVALID_WINDOW_STATE; break;
				case MUCOSA_INVALID_TIME: return MUG_MUCOSA_INVALID_TIME; break;
				case MUCOSA_NONEXISTENT_DEVICE: return MUG_MUCOSA_NONEXISTENT_DEVICE; break;
				case MUCOSA_OVERSIZED_CLIPBOARD: return MUG_MUCOSA_OVERSIZED_CLIPBOARD; break;
				case MUCOSA_WINDOW_NON_RESIZABLE: return MUG_MUCOSA_WINDOW_NON_RESIZABLE; break;
				case MUCOSA_MUMA_SUCCESS: return MUG_MUCOSA_MUMA_SUCCESS; break;
				case MUCOSA_MUMA_FAILED_TO_ALLOCATE: return MUG_MUCOSA_MUMA_FAILED_TO_ALLOCATE; break;
				case MUCOSA_MUMA_INVALID_INDEX: return MUG_MUCOSA_MUMA_INVALID_INDEX; break;
				case MUCOSA_MUMA_INVALID_SHIFT_AMOUNT: return MUG_MUCOSA_MUMA_INVALID_SHIFT_AMOUNT; break;
				case MUCOSA_MUMA_NOT_FOUND: return MUG_MUCOSA_MUMA_NOT_FOUND; break;
			}
		}

		mugResult muma_result_to_mug_result(mumaResult result) {
			switch (result) {
				default: return 0; break;
				case MUMA_SUCCESS: return MUG_MUMA_SUCCESS;
				case MUMA_FAILED_TO_ALLOCATE: return MUG_MUMA_FAILED_TO_ALLOCATE;
				case MUMA_INVALID_INDEX: return MUG_MUMA_INVALID_INDEX;
				case MUMA_INVALID_SHIFT_AMOUNT: return MUG_MUMA_INVALID_SHIFT_AMOUNT;
				case MUMA_NOT_FOUND: return MUG_MUMA_NOT_FOUND;
			}
		}

		void mug_inner_rotate_point_around_point(
			float rpx, float rpy, float cpx, float cpy,
			float srot, float crot,
			float* p_px, float* p_py
		) {
			float ox = rpx-cpx, oy = rpy-cpy;
			if (p_px) {
				*p_px = (ox*crot - oy*srot) + cpx;
			}
			if (p_py) {
				*p_py = (ox*srot + oy*crot) + cpy;
			}
		}

		// p_f[24], p_i[5]
		// i == How many rects we're in, used for indexing
		void mug_inner_rect_single_fill(float* p_f, uint32_t* p_i,
			muRect rect, size_m i, uint32_t prim_restart
		) {
			if (p_f) {
				float srot = mu_sin(rect.rotation);
				float crot = mu_cos(rect.rotation);
				float halfw = rect.dim[0] / 2.f;
				float halfh = rect.dim[1] / 2.f;

				mug_inner_rotate_point_around_point( // Top left
					rect.pos[0] - halfw, rect.pos[1] - halfh,
					rect.pos[0], rect.pos[1], srot, crot,
					&p_f[0], &p_f[1]
				);
				mug_inner_rotate_point_around_point( // Top right
					rect.pos[0] + halfw, rect.pos[1] - halfh,
					rect.pos[0], rect.pos[1], srot, crot,
					&p_f[6], &p_f[7]
				);
				mug_inner_rotate_point_around_point( // Bottom left
					rect.pos[0] - halfw, rect.pos[1] + halfh,
					rect.pos[0], rect.pos[1], srot, crot,
					&p_f[12], &p_f[13]
				);
				mug_inner_rotate_point_around_point( // Bottom right
					rect.pos[0] + halfw, rect.pos[1] + halfh,
					rect.pos[0], rect.pos[1], srot, crot,
					&p_f[18], &p_f[19]
				);

				mu_memcpy(&p_f[2],  &rect.col[0], sizeof(float)*4);
				mu_memcpy(&p_f[8],  &rect.col[0], sizeof(float)*4);
				mu_memcpy(&p_f[14], &rect.col[0], sizeof(float)*4);
				mu_memcpy(&p_f[20], &rect.col[0], sizeof(float)*4);
			}
			if (p_i) {
				size_m i6 = i*4;
				p_i[0] = i6;
				p_i[1] = i6+1;
				p_i[2] = i6+2;
				p_i[3] = i6+3;
				p_i[4] = prim_restart;
			}
		}

	/* OpenGL */

		// Comment/Uncomment to check/not check shader compilation status.
		#define MUG_GL_CHECK_SHADER_COMP_STATUS

		#ifndef MUG_GL_PRIMITIVE_RESTART_INDEX_32
			#define MUG_GL_PRIMITIVE_RESTART_INDEX_32 4294967295
		#endif

		#ifndef MUG_GL_PRIMITIVE_RESTART_INDEX_16
			#define MUG_GL_PRIMITIVE_RESTART_INDEX_16 65535
		#endif

		/* Useful functions */

			GLuint mug_innergl_comp_shader_vf(const char* vss, const char* fss) {
				#ifdef MUG_GL_CHECK_SHADER_COMP_STATUS
					GLint success;
					GLchar complog[512];
				#endif

				GLuint vs = glCreateShader(GL_VERTEX_SHADER);
				glShaderSource(vs, 1, &vss, 0);
				glCompileShader(vs);
				#ifdef MUG_GL_CHECK_SHADER_COMP_STATUS
					glGetShaderiv(vs, GL_COMPILE_STATUS, &success);
					if (!success) {
						glGetShaderInfoLog(vs, 512, NULL, complog);
						//printf("vs %s\n", complog);
						return 0;
					}
				#endif

				GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
				glShaderSource(fs, 1, &fss, 0);
				glCompileShader(fs);
				#ifdef MUG_GL_CHECK_SHADER_COMP_STATUS
					glGetShaderiv(fs, GL_COMPILE_STATUS, &success);
					if (!success) {
						glGetShaderInfoLog(fs, 512, NULL, complog);
						//printf("fs %s\n", complog);
						glDeleteShader(vs);
						return 0;
					}
				#endif

				GLuint sp = glCreateProgram();
				glAttachShader(sp, vs);
				glAttachShader(sp, fs);
				glLinkProgram(sp);
				#ifdef MUG_GL_CHECK_SHADER_COMP_STATUS
					glGetProgramiv(sp, GL_LINK_STATUS, &success);
					if (!success) {
						glDeleteShader(fs);
						glDeleteShader(vs);
						return 0;
					}
				#endif

				glDeleteShader(fs);
				glDeleteShader(vs);
				return sp;
			}

		/* Rects */

			// Data buf format: { vec2 pos, vec4 col }
			// Data structure: vertex/32-index, triangle strip, & primitive restarting.
				/* Notes:
				* The order of positions for rects are top-left, top-right, bottom-left, and bottom-right.
				*/
				/* Justification:
				Two rectangles, in pure vertex form, would cost:
					(sizeof(GLfloat)*6) * 6 * 2, AKA 288 bytes.
				With indexing:
					((sizeof(GLfloat)*6) * 4 * 2) + (sizeof(GLuint) * 6 * 2), AKA 240 bytes. (~83.3%)
				However, with primitive restarting + triangle strip, the indices can be cut down to 5, as
				{ 0, 1, 2, 1, 2, 3... } becomes { 0, 1, 2, 3, RESTART... }, making it:
					((sizeof(GLfloat)*6) * 4 * 2) + (sizeof(GLuint) * 5 * 2), AKA 232 bytes. (~80.6%)
				*/

			/* Buffer */

				struct mug_innergl_rect_buffer {
					muBool active;
					GLuint vbo;
					GLuint ebo;
					GLuint vao;
					size_m tricount; // Unnecessary?
					size_m rect_count;
					muBool rendered_this_frame;
				};
				typedef struct mug_innergl_rect_buffer mug_innergl_rect_buffer;

				muBool mug_innergl_rect_buffer_comp(mug_innergl_rect_buffer b0, mug_innergl_rect_buffer b1) {
					return b0.active == b1.active;
				}
				mu_dynamic_array_declaration(mug_innergl_rect_buffers, mug_innergl_rect_buffer,
					mug_innergl_rect_buffer_arr_, mug_innergl_rect_buffer_comp
				)

				mugResult mug_inner2gl_rect_buffer_fill(mug_innergl_rect_buffer* p_rbuf, muRect* rects) {
					if (p_rbuf->rendered_this_frame) {
						return MUG_ALREADY_RENDERED_BUFFER;
					}

					// Note: not sure if allocating for just glBufferData then deallocating after is fine,
					// but we'll see. Delete this if things have been running well.
					glBindVertexArray(p_rbuf->vao);

					/* Vertexes */

					if (rects != 0) {
						GLfloat* vertexes = (GLfloat*)mu_malloc(sizeof(GLfloat) * p_rbuf->rect_count * 6 * 4);
						if (vertexes == 0) {
							glBindVertexArray(0);
							return MUG_FAILED_ALLOCATE;
						}

						for (size_m i = 0; i < p_rbuf->rect_count; i++) {
							mug_inner_rect_single_fill(&vertexes[i*6*4], 0, rects[i], i, 0);
						}

						glBindBuffer(GL_ARRAY_BUFFER, p_rbuf->vbo);
						glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * p_rbuf->rect_count * 6 * 4, vertexes, GL_DYNAMIC_DRAW);

						mu_free(vertexes);
					} else {
						glBindBuffer(GL_ARRAY_BUFFER, p_rbuf->vbo);
						glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * p_rbuf->rect_count * 6 * 4, 0, GL_DYNAMIC_DRAW);
					}

					/* Indexes */

					if (rects != 0) {
						GLuint* indexes = (GLuint*)mu_malloc(sizeof(GLuint) * p_rbuf->rect_count * 5);
						if (indexes == 0) {
							glBindBuffer(GL_ARRAY_BUFFER, 0);
							glBindVertexArray(0);
							return MUG_FAILED_ALLOCATE;
						}

						for (size_m i = 0; i < p_rbuf->rect_count; i++) {
							mug_inner_rect_single_fill(0, &indexes[i*5], rects[i], i, MUG_GL_PRIMITIVE_RESTART_INDEX_32);
						}

						glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, p_rbuf->ebo);
						glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint) * p_rbuf->rect_count * 5, indexes, GL_STATIC_DRAW);

						mu_free(indexes);
					} else {
						glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, p_rbuf->ebo);
						glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint) * p_rbuf->rect_count * 5, 0, GL_STATIC_DRAW);
					}

					/* Description */

						glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 6 * sizeof(float), 0);
						glEnableVertexAttribArray(0);

						glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(2*sizeof(float)));
						glEnableVertexAttribArray(1);

					glBindBuffer(GL_ARRAY_BUFFER, 0);
					glBindVertexArray(0);
					return MUG_SUCCESS;
				}

				size_m mug_inner2gl_rect_buffer_create(mugResult* result, mug_innergl_rect_buffers* p_rbufs, muRect* rects, size_m rect_count) {
					mugResult res = MUG_SUCCESS;
					mumaResult muma_res = MUMA_SUCCESS;
					size_m id = MU_NONE;
					mug_innergl_rect_buffer rbuf = MU_ZERO_STRUCT(mug_innergl_rect_buffer);
					rbuf.rect_count = rect_count;

					glGenBuffers(1, &rbuf.vbo);
					if (rbuf.vbo == 0) {
						MU_SET_RESULT(result, MUG_FAILED_CREATE_GL_BUFFER)
						return MU_NONE;
					}
					glGenBuffers(1, &rbuf.ebo);
					if (rbuf.ebo == 0) {
						MU_SET_RESULT(result, MUG_FAILED_CREATE_GL_BUFFER)
						glDeleteBuffers(1, &rbuf.vbo);
						return MU_NONE;
					}
					glGenVertexArrays(1, &rbuf.vao);
					if (rbuf.vao == 0) {
						MU_SET_RESULT(result, MUG_FAILED_CREATE_GL_VERTEX_ARRAY)
						glDeleteBuffers(1, &rbuf.ebo);
						glDeleteBuffers(1, &rbuf.vbo);
						return MU_NONE;
					}

					res = mug_inner2gl_rect_buffer_fill(&rbuf, rects);
					if (res != MUG_SUCCESS) {
						MU_SET_RESULT(result, res)
						glDeleteVertexArrays(1, &rbuf.vao);
						glDeleteBuffers(1, &rbuf.ebo);
						glDeleteBuffers(1, &rbuf.vbo);
						return MU_NONE;
					}
					
					*p_rbufs = mug_innergl_rect_buffer_arr_find_push(
						&muma_res, *p_rbufs, rbuf, &id
					);
					if (muma_res != MUMA_SUCCESS) {
						MU_SET_RESULT(result, muma_result_to_mug_result(muma_res))
						glDeleteVertexArrays(1, &rbuf.vao);
						glDeleteBuffers(1, &rbuf.ebo);
						glDeleteBuffers(1, &rbuf.vbo);
						return MU_NONE;
					}

					p_rbufs->data[id] = rbuf;
					p_rbufs->data[id].active = MU_TRUE;
					p_rbufs->data[id].tricount = rect_count * 2;

					return id;
				}

				void mug_inner2gl_rect_buffer_destroy(mug_innergl_rect_buffer* p_rbuf) {
					if (p_rbuf->active) {
						glDeleteVertexArrays(1, &p_rbuf->vao);
						glDeleteBuffers(1, &p_rbuf->ebo);
						glDeleteBuffers(1, &p_rbuf->vbo);
						*p_rbuf = MU_ZERO_STRUCT(mug_innergl_rect_buffer);
					}
				}

			/* Shader */

				struct mug_innergl_rect_shader {
					GLuint program;
					mug_innergl_rect_buffers buffers;
				};
				typedef struct mug_innergl_rect_shader mug_innergl_rect_shader;

				const char* mug_innergl_rect_vshader_source =
					"#version 400 core\n"

					"layout(location=0)in vec2 vPos;"
					"layout(location=1)in vec4 vCol;"

					"out vec4 fCol;"
					"uniform vec2 d;"

					"void main(){"
						"gl_Position=vec4((vPos.x-(d.x))/d.x,-(vPos.y-(d.y))/d.y,0.0,1.0);"
						"fCol=vCol;"
					"}"
				;

				const char* mug_innergl_rect_fshader_source =
					"#version 400 core\n"

					"in vec4 fCol;"
					"out vec4 oCol;"

					"void main(){"
						"oCol=fCol;"
					"}"
				;

				mugResult mug_innergl_rect_shader_comp(mug_innergl_rect_shader* p_s) {
					if (p_s->program != 0) {
						return MUG_SUCCESS;
					}

					p_s->program = mug_innergl_comp_shader_vf(
						mug_innergl_rect_vshader_source, mug_innergl_rect_fshader_source
					);
					if (p_s->program == 0) {
						return MUG_FAILED_COMPILE_GL_SHADERS;
					}

					return MUG_SUCCESS;
				}

				// Note: check if program exists before this...
				void mug_inner2gl_rect_shader_render_tricount(mug_innergl_rect_shader* p_s, size_m buf, size_m tricount, muWindow window) {
					glPrimitiveRestartIndex(MUG_GL_PRIMITIVE_RESTART_INDEX_32);
					glUseProgram(p_s->program);

					muCOSAResult cosa_res = MUCOSA_SUCCESS;
					uint32_m w=800,h=600;
					mu_window_get_dimensions(&cosa_res, window, &w, &h);
					if (cosa_res == MUCOSA_SUCCESS) {
						glUniform2f(glGetUniformLocation(p_s->program, "d"), ((float)(w))/2.f, ((float)(h))/2.f);
					}

					glBindVertexArray(p_s->buffers.data[buf].vao);
					//glDrawElements(GL_TRIANGLE_STRIP, p_s->buffers.data[buf].tricount, GL_UNSIGNED_INT, 0);
					glDrawElements(GL_TRIANGLE_STRIP, tricount*3, GL_UNSIGNED_INT, 0);
					glBindVertexArray(0);
					glUseProgram(0);

					p_s->buffers.data[buf].rendered_this_frame = MU_TRUE;
				}

		/* Shaders */

			struct mug_innergl_shaders {
				mug_innergl_rect_shader rect;
			};
			typedef struct mug_innergl_shaders mug_innergl_shaders;

			#define mug_innergl_refresh_buffers(buf) \
				for (size_m k = 0; k < buf.length; k++) { \
					if (buf.data[k].active) { \
						buf.data[k].rendered_this_frame = MU_FALSE; \
					} \
				}
			void mug_innergl_refresh_shader_buffers(mug_innergl_shaders* p_shaders) {
				mug_innergl_refresh_buffers(p_shaders->rect.buffers)
			}

		/* Graphic */

			struct mug_innergl_graphic {
				muWindow win;
				uint32_m last_width;
				uint32_m last_height;

				mug_innergl_shaders shaders;
			};
			typedef struct mug_innergl_graphic mug_innergl_graphic;

			/* Useful functions */

				void mug_innergl_graphic_bind(mug_innergl_graphic* p_g) {
					mu_opengl_bind_window(0, p_g->win);
				}

				void mug_innergl_enable_features(mug_innergl_graphic* p_g) {
					mug_innergl_graphic_bind(p_g);

					glEnable(GL_PRIMITIVE_RESTART);
				}

			/* Creation / Destruction */

				muBool mug_innergl_load_funcs(void) {
					return gladLoadGL((GLADloadfunc)mu_opengl_get_function_address);
				}

				// Indiciator of success is win != MU_NONE
				mug_innergl_graphic mug_innergl_graphic_create_via_window(mugResult* result, 
					muByte* name, uint16_m width, uint16_m height,
					muWindowCreateInfo create_info) {
					MU_SET_RESULT(result, MUG_SUCCESS)

					mug_innergl_graphic graphic = MU_ZERO_STRUCT(mug_innergl_graphic);

					muCOSAResult cosa_res = MUCOSA_SUCCESS;
					graphic.win = mu_window_create(&cosa_res, MU_OPENGL_4_0_CORE, 
						mug_innergl_load_funcs, name, width, height, create_info);

					if (cosa_res != MUCOSA_SUCCESS) {
						MU_SET_RESULT(result, muCOSA_result_to_mug_result(cosa_res));
					}
					if (graphic.win == MU_NONE) {
						return graphic;
					}

					graphic.last_width = width;
					graphic.last_height = height;

					mug_innergl_enable_features(&graphic);

					return graphic;
				}

				void mug_innergl_graphic_destroy(mugResult* result, mug_innergl_graphic* p_g) {
					MU_SET_RESULT(result, MUG_SUCCESS)
					mug_innergl_graphic_bind(p_g);

					for (size_m i = 0; i < p_g->shaders.rect.buffers.length; i++) {
						mug_inner2gl_rect_buffer_destroy(&p_g->shaders.rect.buffers.data[i]);
					}

					if (p_g->win != MU_NONE) {
						p_g->win = mu_window_destroy(0, p_g->win);
					}
				}

			/* Main loop */

				void mug_innergl_graphic_clear(mugResult* result, mug_innergl_graphic* p_g, float r, float g, float b, float a) {
					mug_innergl_graphic_bind(p_g);

					glClearColor(r, g, b, a);
					glClear(GL_COLOR_BUFFER_BIT);

					return;
					if (result) {}
				}

				void mug_innergl_graphic_swap_buffers(mugResult* result, mug_innergl_graphic* p_g) {
					mug_innergl_graphic_bind(p_g);

					muCOSAResult cosa_res = MUCOSA_SUCCESS;
					mu_window_swap_buffers(&cosa_res, p_g->win);
					if (cosa_res != MUCOSA_SUCCESS) {
						MU_SET_RESULT(result, muCOSA_result_to_mug_result(cosa_res));
					}

					mug_innergl_refresh_shader_buffers(&p_g->shaders);
				}

				void mug_innergl_graphic_update(mugResult* result, mug_innergl_graphic* p_g) {
					mug_innergl_graphic_bind(p_g);

					muCOSAResult cosa_res = MUCOSA_SUCCESS;
					mu_window_update(&cosa_res, p_g->win);
					if (cosa_res != MUCOSA_SUCCESS) {
						MU_SET_RESULT(result, muCOSA_result_to_mug_result(cosa_res));
					}

					uint32_m width=800, height=600;
					mu_window_get_dimensions(&cosa_res, p_g->win, &width, &height);
					if (cosa_res == MUCOSA_SUCCESS) {
						if (width != p_g->last_width || height != p_g->last_height) {
							glViewport(0, 0, width, height);
							p_g->last_width = width;
							p_g->last_height = height;
						}
					}
				}

			/* Objects */

				// ...

				/* Rect */

					muRectBuffer mug_innergl_rect_buffer_create(mugResult* result, mug_innergl_graphic* p_g, size_m rect_count, muRect* rects) {
						mugResult res = MUG_SUCCESS;
						mug_innergl_graphic_bind(p_g);

						res = mug_innergl_rect_shader_comp(&p_g->shaders.rect);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return MU_NONE;
						}

						size_m id = mug_inner2gl_rect_buffer_create(result, &p_g->shaders.rect.buffers,
							rects, rect_count
						);
						return id;
					}

					muRectBuffer mug_innergl_rect_buffer_destroy(mugResult* result, mug_innergl_graphic* p_g, muRectBuffer rb) {
						if (rb >= p_g->shaders.rect.buffers.length) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return rb;
						}
						if (!p_g->shaders.rect.buffers.data[rb].active) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return rb;
						}
						mug_innergl_graphic_bind(p_g);

						mug_inner2gl_rect_buffer_destroy(&p_g->shaders.rect.buffers.data[rb]);
						return MU_NONE;
					}

					void mug_innergl_rect_buffer_render(mugResult* result, mug_innergl_graphic* p_g, muRectBuffer rb) {
						mugResult res = MUG_SUCCESS;

						if (rb >= p_g->shaders.rect.buffers.length) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return;
						}
						if (!p_g->shaders.rect.buffers.data[rb].active) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return;
						}
						mug_innergl_graphic_bind(p_g);

						res = mug_innergl_rect_shader_comp(&p_g->shaders.rect);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return;
						}

						mug_inner2gl_rect_shader_render_tricount(
							&p_g->shaders.rect, rb, p_g->shaders.rect.buffers.data[rb].tricount,
							p_g->win
						);
					}

					void mug_innergl_rect_buffer_fill(mugResult* result, mug_innergl_graphic* p_g, muRectBuffer rb, muRect* rects) {
						mugResult res = MUG_SUCCESS;
						
						if (rb >= p_g->shaders.rect.buffers.length) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return;
						}
						if (!p_g->shaders.rect.buffers.data[rb].active) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return;
						}
						mug_innergl_graphic_bind(p_g);

						res = mug_innergl_rect_shader_comp(&p_g->shaders.rect);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return;
						}

						res = mug_inner2gl_rect_buffer_fill(&p_g->shaders.rect.buffers.data[rb], rects);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return;
						}
					}

	/* Vulkan */

		#ifndef MUG_VK_LOOK_AHEAD_FRAMES
			#define MUG_VK_LOOK_AHEAD_FRAMES 3
		#endif

		/* Useful functions */

			/* Graphics pipeline */

				const char* mug_innervk_shader_entry = "main";

				struct mug_innervk_gpipeline_ci {
					VkGraphicsPipelineCreateInfo pipeline_ci;
					VkPipelineShaderStageCreateInfo shader_stages[2];
					VkPipelineVertexInputStateCreateInfo vertex_input;
					VkPipelineInputAssemblyStateCreateInfo input_asm;
					VkViewport viewport;
					VkRect2D scissor;
					VkPipelineViewportStateCreateInfo viewport_state;
					VkPipelineRasterizationStateCreateInfo raster;
					VkPipelineMultisampleStateCreateInfo ms;
					VkPipelineDepthStencilStateCreateInfo ds;
					VkPipelineColorBlendAttachmentState blend_att;
					VkPipelineColorBlendStateCreateInfo blend;
					VkDynamicState dystates[2];
					VkPipelineDynamicStateCreateInfo dystate;
				};
				typedef struct mug_innervk_gpipeline_ci mug_innervk_gpipeline_ci;

				// Note: does zero the struct for you. :)
				void mug_innervk_def_gpipeline_ci(
					mug_innervk_gpipeline_ci* p_ci,
					VkShaderModule* p_vert_module, VkShaderModule* p_frag_module,
					float width, float height, VkPipelineLayout layout,
					VkRenderPass render_pass, uint32_t subpass
				) {
					*p_ci = MU_ZERO_STRUCT(mug_innervk_gpipeline_ci);
					p_ci->pipeline_ci.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;

					/* Shader stages */

						p_ci->pipeline_ci.pStages = p_ci->shader_stages;

						if (p_vert_module) {
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].stage = VK_SHADER_STAGE_VERTEX_BIT;
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].module = *p_vert_module;
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].pName = mug_innervk_shader_entry;
							p_ci->pipeline_ci.stageCount += 1;
						}

						if (p_frag_module) {
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].module = *p_frag_module;
							p_ci->shader_stages[p_ci->pipeline_ci.stageCount].pName = mug_innervk_shader_entry;
							p_ci->pipeline_ci.stageCount += 1;
						}

					/* Vertex input */

						p_ci->vertex_input.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
						p_ci->pipeline_ci.pVertexInputState = &p_ci->vertex_input;

					/* Input assembly */

						p_ci->input_asm.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
						p_ci->input_asm.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
						p_ci->input_asm.primitiveRestartEnable = VK_FALSE;
						p_ci->pipeline_ci.pInputAssemblyState = &p_ci->input_asm;

					/* Tessellation state */

						// ...

					/* Viewport state */

						p_ci->viewport.x = 0.f;
						p_ci->viewport.y = 0.f;
						p_ci->viewport.width = width;
						p_ci->viewport.height = height;
						p_ci->viewport.minDepth = 0.f;
						p_ci->viewport.maxDepth = 1.f;

						p_ci->scissor.extent.width = width;
						p_ci->scissor.extent.height = height;

						p_ci->viewport_state.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
						p_ci->viewport_state.viewportCount = 1;
						p_ci->viewport_state.pViewports = &p_ci->viewport;
						p_ci->viewport_state.scissorCount = 1;
						p_ci->viewport_state.pScissors = &p_ci->scissor;
						p_ci->pipeline_ci.pViewportState = &p_ci->viewport_state;

					/* Rasterization state */

						p_ci->raster.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
						p_ci->raster.depthClampEnable = VK_FALSE;
						p_ci->raster.rasterizerDiscardEnable = VK_FALSE;
						p_ci->raster.polygonMode = VK_POLYGON_MODE_FILL;
						p_ci->raster.cullMode = VK_CULL_MODE_NONE;
						p_ci->raster.depthBiasEnable = VK_FALSE;
						p_ci->raster.lineWidth = 1.f;
						p_ci->pipeline_ci.pRasterizationState = &p_ci->raster;

					/* Multisample state */

						p_ci->ms.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
						p_ci->ms.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
						p_ci->ms.sampleShadingEnable = VK_FALSE;
						p_ci->ms.alphaToCoverageEnable = VK_FALSE;
						p_ci->ms.alphaToOneEnable = VK_FALSE;
						p_ci->pipeline_ci.pMultisampleState = &p_ci->ms;

					/* Depth/Stencil state */

						p_ci->ds.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
						p_ci->ds.depthTestEnable = VK_FALSE;
						p_ci->ds.depthBoundsTestEnable = VK_FALSE;
						p_ci->ds.stencilTestEnable = VK_FALSE;
						p_ci->pipeline_ci.pDepthStencilState = &p_ci->ds;

					/* Color blend state */

						p_ci->blend_att.blendEnable = VK_FALSE;
						p_ci->blend_att.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
						VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;

						p_ci->blend.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
						p_ci->blend.logicOpEnable = VK_FALSE;
						p_ci->blend.attachmentCount = 1;
						p_ci->blend.pAttachments = &p_ci->blend_att;
						p_ci->pipeline_ci.pColorBlendState = &p_ci->blend;

					/* Dynamic state */

						p_ci->dystates[0] = VK_DYNAMIC_STATE_VIEWPORT;
						p_ci->dystates[1] = VK_DYNAMIC_STATE_SCISSOR;

						p_ci->dystate.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
						p_ci->dystate.dynamicStateCount = 2;
						p_ci->dystate.pDynamicStates = p_ci->dystates;

						p_ci->pipeline_ci.pDynamicState = &p_ci->dystate;

					/* Other given stuff */

						p_ci->pipeline_ci.layout = layout;
						p_ci->pipeline_ci.renderPass = render_pass;
						p_ci->pipeline_ci.subpass = subpass;
				}

		/* Loaded */

			struct mug_innervk_loaded {
				MU_LOCK
				muBool loaded;
			};
			typedef struct mug_innervk_loaded mug_innervk_loaded;

			VkResult mug_innervk_load(mug_innervk_loaded* loaded) {
				MU_LOCK_LOCK(loaded->lock, loaded->lock_active)

				if (!loaded->loaded) {
					VkResult res = vkbInit(NULL);

					if (res == VK_SUCCESS) {
						loaded->loaded = MU_TRUE;
						MU_LOCK_UNLOCK(loaded->lock, loaded->lock_active)
						return VK_SUCCESS;
					} else {
						MU_LOCK_UNLOCK(loaded->lock, loaded->lock_active)
						return res;
					}
				}

				MU_LOCK_UNLOCK(loaded->lock, loaded->lock_active)
				return VK_SUCCESS;
			}

			void mug_innervk_unload(mug_innervk_loaded* loaded) {
				MU_LOCK_LOCK(loaded->lock, loaded->lock_active)

				if (loaded->loaded) {
					vkbUninit();
					loaded->loaded = MU_FALSE;
				}

				MU_LOCK_UNLOCK(loaded->lock, loaded->lock_active)
			}

		/* Inner */

			/* Structs */

				struct mug_innervk_initiation {
					VkInstance instance;
					muBool use_validation_layers;
					VkDebugUtilsMessengerEXT debug_messenger;
					unsigned int (*debug_messenger_callback)(VkDebugUtilsMessageSeverityFlagBitsEXT severity, VkDebugUtilsMessageTypeFlagsEXT types, const VkDebugUtilsMessengerCallbackDataEXT* data, void* user_data);
					VkSurfaceKHR surface;

					VkPhysicalDevice physical_device;
					VkDevice device;
					uint32_t graphics_family;
					VkQueue graphics_queue;
					uint32_t present_family;
					VkQueue present_queue;
				};
				typedef struct mug_innervk_initiation mug_innervk_initiation;

				mug_innervk_initiation mug_innervk_initiation_init(void) {
					mug_innervk_initiation init = MU_ZERO_STRUCT(mug_innervk_initiation);
					init.instance = VK_NULL_HANDLE;
					init.use_validation_layers = MU_TRUE;
					init.debug_messenger = VK_NULL_HANDLE;
					init.surface = VK_NULL_HANDLE;
					init.physical_device = VK_NULL_HANDLE;
					init.device = VK_NULL_HANDLE;
					return init;
				}

				struct mug_innervk_swapchain {
					VkSwapchainKHR handle;
					VkFormat format;
					VkExtent2D extent;
					VkViewport viewport;
					VkRect2D scissor;

					uint32_t image_count;
					VkImage* images;
					VkImageView* image_views;
					uint32_t image_index;
				};
				typedef struct mug_innervk_swapchain mug_innervk_swapchain;

				struct mug_innervk_command {
					VkCommandPool pool;
					VkCommandBuffer buffer;
					muBool on;

					VkSemaphore queue_wait_semaphore;
					VkSemaphore queue_signal_semaphore;
					VkFence queue_wait_fence;
				};
				typedef struct mug_innervk_command mug_innervk_command;

				struct mug_innervk_renderer {
					VkRenderPass render_pass;
					VkFramebuffer* framebuffers; // count = sc.image_count
				};
				typedef struct mug_innervk_renderer mug_innervk_renderer;

				struct mug_innervk_renderers {
					// Unknown layout -> color attachment, used for clearing the contents with a color.
					mug_innervk_renderer unknown_to_ca;
					// Color attachment layout -> present, used for presentation.
					mug_innervk_renderer ca_to_present;
					// Color attachment layout -> color attachment layout, used for pipeline rendering.
					mug_innervk_renderer ca_to_ca_pip;
				};
				typedef struct mug_innervk_renderers mug_innervk_renderers;

				struct mug_innervk_buffer {
					VkBuffer buf;
					VkDeviceMemory mem;
					void* mapped_mem;
				};
				typedef struct mug_innervk_buffer mug_innervk_buffer;

				struct mug_innervk_vbuffer {
					muBool active;
					size_m render_count; // The count given to the draw function.
					size_m obj_count; // The count of whatever object is represnted by this.
					muBool rendered_this_frame;
					mug_innervk_buffer vbuf;
					mug_innervk_buffer ibuf;
				};
				typedef struct mug_innervk_vbuffer mug_innervk_vbuffer;

				muBool mug_innervk_vbuffer_comp(mug_innervk_vbuffer b0, mug_innervk_vbuffer b1) {
					return b0.active == b1.active;
				}

				mu_dynamic_array_declaration(mug_innervk_vbuffers, mug_innervk_vbuffer,
					mug_innervk_vbuffers_, mug_innervk_vbuffer_comp
				)

				struct mug_innervk_uniform_buffer {
					mug_innervk_buffer bufs[MUG_VK_LOOK_AHEAD_FRAMES];
				};
				typedef struct mug_innervk_uniform_buffer mug_innervk_uniform_buffer;

				#define MUG_VK_UNIFORM_BUFFER_BUFLEN 1

				struct mug_innervk_shader_uniforms {
					mug_innervk_uniform_buffer bufs[MUG_VK_UNIFORM_BUFFER_BUFLEN];
					size_m buflen;

					VkDescriptorSetLayout dsl[MUG_VK_LOOK_AHEAD_FRAMES];
					VkDescriptorPool dp;
					VkDescriptorSet ds[MUG_VK_LOOK_AHEAD_FRAMES];
				};
				typedef struct mug_innervk_shader_uniforms mug_innervk_shader_uniforms;

				struct mug_innervk_shader {
					VkShaderModule vert; // <== vert equaling VK_NULL_HANDLE determines whether or not all
					// other Vulkan objects are valid.
					VkShaderModule frag;

					VkPipelineLayout pipeline_layout;
					VkPipeline pipeline;

					muBool use_buffers;
					muBool use_index;
					mug_innervk_vbuffers buffers;

					VkIndexType index_type;
					mug_innervk_shader_uniforms uniforms;
				};
				typedef struct mug_innervk_shader mug_innervk_shader;

				struct mug_innervk_shaders {
					mug_innervk_shader rect;
				};
				typedef struct mug_innervk_shaders mug_innervk_shaders;

				struct mug_innervk_inner {
					muWindow win;
					mug_innervk_initiation init;
					mug_innervk_swapchain sc;
					mug_innervk_renderers rs;

					mug_innervk_command cmds[MUG_VK_LOOK_AHEAD_FRAMES];
					size_m now_cmd;

					mug_innervk_shaders shaders;
				};
				typedef struct mug_innervk_inner mug_innervk_inner;

			/* Initiation */

				#define MUG_VK_VALIDATION_LAYER_COUNT 1
				const char* mug_innervk_validation_layers[MUG_VK_VALIDATION_LAYER_COUNT] = {
					"VK_LAYER_KHRONOS_validation"
				};

				muBool mug_innervk_are_validation_layers_available(mug_innervk_initiation* p_init) {
					if (!p_init->use_validation_layers) {
						return MU_FALSE;
					}

					uint32_t prop_count = 0;
					if (vkEnumerateInstanceLayerProperties(&prop_count, 0) != VK_SUCCESS) {
						return MU_FALSE;
					}
					if (prop_count == 0) {
						return MU_FALSE;
					}

					VkLayerProperties* props = (VkLayerProperties*)mu_malloc(sizeof(VkLayerProperties)*prop_count);
					if (props == 0) {
						return MU_FALSE;
					}
					if (vkEnumerateInstanceLayerProperties(&prop_count, props) != VK_SUCCESS) {
						mu_free(props);
						return MU_FALSE;
					}

					for (uint32_t i = 0; i < MUG_VK_VALIDATION_LAYER_COUNT; i++) {
						muBool found = MU_FALSE;
						for (uint32_t j = 0; j < prop_count; j++) {
							if (mu_strcmp(props[j].layerName, mug_innervk_validation_layers[i]) == 0) {
								found = MU_TRUE;
								break;
							}
						}

						if (!found) {
							mu_free(props);
							return MU_FALSE;
						}
					}

					mu_free(props);
					return MU_TRUE;
				}

				#define MUG_VK_EXTENSION_COUNT 1
				const char* mug_innervk_extensions[MUG_VK_EXTENSION_COUNT] = {
					VK_KHR_SWAPCHAIN_EXTENSION_NAME
				};

				int32_m mug_innervk_rate_physical_device(VkPhysicalDevice physical_device,
					VkExtensionProperties* ext_props, size_m ext_prop_count
				) {
					int32_m score = 0;

					VkPhysicalDeviceProperties props;
					vkGetPhysicalDeviceProperties(physical_device, &props);
					VkPhysicalDeviceFeatures features;
					vkGetPhysicalDeviceFeatures(physical_device, &features);

					for (size_m i = 0; i < MUG_VK_EXTENSION_COUNT; i++) {
						muBool found = MU_FALSE;
						for (size_m j = 0; j < ext_prop_count; j++) {
							if (mu_strcmp(ext_props[j].extensionName, mug_innervk_extensions[i]) == 0) {
								found = MU_TRUE;
								break;
							}
						}

						if (!found) {
							return 0;
						}
					}

					switch (props.deviceType) {
						default: break;
						case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:   score += 500; break;
						case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: score += 400; break;
						case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:    score += 300; break;
						case VK_PHYSICAL_DEVICE_TYPE_CPU:            score += 200; break;
					}

					if (features.fullDrawIndexUint32) score += 20;
					if (features.imageCubeArray) score += 30;
					if (features.geometryShader) score += 50;
					if (features.tessellationShader) score += 100;
					if (features.sampleRateShading) score += 80;
					if (features.multiViewport) score += 50;
					if (features.samplerAnisotropy) score += 60;
					if (features.shaderStorageImageMultisample) score += 50;

					return score;
				}

				mugResult mug_innervk_initiation_create(mug_innervk_inner* p_inner) {
					muCOSAResult cosa_res = MUCOSA_SUCCESS;
					VkResult vk_res = VK_SUCCESS;

					p_inner->init.instance = VK_NULL_HANDLE;
					p_inner->init.debug_messenger = VK_NULL_HANDLE;
					p_inner->init.surface = VK_NULL_HANDLE;
					p_inner->init.physical_device = VK_NULL_HANDLE;
					p_inner->init.device = VK_NULL_HANDLE;

					/* Instance */

						VkInstanceCreateInfo inst_cinfo = MU_ZERO_STRUCT(VkInstanceCreateInfo);
						inst_cinfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;

						// Surface extensions

						size_m surface_extension_count = 0;
						const char** surface_extensions = mu_vulkan_get_surface_instance_extensions(
							&cosa_res, &surface_extension_count
						);
						if (cosa_res != MUG_SUCCESS) {
							return muCOSA_result_to_mug_result(cosa_res);
						}

						const char** actual_surface_extensions = surface_extensions;
						if (p_inner->init.use_validation_layers && mug_innervk_are_validation_layers_available(&p_inner->init)) {
							inst_cinfo.enabledLayerCount = MUG_VK_VALIDATION_LAYER_COUNT;
							inst_cinfo.ppEnabledLayerNames = (const char* const*)mug_innervk_validation_layers;

							size_m surface_extension_size = 0;
							for (size_m i = 0; i < surface_extension_count; i++) {
								surface_extension_size += mu_strlen(surface_extensions[i]) + 1;
							}

							size_m validation_layer_size = mu_strlen(VK_EXT_DEBUG_UTILS_EXTENSION_NAME) + 1;
							actual_surface_extensions = (const char**)mu_malloc(surface_extension_size+validation_layer_size);

							if (actual_surface_extensions != 0) {
								mu_memcpy(actual_surface_extensions, surface_extensions, surface_extension_size);
								actual_surface_extensions[surface_extension_count] = VK_EXT_DEBUG_UTILS_EXTENSION_NAME;
								surface_extension_count += 1;
							} else {
								actual_surface_extensions = surface_extensions;
							}
						} else {
							p_inner->init.use_validation_layers = MU_FALSE;
						}

						inst_cinfo.enabledExtensionCount = (uint32_t)surface_extension_count;
						inst_cinfo.ppEnabledExtensionNames = (const char* const*)actual_surface_extensions;

						if (vkCreateInstance(&inst_cinfo, 0, &p_inner->init.instance) != VK_SUCCESS) {
							if (actual_surface_extensions != 0 && actual_surface_extensions != surface_extensions) {
								mu_free(actual_surface_extensions);
							}
							return MUG_FAILED_CREATE_VK_INSTANCE;
						}

						if (actual_surface_extensions != 0 && actual_surface_extensions != surface_extensions) {
							mu_free(actual_surface_extensions);
						}

					/* Validation layers */

						if (p_inner->init.use_validation_layers) {
							VkDebugUtilsMessengerCreateInfoEXT dum_cinfo = MU_ZERO_STRUCT(VkDebugUtilsMessengerCreateInfoEXT);
							dum_cinfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
							dum_cinfo.messageSeverity = /*VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | */
							VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
							VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
							dum_cinfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
							VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
							dum_cinfo.pfnUserCallback = p_inner->init.debug_messenger_callback;

							PFN_vkCreateDebugUtilsMessengerEXT fun = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(p_inner->init.instance, "vkCreateDebugUtilsMessengerEXT");
							if (fun != 0) {
								if (fun(p_inner->init.instance, &dum_cinfo, 0, &p_inner->init.debug_messenger) != VK_SUCCESS) {
									// :L
								}
							}
						}

					/* Surface */

						mu_vulkan_create_window_surface(&cosa_res, p_inner->win,
							&vk_res, &p_inner->init.instance, 0, &p_inner->init.surface
						);
						if (cosa_res != MUCOSA_SUCCESS) {
							return muCOSA_result_to_mug_result(cosa_res);
						}
						if (vk_res != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_SURFACE;
						}

					/* Physical device */

						uint32_t physical_device_count = 0;
						if (vkEnumeratePhysicalDevices(p_inner->init.instance, &physical_device_count, NULL) != VK_SUCCESS) {
							return MUG_FAILED_FIND_VALID_PHYSICAL_DEVICE;
						}
						if (physical_device_count == 0) {
							return MUG_FAILED_FIND_VALID_PHYSICAL_DEVICE;
						}

						VkPhysicalDevice* physical_devices = (VkPhysicalDevice*)mu_malloc(sizeof(VkPhysicalDevice) * physical_device_count);
						if (physical_devices == 0) {
							return MUG_FAILED_ALLOCATE;
						}
						if (vkEnumeratePhysicalDevices(p_inner->init.instance, &physical_device_count, physical_devices) != VK_SUCCESS) {
							mu_free(physical_devices);
							return MUG_FAILED_FIND_VALID_PHYSICAL_DEVICE;
						}

						int32_m best_score = 0;
						for (uint32_t i = 0; i < physical_device_count; i++) {
							uint32_t extension_count = 0;
							vkEnumerateDeviceExtensionProperties(physical_devices[i], 0, &extension_count, 0);
							VkExtensionProperties* ext_props = 0;
							if (extension_count != 0) {
								ext_props = (VkExtensionProperties*)mu_malloc(sizeof(VkExtensionProperties) * extension_count);
								if (ext_props == 0) {
									// :L
									extension_count = 0;
								} else {
									vkEnumerateDeviceExtensionProperties(physical_devices[i], 0, &extension_count, ext_props);
								}
							}

							int32_m score = mug_innervk_rate_physical_device(physical_devices[i], ext_props, extension_count);
							if (score > best_score) {
								best_score = score;
								p_inner->init.physical_device = physical_devices[i];
							}

							if (ext_props != 0) {
								mu_free(ext_props);
							}
						}
						mu_free(physical_devices);

						if (best_score == 0) {
							return MUG_FAILED_FIND_COMPATIBLE_PHYSICAL_DEVICE;
						}

					/* Device */

						// Queue families

						uint32_t queue_family_property_count = 0;
						vkGetPhysicalDeviceQueueFamilyProperties(p_inner->init.physical_device, 
						&queue_family_property_count, 0);
						if (queue_family_property_count == 0) {
							return MUG_FAILED_GET_QUEUE_FAMILY_PROPERTIES;
						}

						VkQueueFamilyProperties* queue_family_properties = (VkQueueFamilyProperties*)
						mu_malloc(sizeof(VkQueueFamilyProperties) * queue_family_property_count);
						if (queue_family_properties == 0) {
							return MUG_FAILED_ALLOCATE;
						}
						vkGetPhysicalDeviceQueueFamilyProperties(p_inner->init.physical_device,
						&queue_family_property_count, queue_family_properties);

						muBool found_graphics = MU_FALSE, found_present = MU_FALSE;

						for (uint32_t i = 0; i < queue_family_property_count; i++) {
							if (!found_graphics && queue_family_properties[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {
								found_graphics = MU_TRUE;
								p_inner->init.graphics_family = i;
							}

							if (!found_present) {
								VkBool32 present_support = VK_FALSE;
								vkGetPhysicalDeviceSurfaceSupportKHR(p_inner->init.physical_device,
								i, p_inner->init.surface, &present_support);
								if (present_support) {
									found_present = MU_TRUE;
									p_inner->init.present_family = i;
								}
							}

							if (found_graphics && found_present) {
								break;
							}
						}
						mu_free(queue_family_properties);

						if (!found_graphics || !found_present) {
							return MUG_FAILED_FIND_NECESSARY_QUEUE_FAMILIES;
						}

						// Queues
						// This process is gross, but it does indeed work for 2 families. This will need
						// to be overhauled if otherwise.

						float priority = 1.f;

						VkDeviceQueueCreateInfo graphics_dq_ci = MU_ZERO_STRUCT(VkDeviceQueueCreateInfo);
						graphics_dq_ci.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
						graphics_dq_ci.queueFamilyIndex = p_inner->init.graphics_family;
						graphics_dq_ci.queueCount = 1;
						graphics_dq_ci.pQueuePriorities = &priority;

						VkDeviceQueueCreateInfo present_dq_ci = MU_ZERO_STRUCT(VkDeviceQueueCreateInfo);
						present_dq_ci.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
						present_dq_ci.queueFamilyIndex = p_inner->init.present_family;
						present_dq_ci.queueCount = 1;
						present_dq_ci.pQueuePriorities = &priority;

						VkDeviceQueueCreateInfo dq_cis[] = { graphics_dq_ci, present_dq_ci };
						uint32_t dq_ci_count = 2;
						if (p_inner->init.graphics_family == p_inner->init.present_family) {
							dq_ci_count = 1;
						}

						// Device

						VkDeviceCreateInfo device_ci = MU_ZERO_STRUCT(VkDeviceCreateInfo);
						device_ci.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
						device_ci.queueCreateInfoCount = dq_ci_count;
						device_ci.pQueueCreateInfos = dq_cis;
						device_ci.enabledExtensionCount = MUG_VK_EXTENSION_COUNT;
						device_ci.ppEnabledExtensionNames = mug_innervk_extensions;

						if (p_inner->init.use_validation_layers) {
							device_ci.enabledLayerCount = MUG_VK_VALIDATION_LAYER_COUNT;
							device_ci.ppEnabledLayerNames = mug_innervk_validation_layers;
						}

						VkPhysicalDeviceFeatures features = MU_ZERO_STRUCT(VkPhysicalDeviceFeatures);
						device_ci.pEnabledFeatures = &features;

						if (vkCreateDevice(p_inner->init.physical_device, &device_ci, 0, &p_inner->init.device) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_DEVICE;
						}

						// Queues, part II: joke that I'm not going to make

						vkGetDeviceQueue(p_inner->init.device, p_inner->init.graphics_family, 0, &p_inner->init.graphics_queue);
						vkGetDeviceQueue(p_inner->init.device, p_inner->init.present_family, 0, &p_inner->init.present_queue);

					return MUG_SUCCESS;
				}

				void mug_innervk_initiation_destroy(mug_innervk_inner* p_inner) {
					if (p_inner->init.device != VK_NULL_HANDLE) {
						vkDeviceWaitIdle(p_inner->init.device);
						vkDestroyDevice(p_inner->init.device, 0);
					}

					if (p_inner->init.surface != VK_NULL_HANDLE) {
						vkDestroySurfaceKHR(p_inner->init.instance, p_inner->init.surface, 0);
					}
					if (p_inner->init.debug_messenger != VK_NULL_HANDLE) {
						PFN_vkDestroyDebugUtilsMessengerEXT fun = (PFN_vkDestroyDebugUtilsMessengerEXT)
						vkGetInstanceProcAddr(p_inner->init.instance, "vkDestroyDebugUtilsMessengerEXT");
						if (fun != 0) {
							fun(p_inner->init.instance, p_inner->init.debug_messenger, 0);
						}
					}
					if (p_inner->init.instance != VK_NULL_HANDLE) {
						vkDestroyInstance(p_inner->init.instance, 0);
					}
				}

			/* Swapchain */

				mugResult mug_innervk_swapchain_create(mug_innervk_inner* p_inner) {
					muCOSAResult cosa_res = MUCOSA_SUCCESS;

					p_inner->sc.handle = VK_NULL_HANDLE;
					p_inner->sc.images = 0;
					p_inner->sc.image_views = 0;

					/* Start create info */

						VkSwapchainCreateInfoKHR sc_ci = MU_ZERO_STRUCT(VkSwapchainCreateInfoKHR);
						sc_ci.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
						sc_ci.surface = p_inner->init.surface;
						sc_ci.imageArrayLayers = 1;
						sc_ci.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
						sc_ci.clipped = VK_TRUE;
						sc_ci.oldSwapchain = VK_NULL_HANDLE;

						uint32_t families[2] = { p_inner->init.graphics_family, p_inner->init.present_family };
						if (p_inner->init.graphics_family != p_inner->init.present_family) {
							sc_ci.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
							sc_ci.queueFamilyIndexCount = 2;
							sc_ci.pQueueFamilyIndices = families;
						}

					/* Capabilities */

						VkSurfaceCapabilitiesKHR cap;
						if (vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
							p_inner->init.physical_device, p_inner->init.surface, &cap
							) != VK_SUCCESS) {
							return MUG_FAILED_GET_VK_SURFACE_INFO;
						}

						sc_ci.minImageCount = cap.minImageCount + 1;
						if (cap.maxImageCount > 0 && sc_ci.minImageCount > cap.maxImageCount) {
							sc_ci.minImageCount = cap.maxImageCount;
						}

						sc_ci.preTransform = cap.currentTransform;
						sc_ci.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;

					/* Format (based on surface) */

						uint32_t format_count = 0;
						if (vkGetPhysicalDeviceSurfaceFormatsKHR(
							p_inner->init.physical_device, p_inner->init.surface, &format_count, 0
							) != VK_SUCCESS) {
							return MUG_FAILED_GET_VK_SURFACE_INFO;
						}

						if (format_count == 0) {
							return MUG_FAILED_GET_VK_SURFACE_INFO;
						}

						VkSurfaceFormatKHR* formats = (VkSurfaceFormatKHR*)mu_malloc(sizeof(VkSurfaceFormatKHR)*format_count);
						if (formats == 0) {
							return MUG_FAILED_ALLOCATE;
						}

						if (vkGetPhysicalDeviceSurfaceFormatsKHR(
							p_inner->init.physical_device, p_inner->init.surface, &format_count, formats)
							!= VK_SUCCESS) {
							mu_free(formats);
							return MUG_FAILED_GET_VK_SURFACE_INFO;
						}

						VkSurfaceFormatKHR chosen_format = formats[0];
						for (uint32_t i = 0; i < format_count; i++) {
							if (formats[i].format == VK_FORMAT_R8G8B8A8_UNORM && 
								formats[i].colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
								chosen_format = formats[i];
								break;
							}
						}

						mu_free(formats);

						sc_ci.imageFormat = chosen_format.format;
						p_inner->sc.format = sc_ci.imageFormat;
						sc_ci.imageColorSpace = chosen_format.colorSpace;

					/* Extent */

						if (cap.currentExtent.width != MU_UINT32_MAX) {
							sc_ci.imageExtent = cap.currentExtent;
						} else {
							uint32_m width=0, height=0;
							mu_window_get_dimensions(&cosa_res, p_inner->win, &width, &height);
							if (cosa_res != MUCOSA_SUCCESS) {
								return muCOSA_result_to_mug_result(cosa_res);
							}

							sc_ci.imageExtent.width = (uint32_t)width;
							if (sc_ci.imageExtent.width < cap.minImageExtent.width) {
								sc_ci.imageExtent.width = cap.minImageExtent.width;
							} else if (sc_ci.imageExtent.width > cap.maxImageExtent.width) {
								sc_ci.imageExtent.width = cap.maxImageExtent.width;
							}

							sc_ci.imageExtent.height = (uint32_t)height;
							if (sc_ci.imageExtent.height < cap.minImageExtent.height) {
								sc_ci.imageExtent.height = cap.minImageExtent.height;
							} else if (sc_ci.imageExtent.height > cap.maxImageExtent.height) {
								sc_ci.imageExtent.height = cap.maxImageExtent.height;
							}
						}

						p_inner->sc.extent = sc_ci.imageExtent;

						p_inner->sc.viewport = MU_ZERO_STRUCT(VkViewport);
						p_inner->sc.viewport.width = p_inner->sc.extent.width;
						p_inner->sc.viewport.height = p_inner->sc.extent.height;
						p_inner->sc.viewport.minDepth = 0.f;
						p_inner->sc.viewport.maxDepth = 1.f;

						p_inner->sc.scissor = MU_ZERO_STRUCT(VkRect2D);
						p_inner->sc.scissor.extent = p_inner->sc.extent;

					/* Present modes */
					// (see https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html)

						uint32_t present_mode_count = 0;
						if (vkGetPhysicalDeviceSurfacePresentModesKHR(
							p_inner->init.physical_device, p_inner->init.surface, &present_mode_count, 0)
						!= VK_SUCCESS) {
							return MUG_FAILED_GET_VK_SURFACE_INFO;
						}

						if (present_mode_count == 0) {
							return MUG_FAILED_GET_VK_SURFACE_INFO;
						}

						VkPresentModeKHR* present_modes = (VkPresentModeKHR*)mu_malloc(sizeof(VkPresentModeKHR)*present_mode_count);
						if (present_modes == 0) {
							return MUG_FAILED_ALLOCATE;
						}

						if (vkGetPhysicalDeviceSurfacePresentModesKHR(
							p_inner->init.physical_device, p_inner->init.surface, &present_mode_count, present_modes)
						!= VK_SUCCESS) {
							mu_free(present_modes);
							return MUG_FAILED_GET_VK_SURFACE_INFO;
						}

						sc_ci.presentMode = present_modes[0];
						for (uint32_t i = 0; i < present_mode_count; i++) {
							if (present_modes[i] == VK_PRESENT_MODE_MAILBOX_KHR) {
								sc_ci.presentMode = present_modes[i];
								break;
							}
						}

						mu_free(present_modes);

					/* Creation */

						if (vkCreateSwapchainKHR(p_inner->init.device, &sc_ci, 0, &p_inner->sc.handle) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_SWAPCHAIN;
						}

					/* Images */

						if (vkGetSwapchainImagesKHR(
							p_inner->init.device, p_inner->sc.handle, &p_inner->sc.image_count, 0) != VK_SUCCESS) {
							return MUG_FAILED_GET_VK_SWAPCHAIN_INFO;
						}

						p_inner->sc.images = (VkImage*)mu_malloc(sizeof(VkImage) * p_inner->sc.image_count);
						if (p_inner->sc.images == 0) {
							return MUG_FAILED_ALLOCATE;
						}

						if (vkGetSwapchainImagesKHR(
							p_inner->init.device, p_inner->sc.handle, &p_inner->sc.image_count, p_inner->sc.images) != VK_SUCCESS) {
							// Don't need to free here since it's handled later ...
							return MUG_FAILED_GET_VK_SWAPCHAIN_INFO;
						}

					/* Image views */

						p_inner->sc.image_views = (VkImageView*)mu_malloc(sizeof(VkImageView)*p_inner->sc.image_count);
						if (p_inner->sc.image_views == 0) {
							return MUG_FAILED_ALLOCATE;
						}

						for (uint32_t i = 0; i < p_inner->sc.image_count; i++) {
							p_inner->sc.image_views[i] = VK_NULL_HANDLE;
						}

						for (uint32_t i = 0; i < p_inner->sc.image_count; i++) {
							VkImageViewCreateInfo iv_ci = MU_ZERO_STRUCT(VkImageViewCreateInfo);
							iv_ci.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
							iv_ci.image = p_inner->sc.images[i];
							iv_ci.viewType = VK_IMAGE_VIEW_TYPE_2D;
							iv_ci.format = p_inner->sc.format;
							iv_ci.components.r = iv_ci.components.g = iv_ci.components.b = iv_ci.components.a =
							VK_COMPONENT_SWIZZLE_IDENTITY;
							iv_ci.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
							iv_ci.subresourceRange.baseMipLevel = 0;
							iv_ci.subresourceRange.levelCount = 1;
							iv_ci.subresourceRange.baseArrayLayer = 0;
							iv_ci.subresourceRange.layerCount = 1;

							if (vkCreateImageView(p_inner->init.device, &iv_ci, 0, &p_inner->sc.image_views[i]) != VK_SUCCESS) {
								return MUG_FAILED_CREATE_VK_SWAPCHAIN_IMAGE_VIEWS;
							}
						}

					return MUG_SUCCESS;
				}

				void mug_innervk_swapchain_destroy(mug_innervk_inner* p_inner) {
					if (p_inner->sc.image_views != 0) {
						for (uint32_t i = 0; i < p_inner->sc.image_count; i++) {
							if (p_inner->sc.image_views[i] != VK_NULL_HANDLE) {
								vkDestroyImageView(p_inner->init.device, p_inner->sc.image_views[i], 0);
							}
						}
						mu_free(p_inner->sc.image_views);
					}

					if (p_inner->sc.images != 0) {
						mu_free(p_inner->sc.images);
					}

					if (p_inner->sc.handle != VK_NULL_HANDLE) {
						vkDestroySwapchainKHR(p_inner->init.device, p_inner->sc.handle, 0);
					}
				}

			/* Command */

				mugResult mug_innervk_command_create(mug_innervk_inner* p_inner, mug_innervk_command* p_cmd) {
					p_cmd->pool = VK_NULL_HANDLE;
					p_cmd->buffer = VK_NULL_HANDLE;
					p_cmd->queue_wait_semaphore = VK_NULL_HANDLE;
					p_cmd->queue_signal_semaphore = VK_NULL_HANDLE;
					p_cmd->queue_wait_fence = VK_NULL_HANDLE;

					p_cmd->on = MU_FALSE;

					/* Pool */

						VkCommandPoolCreateInfo cp_ci = MU_ZERO_STRUCT(VkCommandPoolCreateInfo);
						cp_ci.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
						cp_ci.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
						cp_ci.queueFamilyIndex = p_inner->init.graphics_family;

						if (vkCreateCommandPool(p_inner->init.device, &cp_ci, 0, &p_cmd->pool) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_COMMAND_POOL;
						}

					/* Buffer */

						VkCommandBufferAllocateInfo alloc_info = MU_ZERO_STRUCT(VkCommandBufferAllocateInfo);
						alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
						alloc_info.commandPool = p_cmd->pool;
						alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
						alloc_info.commandBufferCount = 1;

						if (vkAllocateCommandBuffers(p_inner->init.device, &alloc_info, &p_cmd->buffer) != VK_SUCCESS) {
							return MUG_FAILED_ALLOCATE_VK_COMMAND_BUFFERS;
						}

					/* Semaphores */

						VkSemaphoreCreateInfo s_ci = MU_ZERO_STRUCT(VkSemaphoreCreateInfo);
						s_ci.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

						if (vkCreateSemaphore(p_inner->init.device, &s_ci, 0, &p_cmd->queue_wait_semaphore) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_SEMAPHORE;
						}
						if (vkCreateSemaphore(p_inner->init.device, &s_ci, 0, &p_cmd->queue_signal_semaphore) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_SEMAPHORE;
						}

					/* Fence */

						VkFenceCreateInfo f_ci = MU_ZERO_STRUCT(VkFenceCreateInfo);
						f_ci.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
						f_ci.flags = VK_FENCE_CREATE_SIGNALED_BIT;

						if (vkCreateFence(p_inner->init.device, &f_ci, 0, &p_cmd->queue_wait_fence) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_FENCE;
						}

					return MUG_SUCCESS;
				}

				void mug_innervk_command_destroy(mug_innervk_inner* p_inner, mug_innervk_command* p_cmd) {
					if (p_cmd->queue_wait_fence != VK_NULL_HANDLE) {
						vkDestroyFence(p_inner->init.device, p_cmd->queue_wait_fence, 0);
					}

					if (p_cmd->queue_signal_semaphore != VK_NULL_HANDLE) {
						vkDestroySemaphore(p_inner->init.device, p_cmd->queue_signal_semaphore, 0);
					}
					if (p_cmd->queue_wait_semaphore != VK_NULL_HANDLE) {
						vkDestroySemaphore(p_inner->init.device, p_cmd->queue_wait_semaphore, 0);
					}

					if (p_cmd->buffer != VK_NULL_HANDLE) {
						vkFreeCommandBuffers(p_inner->init.device, p_cmd->pool, 1, &p_cmd->buffer);
					}

					if (p_cmd->pool != VK_NULL_HANDLE) {
						vkDestroyCommandPool(p_inner->init.device, p_cmd->pool, 0);
					}
				}

				void mug_innervk_inner_swapchain_resize(mugResult* result, mug_innervk_inner* p_inner);
				// Note: can (and should) be called even if the command has already begun.
				mugResult mug_innervk_command_begin(mug_innervk_inner* p_inner) {
					mugResult res = MUG_SUCCESS;
					VkResult vk_res = VK_SUCCESS;

					if (p_inner->cmds[p_inner->now_cmd].on) {
						return MUG_SUCCESS;
					}

					if (vkWaitForFences(p_inner->init.device, 1, &p_inner->cmds[p_inner->now_cmd].queue_wait_fence, VK_TRUE, MU_UINT64_MAX) != VK_SUCCESS) {
						return MUG_FAILED_WAIT_FOR_VK_FENCE;
					}

					/* Start getting next swapchain image */

						vk_res = vkAcquireNextImageKHR(p_inner->init.device, p_inner->sc.handle, UINT64_MAX,
							p_inner->cmds[p_inner->now_cmd].queue_wait_semaphore, VK_NULL_HANDLE, &p_inner->sc.image_index
						);

						while (vk_res == VK_ERROR_OUT_OF_DATE_KHR) {
							mug_innervk_inner_swapchain_resize(&res, p_inner);
							vk_res = vkAcquireNextImageKHR(p_inner->init.device, p_inner->sc.handle, UINT64_MAX,
								p_inner->cmds[p_inner->now_cmd].queue_wait_semaphore, VK_NULL_HANDLE, &p_inner->sc.image_index
							);
						}
						if (vk_res != VK_SUCCESS && vk_res != VK_SUBOPTIMAL_KHR) {
							return MUG_FAILED_GET_NEXT_VK_SWAPCHAIN_IMAGE;
						}

					if (vkResetFences(p_inner->init.device, 1, &p_inner->cmds[p_inner->now_cmd].queue_wait_fence) != VK_SUCCESS) {
						return MUG_FAILED_RESET_VK_FENCE;
					}

					/* Begin command buffer */

						if (vkResetCommandBuffer(p_inner->cmds[p_inner->now_cmd].buffer, 0) != VK_SUCCESS) {
							return MUG_FAILED_RESET_VK_COMMAND_BUFFER;
						}

						VkCommandBufferBeginInfo cb_ci = MU_ZERO_STRUCT(VkCommandBufferBeginInfo);
						cb_ci.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

						if (vkBeginCommandBuffer(p_inner->cmds[p_inner->now_cmd].buffer, &cb_ci) != VK_SUCCESS) {
							return MUG_FAILED_BEGIN_VK_COMMAND_BUFFER;
						}

						p_inner->cmds[p_inner->now_cmd].on = MU_TRUE;

					return MUG_SUCCESS;
				}

				// Make sure to check if commands have even started before calling this!!
				mugResult mug_innervk_command_end_and_submit(mug_innervk_inner* p_inner) {
					if (!p_inner->cmds[p_inner->now_cmd].on) {
						return MUG_SUCCESS;
					}

					/* End command buffer, storing all render passes */

						if (vkEndCommandBuffer(p_inner->cmds[p_inner->now_cmd].buffer) != VK_SUCCESS) {
							return MUG_FAILED_END_VK_COMMAND_BUFFER;
						}
						p_inner->cmds[p_inner->now_cmd].on = MU_FALSE;

					/* Submit commands to the graphics queue, which will start the rendering */

						// (For wait semaphore, wait until all commands relevant to the swapchain image being
						// acquired have finished, ensuring that the image is fully available before the queued
						// commands start executing.)
						VkPipelineStageFlags wait_dst = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;

						VkSubmitInfo submit_info = MU_ZERO_STRUCT(VkSubmitInfo);
						submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
						submit_info.waitSemaphoreCount = 1;
						submit_info.pWaitSemaphores = &p_inner->cmds[p_inner->now_cmd].queue_wait_semaphore;
						submit_info.pWaitDstStageMask = &wait_dst;
						submit_info.commandBufferCount = 1;
						submit_info.pCommandBuffers = &p_inner->cmds[p_inner->now_cmd].buffer;
						submit_info.signalSemaphoreCount = 1;
						submit_info.pSignalSemaphores = &p_inner->cmds[p_inner->now_cmd].queue_signal_semaphore;
						// ^ This sets up queue_signal_semaphore to be signaled when all of the commands are
						// submitted to the graphics queue, which is waited for in the present function.

						if (vkQueueSubmit(p_inner->init.graphics_queue, 1, &submit_info, p_inner->cmds[p_inner->now_cmd].queue_wait_fence) != VK_SUCCESS) {
							return MUG_FAILED_SUBMIT_VK_QUEUE;
						}

					return MUG_SUCCESS;
				}

				// Warning: this is an expensive function.
				mugResult mug_innervk_command_present(mug_innervk_inner* p_inner) {
					mugResult res = MUG_SUCCESS;
					VkResult vk_res = VK_SUCCESS;

					if (p_inner->cmds[p_inner->now_cmd].on) {
						return MUG_SUCCESS;
					}

					/* Present swapchain when commands are finished, signaled by the queue signal. */

						VkPresentInfoKHR pres_i = MU_ZERO_STRUCT(VkPresentInfoKHR);
						pres_i.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
						pres_i.waitSemaphoreCount = 1;
						pres_i.pWaitSemaphores = &p_inner->cmds[p_inner->now_cmd].queue_signal_semaphore;
						pres_i.swapchainCount = 1;
						pres_i.pSwapchains = &p_inner->sc.handle;
						pres_i.pImageIndices = &p_inner->sc.image_index;

						vk_res = vkQueuePresentKHR(p_inner->init.present_queue, &pres_i);
						if (vk_res == VK_ERROR_OUT_OF_DATE_KHR || vk_res == VK_SUBOPTIMAL_KHR) {
							mug_innervk_inner_swapchain_resize(&res, p_inner);
						} else if (vk_res != VK_SUCCESS) {
							return MUG_FAILED_PRESENT_VK_QUEUE;
						}

					return MUG_SUCCESS;
				}

				mugResult mug_innervk_command_get_next_swapchain(mug_innervk_inner* p_inner) {
					if (p_inner->cmds[p_inner->now_cmd].on) {
						return MUG_SUCCESS;
					}

					if (vkWaitForFences(p_inner->init.device, 1, &p_inner->cmds[p_inner->now_cmd].queue_wait_fence, VK_TRUE, MU_UINT64_MAX) != VK_SUCCESS) {
						return MUG_FAILED_WAIT_FOR_VK_FENCE;
					}

					/* Start getting next swapchain image */

						if (vkAcquireNextImageKHR(p_inner->init.device, p_inner->sc.handle, UINT64_MAX,
							p_inner->cmds[p_inner->now_cmd].queue_wait_semaphore, VK_NULL_HANDLE, &p_inner->sc.image_index
						) != VK_SUCCESS) {
							return MUG_FAILED_GET_NEXT_VK_SWAPCHAIN_IMAGE;
						}

					if (vkResetFences(p_inner->init.device, 1, &p_inner->cmds[p_inner->now_cmd].queue_wait_fence) != VK_SUCCESS) {
						return MUG_FAILED_RESET_VK_FENCE;
					}

					return MUG_SUCCESS;
				}

			/* Renderers */

				VkAttachmentDescription mug_innervk_renderer_def_attachment_desc(mug_innervk_swapchain* p_sc) {
					VkAttachmentDescription attr = MU_ZERO_STRUCT(VkAttachmentDescription);
					attr.format = p_sc->format;
					attr.samples = VK_SAMPLE_COUNT_1_BIT;
					attr.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
					attr.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
					return attr;
				}

				VkRenderPassCreateInfo mug_innervk_renderer_def_rp_ci(void) {
					VkRenderPassCreateInfo rp_ci = MU_ZERO_STRUCT(VkRenderPassCreateInfo);
					rp_ci.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
					return rp_ci;
				}

				mugResult mug_innervk_renderers_create_render_passes(mug_innervk_inner* p_inner) {
					p_inner->rs.unknown_to_ca.render_pass = VK_NULL_HANDLE;
					p_inner->rs.ca_to_present.render_pass = VK_NULL_HANDLE;
					p_inner->rs.ca_to_ca_pip.render_pass = VK_NULL_HANDLE;

					VkAttachmentDescription attr;
					VkRenderPassCreateInfo rp_ci;
					VkAttachmentReference ref;
					VkSubpassDescription subpass;

					/* unknown_to_ca */

						attr = mug_innervk_renderer_def_attachment_desc(&p_inner->sc);
						attr.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
						attr.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
						attr.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
						attr.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

						ref = MU_ZERO_STRUCT(VkAttachmentReference);
						ref.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

						subpass = MU_ZERO_STRUCT(VkSubpassDescription);
						subpass.colorAttachmentCount = 1;
						subpass.pColorAttachments = &ref;

						rp_ci = mug_innervk_renderer_def_rp_ci();
						rp_ci.attachmentCount = 1;
						rp_ci.pAttachments = &attr;
						rp_ci.subpassCount = 1;
						rp_ci.pSubpasses = &subpass;

						if (vkCreateRenderPass(
							p_inner->init.device, &rp_ci, 0, &p_inner->rs.unknown_to_ca.render_pass
						) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_RENDER_PASS;
						}

					/* ca_to_present */

						attr = mug_innervk_renderer_def_attachment_desc(&p_inner->sc);
						attr.loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
						attr.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
						attr.initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
						attr.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

						rp_ci = mug_innervk_renderer_def_rp_ci();
						rp_ci.attachmentCount = 1;
						rp_ci.pAttachments = &attr;

						ref = MU_ZERO_STRUCT(VkAttachmentReference);
						ref.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

						subpass = MU_ZERO_STRUCT(VkSubpassDescription);
						subpass.colorAttachmentCount = 1;
						subpass.pColorAttachments = &ref;

						rp_ci = mug_innervk_renderer_def_rp_ci();
						rp_ci.attachmentCount = 1;
						rp_ci.pAttachments = &attr;
						rp_ci.subpassCount = 1;
						rp_ci.pSubpasses = &subpass;

						if (vkCreateRenderPass(
							p_inner->init.device, &rp_ci, 0, &p_inner->rs.ca_to_present.render_pass
						) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_RENDER_PASS;
						}

					/* ca_to_ca_pip */

						attr = mug_innervk_renderer_def_attachment_desc(&p_inner->sc);
						attr.loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
						attr.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
						attr.initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
						attr.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

						ref = MU_ZERO_STRUCT(VkAttachmentReference);
						ref.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

						subpass = MU_ZERO_STRUCT(VkSubpassDescription);
						subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
						subpass.colorAttachmentCount = 1;
						subpass.pColorAttachments = &ref;

						rp_ci = mug_innervk_renderer_def_rp_ci();
						rp_ci.attachmentCount = 1;
						rp_ci.pAttachments = &attr;
						rp_ci.subpassCount = 1;
						rp_ci.pSubpasses = &subpass;

						if (vkCreateRenderPass(
							p_inner->init.device, &rp_ci, 0, &p_inner->rs.ca_to_ca_pip.render_pass
						) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_RENDER_PASS;
						}

					return MUG_SUCCESS;
				}

				void mug_innervk_renderers_destroy_render_passes(mug_innervk_inner* p_inner) {
					if (p_inner->rs.unknown_to_ca.render_pass != VK_NULL_HANDLE) {
						vkDestroyRenderPass(p_inner->init.device, p_inner->rs.unknown_to_ca.render_pass, 0);
					}
					if (p_inner->rs.ca_to_present.render_pass != VK_NULL_HANDLE) {
						vkDestroyRenderPass(p_inner->init.device, p_inner->rs.ca_to_present.render_pass, 0);
					}
					if (p_inner->rs.ca_to_ca_pip.render_pass != VK_NULL_HANDLE) {
						vkDestroyRenderPass(p_inner->init.device, p_inner->rs.ca_to_ca_pip.render_pass, 0);
					}
				}

				VkFramebuffer* mug_innervk_def_framebuffers_create(VkResult* vk_result, mug_innervk_inner* p_inner, VkRenderPass rp) {
					MU_SET_RESULT(vk_result, VK_SUCCESS)
					VkResult vkres = VK_SUCCESS;

					VkFramebuffer* fbs = (VkFramebuffer*)mu_malloc(sizeof(VkFramebuffer) * p_inner->sc.image_count);
					if (fbs == 0) {
						return 0;
					}

					for (uint32_t i = 0; i < p_inner->sc.image_count; i++) {
						fbs[i] = VK_NULL_HANDLE;
					}

					for (uint32_t i = 0; i < p_inner->sc.image_count; i++) {
						VkFramebufferCreateInfo ci = MU_ZERO_STRUCT(VkFramebufferCreateInfo);
						ci.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
						ci.renderPass = rp;
						ci.attachmentCount = 1;
						ci.pAttachments = &p_inner->sc.image_views[i];
						ci.width = p_inner->sc.extent.width;
						ci.height = p_inner->sc.extent.height;
						ci.layers = 1;

						vkres = vkCreateFramebuffer(p_inner->init.device, &ci, 0, &fbs[i]);
						if (vkres != VK_SUCCESS) {
							MU_SET_RESULT(vk_result, vkres)
							return fbs;
						}
					}

					return fbs;
				}

				mugResult mug_innervk_renderers_create_framebuffers(mug_innervk_inner* p_inner) {
					VkResult vkres = VK_SUCCESS;

					p_inner->rs.unknown_to_ca.framebuffers = mug_innervk_def_framebuffers_create(&vkres, p_inner, p_inner->rs.unknown_to_ca.render_pass);
					if (p_inner->rs.unknown_to_ca.framebuffers == 0) {
						return MUG_FAILED_ALLOCATE;
					}
					if (vkres != VK_SUCCESS) {
						return MUG_FAILED_CREATE_VK_FRAMEBUFFERS;
					}

					p_inner->rs.ca_to_present.framebuffers = mug_innervk_def_framebuffers_create(&vkres, p_inner, p_inner->rs.ca_to_present.render_pass);
					if (p_inner->rs.ca_to_present.framebuffers == 0) {
						return MUG_FAILED_ALLOCATE;
					}
					if (vkres != VK_SUCCESS) {
						return MUG_FAILED_CREATE_VK_FRAMEBUFFERS;
					}

					p_inner->rs.ca_to_ca_pip.framebuffers = mug_innervk_def_framebuffers_create(&vkres, p_inner, p_inner->rs.ca_to_ca_pip.render_pass);
					if (p_inner->rs.ca_to_ca_pip.framebuffers == 0) {
						return MUG_FAILED_ALLOCATE;
					}
					if (vkres != VK_SUCCESS) {
						return MUG_FAILED_CREATE_VK_FRAMEBUFFERS;
					}

					return MUG_SUCCESS;
				}

				void mug_innervk_renderer_destroy_framebuffers(mug_innervk_inner* p_inner, mug_innervk_renderer* p_r) {
					if (p_r->framebuffers != 0) {
						for (size_m i = 0; i < p_inner->sc.image_count; i++) {
							if (p_r->framebuffers[i] == VK_NULL_HANDLE) {
								return;
							}
							vkDestroyFramebuffer(p_inner->init.device, p_r->framebuffers[i], 0);
						}
					}
				}

				void mug_innervk_renderers_destroy_framebuffers(mug_innervk_inner* p_inner) {
					mug_innervk_renderer_destroy_framebuffers(p_inner, &p_inner->rs.unknown_to_ca);
					mug_innervk_renderer_destroy_framebuffers(p_inner, &p_inner->rs.ca_to_present);
					mug_innervk_renderer_destroy_framebuffers(p_inner, &p_inner->rs.ca_to_ca_pip);
				}

				mugResult mug_innervk_renderers_clear(mug_innervk_inner* p_inner, float r, float g, float b, float a) {
					mugResult res = MUG_SUCCESS;

					/* Turn on commands if they haven't been already */

					if (!p_inner->cmds[p_inner->now_cmd].on) {
						res = mug_innervk_command_begin(p_inner);
						if (res != MUG_SUCCESS) {
							return res;
						}
					}

					/* Start unknown_to_ca render pass to clear contents */

					VkRenderPassBeginInfo rp_ci = MU_ZERO_STRUCT(VkRenderPassBeginInfo);
					rp_ci.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
					rp_ci.renderPass = p_inner->rs.unknown_to_ca.render_pass;
					rp_ci.framebuffer = p_inner->rs.unknown_to_ca.framebuffers[p_inner->sc.image_index];
					rp_ci.renderArea.offset.x = 0;
					rp_ci.renderArea.offset.y = 0;
					rp_ci.renderArea.extent = p_inner->sc.extent;

					VkClearValue clear_value = MU_ZERO_STRUCT(VkClearValue);
					clear_value.color.float32[0] = r;
					clear_value.color.float32[1] = g;
					clear_value.color.float32[2] = b;
					clear_value.color.float32[3] = a;

					rp_ci.clearValueCount = 1;
					rp_ci.pClearValues = &clear_value;

					vkCmdBeginRenderPass(p_inner->cmds[p_inner->now_cmd].buffer, &rp_ci, VK_SUBPASS_CONTENTS_INLINE);

					/* End the render pass */

					vkCmdEndRenderPass(p_inner->cmds[p_inner->now_cmd].buffer);

					return MUG_SUCCESS;
				}

				mugResult mug_innervk_renderers_make_presentable(mug_innervk_inner* p_inner) {
					mugResult res = MUG_SUCCESS;

					/* Turn on commands if they haven't been already */

					if (!p_inner->cmds[p_inner->now_cmd].on) {
						res = mug_innervk_command_begin(p_inner);
						if (res != MUG_SUCCESS) {
							return res;
						}
					}

					/* Start ca_to_present render pass to make layout presentable */

					VkRenderPassBeginInfo rp_ci = MU_ZERO_STRUCT(VkRenderPassBeginInfo);
					rp_ci.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
					rp_ci.renderPass = p_inner->rs.ca_to_present.render_pass;
					rp_ci.framebuffer = p_inner->rs.ca_to_present.framebuffers[p_inner->sc.image_index];
					rp_ci.renderArea.offset.x = 0;
					rp_ci.renderArea.offset.y = 0;
					rp_ci.renderArea.extent = p_inner->sc.extent;

					vkCmdBeginRenderPass(p_inner->cmds[p_inner->now_cmd].buffer, &rp_ci, VK_SUBPASS_CONTENTS_INLINE);

					/* End the render pass */

					vkCmdEndRenderPass(p_inner->cmds[p_inner->now_cmd].buffer);

					return MUG_SUCCESS;
				}

				// Note: load shader before this
				// Note: render_count is discarded if p_shader->use_buffers; overridable by use_count
				mugResult mug_innervk_renderers_render_shader(mug_innervk_inner* p_inner, mug_innervk_shader* p_shader, size_m buf, size_m render_count, muBool use_count) {
					mugResult res = MUG_SUCCESS;

					/* Turn on commands if they haven't been already */

						if (!p_inner->cmds[p_inner->now_cmd].on) {
							res = mug_innervk_command_begin(p_inner);
							if (res != MUG_SUCCESS) {
								return res;
							}
						}

					/* Start render pass with pipeline render pass */

						VkRenderPassBeginInfo rp_ci = MU_ZERO_STRUCT(VkRenderPassBeginInfo);
						rp_ci.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
						rp_ci.renderPass = p_inner->rs.ca_to_ca_pip.render_pass;
						rp_ci.framebuffer = p_inner->rs.ca_to_ca_pip.framebuffers[p_inner->sc.image_index];
						rp_ci.renderArea.extent = p_inner->sc.extent;

						vkCmdBeginRenderPass(p_inner->cmds[p_inner->now_cmd].buffer, &rp_ci, VK_SUBPASS_CONTENTS_INLINE);

					/* Bind and draw pipeline */

						vkCmdBindPipeline(p_inner->cmds[p_inner->now_cmd].buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, p_shader->pipeline);

						// (Set dynamic state)

						vkCmdSetScissor(p_inner->cmds[p_inner->now_cmd].buffer, 0, 1, &p_inner->sc.scissor);
						vkCmdSetViewport(p_inner->cmds[p_inner->now_cmd].buffer, 0, 1, &p_inner->sc.viewport);

						// (Bind revelant buffers)

						if (p_shader->use_buffers) {
							VkDeviceSize offset = 0;
							vkCmdBindVertexBuffers(p_inner->cmds[p_inner->now_cmd].buffer, 0, 1, &p_shader->buffers.data[buf].vbuf.buf, &offset);

							if (p_shader->use_index) {
								vkCmdBindIndexBuffer(p_inner->cmds[p_inner->now_cmd].buffer, p_shader->buffers.data[buf].ibuf.buf, 0, p_shader->index_type);
							}
						}

						if (p_shader->uniforms.ds[0] != VK_NULL_HANDLE) {
							vkCmdBindDescriptorSets(p_inner->cmds[p_inner->now_cmd].buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, 
								p_shader->pipeline_layout, 0, 1, &p_shader->uniforms.ds[p_inner->now_cmd], 0, 0
							);
						}

						uint32_t count = (uint32_t)render_count;
						if (p_shader->use_buffers && !use_count) {
							count = (uint32_t)p_shader->buffers.data[buf].render_count;
						}

						if (p_shader->use_index) {
							vkCmdDrawIndexed(p_inner->cmds[p_inner->now_cmd].buffer, count, 1, 0, 0, 0);
						} else if (p_shader->use_buffers) {
							vkCmdDraw(p_inner->cmds[p_inner->now_cmd].buffer, count, 1, 0, 0);
						} else {
							vkCmdDraw(p_inner->cmds[p_inner->now_cmd].buffer, count, 1, 0, 0);
						}

					/* End render pass */

						vkCmdEndRenderPass(p_inner->cmds[p_inner->now_cmd].buffer);

					if (p_shader->use_buffers) {
						p_shader->buffers.data[buf].rendered_this_frame = MU_TRUE;
					}

					return MUG_SUCCESS;
				}

			/* Buffers */

				mugResult mug_innervk_buffer_create_manual(mug_innervk_inner* p_inner, VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags props, VkBuffer* p_buffer, VkDeviceMemory* p_memory
				) {
					/* Buffer */

						VkBufferCreateInfo ci = MU_ZERO_STRUCT(VkBufferCreateInfo);
						ci.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
						ci.size = size;
						ci.usage = usage;
						ci.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

						if (vkCreateBuffer(p_inner->init.device, &ci, 0, p_buffer) != VK_SUCCESS) {
							return MUG_FAILED_CREATE_VK_BUFFER;
						}

					/* Memory */

						VkMemoryRequirements mem_req;
						vkGetBufferMemoryRequirements(p_inner->init.device, *p_buffer, &mem_req);
						VkPhysicalDeviceMemoryProperties mem_prop;
						vkGetPhysicalDeviceMemoryProperties(p_inner->init.physical_device, &mem_prop);

						muBool found = MU_FALSE;
						uint32_t mem_index = 0;
						for (uint32_t i = 0; i < mem_prop.memoryTypeCount; i++) {
							if ((mem_req.memoryTypeBits & (1 << i)) &&
								(mem_prop.memoryTypes[i].propertyFlags & props) == props
							) {
								mem_index = i;
								found = MU_TRUE;
								break;
							}
						}
						if (!found) {
							vkDestroyBuffer(p_inner->init.device, *p_buffer, 0);
							return MUG_FAILED_FIND_VALID_VK_MEMORY_TYPE;
						}

						VkMemoryAllocateInfo alloc_i = MU_ZERO_STRUCT(VkMemoryAllocateInfo);
						alloc_i.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
						alloc_i.allocationSize = mem_req.size;
						alloc_i.memoryTypeIndex = mem_index;

						if (vkAllocateMemory(p_inner->init.device, &alloc_i, 0, p_memory) != VK_SUCCESS) {
							vkDestroyBuffer(p_inner->init.device, *p_buffer, 0);
							return MUG_FAILED_ALLOCATE_VK_MEMORY;
						}

						vkBindBufferMemory(p_inner->init.device, *p_buffer, *p_memory, 0);

					return MUG_SUCCESS;
				}

				// Note: this whole process can most likely be optimized.
				mugResult mug_innervk_buffer_raw_copy(mug_innervk_inner* p_inner, VkBuffer dst, VkBuffer src, VkDeviceSize size) {
					/* Allocation */

						VkCommandBufferAllocateInfo alloc_i = MU_ZERO_STRUCT(VkCommandBufferAllocateInfo);
						alloc_i.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
						alloc_i.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
						alloc_i.commandPool = p_inner->cmds[p_inner->now_cmd].pool;
						alloc_i.commandBufferCount = 1;

						VkCommandBuffer cmd_buf = VK_NULL_HANDLE;
						if (vkAllocateCommandBuffers(p_inner->init.device, &alloc_i, &cmd_buf) != VK_SUCCESS) {
							return MUG_FAILED_ALLOCATE_VK_COMMAND_BUFFERS;
						}

					/* Commands */

						VkCommandBufferBeginInfo begin_i = MU_ZERO_STRUCT(VkCommandBufferBeginInfo);
						begin_i.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
						begin_i.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

						if (vkBeginCommandBuffer(cmd_buf, &begin_i) != VK_SUCCESS) {
							vkFreeCommandBuffers(p_inner->init.device, p_inner->cmds[p_inner->now_cmd].pool, 1, &cmd_buf);
							return MUG_FAILED_BEGIN_VK_COMMAND_BUFFER;
						}

						VkBufferCopy region = MU_ZERO_STRUCT(VkBufferCopy);
						region.size = size;
						vkCmdCopyBuffer(cmd_buf, src, dst, 1, &region);

						if (vkEndCommandBuffer(cmd_buf) != VK_SUCCESS) {
							vkFreeCommandBuffers(p_inner->init.device, p_inner->cmds[p_inner->now_cmd].pool, 1, &cmd_buf);
							return MUG_FAILED_END_VK_COMMAND_BUFFER;
						}

					/* Submit */

						VkSubmitInfo submit_i = MU_ZERO_STRUCT(VkSubmitInfo);
						submit_i.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
						submit_i.commandBufferCount = 1;
						submit_i.pCommandBuffers = &cmd_buf;

						if (vkQueueSubmit(p_inner->init.graphics_queue, 1, &submit_i, VK_NULL_HANDLE) != VK_SUCCESS) {
							vkFreeCommandBuffers(p_inner->init.device, p_inner->cmds[p_inner->now_cmd].pool, 1, &cmd_buf);
							return MUG_FAILED_SUBMIT_VK_QUEUE;
						}

					vkQueueWaitIdle(p_inner->init.graphics_queue);
					vkFreeCommandBuffers(p_inner->init.device, p_inner->cmds[p_inner->now_cmd].pool, 1, &cmd_buf);
					return MUG_SUCCESS;
				}

				// This function's kinda dumb now, eh
				mug_innervk_buffer mug_innervk_buffer_create(mugResult* result, mug_innervk_inner* p_inner, VkDeviceSize data_size, VkBufferUsageFlagBits usage, muBool local) {
					mugResult res = MUG_SUCCESS;
					mug_innervk_buffer buffer = MU_ZERO_STRUCT(mug_innervk_buffer);
					buffer.buf = VK_NULL_HANDLE;
					buffer.mem = VK_NULL_HANDLE;

					VkMemoryPropertyFlags props = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
					if (!local) {
						props = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
					}
					res = mug_innervk_buffer_create_manual(p_inner, data_size, VK_BUFFER_USAGE_TRANSFER_DST_BIT | usage, props, &buffer.buf, &buffer.mem);
					if (res != MUG_SUCCESS) {
						MU_SET_RESULT(result, res)
						return buffer;
					}

					return buffer;
				}

				void mug_innervk_buffer_destroy(mug_innervk_inner* p_inner, mug_innervk_buffer* p_buffer) {
					if (p_buffer->buf != VK_NULL_HANDLE) {
						vkDestroyBuffer(p_inner->init.device, p_buffer->buf, 0);
						p_buffer->buf = VK_NULL_HANDLE;
					}
					if (p_buffer->mem != VK_NULL_HANDLE) {
						vkFreeMemory(p_inner->init.device, p_buffer->mem, 0);
						p_buffer->mem = VK_NULL_HANDLE;
					}
				}

				mugResult mug_innervk_buffer_transfer(mug_innervk_inner* p_inner, mug_innervk_buffer* p_buffer, void* data, VkDeviceSize data_size) {
					mugResult res = MUG_SUCCESS;

					// Stage buffer creation

					VkBuffer stage_buf = VK_NULL_HANDLE;
					VkDeviceMemory stage_mem = VK_NULL_HANDLE;
					res = mug_innervk_buffer_create_manual(
						p_inner, data_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
						VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
						&stage_buf, &stage_mem
					);
					if (res != MUG_SUCCESS) {
						return res;
					}

					// Stage buffer data copying

					void* gpu_memory = 0;
					if (vkMapMemory(p_inner->init.device, stage_mem, 0, data_size, 0, &gpu_memory) != VK_SUCCESS) {
						vkDestroyBuffer(p_inner->init.device, stage_buf, 0);
						vkFreeMemory(p_inner->init.device, stage_mem, 0);
						return MUG_FAILED_MAP_VK_MEMORY;
					}

					mu_memcpy(gpu_memory, data, (size_t)data_size);
					vkUnmapMemory(p_inner->init.device, stage_mem);

					// Copying stage buffer data into buffer

					res = mug_innervk_buffer_raw_copy(p_inner, p_buffer->buf, stage_buf, data_size);
					if (res != MUG_SUCCESS) {
						vkDestroyBuffer(p_inner->init.device, stage_buf, 0);
						vkFreeMemory(p_inner->init.device, stage_mem, 0);
						return res;
					}

					vkDestroyBuffer(p_inner->init.device, stage_buf, 0);
					vkFreeMemory(p_inner->init.device, stage_mem, 0);
					return MUG_SUCCESS;
				}

			/* Shaders */

				/* Buffer prep */

					// isize is ignored if !p_shader->use_index
					// Doesn't perform checks on p_shader->use_buffers, so don't use if the case is such.
					size_m mug_innervk_shader_create_vbuffer(mugResult* result, mug_innervk_inner* p_inner, mug_innervk_shader* p_shader, size_m vsize, size_m isize, size_m render_count, size_m obj_count) {
						mugResult res = MUG_SUCCESS;
						mumaResult muma_res = MUMA_SUCCESS;
						mug_innervk_vbuffer s_vbuf = MU_ZERO_STRUCT(mug_innervk_vbuffer);
						s_vbuf.render_count = render_count;
						s_vbuf.obj_count = obj_count;
						size_m i_vbuf = MU_NONE;

						s_vbuf.vbuf = mug_innervk_buffer_create(
							&res, p_inner, (VkDeviceSize)vsize, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, MU_TRUE
						);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return i_vbuf;
						}

						if (p_shader->use_index) {
							s_vbuf.ibuf = mug_innervk_buffer_create(
								&res, p_inner, (VkDeviceSize)isize, VK_BUFFER_USAGE_INDEX_BUFFER_BIT, MU_TRUE
							);
							if (res != MUG_SUCCESS) {
								MU_SET_RESULT(result, res)
								mug_innervk_buffer_destroy(p_inner, &s_vbuf.vbuf);
								return i_vbuf;
							}
						}

						p_shader->buffers = mug_innervk_vbuffers_find_push(
							&muma_res, p_shader->buffers, s_vbuf, &i_vbuf
						);
						if (muma_res != MUMA_SUCCESS) {
							MU_SET_RESULT(result, muma_result_to_mug_result(muma_res))
							mug_innervk_buffer_destroy(p_inner, &s_vbuf.ibuf);
							mug_innervk_buffer_destroy(p_inner, &s_vbuf.vbuf);
							return i_vbuf;
						}

						s_vbuf.active = MU_TRUE;
						p_shader->buffers.data[i_vbuf] = s_vbuf;
						return i_vbuf;
					}

					void mug_innervk_shader_destroy_vbuffer(mug_innervk_inner* p_inner, mug_innervk_shader* p_shader, size_m buf) {
						if (buf >= p_shader->buffers.length) {
							return;
						}
						if (p_shader->buffers.data[buf].active) {
							vkDeviceWaitIdle(p_inner->init.device);
							if (p_shader->use_buffers) {
								mug_innervk_buffer_destroy(p_inner, &p_shader->buffers.data[buf].vbuf);
							}
							if (p_shader->use_index) {
								mug_innervk_buffer_destroy(p_inner, &p_shader->buffers.data[buf].ibuf);
							}
							p_shader->buffers.data[buf] = MU_ZERO_STRUCT(mug_innervk_vbuffer);
						}
					}

				/* Shader uniforms */

					VkBufferUsageFlagBits mug_innervk_descriptor_to_usage(VkDescriptorType type) {
						switch (type) {
							default: return (VkBufferUsageFlagBits)0; break;
							case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: return VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT; break;
						}
					}

					void mug_innervk_shader_uniform_empty(mug_innervk_shader_uniforms* p_su) {
						*p_su = MU_ZERO_STRUCT(mug_innervk_shader_uniforms);

						p_su->dp = VK_NULL_HANDLE;

						for (size_m i = 0; i < MUG_VK_LOOK_AHEAD_FRAMES; i++) {
							p_su->dsl[i] = VK_NULL_HANDLE;
							p_su->ds[i] = VK_NULL_HANDLE;

							for (size_m j = 0; j < MUG_VK_UNIFORM_BUFFER_BUFLEN; j++) {
								p_su->bufs[j].bufs[i].buf = VK_NULL_HANDLE;
								p_su->bufs[j].bufs[i].mem = VK_NULL_HANDLE;
							}
						}
					}

					void mug_innervk_shader_uniform_destroy(mug_innervk_inner* p_inner, mug_innervk_shader_uniforms* p_su) {
						if (p_su->dp != VK_NULL_HANDLE) {
							// (DSs are implicity free'd by this call btw)
							vkDestroyDescriptorPool(p_inner->init.device, p_su->dp, 0);
						}

						for (size_m f = 0; f < MUG_VK_LOOK_AHEAD_FRAMES; f++) {
							if (p_su->dsl[f] != VK_NULL_HANDLE) {
								vkDestroyDescriptorSetLayout(p_inner->init.device, p_su->dsl[f], 0);
							}
						}

						for (size_m i = 0; i < p_su->buflen; i++) {
							for (size_m j = 0; j < MUG_VK_LOOK_AHEAD_FRAMES; j++) {
								mug_innervk_buffer_destroy(p_inner, &p_su->bufs[i].bufs[j]);
							}
						}
						mug_innervk_shader_uniform_empty(p_su);
					}

					mugResult mug_innervk_shader_uniform_create(mug_innervk_inner* p_inner, mug_innervk_shader_uniforms* p_su, uint32_t uniform_count, VkDescriptorType* p_descriptors, VkDeviceSize* p_sizes, uint32_t* p_bindings, VkShaderStageFlags* p_stages) {
						mug_innervk_shader_uniform_empty(p_su);
						mugResult res = MUG_SUCCESS;

						p_su->buflen = (size_m)uniform_count;

						/* Uniform buffers */

							for (uint32_t u = 0; u < uniform_count; u++) {
								for (size_m b = 0; b < MUG_VK_LOOK_AHEAD_FRAMES; b++) {

									p_su->bufs[u].bufs[b] = mug_innervk_buffer_create(&res, p_inner, p_sizes[u], mug_innervk_descriptor_to_usage(p_descriptors[u]), MU_FALSE);
									if (res != MUG_SUCCESS) {
										mug_innervk_shader_uniform_destroy(p_inner, p_su);
										return res;
									}

									if (vkMapMemory(p_inner->init.device, p_su->bufs[u].bufs[b].mem, 0, p_sizes[u], 0, &p_su->bufs[u].bufs[b].mapped_mem ) != VK_SUCCESS) {
										mug_innervk_shader_uniform_destroy(p_inner, p_su);
										return MUG_FAILED_MAP_VK_MEMORY;
									}
								}
							}

						/* Descriptor set layouts */

							VkDescriptorSetLayoutBinding dsl_bindings[MUG_VK_UNIFORM_BUFFER_BUFLEN] = { MU_ZERO_STRUCT(VkDescriptorSetLayoutBinding) };

							for (uint32_t i = 0; i < uniform_count; i++) {
								dsl_bindings[i].binding = p_bindings[i];
								dsl_bindings[i].descriptorType = p_descriptors[i];
								dsl_bindings[i].descriptorCount = 1;
								dsl_bindings[i].stageFlags = p_stages[i];
							}

							VkDescriptorSetLayoutCreateInfo dsl_ci = MU_ZERO_STRUCT(VkDescriptorSetLayoutCreateInfo);
							dsl_ci.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
							dsl_ci.bindingCount = uniform_count;
							dsl_ci.pBindings = dsl_bindings;

							for (size_m i = 0; i < MUG_VK_LOOK_AHEAD_FRAMES; i++) {
								if (vkCreateDescriptorSetLayout(p_inner->init.device, &dsl_ci, 0, &p_su->dsl[i]) != VK_SUCCESS) {
									mug_innervk_shader_uniform_destroy(p_inner, p_su);
									return MUG_FAILED_CREATE_VK_DESCRIPTOR_SET_LAYOUT;
								}
							}

						/* Descriptor pool */

							VkDescriptorPoolSize pool_sizes[MUG_VK_UNIFORM_BUFFER_BUFLEN] = { MU_ZERO_STRUCT(VkDescriptorPoolSize) };

							for (uint32_t i = 0; i < uniform_count; i++) {
								pool_sizes[i].type = p_descriptors[i];
								pool_sizes[i].descriptorCount = MUG_VK_LOOK_AHEAD_FRAMES;
							}

							VkDescriptorPoolCreateInfo dp_ci = MU_ZERO_STRUCT(VkDescriptorPoolCreateInfo);
							dp_ci.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
							dp_ci.maxSets = MUG_VK_LOOK_AHEAD_FRAMES;
							dp_ci.poolSizeCount = uniform_count;
							dp_ci.pPoolSizes = pool_sizes;

							if (vkCreateDescriptorPool(p_inner->init.device, &dp_ci, 0, &p_su->dp) != VK_SUCCESS) {
								mug_innervk_shader_uniform_destroy(p_inner, p_su);
								return MUG_FAILED_CREATE_VK_DESCRIPTOR_POOL;
							}

						/* Descriptor sets */

							VkDescriptorSetAllocateInfo ds_ai = MU_ZERO_STRUCT(VkDescriptorSetAllocateInfo);
							ds_ai.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
							ds_ai.descriptorPool = p_su->dp;
							ds_ai.descriptorSetCount = MUG_VK_LOOK_AHEAD_FRAMES;
							ds_ai.pSetLayouts = p_su->dsl;

							if (vkAllocateDescriptorSets(p_inner->init.device, &ds_ai, p_su->ds) != VK_SUCCESS) {
								mug_innervk_shader_uniform_destroy(p_inner, p_su);
								return MUG_FAILED_ALLOCATE_VK_DESCRIPTOR_SETS;
							}

							for (size_m f = 0; f < MUG_VK_LOOK_AHEAD_FRAMES; f++) {
								for (uint32_t u = 0; u < uniform_count; u++) {
									VkDescriptorBufferInfo buf_info = MU_ZERO_STRUCT(VkDescriptorBufferInfo);
									buf_info.buffer = p_su->bufs[u].bufs[f].buf;
									buf_info.range = p_sizes[u];

									VkWriteDescriptorSet wds = MU_ZERO_STRUCT(VkWriteDescriptorSet);
									wds.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
									wds.dstSet = p_su->ds[f];
									wds.dstBinding = p_bindings[u];
									wds.dstArrayElement = 0;
									wds.descriptorCount = 1;
									wds.descriptorType = p_descriptors[u];
									wds.pBufferInfo = &buf_info;

									vkUpdateDescriptorSets(p_inner->init.device, 1, &wds, 0, 0);
								}
							}

						return MUG_SUCCESS;
					}

				/* Rect */

					// ^ All same as OpenGL
					size_m mug_innervk_rect_count_to_tricount(size_m rect_count) {
						return rect_count * 2;
					}
					size_m mug_innervk_rect_count_to_vertex_size(size_m rect_count) {
						return rect_count * 4 * 6 * 4;
					}
					size_m mug_innervk_rect_count_to_indcount(size_m rect_count) {
						return rect_count * 5;
					}
					size_m mug_innervk_rect_count_to_index_size(size_m rect_count) {
						return rect_count * 4 * 5;
					}

					/* Compiled code */

						/* glslc shader.vert -o vert.spv
						#version 450

						layout(location=0)in vec2 vPos;
						layout(location=1)in vec4 vCol;

						layout(location=0)out vec4 fCol;

						layout(binding=0)uniform Dim {
							vec2 dim;	
						};

						void main() {
							gl_Position=vec4((vPos.x-(dim.x))/dim.x,(vPos.y-(dim.y))/dim.y,0.0,1.0);
							fCol = vCol;
						}
						*/
						
						const muByte mug_innervk_vrect_spirv[] = {
							0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x0B, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x00, 0x00, 
							0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x06, 0x00, 
							0x01, 0x00, 0x00, 0x00, 0x47, 0x4C, 0x53, 0x4C, 0x2E, 0x73, 0x74, 0x64, 0x2E, 0x34, 0x35, 0x30, 
							0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
							0x0F, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x69, 0x6E, 
							0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
							0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0xC2, 0x01, 0x00, 0x00, 
							0x04, 0x00, 0x0A, 0x00, 0x47, 0x4C, 0x5F, 0x47, 0x4F, 0x4F, 0x47, 0x4C, 0x45, 0x5F, 0x63, 0x70, 
							0x70, 0x5F, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x5F, 0x6C, 0x69, 0x6E, 0x65, 0x5F, 0x64, 0x69, 0x72, 
							0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x47, 0x4C, 0x5F, 0x47, 
							0x4F, 0x4F, 0x47, 0x4C, 0x45, 0x5F, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x5F, 0x64, 0x69, 
							0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x00, 0x05, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 
							0x6D, 0x61, 0x69, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x06, 0x00, 0x0B, 0x00, 0x00, 0x00, 
							0x67, 0x6C, 0x5F, 0x50, 0x65, 0x72, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 
							0x06, 0x00, 0x06, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x6C, 0x5F, 0x50, 
							0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0B, 0x00, 0x00, 0x00, 
							0x01, 0x00, 0x00, 0x00, 0x67, 0x6C, 0x5F, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x53, 0x69, 0x7A, 0x65, 
							0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x07, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
							0x67, 0x6C, 0x5F, 0x43, 0x6C, 0x69, 0x70, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x00, 
							0x06, 0x00, 0x07, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x67, 0x6C, 0x5F, 0x43, 
							0x75, 0x6C, 0x6C, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x00, 0x05, 0x00, 0x03, 0x00, 
							0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00, 
							0x76, 0x50, 0x6F, 0x73, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x17, 0x00, 0x00, 0x00, 
							0x44, 0x69, 0x6D, 0x00, 0x06, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
							0x64, 0x69, 0x6D, 0x00, 0x05, 0x00, 0x03, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
							0x05, 0x00, 0x04, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x66, 0x43, 0x6F, 0x6C, 0x00, 0x00, 0x00, 0x00, 
							0x05, 0x00, 0x04, 0x00, 0x30, 0x00, 0x00, 0x00, 0x76, 0x43, 0x6F, 0x6C, 0x00, 0x00, 0x00, 0x00, 
							0x48, 0x00, 0x05, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
							0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
							0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x0B, 0x00, 0x00, 0x00, 
							0x02, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 
							0x0B, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
							0x47, 0x00, 0x03, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 
							0x12, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 
							0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
							0x47, 0x00, 0x03, 0x00, 0x17, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 
							0x19, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 
							0x19, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 
							0x2E, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 
							0x30, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 
							0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
							0x16, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 
							0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 
							0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x04, 0x00, 
							0x08, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x04, 0x00, 
							0x0A, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x06, 0x00, 
							0x0B, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 
							0x0A, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
							0x0B, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x04, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 
							0x03, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
							0x01, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x04, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 
							0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
							0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
							0x10, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 
							0x01, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 
							0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
							0x06, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x03, 0x00, 0x17, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
							0x20, 0x00, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 
							0x3B, 0x00, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
							0x20, 0x00, 0x04, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
							0x2B, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
							0x2B, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 
							0x20, 0x00, 0x04, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
							0x3B, 0x00, 0x04, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
							0x20, 0x00, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
							0x3B, 0x00, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
							0x36, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
							0x03, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 
							0x14, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 
							0x3D, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 
							0x41, 0x00, 0x06, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 
							0x0F, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 
							0x1C, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 
							0x1D, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x41, 0x00, 0x06, 0x00, 
							0x1A, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 
							0x13, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 
							0x1E, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
							0x1D, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x14, 0x00, 0x00, 0x00, 
							0x21, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x04, 0x00, 
							0x06, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x41, 0x00, 0x06, 0x00, 
							0x1A, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 
							0x09, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
							0x23, 0x00, 0x00, 0x00, 0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 
							0x22, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x41, 0x00, 0x06, 0x00, 0x1A, 0x00, 0x00, 0x00, 
							0x26, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
							0x3D, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
							0x88, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 
							0x27, 0x00, 0x00, 0x00, 0x50, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 
							0x20, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
							0x41, 0x00, 0x05, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 
							0x0F, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x03, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 
							0x3D, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
							0x3E, 0x00, 0x03, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x01, 0x00, 
							0x38, 0x00, 0x01, 0x00
						};

						/* glslc shader.frag -o frag.spv
						#version 450

						layout (location=0) in vec4 fCol;
						layout (location=0) out vec4 oCol;

						void main() {
							oCol = fCol;
						}
						*/
						const muByte mug_innervk_frect_spirv[] = {
							0x03,0x02,0x23,0x07,0x00,0x00,0x01,0x00,0x0b,0x00,0x0d,0x00,0x0d,0x00,0x00,0x00
							,0x00,0x00,0x00,0x00,0x11,0x00,0x02,0x00,0x01,0x00,0x00,0x00,0x0b,0x00,0x06,0x00
							,0x01,0x00,0x00,0x00,0x47,0x4c,0x53,0x4c,0x2e,0x73,0x74,0x64,0x2e,0x34,0x35,0x30
							,0x00,0x00,0x00,0x00,0x0e,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00
							,0x0f,0x00,0x07,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x6d,0x61,0x69,0x6e
							,0x00,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x10,0x00,0x03,0x00
							,0x04,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x02,0x00,0x00,0x00
							,0xc2,0x01,0x00,0x00,0x04,0x00,0x0a,0x00,0x47,0x4c,0x5f,0x47,0x4f,0x4f,0x47,0x4c
							,0x45,0x5f,0x63,0x70,0x70,0x5f,0x73,0x74,0x79,0x6c,0x65,0x5f,0x6c,0x69,0x6e,0x65
							,0x5f,0x64,0x69,0x72,0x65,0x63,0x74,0x69,0x76,0x65,0x00,0x00,0x04,0x00,0x08,0x00
							,0x47,0x4c,0x5f,0x47,0x4f,0x4f,0x47,0x4c,0x45,0x5f,0x69,0x6e,0x63,0x6c,0x75,0x64
							,0x65,0x5f,0x64,0x69,0x72,0x65,0x63,0x74,0x69,0x76,0x65,0x00,0x05,0x00,0x04,0x00
							,0x04,0x00,0x00,0x00,0x6d,0x61,0x69,0x6e,0x00,0x00,0x00,0x00,0x05,0x00,0x04,0x00
							,0x09,0x00,0x00,0x00,0x6f,0x43,0x6f,0x6c,0x00,0x00,0x00,0x00,0x05,0x00,0x04,0x00
							,0x0b,0x00,0x00,0x00,0x66,0x43,0x6f,0x6c,0x00,0x00,0x00,0x00,0x47,0x00,0x04,0x00
							,0x09,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x00,0x04,0x00
							,0x0b,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0x02,0x00
							,0x02,0x00,0x00,0x00,0x21,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00
							,0x16,0x00,0x03,0x00,0x06,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x17,0x00,0x04,0x00
							,0x07,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x20,0x00,0x04,0x00
							,0x08,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x3b,0x00,0x04,0x00
							,0x08,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x20,0x00,0x04,0x00
							,0x0a,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x3b,0x00,0x04,0x00
							,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x36,0x00,0x05,0x00
							,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00
							,0xf8,0x00,0x02,0x00,0x05,0x00,0x00,0x00,0x3d,0x00,0x04,0x00,0x07,0x00,0x00,0x00
							,0x0c,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0x09,0x00,0x00,0x00
							,0x0c,0x00,0x00,0x00,0xfd,0x00,0x01,0x00,0x38,0x00,0x01,0x00
						};

					void mug_innervk_shader_deload(mug_innervk_inner* p_inner, mug_innervk_shader* p_shader) {
						mug_innervk_shader_uniform_destroy(p_inner, &p_shader->uniforms);

						if (p_shader->pipeline_layout != VK_NULL_HANDLE) {
							vkDestroyPipelineLayout(p_inner->init.device, p_shader->pipeline_layout, 0);
						}
						if (p_shader->pipeline != VK_NULL_HANDLE) {
							vkDestroyPipeline(p_inner->init.device, p_shader->pipeline, 0);
						}

						if (p_shader->vert != VK_NULL_HANDLE) {
							vkDestroyShaderModule(p_inner->init.device, p_shader->vert, 0);
						}
						if (p_shader->frag != VK_NULL_HANDLE) {
							vkDestroyShaderModule(p_inner->init.device, p_shader->frag, 0);
						}
					}

					void mug_innervk_shaders_deload(mug_innervk_inner* p_inner) {
						mug_innervk_shader_deload(p_inner, &p_inner->shaders.rect);
					}

					void mug_innervk_shader_destroy_buffers(mug_innervk_inner* p_inner, mug_innervk_shader* p_shader) {
						for (size_m i = 0; i < p_shader->buffers.length; i++) {
							mug_innervk_shader_destroy_vbuffer(p_inner, p_shader, i);
						}
					}

					void mug_innervk_shaders_destroy_buffers(mug_innervk_inner* p_inner) {
						mug_innervk_shader_destroy_buffers(p_inner, &p_inner->shaders.rect);
					}

					// Note: can and should be called even if already created
					// Note: also creates the pipeline
					mugResult mug_innervk_rect_shaders_load(mug_innervk_inner* p_inner, mug_innervk_shader* p_srect) {
						mugResult res = MUG_SUCCESS;

						if (p_srect->vert != VK_NULL_HANDLE) {
							return MUG_SUCCESS;
						}

						// ^
						// p_srect->vert = VK_NULL_HANDLE;
						p_srect->frag = VK_NULL_HANDLE;
						p_srect->pipeline_layout = VK_NULL_HANDLE;
						p_srect->pipeline = VK_NULL_HANDLE;

						p_srect->use_buffers = MU_TRUE;
						p_srect->use_index = MU_TRUE;
						p_srect->index_type = VK_INDEX_TYPE_UINT32;

						mug_innervk_shader_uniform_empty(&p_srect->uniforms);

						/* Shader */

							VkShaderModuleCreateInfo sci = MU_ZERO_STRUCT(VkShaderModuleCreateInfo);
							sci.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;

							sci.codeSize = sizeof(mug_innervk_vrect_spirv);
							sci.pCode = (const uint32_t*)mug_innervk_vrect_spirv;
							if (vkCreateShaderModule(p_inner->init.device, &sci, 0, &p_srect->vert) != VK_SUCCESS) {
								mug_innervk_shader_deload(p_inner, p_srect);
								return MUG_FAILED_CREATE_VK_SHADER_MODULE;
							}

							sci.codeSize = sizeof(mug_innervk_frect_spirv);
							sci.pCode = (const uint32_t*)mug_innervk_frect_spirv;
							if (vkCreateShaderModule(p_inner->init.device, &sci, 0, &p_srect->frag) != VK_SUCCESS) {
								mug_innervk_shader_deload(p_inner, p_srect);
								return MUG_FAILED_CREATE_VK_SHADER_MODULE;
							}

						/* Uniforms */

							VkDescriptorType descriptor = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
							VkDeviceSize size = 4*2;
							uint32_t binding = 0;
							VkShaderStageFlags stage = VK_SHADER_STAGE_VERTEX_BIT;

							res = mug_innervk_shader_uniform_create(p_inner, &p_srect->uniforms, 1, &descriptor, &size, &binding, &stage);
							if (res != MUG_SUCCESS) {
								mug_innervk_shader_deload(p_inner, p_srect);
								return res;
							}

						/* Pipeline layout */

							// (To be possibly made more complicated with the dimensions uniform)

							VkPipelineLayoutCreateInfo playout_ci = MU_ZERO_STRUCT(VkPipelineLayoutCreateInfo);
							playout_ci.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
							playout_ci.setLayoutCount = MUG_VK_LOOK_AHEAD_FRAMES;
							playout_ci.pSetLayouts = p_srect->uniforms.dsl;

							if (vkCreatePipelineLayout(
								p_inner->init.device, &playout_ci, 0, &p_srect->pipeline_layout
							) != VK_SUCCESS) {
								mug_innervk_shader_deload(p_inner, p_srect);
								return MUG_FAILED_CREATE_VK_PIPELINE_LAYOUT;
							}

						/* Pipeline */

							uint32_m uw=800, uh=600;
							mu_window_get_dimensions(0, p_inner->win, &uw, &uh);
							float fw = (float)uw, fh = (float)uh;

							mug_innervk_gpipeline_ci pipeline_creator = MU_ZERO_STRUCT(mug_innervk_gpipeline_ci);
							mug_innervk_def_gpipeline_ci(&pipeline_creator,
								&p_srect->vert, &p_srect->frag, fw, fh, p_srect->pipeline_layout,
								p_inner->rs.ca_to_ca_pip.render_pass, 0
							);

							pipeline_creator.input_asm.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
							pipeline_creator.input_asm.primitiveRestartEnable = VK_TRUE;

							/* Vertex input attributes */

								VkVertexInputAttributeDescription inp_att[2] = {
									MU_ZERO_STRUCT(VkVertexInputAttributeDescription)
								};

								uint32_t offset = 0;

								inp_att[0].format = VK_FORMAT_R32G32_SFLOAT;
								offset += 4*2;

								inp_att[1].location = 1;
								inp_att[1].binding = 0;
								inp_att[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
								inp_att[1].offset = offset;
								offset += 4*4;

								pipeline_creator.vertex_input.vertexAttributeDescriptionCount = 
								sizeof(inp_att) / sizeof(VkVertexInputAttributeDescription);
								pipeline_creator.vertex_input.pVertexAttributeDescriptions = inp_att;

							/* Vertex binding */

								VkVertexInputBindingDescription v_binding = MU_ZERO_STRUCT(VkVertexInputBindingDescription);
								v_binding.stride = offset;
								v_binding.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

								pipeline_creator.vertex_input.vertexBindingDescriptionCount = 1;
								pipeline_creator.vertex_input.pVertexBindingDescriptions = &v_binding;

							if (vkCreateGraphicsPipelines(
								p_inner->init.device, VK_NULL_HANDLE,
								1, &pipeline_creator.pipeline_ci, 0, &p_srect->pipeline
							) != VK_SUCCESS) {
								mug_innervk_shader_deload(p_inner, p_srect);
								return MUG_FAILED_CREATE_VK_PIPELINE_LAYOUT;
							}

						return MUG_SUCCESS;
					}

					mugResult mug_inner2vk_rect_buffer_fill(mug_innervk_inner* p_inner, mug_innervk_vbuffer* p_buf, muRect* rects) {
						mugResult res = MUG_SUCCESS;

						if (p_buf->rendered_this_frame) {
							return MUG_ALREADY_RENDERED_BUFFER;
						}

						float* vertexes = (float*)mu_malloc(sizeof(float) * p_buf->obj_count * 6 * 4);
						if (vertexes == 0) {
							return MUG_FAILED_ALLOCATE;
						}

						for (size_m i = 0; i < p_buf->obj_count; i++) {
							mug_inner_rect_single_fill(&vertexes[i*6*4], 0, rects[i], i, 0);
						}

						res = mug_innervk_buffer_transfer(p_inner, &p_buf->vbuf, (void*)vertexes, sizeof(float) * p_buf->obj_count * 6 * 4);
						mu_free(vertexes);
						if (res != MUG_SUCCESS) {
							return res;
						}

						uint32_t* indexes = (uint32_t*)mu_malloc(sizeof(uint32_t) * p_buf->obj_count * 5);
						if (indexes == 0) {
							return MUG_FAILED_ALLOCATE;
						}

						for (size_m i = 0; i < p_buf->obj_count; i++) {
							// https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html
							mug_inner_rect_single_fill(0, &indexes[i*5], rects[i], i, 0xFFFFFFFF);
						}

						res = mug_innervk_buffer_transfer(p_inner, &p_buf->ibuf, (void*)indexes, sizeof(uint32_t) * p_buf->obj_count * 5);
						mu_free(indexes);
						if (res != MUG_SUCCESS) {
							return res;
						}

						return MUG_SUCCESS;
					}

					void mug_innervk_rect_buffer_update_uniforms(mug_innervk_inner* p_inner) {
						mugResult res = MUG_SUCCESS;
						uint32_m w=800, h=600;
						mu_window_get_dimensions(&res, p_inner->win, &w, &h);

						float* p_f = (float*)p_inner->shaders.rect.uniforms.bufs[0].bufs[p_inner->now_cmd].mapped_mem;
						if (p_f) {
							p_f[0] = ((float)w) / 2.f;
							p_f[1] = ((float)h) / 2.f;
						}
					}

				/* All shader functions */

					void mug_innervk_refresh_shader_buffers(mug_innervk_shader* p_shader) {
						for (size_m b = 0; b < p_shader->buffers.length; b++) {
							if (p_shader->buffers.data[b].active) {
								p_shader->buffers.data[b].rendered_this_frame = MU_FALSE;
							}
						}
					}

					void mug_innervk_refresh_shaders_buffers(mug_innervk_inner* p_inner) {
						mug_innervk_refresh_shader_buffers(&p_inner->shaders.rect);
					}

			/* Inner */

				unsigned int mug_innervk_DebugUtilsMessengerCallback(VkDebugUtilsMessageSeverityFlagBitsEXT severity,
				VkDebugUtilsMessageTypeFlagsEXT types, const VkDebugUtilsMessengerCallbackDataEXT* data, void* user_data) {
					if (user_data) {}

					printf("[DEBUG] (Vulkan debug message) ");
					
					printf("(severity: ");
					if (severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) {
						printf("verbose ");
					}
					if (severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) {
						printf("info ");
					}
					if (severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
						printf("warning ");
					}
					if (severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) {
						printf("error ");
					}
					printf(") ");

					printf("(types: ");
					if (types & VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT) {
						printf("general ");
					}
					if (types & VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT) {
						printf("validation ");
					}
					if (types & VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) {
						printf("performance ");
					}
					printf(") ");

					printf("message: \n%s\n", data->pMessage);
					return VK_TRUE;
				}

				mug_innervk_inner mug_innervk_inner_create(mugResult* result, muWindow window) {
					mug_innervk_inner inner = MU_ZERO_STRUCT(mug_innervk_inner);
					mugResult res = MUG_SUCCESS;

					inner.win = window;
					inner.init.use_validation_layers = MU_TRUE;
					inner.init.debug_messenger_callback = mug_innervk_DebugUtilsMessengerCallback;
					res = mug_innervk_initiation_create(&inner);
					if (res != MUG_SUCCESS) {
						mug_innervk_initiation_destroy(&inner);
						MU_SET_RESULT(result, res)
						return inner;
					}

					res = mug_innervk_swapchain_create(&inner);
					if (res != MUG_SUCCESS) {
						mug_innervk_swapchain_destroy(&inner);
						mug_innervk_initiation_destroy(&inner);
						MU_SET_RESULT(result, res)
						return inner;
					}

					for (size_m i = 0; i < MUG_VK_LOOK_AHEAD_FRAMES; i++) {
						res = mug_innervk_command_create(&inner, &inner.cmds[i]);

						if (res != MUG_SUCCESS) {
							for (size_m j = 0; j <= i; j++) {
								mug_innervk_command_destroy(&inner, &inner.cmds[j]);
							}

							mug_innervk_swapchain_destroy(&inner);
							mug_innervk_initiation_destroy(&inner);
							MU_SET_RESULT(result, res)
							return inner;
						}
					}
					inner.now_cmd = 0;

					res = mug_innervk_renderers_create_render_passes(&inner);
					if (res != MUG_SUCCESS) {
						mug_innervk_renderers_destroy_render_passes(&inner);
						for (size_m i = 0; i < MUG_VK_LOOK_AHEAD_FRAMES; i++) {
							mug_innervk_command_destroy(&inner, &inner.cmds[i]);
						}
						mug_innervk_swapchain_destroy(&inner);
						mug_innervk_initiation_destroy(&inner);
						MU_SET_RESULT(result, res)
						return inner;
					}

					res = mug_innervk_renderers_create_framebuffers(&inner);
					if (res != MUG_SUCCESS) {
						mug_innervk_renderers_destroy_framebuffers(&inner);
						mug_innervk_renderers_destroy_render_passes(&inner);
						for (size_m i = 0; i < MUG_VK_LOOK_AHEAD_FRAMES; i++) {
							mug_innervk_command_destroy(&inner, &inner.cmds[i]);
						}
						mug_innervk_swapchain_destroy(&inner);
						mug_innervk_initiation_destroy(&inner);
					}

					return inner;
				}

				void mug_innervk_inner_destroy(mugResult* result, mug_innervk_inner* p_inner) {
					mug_innervk_shaders_deload(p_inner);
					mug_innervk_shaders_destroy_buffers(p_inner);

					mug_innervk_renderers_destroy_framebuffers(p_inner);
					mug_innervk_renderers_destroy_render_passes(p_inner);

					for (size_m i = 0; i < MUG_VK_LOOK_AHEAD_FRAMES; i++) {
						mug_innervk_command_destroy(p_inner, &p_inner->cmds[i]);
					}

					mug_innervk_swapchain_destroy(p_inner);
					mug_innervk_initiation_destroy(p_inner);

					return;
					if (result) {}
				}

				void mug_innervk_inner_swapchain_resize(mugResult* result, mug_innervk_inner* p_inner) {
					mugResult res = MUG_SUCCESS;
					vkDeviceWaitIdle(p_inner->init.device);

					mug_innervk_renderers_destroy_framebuffers(p_inner);
					mug_innervk_swapchain_destroy(p_inner);

					res = mug_innervk_swapchain_create(p_inner);
					if (res != MUG_SUCCESS) {
						MU_SET_RESULT(result, res)
						return;
					}

					res = mug_innervk_renderers_create_framebuffers(p_inner);
					if (res != MUG_SUCCESS) {
						MU_SET_RESULT(result, res)
						return;
					}
				}

		/* Graphic */

			struct mug_innervk_graphic {
				muWindow win;
				uint32_m prev_width;
				uint32_m prev_height;

				mug_innervk_inner inner;
			};
			typedef struct mug_innervk_graphic mug_innervk_graphic;

			/* Creation / Destruction */

				mug_innervk_graphic mug_innervk_graphic_create_via_window(mugResult* result,
					muByte* name, uint16_m width, uint16_m height, muWindowCreateInfo create_info
				) {
					MU_SET_RESULT(result, MUG_SUCCESS)

					mug_innervk_graphic graphic = MU_ZERO_STRUCT(mug_innervk_graphic);
					muCOSAResult cosa_res = MUCOSA_SUCCESS;
					mugResult mug_res = MUG_SUCCESS;

					graphic.win = mu_window_create(&cosa_res, MU_NO_GRAPHICS_API, 0,
					name, width, height, create_info);

					if (cosa_res != MUCOSA_SUCCESS) {
						MU_SET_RESULT(result, muCOSA_result_to_mug_result(cosa_res))
					}
					if (graphic.win == MU_NONE) {
						return graphic;
					}

					graphic.inner = mug_innervk_inner_create(&mug_res, graphic.win);
					if (mug_res != MUG_SUCCESS) {
						MU_SET_RESULT(result, mug_res)
						mu_window_destroy(0, graphic.win);
						return graphic;
					}

					graphic.prev_width = (uint32_m)width;
					graphic.prev_height = (uint32_m)height;

					return graphic;
				}

				void mug_innervk_graphic_destroy(mugResult* result, mug_innervk_graphic* p_g) {
					MU_SET_RESULT(result, MUG_SUCCESS)

					if (p_g->inner.init.device != VK_NULL_HANDLE) {
						vkDeviceWaitIdle(p_g->inner.init.device);
					}

					// Due to X11/Vulkan being weird, X11 requires us to destroy Vulkan stuff AFTER its given
					// window is fully destroyed.
					// https://github.com/KhronosGroup/Vulkan-LoaderAndValidationLayers/issues/1894

					muWindowSystem window_system = muCOSA_get_current_window_system(0);
					if (window_system != MU_WINDOW_SYSTEM_X11) {
						mug_innervk_inner_destroy(0, &p_g->inner);
					} else if (p_g->inner.sc.handle != VK_NULL_HANDLE) {
						// X11 *does* want the swapchain to be destroyed here, though
						vkDestroySwapchainKHR(p_g->inner.init.device, p_g->inner.sc.handle, 0);
						p_g->inner.sc.handle = VK_NULL_HANDLE;
					}

					mu_window_destroy(0, p_g->win);

					if (window_system == MU_WINDOW_SYSTEM_X11) {
						mug_innervk_inner_destroy(0, &p_g->inner);
					}
				}

			/* Main loop */

				void mug_innervk_graphic_clear(mugResult* result, mug_innervk_graphic* p_g, 
					float r, float g, float b, float a
				) {
					mugResult res = MUG_SUCCESS;

					res = mug_innervk_renderers_clear(&p_g->inner, r, g, b, a);
					MU_SET_RESULT(result, res)
				}

				void mug_innervk_graphic_swap_buffers(mugResult* result, mug_innervk_graphic* p_g) {
					mugResult res = MUG_SUCCESS;

					if (!p_g->inner.cmds[p_g->inner.now_cmd].on) {
						MU_SET_RESULT(result, MUG_NO_RENDER_CALLS_YET)
						return;
					}

					res = mug_innervk_renderers_make_presentable(&p_g->inner);
					if (res != MUG_SUCCESS) {
						MU_SET_RESULT(result, res)
						return;
					}

					res = mug_innervk_command_end_and_submit(&p_g->inner);
					if (res != MUG_SUCCESS) {
						MU_SET_RESULT(result, res)
						return;
					}

					// Warning: the function 'vkQueuePresentKHR' is perhaps the meatiest in Vulkan; I'm
					// considering moving this to the beginning of mug_innervk_command_begin, but I'm not
					// sure if that would be wise or even work, and I only wanna try it when mug is in a
					// developed-enough state to do performance tests for this sort of stuff. @TODO 
					res = mug_innervk_command_present(&p_g->inner);
					if (res != MUG_SUCCESS) {
						MU_SET_RESULT(result, res)
						return;
					}

					// I'm pretty sure this is where you would do this...
					p_g->inner.now_cmd = (p_g->inner.now_cmd + 1) % MUG_VK_LOOK_AHEAD_FRAMES;

					mug_innervk_refresh_shaders_buffers(&p_g->inner);
				}

				void mug_innervk_graphic_update(mugResult* result, mug_innervk_graphic* p_g) {
					muCOSAResult cosa_res = MUCOSA_SUCCESS;
					mugResult res = MUG_SUCCESS;

					mu_window_update(&cosa_res, p_g->win);
					if (cosa_res != MUCOSA_SUCCESS) {
						MU_SET_RESULT(result, muCOSA_result_to_mug_result(cosa_res));
						return;
					}

					uint32_m width=800,height=600;
					mu_window_get_dimensions(&cosa_res, p_g->win, &width, &height);
					
					if (cosa_res == MUCOSA_SUCCESS && (width != p_g->prev_width || height != p_g->prev_height)) {

						mug_innervk_inner_swapchain_resize(&res, &p_g->inner);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return;
						}

						p_g->prev_width = width;
						p_g->prev_height = height;
					}
				}

			/* Objects */

				// ...

				/* Rect */

					muRectBuffer mug_innervk_rect_buffer_create(mugResult* result, mug_innervk_graphic* p_g, size_m rect_count, muRect* rects) {
						mugResult res = MUG_SUCCESS;

						res = mug_innervk_rect_shaders_load(&p_g->inner, &p_g->inner.shaders.rect);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return MU_NONE;
						}

						size_m rb = mug_innervk_shader_create_vbuffer(&res,
							&p_g->inner, &p_g->inner.shaders.rect,
							mug_innervk_rect_count_to_vertex_size(rect_count),
							mug_innervk_rect_count_to_index_size(rect_count),
							mug_innervk_rect_count_to_indcount(rect_count),
							rect_count
						);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return rb;
						}

						if (rects != 0) {
							res = mug_inner2vk_rect_buffer_fill(
								&p_g->inner, &p_g->inner.shaders.rect.buffers.data[rb],
								rects
							);
							if (res != MUG_SUCCESS) {
								MU_SET_RESULT(result, res)
								return rb;
							}
						}

						return rb;
					}

					muRectBuffer mug_innervk_rect_buffer_destroy(mugResult* result, mug_innervk_graphic* p_g, muRectBuffer rb) {
						if (rb >= p_g->inner.shaders.rect.buffers.length) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return rb;
						}
						if (!p_g->inner.shaders.rect.buffers.data[rb].active) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return rb;
						}

						mug_innervk_shader_destroy_vbuffer(
							&p_g->inner, &p_g->inner.shaders.rect, rb
						);
						return MU_NONE;
					}

					void mug_innervk_rect_buffer_render(mugResult* result, mug_innervk_graphic* p_g, muRectBuffer rb) {
						mugResult res = MUG_SUCCESS;

						if (rb >= p_g->inner.shaders.rect.buffers.length) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return;
						}
						if (!p_g->inner.shaders.rect.buffers.data[rb].active) {
							MU_SET_RESULT(result, MUG_INVALID_BUFFER_ID)
							return;
						}

						mug_innervk_rect_buffer_update_uniforms(&p_g->inner);

						res = mug_innervk_renderers_render_shader(&p_g->inner, &p_g->inner.shaders.rect, rb, 0, MU_FALSE);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return;
						}
					}

					void mug_innervk_rect_buffer_fill(mugResult* result, mug_innervk_graphic* p_g, muRectBuffer rb, muRect* rects) {
						mugResult res = MUG_SUCCESS;

						res = mug_inner2vk_rect_buffer_fill(
							&p_g->inner, &p_g->inner.shaders.rect.buffers.data[rb],
							rects
						);
						if (res != MUG_SUCCESS) {
							MU_SET_RESULT(result, res)
							return;
						}
					}

	/* Cross graphics-API */

		/* Graphic */

			union mug_innergapi_graphic {
				mug_innergl_graphic gl;
				mug_innervk_graphic vk;
			};
			typedef union mug_innergapi_graphic mug_innergapi_graphic;

			struct mug_inner_graphic {
				MU_LOCK
				muBool active;
				muGraphicAPI api;
				mug_innergapi_graphic gapi;
			};
			typedef struct mug_inner_graphic mug_inner_graphic;

			MU_HRARRAY_DEFAULT_FUNC(mug_inner_graphic)

	/* API-level functions */

		/* Names */

			#ifdef MUG_NAMES
				MUDEF const char* mug_result_get_name(mugResult result) {
					switch (result) {
						default: return "MUG_UNKNOWN"; break;
						case MUG_SUCCESS: return "MUG_SUCCESS"; break;
						case MUG_ALREADY_INITIATED: return "MUG_ALREADY_INITIATED"; break;
						case MUG_ALREADY_TERMINATED: return "MUG_ALREADY_TERMINATED"; break;
						case MUG_ALREADY_RENDERED_BUFFER: return "MUG_ALREADY_RENDERED_BUFFER"; break;
						case MUG_NOT_YET_INITIALIZED: return "MUG_NOT_YET_INITIALIZED"; break;
						case MUG_FAILED_ALLOCATE: return "MUG_FAILED_ALLOCATE"; break;
						case MUG_FAILED_LOAD_GRAPHICS_API: return "MUG_FAILED_LOAD_GRAPHICS_API"; break;
						case MUG_FAILED_CREATE_VK_INSTANCE: return "MUG_FAILED_CREATE_VK_INSTANCE"; break;
						case MUG_FAILED_CREATE_VK_SURFACE: return "MUG_FAILED_CREATE_VK_SURFACE"; break;
						case MUG_FAILED_FIND_VALID_PHYSICAL_DEVICE: return "MUG_FAILED_FIND_VALID_PHYSICAL_DEVICE"; break;
						case MUG_FAILED_FIND_COMPATIBLE_PHYSICAL_DEVICE: return "MUG_FAILED_FIND_COMPATIBLE_PHYSICAL_DEVICE"; break;
						case MUG_FAILED_GET_QUEUE_FAMILY_PROPERTIES: return "MUG_FAILED_GET_QUEUE_FAMILY_PROPERTIES"; break;
						case MUG_FAILED_FIND_NECESSARY_QUEUE_FAMILIES: return "MUG_FAILED_FIND_NECESSARY_QUEUE_FAMILIES"; break;
						case MUG_FAILED_CREATE_VK_DEVICE: return "MUG_FAILED_CREATE_VK_DEVICE"; break;
						case MUG_FAILED_GET_VK_SURFACE_INFO: return "MUG_FAILED_GET_VK_SURFACE_INFO"; break;
						case MUG_FAILED_CREATE_VK_SWAPCHAIN: return "MUG_FAILED_CREATE_VK_SWAPCHAIN"; break;
						case MUG_FAILED_GET_VK_SWAPCHAIN_INFO: return "MUG_FAILED_GET_VK_SWAPCHAIN_INFO"; break;
						case MUG_FAILED_CREATE_VK_SWAPCHAIN_IMAGE_VIEWS: return "MUG_FAILED_CREATE_VK_SWAPCHAIN_IMAGE_VIEWS"; break;
						case MUG_FAILED_CREATE_VK_COMMAND_POOL: return "MUG_FAILED_CREATE_VK_COMMAND_POOL"; break;
						case MUG_FAILED_ALLOCATE_VK_COMMAND_BUFFERS: return "MUG_FAILED_ALLOCATE_VK_COMMAND_BUFFERS"; break;
						case MUG_FAILED_CREATE_VK_SEMAPHORE: return "MUG_FAILED_CREATE_VK_SEMAPHORE"; break;
						case MUG_FAILED_CREATE_VK_FENCE: return "MUG_FAILED_CREATE_VK_FENCE"; break;
						case MUG_FAILED_CREATE_VK_RENDER_PASS: return "MUG_FAILED_CREATE_VK_RENDER_PASS"; break;
						case MUG_FAILED_CREATE_VK_FRAMEBUFFERS: return "MUG_FAILED_CREATE_VK_FRAMEBUFFERS"; break;
						case MUG_FAILED_WAIT_FOR_VK_FENCE: return "MUG_FAILED_WAIT_FOR_VK_FENCE"; break;
						case MUG_FAILED_RESET_VK_FENCE: return "MUG_FAILED_RESET_VK_FENCE"; break;
						case MUG_FAILED_RESET_VK_COMMAND_BUFFER: return "MUG_FAILED_RESET_VK_COMMAND_BUFFER"; break;
						case MUG_FAILED_BEGIN_VK_COMMAND_BUFFER: return "MUG_FAILED_BEGIN_VK_COMMAND_BUFFER"; break;
						case MUG_FAILED_END_VK_COMMAND_BUFFER: return "MUG_FAILED_END_VK_COMMAND_BUFFER"; break;
						case MUG_FAILED_SUBMIT_VK_QUEUE: return "MUG_FAILED_SUBMIT_VK_QUEUE"; break;
						case MUG_FAILED_PRESENT_VK_QUEUE: return "MUG_FAILED_PRESENT_VK_QUEUE"; break;
						case MUG_FAILED_GET_NEXT_VK_SWAPCHAIN_IMAGE: return "MUG_FAILED_GET_NEXT_VK_SWAPCHAIN_IMAGE"; break;
						case MUG_FAILED_CREATE_VK_BUFFER: return "MUG_FAILED_CREATE_VK_BUFFER"; break;
						case MUG_FAILED_FIND_VALID_VK_MEMORY_TYPE: return "MUG_FAILED_FIND_VALID_VK_MEMORY_TYPE"; break;
						case MUG_FAILED_ALLOCATE_VK_MEMORY: return "MUG_FAILED_ALLOCATE_VK_MEMORY"; break;
						case MUG_FAILED_MAP_VK_MEMORY: return "MUG_FAILED_MAP_VK_MEMORY"; break;
						case MUG_FAILED_CREATE_VK_SHADER_MODULE: return "MUG_FAILED_CREATE_VK_SHADER_MODULE"; break;
						case MUG_FAILED_CREATE_VK_PIPELINE_LAYOUT: return "MUG_FAILED_CREATE_VK_PIPELINE_LAYOUT"; break;
						case MUG_FAILED_CREATE_VK_PIPELINE: return "MUG_FAILED_CREATE_VK_PIPELINE"; break;
						case MUG_FAILED_CREATE_VK_DESCRIPTOR_SET_LAYOUT: return "MUG_FAILED_CREATE_VK_DESCRIPTOR_SET_LAYOUT"; break;
						case MUG_FAILED_CREATE_VK_DESCRIPTOR_POOL: return "MUG_FAILED_CREATE_VK_DESCRIPTOR_POOL"; break;
						case MUG_FAILED_ALLOCATE_VK_DESCRIPTOR_SETS: return "MUG_FAILED_ALLOCATE_VK_DESCRIPTOR_SETS"; break;
						case MUG_FAILED_CREATE_GL_VERTEX_ARRAY: return "MUG_FAILED_CREATE_GL_VERTEX_ARRAY"; break;
						case MUG_FAILED_CREATE_GL_BUFFER: return "MUG_FAILED_CREATE_GL_BUFFER"; break;
						case MUG_FAILED_COMPILE_GL_SHADERS: return "MUG_FAILED_COMPILE_GL_SHADERS"; break;
						case MUG_NO_RENDER_CALLS_YET: return "MUG_NO_RENDER_CALLS_YET"; break;
						case MUG_UNKNOWN_GRAPHIC_API: return "MUG_UNKNOWN_GRAPHIC_API"; break;
						case MUG_INVALID_ID: return "MUG_INVALID_ID"; break;
						case MUG_INVALID_BUFFER_ID: return "MUG_INVALID_BUFFER_ID"; break;
						case MUG_MUCOSA_SUCCESS: return "MUG_MUCOSA_SUCCESS"; break;
						case MUG_MUCOSA_ALREADY_INITIALIZED: return "MUG_MUCOSA_ALREADY_INITIALIZED"; break;
						case MUG_MUCOSA_ALREADY_TERMINATED: return "MUG_MUCOSA_ALREADY_TERMINATED"; break;
						case MUG_MUCOSA_ALREADY_ACTIVE: return "MUG_MUCOSA_ALREADY_ACTIVE"; break;
						case MUG_MUCOSA_ALREADY_INACTIVE: return "MUG_MUCOSA_ALREADY_INACTIVE"; break;
						case MUG_MUCOSA_NOT_YET_INITIALIZED: return "MUG_MUCOSA_NOT_YET_INITIALIZED"; break;
						case MUG_MUCOSA_ALLOCATION_FAILED: return "MUG_MUCOSA_ALLOCATION_FAILED"; break;
						case MUG_MUCOSA_UNKNOWN_WINDOW_SYSTEM: return "MUG_MUCOSA_UNKNOWN_WINDOW_SYSTEM"; break;
						case MUG_MUCOSA_UNKNOWN_GRAPHICS_API: return "MUG_MUCOSA_UNKNOWN_GRAPHICS_API"; break;
						case MUG_MUCOSA_UNKNOWN_KEYBOARD_KEY: return "MUG_MUCOSA_UNKNOWN_KEYBOARD_KEY"; break;
						case MUG_MUCOSA_UNKNOWN_KEYBOARD_STATE: return "MUG_MUCOSA_UNKNOWN_KEYBOARD_STATE"; break;
						case MUG_MUCOSA_UNKNOWN_MOUSE_BUTTON: return "MUG_MUCOSA_UNKNOWN_MOUSE_BUTTON"; break;
						case MUG_MUCOSA_UNKNOWN_WINDOW_HANDLE: return "MUG_MUCOSA_UNKNOWN_WINDOW_HANDLE"; break;
						case MUG_MUCOSA_UNSUPPORTED_WINDOW_SYSTEM: return "MUG_MUCOSA_UNSUPPORTED_WINDOW_SYSTEM"; break;
						case MUG_MUCOSA_UNSUPPORTED_FEATURE: return "MUG_MUCOSA_UNSUPPORTED_FEATURE"; break;
						case MUG_MUCOSA_UNSUPPORTED_OPENGL_FEATURE: return "MUG_MUCOSA_UNSUPPORTED_OPENGL_FEATURE"; break;
						case MUG_MUCOSA_UNSUPPORTED_GRAPHICS_API: return "MUG_MUCOSA_UNSUPPORTED_GRAPHICS_API"; break;
						case MUG_MUCOSA_FAILED_CONNECTION_TO_SERVER: return "MUG_MUCOSA_FAILED_CONNECTION_TO_SERVER"; break;
						case MUG_MUCOSA_FAILED_CREATE_WINDOW: return "MUG_MUCOSA_FAILED_CREATE_WINDOW"; break;
						case MUG_MUCOSA_FAILED_LOAD_FUNCTIONS: return "MUG_MUCOSA_FAILED_LOAD_FUNCTIONS"; break;
						case MUG_MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER: return "MUG_MUCOSA_FAILED_FIND_COMPATIBLE_FRAMEBUFFER"; break;
						case MUG_MUCOSA_FAILED_CREATE_OPENGL_CONTEXT: return "MUG_MUCOSA_FAILED_CREATE_OPENGL_CONTEXT"; break;
						case MUG_MUCOSA_FAILED_LOAD_OPENGL_CONTEXT: return "MUG_MUCOSA_FAILED_LOAD_OPENGL_CONTEXT"; break;
						case MUG_MUCOSA_FAILED_USE_PIXEL_FORMAT: return "MUG_MUCOSA_FAILED_USE_PIXEL_FORMAT"; break;
						case MUG_MUCOSA_FAILED_JOIN_THREAD: return "MUG_MUCOSA_FAILED_JOIN_THREAD"; break;
						case MUG_MUCOSA_FAILED_CREATE_THREAD: return "MUG_MUCOSA_FAILED_CREATE_THREAD"; break;
						case MUG_MUCOSA_FAILED_CREATE_INPUT_METHOD: return "MUG_MUCOSA_FAILED_CREATE_INPUT_METHOD"; break;
						case MUG_MUCOSA_FAILED_GET_INPUT_STYLES: return "MUG_MUCOSA_FAILED_GET_INPUT_STYLES"; break;
						case MUG_MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE: return "MUG_MUCOSA_FAILED_FIND_COMPATIBLE_INPUT_STYLE"; break;
						case MUG_MUCOSA_FAILED_CREATE_INPUT_CONTEXT: return "MUG_MUCOSA_FAILED_CREATE_INPUT_CONTEXT"; break;
						case MUG_MUCOSA_FAILED_REGISTER_WINDOW_CLASS: return "MUG_MUCOSA_FAILED_REGISTER_WINDOW_CLASS"; break;
						case MUG_MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR: return "MUG_MUCOSA_FAILED_CONVERT_UTF8_TO_WCHAR"; break;
						case MUG_MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8: return "MUG_MUCOSA_FAILED_CONVERT_WCHAR_TO_UTF8"; break;
						case MUG_MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS: return "MUG_MUCOSA_FAILED_REGISTER_DUMMY_WGL_WINDOW_CLASS"; break;
						case MUG_MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW: return "MUG_MUCOSA_FAILED_CREATE_DUMMY_WGL_WINDOW"; break;
						case MUG_MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT: return "MUG_MUCOSA_FAILED_FIND_COMPATIBLE_PIXEL_FORMAT"; break;
						case MUG_MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT: return "MUG_MUCOSA_FAILED_DESCRIBE_PIXEL_FORMAT"; break;
						case MUG_MUCOSA_FAILED_SET_PIXEL_FORMAT: return "MUG_MUCOSA_FAILED_SET_PIXEL_FORMAT"; break;
						case MUG_MUCOSA_FAILED_QUERY_WINDOW_INFO: return "MUG_MUCOSA_FAILED_QUERY_WINDOW_INFO"; break;
						case MUG_MUCOSA_FAILED_SET_WINDOW_INFO: return "MUG_MUCOSA_FAILED_SET_WINDOW_INFO"; break;
						case MUG_MUCOSA_FAILED_GET_IMM_CONTEXT: return "MUG_MUCOSA_FAILED_GET_IMM_CONTEXT"; break;
						case MUG_MUCOSA_FAILED_LET_IMM_CONTEXT: return "MUG_MUCOSA_FAILED_LET_IMM_CONTEXT"; break;
						case MUG_MUCOSA_FAILED_GLOBAL_ALLOCATION: return "MUG_MUCOSA_FAILED_GLOBAL_ALLOCATION"; break;
						case MUG_MUCOSA_FAILED_GLOBAL_LOCK: return "MUG_MUCOSA_FAILED_GLOBAL_LOCK"; break;
						case MUG_MUCOSA_FAILED_HOLD_CLIPBOARD: return "MUG_MUCOSA_FAILED_HOLD_CLIPBOARD"; break;
						case MUG_MUCOSA_FAILED_SET_CLIPBOARD: return "MUG_MUCOSA_FAILED_SET_CLIPBOARD"; break;
						case MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS: return "MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_BOOLS"; break;
						case MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS: return "MUG_MUCOSA_INVALID_MINIMUM_MAXIMUM_DIMENSIONS"; break;
						case MUG_MUCOSA_INVALID_ID: return "MUG_MUCOSA_INVALID_ID"; break;
						case MUG_MUCOSA_INVALID_SAMPLE_COUNT: return "MUG_MUCOSA_INVALID_SAMPLE_COUNT"; break;
						case MUG_MUCOSA_INVALID_DIMENSIONS: return "MUG_MUCOSA_INVALID_DIMENSIONS"; break;
						case MUG_MUCOSA_INVALID_POINTER: return "MUG_MUCOSA_INVALID_POINTER"; break;
						case MUG_MUCOSA_INVALID_WINDOW_STATE: return "MUG_MUCOSA_INVALID_WINDOW_STATE"; break;
						case MUG_MUCOSA_INVALID_TIME: return "MUG_MUCOSA_INVALID_TIME"; break;
						case MUG_MUCOSA_NONEXISTENT_DEVICE: return "MUG_MUCOSA_NONEXISTENT_DEVICE"; break;
						case MUG_MUCOSA_OVERSIZED_CLIPBOARD: return "MUG_MUCOSA_OVERSIZED_CLIPBOARD"; break;
						case MUG_MUCOSA_WINDOW_NON_RESIZABLE: return "MUG_MUCOSA_WINDOW_NON_RESIZABLE"; break;
						case MUG_MUCOSA_MUMA_SUCCESS: return "MUG_MUCOSA_MUMA_SUCCESS"; break;
						case MUG_MUCOSA_MUMA_FAILED_TO_ALLOCATE: return "MUG_MUCOSA_MUMA_FAILED_TO_ALLOCATE"; break;
						case MUG_MUCOSA_MUMA_INVALID_INDEX: return "MUG_MUCOSA_MUMA_INVALID_INDEX"; break;
						case MUG_MUCOSA_MUMA_INVALID_SHIFT_AMOUNT: return "MUG_MUCOSA_MUMA_INVALID_SHIFT_AMOUNT"; break;
						case MUG_MUCOSA_MUMA_NOT_FOUND: return "MUG_MUCOSA_MUMA_NOT_FOUND"; break;
						case MUG_MUMA_SUCCESS: return "MUG_MUMA_SUCCESS"; break;
						case MUG_MUMA_FAILED_TO_ALLOCATE: return "MUG_MUMA_FAILED_TO_ALLOCATE"; break;
						case MUG_MUMA_INVALID_INDEX: return "MUG_MUMA_INVALID_INDEX"; break;
						case MUG_MUMA_INVALID_SHIFT_AMOUNT: return "MUG_MUMA_INVALID_SHIFT_AMOUNT"; break;
						case MUG_MUMA_NOT_FOUND: return "MUG_MUMA_NOT_FOUND"; break;
					}
				}
			#endif

		/* Initiation / Termination */

			struct mugContext {
				mug_inner_graphic_array graphics;
				#define MUG_GGFX mug_global_context->graphics
				mug_innervk_loaded loaded;
				#define MUG_GVK_LOADED mug_global_context->loaded
			};

			mugContext* mug_global_context = 0;

			MUDEF void mug_init(mugResult* result, muWindowSystem window_system) {
				MU_SET_RESULT(result, MUG_SUCCESS)

				if (mug_global_context != 0) {
					MU_SET_RESULT(result, MUG_ALREADY_INITIATED)
					return;
				}

				muCOSAResult cosa_res = MUCOSA_SUCCESS;
				muCOSA_init(&cosa_res, window_system);
				if (cosa_res != MUCOSA_SUCCESS) {
					MU_SET_RESULT(result, muCOSA_result_to_mug_result(cosa_res))
					return;
				}

				mug_global_context = (mugContext*)mu_malloc(sizeof(mugContext));
				if (mug_global_context == 0) {
					MU_SET_RESULT(result, MUG_FAILED_ALLOCATE)
					return;
				}

				*mug_global_context = MU_ZERO_STRUCT(mugContext);
				
				MU_LOCK_CREATE(MUG_GVK_LOADED.lock, MUG_GVK_LOADED.lock_active)
			}

			MUDEF void mug_term(mugResult* result) {
				MU_SET_RESULT(result, MUG_SUCCESS)

				if (mug_global_context == 0) {
					MU_SET_RESULT(result, MUG_ALREADY_TERMINATED)
					return;
				}

				for (size_m i = 0; i < MUG_GGFX.length; i++) {
					mu_graphic_destroy(0, i);
				}

				muCOSAResult cosa_res = MUCOSA_SUCCESS;
				muCOSA_term(&cosa_res);
				if (cosa_res != MUCOSA_SUCCESS) {
					MU_SET_RESULT(result, muCOSA_result_to_mug_result(cosa_res))
					return;
				}

				mug_innervk_unload(&MUG_GVK_LOADED);

				MU_LOCK_DESTROY(MUG_GVK_LOADED.lock, MUG_GVK_LOADED.lock_active)

				mu_free(mug_global_context);
				mug_global_context = 0;
			}

		/* Graphic */

			/* Creation / Destruction */

				MUDEF muGraphic mu_graphic_create_via_window(mugResult* result, muGraphicAPI api, 
					muByte* name, uint16_m width, uint16_m height,
					muWindowCreateInfo create_info
				) {
					MU_SAFEFUNC(result, MUG_, mug_global_context, return MU_NONE;)

					mug_inner_graphic s_graphic = MU_ZERO_STRUCT(mug_inner_graphic);

					mumaResult muma_res = MUMA_SUCCESS;
					muGraphic graphic = MU_NONE;
					mug_inner_graphic_find_push(&muma_res, &MUG_GGFX, s_graphic, &graphic);
					if (muma_res != MUMA_SUCCESS) {
						MU_SET_RESULT(result, muma_result_to_mug_result(muma_res))
					}
					if (graphic == MU_NONE) {
						return graphic;
					}

					mug_inner_graphic_hold_element(&muma_res, &MUG_GGFX, graphic);
					if (muma_res != MUMA_SUCCESS) {
						MU_SET_RESULT(result, muma_result_to_mug_result(muma_res))
						return MU_NONE;
					}

					switch (api) {
						default: {
							MU_SET_RESULT(result, MUG_UNKNOWN_GRAPHIC_API)
							MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
							return MU_NONE;
						} break;

						case MUG_OPENGL: {
							s_graphic.api = MUG_OPENGL;

							mugResult res = MUG_SUCCESS;
							s_graphic.gapi.gl = mug_innergl_graphic_create_via_window(&res,
								name, width, height, create_info
							);
							if (res != MUG_SUCCESS) {
								MU_SET_RESULT(result, res)
							}
							if (s_graphic.gapi.gl.win == MU_NONE) {
								MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
								return MU_NONE;
							}
						} break;

						case MUG_VULKAN: {
							s_graphic.api = MUG_VULKAN;

							if (mug_innervk_load(&MUG_GVK_LOADED) != VK_SUCCESS) {
								MU_SET_RESULT(result, MUG_UNKNOWN_GRAPHIC_API)
								MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
								return MU_NONE;
							}

							mugResult res = MUG_SUCCESS;
							s_graphic.gapi.vk = mug_innervk_graphic_create_via_window(&res,
								name, width, height, create_info);
							if (res != MUG_SUCCESS) {
								MU_SET_RESULT(result, res)
							}
							if (s_graphic.gapi.vk.win == MU_NONE) {
								MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
								return MU_NONE;
							}
						} break;
					}

					s_graphic.active = MU_TRUE;

					MUG_GGFX.data[graphic] = s_graphic;
					MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
					return graphic;
				}

				MUDEF muGraphic mu_graphic_destroy(mugResult* result, muGraphic graphic) {
					MU_SET_RESULT(result, MUG_SUCCESS)
					MU_SAFEFUNC(result, MUG_, mug_global_context, return graphic;)

					MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return graphic;, mug_inner_graphic_)

					switch (MUG_GGFX.data[graphic].api) {
						default: break;
						case MUG_OPENGL: mug_innergl_graphic_destroy(result, &MUG_GGFX.data[graphic].gapi.gl); break;
						case MUG_VULKAN: mug_innervk_graphic_destroy(result, &MUG_GGFX.data[graphic].gapi.vk); break;
					}

					MUG_GGFX.data[graphic].active = MU_FALSE;

					MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
					return MU_NONE;
				}

			/* Main loop */

				MUDEF void mu_graphic_clear(mugResult* result, muGraphic graphic, float r, float g, float b, float a) {
					MU_SET_RESULT(result, MUG_SUCCESS)
					MU_SAFEFUNC(result, MUG_, mug_global_context, return;)

					MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return;, mug_inner_graphic_)

					switch (MUG_GGFX.data[graphic].api) {
						default: break;
						case MUG_OPENGL: mug_innergl_graphic_clear(result, &MUG_GGFX.data[graphic].gapi.gl, r, g, b, a); break;
						case MUG_VULKAN: mug_innervk_graphic_clear(result, &MUG_GGFX.data[graphic].gapi.vk, r, g, b, a); break;
					}

					MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
					return;
				}

				MUDEF void mu_graphic_swap_buffers(mugResult* result, muGraphic graphic) {
					MU_SET_RESULT(result, MUG_SUCCESS)
					MU_SAFEFUNC(result, MUG_, mug_global_context, return;)

					MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return;, mug_inner_graphic_)

					switch (MUG_GGFX.data[graphic].api) {
						default: break;
						case MUG_OPENGL: mug_innergl_graphic_swap_buffers(result, &MUG_GGFX.data[graphic].gapi.gl); break;
						case MUG_VULKAN: mug_innervk_graphic_swap_buffers(result, &MUG_GGFX.data[graphic].gapi.vk); break;
					}

					MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
					return;
				}

				MUDEF void mu_graphic_update(mugResult* result, muGraphic graphic) {
					MU_SET_RESULT(result, MUG_SUCCESS)
					MU_SAFEFUNC(result, MUG_, mug_global_context, return;)

					MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return;, mug_inner_graphic_)

					switch (MUG_GGFX.data[graphic].api) {
						default: break;
						case MUG_OPENGL: mug_innergl_graphic_update(result, &MUG_GGFX.data[graphic].gapi.gl); break;
						case MUG_VULKAN: mug_innervk_graphic_update(result, &MUG_GGFX.data[graphic].gapi.vk); break;
					}

					MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
					return;
				}

			/* Get */

				MUDEF muWindow mu_graphic_get_window(mugResult* result, muGraphic graphic) {
					MU_SET_RESULT(result, MUG_SUCCESS)
					MU_SAFEFUNC(result, MUG_, mug_global_context, return MU_NONE;)

					MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return MU_NONE;, mug_inner_graphic_)

					muWindow win = MU_NONE;
					switch (MUG_GGFX.data[graphic].api) {
						default: break;
						case MUG_OPENGL: win = MUG_GGFX.data[graphic].gapi.gl.win; break;
						case MUG_VULKAN: win = MUG_GGFX.data[graphic].gapi.vk.win; break;
					}

					MU_RELEASE(MUG_GGFX, graphic, mug_inner_graphic_)
					return win;
				}

			/* Objects */

				// ...

				/* Rect */

					MUDEF muRectBuffer mu_rect_buffer_create(mugResult* result, muGraphic graphic, size_m rect_count, muRect* rects) {
						MU_SET_RESULT(result, MUG_SUCCESS)
						MU_SAFEFUNC(result, MUG_, mug_global_context, return MU_NONE;)

						MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return MU_NONE;, mug_inner_graphic_)

						muRectBuffer rb = MU_NONE;

						switch (MUG_GGFX.data[graphic].api) {
							default: break;
							case MUG_OPENGL: {
								rb = mug_innergl_rect_buffer_create(result, &MUG_GGFX.data[graphic].gapi.gl, rect_count, rects);
							} break;
							case MUG_VULKAN: {
								rb = mug_innervk_rect_buffer_create(result, &MUG_GGFX.data[graphic].gapi.vk, rect_count, rects);
							} break;
						}

						return rb;
					}

					MUDEF muRectBuffer mu_rect_buffer_destroy(mugResult* result, muGraphic graphic, muRectBuffer rb) {
						MU_SET_RESULT(result, MUG_SUCCESS)
						MU_SAFEFUNC(result, MUG_, mug_global_context, return rb;)

						MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return rb;, mug_inner_graphic_)

						switch (MUG_GGFX.data[graphic].api) {
							default: break;
							case MUG_OPENGL: {
								rb = mug_innergl_rect_buffer_destroy(result, &MUG_GGFX.data[graphic].gapi.gl, rb);
							} break;
							case MUG_VULKAN: {
								rb = mug_innervk_rect_buffer_destroy(result, &MUG_GGFX.data[graphic].gapi.vk, rb);
							} break;
						}

						return rb;
					}

					MUDEF void mu_rect_buffer_render(mugResult* result, muGraphic graphic, muRectBuffer rb) {
						MU_SET_RESULT(result, MUG_SUCCESS)
						MU_SAFEFUNC(result, MUG_, mug_global_context, return;)

						MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return;, mug_inner_graphic_)

						switch (MUG_GGFX.data[graphic].api) {
							default: break;
							case MUG_OPENGL: {
								mug_innergl_rect_buffer_render(result, &MUG_GGFX.data[graphic].gapi.gl, rb);
							} break;
							case MUG_VULKAN: {
								mug_innervk_rect_buffer_render(result, &MUG_GGFX.data[graphic].gapi.vk, rb);
							} break;
						}
					}

					MUDEF void mu_rect_buffer_fill(mugResult* result, muGraphic graphic, muRectBuffer rb, muRect* rects) {
						MU_SET_RESULT(result, MUG_SUCCESS)
						MU_SAFEFUNC(result, MUG_, mug_global_context, return;)

						MU_HOLD(result, graphic, MUG_GGFX, mug_global_context, MUG_, return;, mug_inner_graphic_)

						switch (MUG_GGFX.data[graphic].api) {
							default: break;
							case MUG_OPENGL: {
								mug_innergl_rect_buffer_fill(result, &MUG_GGFX.data[graphic].gapi.gl, rb, rects);
							} break;
							case MUG_VULKAN: {
								mug_innervk_rect_buffer_fill(result, &MUG_GGFX.data[graphic].gapi.vk, rb, rects);
							} break;
						}
					}

	#ifdef __cplusplus
	}
	#endif
#endif /* MUG_IMPLEMENTATION */

/*
For provided source code:
	------------------------------------------------------------------------------
	This software is available under 2 licenses -- choose whichever you prefer.
	------------------------------------------------------------------------------
	ALTERNATIVE A - MIT License
	Copyright (c) 2024 Hum
	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	of the Software, and to permit persons to whom the Software is furnished to do
	so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
	------------------------------------------------------------------------------
	ALTERNATIVE B - Public Domain (www.unlicense.org)
	This is free and unencumbered software released into the public domain.
	Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
	software, either in source code form or as a compiled binary, for any purpose,
	commercial or non-commercial, and by any means.
	In jurisdictions that recognize copyright laws, the author or authors of this
	software dedicate any and all copyright interest in the software to the public
	domain. We make this dedication for the benefit of the public at large and to
	the detriment of our heirs and successors. We intend this dedication to be an
	overt act of relinquishment in perpetuity of all present and future rights to
	this software under copyright law.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	------------------------------------------------------------------------------

For Khronos specifications:
	Copyright (c) 2013-2020 The Khronos Group Inc.

	Licensed under the Apache License, Version 2.0 (the "License"); you may not
	use this file except in compliance with the License. You may obtain a copy of
	the License at

	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed
	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	CONDITIONS OF ANY KIND, either express or implied. See the License for the
	specific language governing permissions and limitations under the License.
*/

